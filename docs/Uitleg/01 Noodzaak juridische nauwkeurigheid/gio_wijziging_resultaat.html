<html>
<head>
    <meta charset="UTF-8">
    <title>GIO-wijziging</title>
    <link rel="icon" type="image/png" href="static/applicatie_web_favicon.png">

    <style>
        body {
            background-color: White;
            color: Black;
            font-family: Verdana, Geneva, sans-serif;
            font-size: 10pt;
            line-height: 1.4em;
            width: 1000px;
            margin: auto;
        }

        table {
            font-family: Verdana, Geneva, sans-serif;
            font-size: 10pt;
            line-height: 1.4em;
        }

        .log {
            width: 100%;
        }

        th {
            text-align: left;
        }

        td {
            vertical-align: top;
        }

        a {
            color: blue;
            text-decoration: none;
        }

            a:hover {
                text-decoration: underline;
            }

            a:visited {
                color: blue;
            }

        .aslink {
            color: blue;
            cursor: pointer;
            text-decoration: none;
        }

            .aslink:hover {
                text-decoration: underline;
            }


        #meldingen_tabel {
            border: 1px solid #808080;
        }

        .entry_detail {
            color: #CCCCCC;
        }

            .entry_detail td {
                color: #CCCCCC;
            }

        .level_fout {
            color: #FFFFFF;
            background-color: #FF0000;
        }

        .level_letop {
            color: #FFFFFF;
            background-color: #CC8800;
            white-space: nowrap;
        }

        .main {
            width: 70em;
            overflow: auto;
            white-space: pre-line;
        }

        .message_fout {
            color: #FF0000;
        }

        .message_letop {
            color: #880000;
        }

        .message_detail {
            color: #CCCCCC;
        }

        .extra {
            width: 200pt;
            color: #CCCCCC;
            overflow: auto;
        }

        .exception {
            color: #CCCCCC;
            font-family: Courier New, monospace;
        }

        .accordion_h {
            background-color: #eee;
            color: #444;
            cursor: pointer;
            padding: 8px;
            width: 100%;
            text-align: left;
            border: none;
            outline: none;
            transition: 0.4s;
        }

            .accordion_h.active, .accordion_h:hover {
                background-color: #ccc;
            }

        .accordion_h_paneel {
            padding: 0 8px;
            display: none;
            overflow: hidden;
        }

        .accordion_t {
            background-color: #eee;
            color: #444;
            cursor: pointer;
            padding: 4px;
            text-align: center;
            border: 1px solid #000000;
            outline: none;
            transition: 0.4s;
        }

            .accordion_t.active {
                background-color: #ccc;
                padding: 10px;
            }

            .accordion_t:hover {
                background-color: #ccc;
            }

        .accordion_t_paneel {
            overflow: hidden;
        }

        .accordion_t_titel {
            display: none;
            overflow: hidden;
            padding: 0 4px;
        }

        .leestip::after {
            content: "\1F453";
            # https://unicode-table.com/en/1F453/
        }

        .a_symbool_goed {
            color: #82b366;
            font-weight: bold;
        }

        .a_symbool_fout {
            color: #b85450;
            font-weight: bold;
        }

        .sectie_toon_geo {
            border-right: 1em solid #d79b00;
            border-top: 3px solid #d79b00;
        }

            .sectie_toon_geo h1 {
                color: #d79b00;
            }

        .sectie_toon_geo_alt1 {
            border-right: 1em solid #ffe6cc;
        }

        .sectie_toon_geo_alt2 {
            border-right: 1em solid #d79b00;
        }

        .sectie_maak_gio_wijziging {
            border-right: 1em solid #9673a6;
            border-top: 3px solid #9673a6;
        }

            .sectie_maak_gio_wijziging h1 {
                color: #9673a6;
            }

        .sectie_maak_gio_wijziging_alt1 {
            border-right: 1em solid #e1d5e7;
        }

        .sectie_maak_gio_wijziging_alt2 {
            border-right: 1em solid #9673a6;
        }

        .sectie_toon_gio_wijziging {
            border-right: 1em solid #6c8ebf;
            border-top: 3px solid #6c8ebf;
        }

            .sectie_toon_gio_wijziging h1 {
                color: #6c8ebf;
            }

        .sectie_toon_gio_wijziging_alt1 {
            border-right: 1em solid #dae8fc;
        }

        .sectie_toon_gio_wijziging_alt2 {
            border-right: 1em solid #6c8ebf;
        }

        .kaart {
    border: 1px solid #888888;
    position: relative;
}

.kaart-slider {
    position: relative;
    z-index: 9;
    cursor: ew-resize;
    background-color: #2196F3;
    opacity: 0.7;
}

    .kaart-slider.knop {
        width: 40px;
        height: 40px;
        border-radius: 50%;
    }

    .kaart-slider.lijn {
        width: 4px;
    }

.juridische_nauwkeurigheid {
    background-color: #000000;
    border-radius: 50%;
    display: inline-block;
}

.ol-popup {
    position: absolute;
    background-color: white;
    -webkit-filter: drop-shadow(0 1px 4px rgba(0,0,0,0.2));
    filter: drop-shadow(0 1px 4px rgba(0,0,0,0.2));
    padding: 15px;
    border-radius: 10px;
    border: 1px solid #cccccc;
    bottom: 12px;
    left: -50px;
    min-width: 200px;
}

    .ol-popup:after, .ol-popup:before {
        top: 100%;
        border: solid transparent;
        content: " ";
        height: 0;
        width: 0;
        position: absolute;
        pointer-events: none;
    }

    .ol-popup:after {
        border-top-color: white;
        border-width: 10px;
        left: 48px;
        margin-left: -10px;
    }

    .ol-popup:before {
        border-top-color: #cccccc;
        border-width: 11px;
        left: 48px;
        margin-left: -11px;
    }

.ol-popup-closer {
    text-decoration: none;
    position: absolute;
    top: 2px;
    right: 8px;
}

    .ol-popup-closer:after {
        content: "✖";
    }

.ol-popup-content div {
    white-space: nowrap;
}

.kaart {
    width: 600px;
    height: 400px;
    border: 1px solid #888888;
}

:root,
:host {
  --ol-background-color: white;
  --ol-accent-background-color: #F5F5F5;
  --ol-subtle-background-color: rgba(128, 128, 128, 0.25);
  --ol-partial-background-color: rgba(255, 255, 255, 0.75);
  --ol-foreground-color: #333333;
  --ol-subtle-foreground-color: #666666;
  --ol-brand-color: #00AAFF;
}

.ol-box {
  box-sizing: border-box;
  border-radius: 2px;
  border: 1.5px solid var(--ol-background-color);
  background-color: var(--ol-partial-background-color);
}

.ol-mouse-position {
  top: 8px;
  right: 8px;
  position: absolute;
}

.ol-scale-line {
  background: var(--ol-partial-background-color);
  border-radius: 4px;
  bottom: 8px;
  left: 8px;
  padding: 2px;
  position: absolute;
}

.ol-scale-line-inner {
  border: 1px solid var(--ol-subtle-foreground-color);
  border-top: none;
  color: var(--ol-foreground-color);
  font-size: 10px;
  text-align: center;
  margin: 1px;
  will-change: contents, width;
  transition: all 0.25s;
}

.ol-scale-bar {
  position: absolute;
  bottom: 8px;
  left: 8px;
}

.ol-scale-bar-inner {
  display: flex;
}

.ol-scale-step-marker {
  width: 1px;
  height: 15px;
  background-color: var(--ol-foreground-color);
  float: right;
  z-index: 10;
}

.ol-scale-step-text {
  position: absolute;
  bottom: -5px;
  font-size: 10px;
  z-index: 11;
  color: var(--ol-foreground-color);
  text-shadow: -1.5px 0 var(--ol-partial-background-color), 0 1.5px var(--ol-partial-background-color), 1.5px 0 var(--ol-partial-background-color), 0 -1.5px var(--ol-partial-background-color);
}

.ol-scale-text {
  position: absolute;
  font-size: 12px;
  text-align: center;
  bottom: 25px;
  color: var(--ol-foreground-color);
  text-shadow: -1.5px 0 var(--ol-partial-background-color), 0 1.5px var(--ol-partial-background-color), 1.5px 0 var(--ol-partial-background-color), 0 -1.5px var(--ol-partial-background-color);
}

.ol-scale-singlebar {
  position: relative;
  height: 10px;
  z-index: 9;
  box-sizing: border-box;
  border: 1px solid var(--ol-foreground-color);
}

.ol-scale-singlebar-even {
  background-color: var(--ol-subtle-foreground-color);
}

.ol-scale-singlebar-odd {
  background-color: var(--ol-background-color);
}

.ol-unsupported {
  display: none;
}

.ol-viewport,
.ol-unselectable {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

.ol-viewport canvas {
  all: unset;
}

.ol-selectable {
  -webkit-touch-callout: default;
  -webkit-user-select: text;
  -moz-user-select: text;
  user-select: text;
}

.ol-grabbing {
  cursor: -webkit-grabbing;
  cursor: -moz-grabbing;
  cursor: grabbing;
}

.ol-grab {
  cursor: move;
  cursor: -webkit-grab;
  cursor: -moz-grab;
  cursor: grab;
}

.ol-control {
  position: absolute;
  background-color: var(--ol-subtle-background-color);
  border-radius: 4px;
}

.ol-zoom {
  top: .5em;
  left: .5em;
}

.ol-rotate {
  top: .5em;
  right: .5em;
  transition: opacity .25s linear, visibility 0s linear;
}

.ol-rotate.ol-hidden {
  opacity: 0;
  visibility: hidden;
  transition: opacity .25s linear, visibility 0s linear .25s;
}

.ol-zoom-extent {
  top: 4.643em;
  left: .5em;
}

.ol-full-screen {
  right: .5em;
  top: .5em;
}

.ol-control button {
  display: block;
  margin: 1px;
  padding: 0;
  color: var(--ol-subtle-foreground-color);
  font-weight: bold;
  text-decoration: none;
  font-size: inherit;
  text-align: center;
  height: 1.375em;
  width: 1.375em;
  line-height: .4em;
  background-color: var(--ol-background-color);
  border: none;
  border-radius: 2px;
}

.ol-control button::-moz-focus-inner {
  border: none;
  padding: 0;
}

.ol-zoom-extent button {
  line-height: 1.4em;
}

.ol-compass {
  display: block;
  font-weight: normal;
  will-change: transform;
}

.ol-touch .ol-control button {
  font-size: 1.5em;
}

.ol-touch .ol-zoom-extent {
  top: 5.5em;
}

.ol-control button:hover,
.ol-control button:focus {
  text-decoration: none;
  outline: 1px solid var(--ol-subtle-foreground-color);
  color: var(--ol-foreground-color);
}

.ol-zoom .ol-zoom-in {
  border-radius: 2px 2px 0 0;
}

.ol-zoom .ol-zoom-out {
  border-radius: 0 0 2px 2px;
}

.ol-attribution {
  text-align: right;
  bottom: .5em;
  right: .5em;
  max-width: calc(100% - 1.3em);
  display: flex;
  flex-flow: row-reverse;
  align-items: center;
}

.ol-attribution a {
  color: var(--ol-subtle-foreground-color);
  text-decoration: none;
}

.ol-attribution ul {
  margin: 0;
  padding: 1px .5em;
  color: var(--ol-foreground-color);
  text-shadow: 0 0 2px var(--ol-background-color);
  font-size: 12px;
}

.ol-attribution li {
  display: inline;
  list-style: none;
}

.ol-attribution li:not(:last-child):after {
  content: " ";
}

.ol-attribution img {
  max-height: 2em;
  max-width: inherit;
  vertical-align: middle;
}

.ol-attribution button {
  flex-shrink: 0;
}

.ol-attribution.ol-collapsed ul {
  display: none;
}

.ol-attribution:not(.ol-collapsed) {
  background: var(--ol-partial-background-color);
}

.ol-attribution.ol-uncollapsible {
  bottom: 0;
  right: 0;
  border-radius: 4px 0 0;
}

.ol-attribution.ol-uncollapsible img {
  margin-top: -.2em;
  max-height: 1.6em;
}

.ol-attribution.ol-uncollapsible button {
  display: none;
}

.ol-zoomslider {
  top: 4.5em;
  left: .5em;
  height: 200px;
}

.ol-zoomslider button {
  position: relative;
  height: 10px;
}

.ol-touch .ol-zoomslider {
  top: 5.5em;
}

.ol-overviewmap {
  left: 0.5em;
  bottom: 0.5em;
}

.ol-overviewmap.ol-uncollapsible {
  bottom: 0;
  left: 0;
  border-radius: 0 4px 0 0;
}

.ol-overviewmap .ol-overviewmap-map,
.ol-overviewmap button {
  display: block;
}

.ol-overviewmap .ol-overviewmap-map {
  border: 1px solid var(--ol-subtle-foreground-color);
  height: 150px;
  width: 150px;
}

.ol-overviewmap:not(.ol-collapsed) button {
  bottom: 0;
  left: 0;
  position: absolute;
}

.ol-overviewmap.ol-collapsed .ol-overviewmap-map,
.ol-overviewmap.ol-uncollapsible button {
  display: none;
}

.ol-overviewmap:not(.ol-collapsed) {
  background: var(--ol-subtle-background-color);
}

.ol-overviewmap-box {
  border: 1.5px dotted var(--ol-subtle-foreground-color);
}

.ol-overviewmap .ol-overviewmap-box:hover {
  cursor: move;
}

textarea.resultaat {
    width: 900px;
    height: 400px;
    border: 1px solid #888888;
    font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif
}

    </style>

    <script type="text/javascript">
        var ol = function () {
    "use strict"; const t = { 1: "The view center is not defined", 2: "The view resolution is not defined", 3: "The view rotation is not defined", 4: "`image` and `src` cannot be provided at the same time", 5: "`imgSize` must be set when `image` is provided", 7: "`format` must be set when `url` is set", 8: "Unknown `serverType` configured", 9: "`url` must be configured or set using `#setUrl()`", 10: "The default `geometryFunction` can only handle `Point` geometries", 11: "`options.featureTypes` must be an Array", 12: "`options.geometryName` must also be provided when `options.bbox` is set", 13: "Invalid corner", 14: "Invalid color", 15: "Tried to get a value for a key that does not exist in the cache", 16: "Tried to set a value for a key that is used already", 17: "`resolutions` must be sorted in descending order", 18: "Either `origin` or `origins` must be configured, never both", 19: "Number of `tileSizes` and `resolutions` must be equal", 20: "Number of `origins` and `resolutions` must be equal", 22: "Either `tileSize` or `tileSizes` must be configured, never both", 24: "Invalid extent or geometry provided as `geometry`", 25: "Cannot fit empty extent provided as `geometry`", 26: "Features must have an id set", 27: "Features must have an id set", 28: '`renderMode` must be `"hybrid"` or `"vector"`', 30: "The passed `feature` was already added to the source", 31: "Tried to enqueue an `element` that was already added to the queue", 32: "Transformation matrix cannot be inverted", 33: "Invalid units", 34: "Invalid geometry layout", 36: "Unknown SRS type", 37: "Unknown geometry type found", 38: "`styleMapValue` has an unknown type", 39: "Unknown geometry type", 40: "Expected `feature` to have a geometry", 41: "Expected an `ol/style/Style` or an array of `ol/style/Style.js`", 42: "Question unknown, the answer is 42", 43: "Expected `layers` to be an array or a `Collection`", 47: "Expected `controls` to be an array or an `ol/Collection`", 48: "Expected `interactions` to be an array or an `ol/Collection`", 49: "Expected `overlays` to be an array or an `ol/Collection`", 50: "`options.featureTypes` should be an Array", 51: "Either `url` or `tileJSON` options must be provided", 52: "Unknown `serverType` configured", 53: "Unknown `tierSizeCalculation` configured", 55: "The {-y} placeholder requires a tile grid with extent", 56: "mapBrowserEvent must originate from a pointer event", 57: "At least 2 conditions are required", 59: "Invalid command found in the PBF", 60: "Missing or invalid `size`", 61: "Cannot determine IIIF Image API version from provided image information JSON", 62: "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`", 64: "Layer opacity must be a number", 66: "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`", 67: "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both", 68: "A VectorTile source can only be rendered if it has a projection compatible with the view projection" }; class e extends Error { constructor(e) { const i = t[e]; super(i), this.code = e, this.name = "AssertionError", this.message = i } } class i { constructor(t) { this.propagationStopped, this.defaultPrevented, this.type = t, this.target = null } preventDefault() { this.defaultPrevented = !0 } stopPropagation() { this.propagationStopped = !0 } } function n(t) { t.stopPropagation() } var r = "propertychange"; class s { constructor() { this.disposed = !1 } dispose() { this.disposed || (this.disposed = !0, this.disposeInternal()) } disposeInternal() { } } function o(t, e, i) { let n, r; i = i || a; let s = 0, o = t.length, l = !1; for (; s < o;)n = s + (o - s >> 1), r = +i(t[n], e), r < 0 ? s = n + 1 : (o = n, l = !r); return l ? s : ~s } function a(t, e) { return t > e ? 1 : t < e ? -1 : 0 } function l(t, e, i) { const n = t.length; if (t[0] <= e) return 0; if (e <= t[n - 1]) return n - 1; { let r; if (i > 0) { for (r = 1; r < n; ++r)if (t[r] < e) return r - 1 } else if (i < 0) { for (r = 1; r < n; ++r)if (t[r] <= e) return r } else for (r = 1; r < n; ++r) { if (t[r] == e) return r; if (t[r] < e) return "function" == typeof i ? i(e, t[r - 1], t[r]) > 0 ? r - 1 : r : t[r - 1] - e < e - t[r] ? r - 1 : r } return n - 1 } } function h(t, e, i) { for (; e < i;) { const n = t[e]; t[e] = t[i], t[i] = n, ++e, --i } } function c(t, e) { const i = Array.isArray(e) ? e : [e], n = i.length; for (let e = 0; e < n; e++)t[t.length] = i[e] } function u(t, e) { const i = t.length; if (i !== e.length) return !1; for (let n = 0; n < i; n++)if (t[n] !== e[n]) return !1; return !0 } function d(t, e, i) { const n = e || a; return t.every((function (e, r) { if (0 === r) return !0; const s = n(t[r - 1], e); return !(s > 0 || i && 0 === s) })) } function g() { return !0 } function f() { return !1 } function p() { } function m(t) { let e, i, n, r = !1; return function () { const s = Array.prototype.slice.call(arguments); return r && this === n && u(s, i) || (r = !0, n = this, i = s, e = t.apply(this, arguments)), e } } function _(t) { return function () { let e; try { e = t() } catch (t) { return Promise.reject(t) } return e instanceof Promise ? e : Promise.resolve(e) }() } function y(t) { for (const e in t) delete t[e] } function x(t) { let e; for (e in t) return !1; return !e } class v extends s { constructor(t) { super(), this.eventTarget_ = t, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null } addEventListener(t, e) { if (!t || !e) return; const i = this.listeners_ || (this.listeners_ = {}), n = i[t] || (i[t] = []); n.includes(e) || n.push(e) } dispatchEvent(t) { const e = "string" == typeof t, n = e ? t : t.type, r = this.listeners_ && this.listeners_[n]; if (!r) return; const s = e ? new i(t) : t; s.target || (s.target = this.eventTarget_ || this); const o = this.dispatching_ || (this.dispatching_ = {}), a = this.pendingRemovals_ || (this.pendingRemovals_ = {}); let l; n in o || (o[n] = 0, a[n] = 0), ++o[n]; for (let t = 0, e = r.length; t < e; ++t)if (l = "handleEvent" in r[t] ? r[t].handleEvent(s) : r[t].call(this, s), !1 === l || s.propagationStopped) { l = !1; break } if (0 == --o[n]) { let t = a[n]; for (delete a[n]; t--;)this.removeEventListener(n, p); delete o[n] } return l } disposeInternal() { this.listeners_ && y(this.listeners_) } getListeners(t) { return this.listeners_ && this.listeners_[t] || void 0 } hasListener(t) { return !!this.listeners_ && (t ? t in this.listeners_ : Object.keys(this.listeners_).length > 0) } removeEventListener(t, e) { const i = this.listeners_ && this.listeners_[t]; if (i) { const n = i.indexOf(e); -1 !== n && (this.pendingRemovals_ && t in this.pendingRemovals_ ? (i[n] = p, ++this.pendingRemovals_[t]) : (i.splice(n, 1), 0 === i.length && delete this.listeners_[t])) } } } var S = "change", w = "error", E = "contextmenu", T = "click", C = "dblclick", b = "dragenter", R = "dragover", P = "drop", I = "keydown", L = "keypress", M = "load", F = "resize", A = "touchmove", O = "wheel"; function N(t, e, i, n, r) { if (n && n !== t && (i = i.bind(n)), r) { const n = i; i = function () { t.removeEventListener(e, i), n.apply(this, arguments) } } const s = { target: t, type: e, listener: i }; return t.addEventListener(e, i), s } function D(t, e, i, n) { return N(t, e, i, n, !0) } function k(t) { t && t.target && (t.target.removeEventListener(t.type, t.listener), y(t)) } class G extends v { constructor() { super(), this.on = this.onInternal, this.once = this.onceInternal, this.un = this.unInternal, this.revision_ = 0 } changed() { ++this.revision_, this.dispatchEvent(S) } getRevision() { return this.revision_ } onInternal(t, e) { if (Array.isArray(t)) { const i = t.length, n = new Array(i); for (let r = 0; r < i; ++r)n[r] = N(this, t[r], e); return n } return N(this, t, e) } onceInternal(t, e) { let i; if (Array.isArray(t)) { const n = t.length; i = new Array(n); for (let r = 0; r < n; ++r)i[r] = D(this, t[r], e) } else i = D(this, t, e); return e.ol_key = i, i } unInternal(t, e) { const i = e.ol_key; if (i) j(i); else if (Array.isArray(t)) for (let i = 0, n = t.length; i < n; ++i)this.removeEventListener(t[i], e); else this.removeEventListener(t, e) } } function j(t) { if (Array.isArray(t)) for (let e = 0, i = t.length; e < i; ++e)k(t[e]); else k(t) } function B() { throw new Error("Unimplemented abstract method.") } G.prototype.on, G.prototype.once, G.prototype.un; let U = 0; function z(t) { return t.ol_uid || (t.ol_uid = String(++U)) } class X extends i { constructor(t, e, i) { super(t), this.key = e, this.oldValue = i } } class V extends G { constructor(t) { super(), this.on, this.once, this.un, z(this), this.values_ = null, void 0 !== t && this.setProperties(t) } get(t) { let e; return this.values_ && this.values_.hasOwnProperty(t) && (e = this.values_[t]), e } getKeys() { return this.values_ && Object.keys(this.values_) || [] } getProperties() { return this.values_ && Object.assign({}, this.values_) || {} } hasProperties() { return !!this.values_ } notify(t, e) { let i; i = `change:${t}`, this.hasListener(i) && this.dispatchEvent(new X(i, t, e)), i = r, this.hasListener(i) && this.dispatchEvent(new X(i, t, e)) } addChangeListener(t, e) { this.addEventListener(`change:${t}`, e) } removeChangeListener(t, e) { this.removeEventListener(`change:${t}`, e) } set(t, e, i) { const n = this.values_ || (this.values_ = {}); if (i) n[t] = e; else { const i = n[t]; n[t] = e, i !== e && this.notify(t, i) } } setProperties(t, e) { for (const i in t) this.set(i, t[i], e) } applyProperties(t) { t.values_ && Object.assign(this.values_ || (this.values_ = {}), t.values_) } unset(t, e) { if (this.values_ && t in this.values_) { const i = this.values_[t]; delete this.values_[t], x(this.values_) && (this.values_ = null), e || this.notify(t, i) } } } var W = "add", Z = "remove"; const Y = "length"; class K extends i { constructor(t, e, i) { super(t), this.element = e, this.index = i } } class q extends V { constructor(t, e) { if (super(), this.on, this.once, this.un, e = e || {}, this.unique_ = !!e.unique, this.array_ = t || [], this.unique_) for (let t = 0, e = this.array_.length; t < e; ++t)this.assertUnique_(this.array_[t], t); this.updateLength_() } clear() { for (; this.getLength() > 0;)this.pop() } extend(t) { for (let e = 0, i = t.length; e < i; ++e)this.push(t[e]); return this } forEach(t) { const e = this.array_; for (let i = 0, n = e.length; i < n; ++i)t(e[i], i, e) } getArray() { return this.array_ } item(t) { return this.array_[t] } getLength() { return this.get(Y) } insertAt(t, e) { if (t < 0 || t > this.getLength()) throw new Error("Index out of bounds: " + t); this.unique_ && this.assertUnique_(e), this.array_.splice(t, 0, e), this.updateLength_(), this.dispatchEvent(new K(W, e, t)) } pop() { return this.removeAt(this.getLength() - 1) } push(t) { this.unique_ && this.assertUnique_(t); const e = this.getLength(); return this.insertAt(e, t), this.getLength() } remove(t) { const e = this.array_; for (let i = 0, n = e.length; i < n; ++i)if (e[i] === t) return this.removeAt(i) } removeAt(t) { if (t < 0 || t >= this.getLength()) return; const e = this.array_[t]; return this.array_.splice(t, 1), this.updateLength_(), this.dispatchEvent(new K(Z, e, t)), e } setAt(t, e) { if (t >= this.getLength()) return void this.insertAt(t, e); if (t < 0) throw new Error("Index out of bounds: " + t); this.unique_ && this.assertUnique_(e, t); const i = this.array_[t]; this.array_[t] = e, this.dispatchEvent(new K(Z, i, t)), this.dispatchEvent(new K(W, e, t)) } updateLength_() { this.set(Y, this.array_.length) } assertUnique_(t, i) { for (let n = 0, r = this.array_.length; n < r; ++n)if (this.array_[n] === t && n !== i) throw new e(58) } } var H = 0, $ = 1, J = 2, Q = 3, tt = 4; function et(t) { return Math.pow(t, 3) } function it(t) { return 1 - et(1 - t) } function nt(t) { return 3 * t * t - 2 * t * t * t } function rt(t) { return t } class st extends v { constructor(t, e, i) { super(), i = i || {}, this.tileCoord = t, this.state = e, this.interimTile = null, this.key = "", this.transition_ = void 0 === i.transition ? 250 : i.transition, this.transitionStarts_ = {}, this.interpolate = !!i.interpolate } changed() { this.dispatchEvent(S) } release() { this.state === Q && this.setState(tt) } getKey() { return this.key + "/" + this.tileCoord } getInterimTile() { if (!this.interimTile) return this; let t = this.interimTile; do { if (t.getState() == J) return this.transition_ = 0, t; t = t.interimTile } while (t); return this } refreshInterimChain() { if (!this.interimTile) return; let t = this.interimTile, e = this; do { if (t.getState() == J) { t.interimTile = null; break } t.getState() == $ ? e = t : t.getState() == H ? e.interimTile = t.interimTile : e = t, t = e.interimTile } while (t) } getTileCoord() { return this.tileCoord } getState() { return this.state } setState(t) { if (this.state !== Q && this.state > t) throw new Error("Tile load sequence violation"); this.state = t, this.changed() } load() { B() } getAlpha(t, e) { if (!this.transition_) return 1; let i = this.transitionStarts_[t]; if (i) { if (-1 === i) return 1 } else i = e, this.transitionStarts_[t] = i; const n = e - i + 1e3 / 60; return n >= this.transition_ ? 1 : et(n / this.transition_) } inTransition(t) { return !!this.transition_ && -1 !== this.transitionStarts_[t] } endTransition(t) { this.transition_ && (this.transitionStarts_[t] = -1) } } class ot extends st { constructor(t) { const e = H; super(t.tileCoord, e, { transition: t.transition, interpolate: t.interpolate }), this.loader_ = t.loader, this.data_ = null, this.error_ = null, this.size_ = t.size || [256, 256] } getSize() { return this.size_ } getData() { return this.data_ } getError() { return this.error_ } load() { if (this.state !== H && this.state !== Q) return; this.state = $, this.changed(); const t = this; this.loader_().then((function (e) { t.data_ = e, t.state = J, t.changed() })).catch((function (e) { t.error_ = e, t.state = Q, t.changed() })) } } function at(t, i) { if (!t) throw new e(i) } class lt extends V { constructor(t) { if (super(), this.on, this.once, this.un, this.id_ = void 0, this.geometryName_ = "geometry", this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), t) if ("function" == typeof t.getSimplifiedGeometry) { const e = t; this.setGeometry(e) } else { const e = t; this.setProperties(e) } } clone() { const t = new lt(this.hasProperties() ? this.getProperties() : null); t.setGeometryName(this.getGeometryName()); const e = this.getGeometry(); e && t.setGeometry(e.clone()); const i = this.getStyle(); return i && t.setStyle(i), t } getGeometry() { return this.get(this.geometryName_) } getId() { return this.id_ } getGeometryName() { return this.geometryName_ } getStyle() { return this.style_ } getStyleFunction() { return this.styleFunction_ } handleGeometryChange_() { this.changed() } handleGeometryChanged_() { this.geometryChangeKey_ && (k(this.geometryChangeKey_), this.geometryChangeKey_ = null); const t = this.getGeometry(); t && (this.geometryChangeKey_ = N(t, S, this.handleGeometryChange_, this)), this.changed() } setGeometry(t) { this.set(this.geometryName_, t) } setStyle(t) { this.style_ = t, this.styleFunction_ = t ? ht(t) : void 0, this.changed() } setId(t) { this.id_ = t, this.changed() } setGeometryName(t) { this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_), this.geometryName_ = t, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), this.handleGeometryChanged_() } } function ht(t) { if ("function" == typeof t) return t; { let e; if (Array.isArray(t)) e = t; else { at("function" == typeof t.getZIndex, 41); e = [t] } return function () { return e } } } const ct = "undefined" != typeof navigator && void 0 !== navigator.userAgent ? navigator.userAgent.toLowerCase() : "", ut = ct.includes("firefox"), dt = ct.includes("safari") && !ct.includes("chrom"), gt = dt && (ct.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ct)), ft = ct.includes("webkit") && !ct.includes("edge"), pt = ct.includes("macintosh"), mt = "undefined" != typeof devicePixelRatio ? devicePixelRatio : 1, _t = "undefined" != typeof WorkerGlobalScope && "undefined" != typeof OffscreenCanvas && self instanceof WorkerGlobalScope, yt = "undefined" != typeof Image && Image.prototype.decode, xt = function () { let t = !1; try { const e = Object.defineProperty({}, "passive", { get: function () { t = !0 } }); window.addEventListener("_", null, e), window.removeEventListener("_", null, e) } catch (t) { } return t }(), vt = new Array(6); function St() { return [1, 0, 0, 1, 0, 0] } function wt(t) { return Tt(t, 1, 0, 0, 1, 0, 0) } function Et(t, e) { const i = t[0], n = t[1], r = t[2], s = t[3], o = t[4], a = t[5], l = e[0], h = e[1], c = e[2], u = e[3], d = e[4], g = e[5]; return t[0] = i * l + r * h, t[1] = n * l + s * h, t[2] = i * c + r * u, t[3] = n * c + s * u, t[4] = i * d + r * g + o, t[5] = n * d + s * g + a, t } function Tt(t, e, i, n, r, s, o) { return t[0] = e, t[1] = i, t[2] = n, t[3] = r, t[4] = s, t[5] = o, t } function Ct(t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t } function bt(t, e) { const i = e[0], n = e[1]; return e[0] = t[0] * i + t[2] * n + t[4], e[1] = t[1] * i + t[3] * n + t[5], e } function Rt(t, e) { const i = Math.cos(e), n = Math.sin(e); return Et(t, Tt(vt, i, n, -n, i, 0, 0)) } function Pt(t, e, i) { return Et(t, Tt(vt, e, 0, 0, i, 0, 0)) } function It(t, e, i) { return Tt(t, e, 0, 0, i, 0, 0) } function Lt(t, e, i) { return Et(t, Tt(vt, 1, 0, 0, 1, e, i)) } function Mt(t, e, i, n, r, s, o, a) { const l = Math.sin(s), h = Math.cos(s); return t[0] = n * h, t[1] = r * l, t[2] = -n * l, t[3] = r * h, t[4] = o * n * h - a * n * l + e, t[5] = o * r * l + a * r * h + i, t } function Ft(t, e) { const i = At(e); at(0 !== i, 32); const n = e[0], r = e[1], s = e[2], o = e[3], a = e[4], l = e[5]; return t[0] = o / i, t[1] = -r / i, t[2] = -s / i, t[3] = n / i, t[4] = (s * l - o * a) / i, t[5] = -(n * l - r * a) / i, t } function At(t) { return t[0] * t[3] - t[1] * t[2] } let Ot; function Nt(t) { const e = "matrix(" + t.join(", ") + ")"; if (_t) return e; const i = Ot || (Ot = document.createElement("div")); return i.style.transform = e, i.style.transform } var Dt = 0, kt = 1, Gt = 2, jt = 4, Bt = 8, Ut = 16; function zt(t) { const e = Ht(); for (let i = 0, n = t.length; i < n; ++i)re(e, t[i]); return e } function Xt(t, e, i) { return i ? (i[0] = t[0] - e, i[1] = t[1] - e, i[2] = t[2] + e, i[3] = t[3] + e, i) : [t[0] - e, t[1] - e, t[2] + e, t[3] + e] } function Vt(t, e) { return e ? (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e) : t.slice() } function Wt(t, e, i) { let n, r; return n = e < t[0] ? t[0] - e : t[2] < e ? e - t[2] : 0, r = i < t[1] ? t[1] - i : t[3] < i ? i - t[3] : 0, n * n + r * r } function Zt(t, e) { return Kt(t, e[0], e[1]) } function Yt(t, e) { return t[0] <= e[0] && e[2] <= t[2] && t[1] <= e[1] && e[3] <= t[3] } function Kt(t, e, i) { return t[0] <= e && e <= t[2] && t[1] <= i && i <= t[3] } function qt(t, e) { const i = t[0], n = t[1], r = t[2], s = t[3], o = e[0], a = e[1]; let l = Dt; return o < i ? l |= Ut : o > r && (l |= jt), a < n ? l |= Bt : a > s && (l |= Gt), l === Dt && (l = kt), l } function Ht() { return [1 / 0, 1 / 0, -1 / 0, -1 / 0] } function $t(t, e, i, n, r) { return r ? (r[0] = t, r[1] = e, r[2] = i, r[3] = n, r) : [t, e, i, n] } function Jt(t) { return $t(1 / 0, 1 / 0, -1 / 0, -1 / 0, t) } function Qt(t, e) { const i = t[0], n = t[1]; return $t(i, n, i, n, e) } function te(t, e, i, n, r) { return oe(Jt(r), t, e, i, n) } function ee(t, e) { return t[0] == e[0] && t[2] == e[2] && t[1] == e[1] && t[3] == e[3] } function ie(t, e, i) { return Math.abs(t[0] - e[0]) < i && Math.abs(t[2] - e[2]) < i && Math.abs(t[1] - e[1]) < i && Math.abs(t[3] - e[3]) < i } function ne(t, e) { return e[0] < t[0] && (t[0] = e[0]), e[2] > t[2] && (t[2] = e[2]), e[1] < t[1] && (t[1] = e[1]), e[3] > t[3] && (t[3] = e[3]), t } function re(t, e) { e[0] < t[0] && (t[0] = e[0]), e[0] > t[2] && (t[2] = e[0]), e[1] < t[1] && (t[1] = e[1]), e[1] > t[3] && (t[3] = e[1]) } function se(t, e) { for (let i = 0, n = e.length; i < n; ++i)re(t, e[i]); return t } function oe(t, e, i, n, r) { for (; i < n; i += r)le(t, e[i], e[i + 1]); return t } function ae(t, e) { for (let i = 0, n = e.length; i < n; ++i)se(t, e[i]); return t } function le(t, e, i) { t[0] = Math.min(t[0], e), t[1] = Math.min(t[1], i), t[2] = Math.max(t[2], e), t[3] = Math.max(t[3], i) } function he(t, e) { let i; return i = e(ue(t)), i || (i = e(de(t)), i || (i = e(ve(t)), i || (i = e(xe(t)), i || !1))) } function ce(t) { let e = 0; return Ee(t) || (e = Se(t) * _e(t)), e } function ue(t) { return [t[0], t[1]] } function de(t) { return [t[2], t[1]] } function ge(t) { return [(t[0] + t[2]) / 2, (t[1] + t[3]) / 2] } function fe(t, e) { let i; return "bottom-left" === e ? i = ue(t) : "bottom-right" === e ? i = de(t) : "top-left" === e ? i = xe(t) : "top-right" === e ? i = ve(t) : at(!1, 13), i } function pe(t, e, i, n, r) { const [s, o, a, l, h, c, u, d] = me(t, e, i, n); return $t(Math.min(s, a, h, u), Math.min(o, l, c, d), Math.max(s, a, h, u), Math.max(o, l, c, d), r) } function me(t, e, i, n) { const r = e * n[0] / 2, s = e * n[1] / 2, o = Math.cos(i), a = Math.sin(i), l = r * o, h = r * a, c = s * o, u = s * a, d = t[0], g = t[1]; return [d - l + u, g - h - c, d - l - u, g - h + c, d + l - u, g + h + c, d + l + u, g + h - c, d - l + u, g - h - c] } function _e(t) { return t[3] - t[1] } function ye(t, e, i) { const n = i || [1 / 0, 1 / 0, -1 / 0, -1 / 0]; return we(t, e) ? (t[0] > e[0] ? n[0] = t[0] : n[0] = e[0], t[1] > e[1] ? n[1] = t[1] : n[1] = e[1], t[2] < e[2] ? n[2] = t[2] : n[2] = e[2], t[3] < e[3] ? n[3] = t[3] : n[3] = e[3]) : Jt(n), n } function xe(t) { return [t[0], t[3]] } function ve(t) { return [t[2], t[3]] } function Se(t) { return t[2] - t[0] } function we(t, e) { return t[0] <= e[2] && t[2] >= e[0] && t[1] <= e[3] && t[3] >= e[1] } function Ee(t) { return t[2] < t[0] || t[3] < t[1] } function Te(t, e) { return e ? (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e) : t } function Ce(t, e) { const i = (t[2] - t[0]) / 2 * (e - 1), n = (t[3] - t[1]) / 2 * (e - 1); t[0] -= i, t[2] += i, t[1] -= n, t[3] += n } function be(t, e, i) { let n = !1; const r = qt(t, e), s = qt(t, i); if (r === kt || s === kt) n = !0; else { const o = t[0], a = t[1], l = t[2], h = t[3], c = e[0], u = e[1], d = i[0], g = i[1], f = (g - u) / (d - c); let p, m; s & Gt && !(r & Gt) && (p = d - (g - h) / f, n = p >= o && p <= l), n || !(s & jt) || r & jt || (m = g - (d - l) * f, n = m >= a && m <= h), n || !(s & Bt) || r & Bt || (p = d - (g - a) / f, n = p >= o && p <= l), n || !(s & Ut) || r & Ut || (m = g - (d - o) * f, n = m >= a && m <= h) } return n } function Re(t, e, i, n) { let r = []; if (n > 1) { const e = t[2] - t[0], i = t[3] - t[1]; for (let s = 0; s < n; ++s)r.push(t[0] + e * s / n, t[1], t[2], t[1] + i * s / n, t[2] - e * s / n, t[3], t[0], t[3] - i * s / n) } else r = [t[0], t[1], t[2], t[1], t[2], t[3], t[0], t[3]]; e(r, r, 2); const s = [], o = []; for (let t = 0, e = r.length; t < e; t += 2)s.push(r[t]), o.push(r[t + 1]); return function (t, e, i) { return $t(Math.min.apply(null, t), Math.min.apply(null, e), Math.max.apply(null, t), Math.max.apply(null, e), i) }(s, o, i) } function Pe(t, e) { const i = e.getExtent(), n = ge(t); if (e.canWrapX() && (n[0] < i[0] || n[0] >= i[2])) { const e = Se(i), r = Math.floor((n[0] - i[0]) / e) * e; t[0] -= r, t[2] -= r } return t } function Ie(t, e) { if (e.canWrapX()) { const i = e.getExtent(); if (!isFinite(t[0]) || !isFinite(t[2])) return [[i[0], t[1], i[2], t[3]]]; Pe(t, e); const n = Se(i); if (Se(t) > n) return [[i[0], t[1], i[2], t[3]]]; if (t[0] < i[0]) return [[t[0] + n, t[1], i[2], t[3]], [i[0], t[1], t[2], t[3]]]; if (t[2] > i[2]) return [[t[0], t[1], i[2], t[3]], [i[0], t[1], t[2] - n, t[3]]] } return [t] } const Le = { 9001: "m", 9002: "ft", 9003: "us-ft", 9101: "radians", 9102: "degrees" }; function Me(t) { return Le[t] } const Fe = { radians: 6370997 / (2 * Math.PI), degrees: 2 * Math.PI * 6370997 / 360, ft: .3048, m: 1, "us-ft": 1200 / 3937 }; class Ae { constructor(t) { this.code_ = t.code, this.units_ = t.units, this.extent_ = void 0 !== t.extent ? t.extent : null, this.worldExtent_ = void 0 !== t.worldExtent ? t.worldExtent : null, this.axisOrientation_ = void 0 !== t.axisOrientation ? t.axisOrientation : "enu", this.global_ = void 0 !== t.global && t.global, this.canWrapX_ = !(!this.global_ || !this.extent_), this.getPointResolutionFunc_ = t.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = t.metersPerUnit } canWrapX() { return this.canWrapX_ } getCode() { return this.code_ } getExtent() { return this.extent_ } getUnits() { return this.units_ } getMetersPerUnit() { return this.metersPerUnit_ || Fe[this.units_] } getWorldExtent() { return this.worldExtent_ } getAxisOrientation() { return this.axisOrientation_ } isGlobal() { return this.global_ } setGlobal(t) { this.global_ = t, this.canWrapX_ = !(!t || !this.extent_) } getDefaultTileGrid() { return this.defaultTileGrid_ } setDefaultTileGrid(t) { this.defaultTileGrid_ = t } setExtent(t) { this.extent_ = t, this.canWrapX_ = !(!this.global_ || !t) } setWorldExtent(t) { this.worldExtent_ = t } setGetPointResolution(t) { this.getPointResolutionFunc_ = t } getPointResolutionFunc() { return this.getPointResolutionFunc_ } } const Oe = 6378137, Ne = Math.PI * Oe, De = [-Ne, -Ne, Ne, Ne], ke = [-180, -85, 180, 85], Ge = Oe * Math.log(Math.tan(Math.PI / 2)); class je extends Ae { constructor(t) { super({ code: t, units: "m", extent: De, global: !0, worldExtent: ke, getPointResolution: function (t, e) { return t / Math.cosh(e[1] / Oe) } }) } } const Be = [new je("EPSG:3857"), new je("EPSG:102100"), new je("EPSG:102113"), new je("EPSG:900913"), new je("http://www.opengis.net/def/crs/EPSG/0/3857"), new je("http://www.opengis.net/gml/srs/epsg.xml#3857")]; function Ue(t, e, i) { const n = t.length; i = i > 1 ? i : 2, void 0 === e && (e = i > 2 ? t.slice() : new Array(n)); for (let r = 0; r < n; r += i) { e[r] = Ne * t[r] / 180; let i = Oe * Math.log(Math.tan(Math.PI * (+t[r + 1] + 90) / 360)); i > Ge ? i = Ge : i < -Ge && (i = -Ge), e[r + 1] = i } return e } function ze(t, e, i) { const n = t.length; i = i > 1 ? i : 2, void 0 === e && (e = i > 2 ? t.slice() : new Array(n)); for (let r = 0; r < n; r += i)e[r] = 180 * t[r] / Ne, e[r + 1] = 360 * Math.atan(Math.exp(t[r + 1] / Oe)) / Math.PI - 90; return e } const Xe = 6378137, Ve = [-180, -90, 180, 90], We = Math.PI * Xe / 180; class Ze extends Ae { constructor(t, e) { super({ code: t, units: "degrees", extent: Ve, axisOrientation: e, global: !0, metersPerUnit: We, worldExtent: Ve }) } } const Ye = [new Ze("CRS:84"), new Ze("EPSG:4326", "neu"), new Ze("urn:ogc:def:crs:OGC:1.3:CRS84"), new Ze("urn:ogc:def:crs:OGC:2:84"), new Ze("http://www.opengis.net/def/crs/OGC/1.3/CRS84"), new Ze("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"), new Ze("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")]; let Ke = {}; function qe() { Ke = {} } function He(t) { return Ke[t] || Ke[t.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null } function $e(t, e) { Ke[t] = e } let Je = {}; function Qe() { Je = {} } function ti(t, e, i) { const n = t.getCode(), r = e.getCode(); n in Je || (Je[n] = {}), Je[n][r] = i } function ei(t, e) { let i; return t in Je && e in Je[t] && (i = Je[t][e]), i } function ii(t, e, i) { return Math.min(Math.max(t, e), i) } function ni(t, e, i, n, r, s) { const o = r - i, a = s - n; if (0 !== o || 0 !== a) { const l = ((t - i) * o + (e - n) * a) / (o * o + a * a); l > 1 ? (i = r, n = s) : l > 0 && (i += o * l, n += a * l) } return ri(t, e, i, n) } function ri(t, e, i, n) { const r = i - t, s = n - e; return r * r + s * s } function si(t) { const e = t.length; for (let i = 0; i < e; i++) { let n = i, r = Math.abs(t[i][i]); for (let s = i + 1; s < e; s++) { const e = Math.abs(t[s][i]); e > r && (r = e, n = s) } if (0 === r) return null; const s = t[n]; t[n] = t[i], t[i] = s; for (let n = i + 1; n < e; n++) { const r = -t[n][i] / t[i][i]; for (let s = i; s < e + 1; s++)i == s ? t[n][s] = 0 : t[n][s] += r * t[i][s] } } const i = new Array(e); for (let n = e - 1; n >= 0; n--) { i[n] = t[n][e] / t[n][n]; for (let r = n - 1; r >= 0; r--)t[r][e] -= t[r][n] * i[n] } return i } function oi(t) { return 180 * t / Math.PI } function ai(t) { return t * Math.PI / 180 } function li(t, e) { const i = t % e; return i * e < 0 ? i + e : i } function hi(t, e, i) { return t + i * (e - t) } function ci(t, e) { const i = Math.pow(10, e); return Math.round(t * i) / i } function ui(t, e) { return Math.round(ci(t, e)) } function di(t, e) { return Math.floor(ci(t, e)) } function gi(t, e) { return Math.ceil(ci(t, e)) } function fi(t, e, i) { const n = void 0 !== i ? t.toFixed(i) : "" + t; let r = n.indexOf("."); return r = -1 === r ? n.length : r, r > e ? n : new Array(1 + e - r).join("0") + n } function pi(t, e) { const i = ("" + t).split("."), n = ("" + e).split("."); for (let t = 0; t < Math.max(i.length, n.length); t++) { const e = parseInt(i[t] || "0", 10), r = parseInt(n[t] || "0", 10); if (e > r) return 1; if (r > e) return -1 } return 0 } function mi(t, e) { return t[0] += +e[0], t[1] += +e[1], t } function _i(t, e) { const i = e.getRadius(), n = e.getCenter(), r = n[0], s = n[1]; let o = t[0] - r; const a = t[1] - s; 0 === o && 0 === a && (o = 1); const l = Math.sqrt(o * o + a * a); return [r + i * o / l, s + i * a / l] } function yi(t, e) { const i = t[0], n = t[1], r = e[0], s = e[1], o = r[0], a = r[1], l = s[0], h = s[1], c = l - o, u = h - a, d = 0 === c && 0 === u ? 0 : (c * (i - o) + u * (n - a)) / (c * c + u * u || 0); let g, f; return d <= 0 ? (g = o, f = a) : d >= 1 ? (g = l, f = h) : (g = o + d * c, f = a + d * u), [g, f] } function xi(t, e, i) { const n = li(e + 180, 360) - 180, r = Math.abs(3600 * n), s = i || 0; let o = Math.floor(r / 3600), a = Math.floor((r - 3600 * o) / 60), l = ci(r - 3600 * o - 60 * a, s); l >= 60 && (l = 0, a += 1), a >= 60 && (a = 0, o += 1); let h = o + "°"; return 0 === a && 0 === l || (h += " " + fi(a, 2) + "′"), 0 !== l && (h += " " + fi(l, 2, s) + "″"), 0 !== n && (h += " " + t.charAt(n < 0 ? 1 : 0)), h } function vi(t, e, i) { return t ? e.replace("{x}", t[0].toFixed(i)).replace("{y}", t[1].toFixed(i)) : "" } function Si(t, e) { let i = !0; for (let n = t.length - 1; n >= 0; --n)if (t[n] != e[n]) { i = !1; break } return i } function wi(t, e) { const i = Math.cos(e), n = Math.sin(e), r = t[0] * i - t[1] * n, s = t[1] * i + t[0] * n; return t[0] = r, t[1] = s, t } function Ei(t, e) { return t[0] *= e, t[1] *= e, t } function Ti(t, e) { const i = t[0] - e[0], n = t[1] - e[1]; return i * i + n * n } function Ci(t, e) { return Math.sqrt(Ti(t, e)) } function bi(t, e) { return Ti(t, yi(t, e)) } function Ri(t, e) { return vi(t, "{x}, {y}", e) } function Pi(t, e) { if (e.canWrapX()) { const i = Se(e.getExtent()), n = Ii(t, e, i); n && (t[0] -= n * i) } return t } function Ii(t, e, i) { const n = e.getExtent(); let r = 0; return e.canWrapX() && (t[0] < n[0] || t[0] > n[2]) && (i = i || Se(n), r = Math.floor((t[0] - n[0]) / i)), r } const Li = 6371008.8; function Mi(t, e, i) { i = i || Li; const n = ai(t[1]), r = ai(e[1]), s = (r - n) / 2, o = ai(e[0] - t[0]) / 2, a = Math.sin(s) * Math.sin(s) + Math.sin(o) * Math.sin(o) * Math.cos(n) * Math.cos(r); return 2 * i * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)) } function Fi(t, e) { let i = 0; for (let n = 0, r = t.length; n < r - 1; ++n)i += Mi(t[n], t[n + 1], e); return i } function Ai(t, e) { let i = 0; const n = t.length; let r = t[n - 1][0], s = t[n - 1][1]; for (let e = 0; e < n; e++) { const n = t[e][0], o = t[e][1]; i += ai(n - r) * (2 + Math.sin(ai(s)) + Math.sin(ai(o))), r = n, s = o } return i * e * e / 2 } function Oi(t, e, i, n) { n = n || Li; const r = ai(t[1]), s = ai(t[0]), o = e / n, a = Math.asin(Math.sin(r) * Math.cos(o) + Math.cos(r) * Math.sin(o) * Math.cos(i)); return [oi(s + Math.atan2(Math.sin(i) * Math.sin(o) * Math.cos(r), Math.cos(o) - Math.sin(r) * Math.sin(a))), oi(a)] } let Ni = !0; function Di(t) { Ni = !(void 0 === t || t) } function ki(t, e, i) { if (void 0 !== e) for (let i = 0, n = t.length; i < n; ++i)e[i] = t[i]; else e = t.slice(); return e } function Gi(t, e, i) { if (void 0 !== e && t !== e) { for (let i = 0, n = t.length; i < n; ++i)e[i] = t[i]; t = e } return t } function ji(t) { $e(t.getCode(), t), ti(t, t, ki) } function Bi(t) { t.forEach(ji) } function Ui(t) { return "string" == typeof t ? He(t) : t || null } function zi(t, e, i, n) { let r; const s = (t = Ui(t)).getPointResolutionFunc(); if (s) { if (r = s(e, i), n && n !== t.getUnits()) { const e = t.getMetersPerUnit(); e && (r = r * e / Fe[n]) } } else { const s = t.getUnits(); if ("degrees" == s && !n || "degrees" == n) r = e; else { const o = qi(t, Ui("EPSG:4326")); if (o === Gi && "degrees" !== s) r = e * t.getMetersPerUnit(); else { let t = [i[0] - e / 2, i[1], i[0] + e / 2, i[1], i[0], i[1] - e / 2, i[0], i[1] + e / 2]; t = o(t, t, 2); r = (Mi(t.slice(0, 2), t.slice(2, 4)) + Mi(t.slice(4, 6), t.slice(6, 8))) / 2 } const a = n ? Fe[n] : t.getMetersPerUnit(); void 0 !== a && (r /= a) } } return r } function Xi(t) { Bi(t), t.forEach((function (e) { t.forEach((function (t) { e !== t && ti(e, t, ki) })) })) } function Vi(t, e, i, n) { t.forEach((function (t) { e.forEach((function (e) { ti(t, e, i), ti(e, t, n) })) })) } function Wi(t, e) { return t ? "string" == typeof t ? Ui(t) : t : Ui(e) } function Zi(t) { return function (e, i, n) { const r = e.length; n = void 0 !== n ? n : 2, i = void 0 !== i ? i : new Array(r); for (let s = 0; s < r; s += n) { const r = t(e.slice(s, s + n)), o = r.length; for (let t = 0, a = n; t < a; ++t)i[s + t] = t >= o ? e[s + t] : r[t] } return i } } function Yi(t, e, i, n) { const r = Ui(t), s = Ui(e); ti(r, s, Zi(i)), ti(s, r, Zi(n)) } function Ki(t, e) { if (t === e) return !0; const i = t.getUnits() === e.getUnits(); if (t.getCode() === e.getCode()) return i; return qi(t, e) === ki && i } function qi(t, e) { let i = ei(t.getCode(), e.getCode()); return i || (i = Gi), i } function Hi(t, e) { return qi(Ui(t), Ui(e)) } function $i(t, e, i) { return Hi(e, i)(t, void 0, t.length) } function Ji(t, e, i, n) { return Re(t, Hi(e, i), void 0, n) } let Qi = null; function tn(t) { Qi = Ui(t) } function en() { return Qi } function nn(t, e) { return Qi ? $i(t, e, Qi) : t } function rn(t, e) { return Qi ? $i(t, Qi, e) : (Ni && !Si(t, [0, 0]) && t[0] >= -180 && t[0] <= 180 && t[1] >= -90 && t[1] <= 90 && (Ni = !1, console.warn("Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.")), t) } function sn(t, e) { return Qi ? Ji(t, e, Qi) : t } function on(t, e) { return Qi ? Ji(t, Qi, e) : t } function an(t, e) { if (!Qi) return t; const i = Ui(e).getUnits(), n = Qi.getUnits(); return i && n ? t * Fe[i] / Fe[n] : t } function ln(t, e) { if (!Qi) return t; const i = Ui(e).getUnits(), n = Qi.getUnits(); return i && n ? t * Fe[n] / Fe[i] : t } function hn(t, e, i) { return function (n) { let r, s; if (t.canWrapX()) { const e = t.getExtent(), o = Se(e); s = Ii(n = n.slice(0), t, o), s && (n[0] = n[0] - s * o), n[0] = ii(n[0], e[0], e[2]), n[1] = ii(n[1], e[1], e[3]), r = i(n) } else r = i(n); return s && e.canWrapX() && (r[0] += s * Se(e.getExtent())), r } } function cn() { Xi(Be), Xi(Ye), Vi(Ye, Be, Ue, ze) } function un(t, e, i, n, r, s) { s = s || []; let o = 0; for (let a = e; a < i; a += n) { const e = t[a], i = t[a + 1]; s[o++] = r[0] * e + r[2] * i + r[4], s[o++] = r[1] * e + r[3] * i + r[5] } return s && s.length != o && (s.length = o), s } function dn(t, e, i, n, r, s, o) { o = o || []; const a = Math.cos(r), l = Math.sin(r), h = s[0], c = s[1]; let u = 0; for (let r = e; r < i; r += n) { const e = t[r] - h, i = t[r + 1] - c; o[u++] = h + e * a - i * l, o[u++] = c + e * l + i * a; for (let e = r + 2; e < r + n; ++e)o[u++] = t[e] } return o && o.length != u && (o.length = u), o } function gn(t, e, i, n, r, s, o, a) { a = a || []; const l = o[0], h = o[1]; let c = 0; for (let o = e; o < i; o += n) { const e = t[o] - l, i = t[o + 1] - h; a[c++] = l + r * e, a[c++] = h + s * i; for (let e = o + 2; e < o + n; ++e)a[c++] = t[e] } return a && a.length != c && (a.length = c), a } function fn(t, e, i, n, r, s, o) { o = o || []; let a = 0; for (let l = e; l < i; l += n) { o[a++] = t[l] + r, o[a++] = t[l + 1] + s; for (let e = l + 2; e < l + n; ++e)o[a++] = t[e] } return o && o.length != a && (o.length = a), o } cn(); const pn = [1, 0, 0, 1, 0, 0]; class mn extends V { constructor() { super(), this.extent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = m((function (t, e, i) { if (!i) return this.getSimplifiedGeometry(e); const n = this.clone(); return n.applyTransform(i), n.getSimplifiedGeometry(e) })) } simplifyTransformed(t, e) { return this.simplifyTransformedInternal(this.getRevision(), t, e) } clone() { return B() } closestPointXY(t, e, i, n) { return B() } containsXY(t, e) { const i = this.getClosestPoint([t, e]); return i[0] === t && i[1] === e } getClosestPoint(t, e) { return e = e || [NaN, NaN], this.closestPointXY(t[0], t[1], e, 1 / 0), e } intersectsCoordinate(t) { return this.containsXY(t[0], t[1]) } computeExtent(t) { return B() } getExtent(t) { if (this.extentRevision_ != this.getRevision()) { const t = this.computeExtent(this.extent_); (isNaN(t[0]) || isNaN(t[1])) && Jt(t), this.extentRevision_ = this.getRevision() } return Te(this.extent_, t) } rotate(t, e) { B() } scale(t, e, i) { B() } simplify(t) { return this.getSimplifiedGeometry(t * t) } getSimplifiedGeometry(t) { return B() } getType() { return B() } applyTransform(t) { B() } intersectsExtent(t) { return B() } translate(t, e) { B() } transform(t, e) { const i = Ui(t), n = "tile-pixels" == i.getUnits() ? function (t, n, r) { const s = i.getExtent(), o = i.getWorldExtent(), a = _e(o) / _e(s); return Mt(pn, o[0], o[3], a, -a, 0, 0, 0), un(t, 0, t.length, r, pn, n), Hi(i, e)(t, n, r) } : Hi(i, e); return this.applyTransform(n), this } } class _n extends mn { constructor() { super(), this.layout = "XY", this.stride = 2, this.flatCoordinates = null } computeExtent(t) { return te(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t) } getCoordinates() { return B() } getFirstCoordinate() { return this.flatCoordinates.slice(0, this.stride) } getFlatCoordinates() { return this.flatCoordinates } getLastCoordinate() { return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride) } getLayout() { return this.layout } getSimplifiedGeometry(t) { if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || 0 !== this.simplifiedGeometryMaxMinSquaredTolerance && t <= this.simplifiedGeometryMaxMinSquaredTolerance) return this; const e = this.getSimplifiedGeometryInternal(t); return e.getFlatCoordinates().length < this.flatCoordinates.length ? e : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this) } getSimplifiedGeometryInternal(t) { return this } getStride() { return this.stride } setFlatCoordinates(t, e) { this.stride = yn(t), this.layout = t, this.flatCoordinates = e } setCoordinates(t, e) { B() } setLayout(t, e, i) { let n; if (t) n = yn(t); else { for (let t = 0; t < i; ++t) { if (0 === e.length) return this.layout = "XY", void (this.stride = 2); e = e[0] } n = e.length, t = function (t) { let e; 2 == t ? e = "XY" : 3 == t ? e = "XYZ" : 4 == t && (e = "XYZM"); return e }(n) } this.layout = t, this.stride = n } applyTransform(t) { this.flatCoordinates && (t(this.flatCoordinates, this.flatCoordinates, this.stride), this.changed()) } rotate(t, e) { const i = this.getFlatCoordinates(); if (i) { const n = this.getStride(); dn(i, 0, i.length, n, t, e, i), this.changed() } } scale(t, e, i) { void 0 === e && (e = t), i || (i = ge(this.getExtent())); const n = this.getFlatCoordinates(); if (n) { const r = this.getStride(); gn(n, 0, n.length, r, t, e, i, n), this.changed() } } translate(t, e) { const i = this.getFlatCoordinates(); if (i) { const n = this.getStride(); fn(i, 0, i.length, n, t, e, i), this.changed() } } } function yn(t) { let e; return "XY" == t ? e = 2 : "XYZ" == t || "XYM" == t ? e = 3 : "XYZM" == t && (e = 4), e } function xn(t, e, i) { const n = t.getFlatCoordinates(); if (n) { const r = t.getStride(); return un(n, 0, n.length, r, e, i) } return null } function vn(t, e, i, n, r, s, o) { const a = t[e], l = t[e + 1], h = t[i] - a, c = t[i + 1] - l; let u; if (0 === h && 0 === c) u = e; else { const d = ((r - a) * h + (s - l) * c) / (h * h + c * c); if (d > 1) u = i; else { if (d > 0) { for (let r = 0; r < n; ++r)o[r] = hi(t[e + r], t[i + r], d); return void (o.length = n) } u = e } } for (let e = 0; e < n; ++e)o[e] = t[u + e]; o.length = n } function Sn(t, e, i, n, r) { let s = t[e], o = t[e + 1]; for (e += n; e < i; e += n) { const i = t[e], n = t[e + 1], a = ri(s, o, i, n); a > r && (r = a), s = i, o = n } return r } function wn(t, e, i, n, r) { for (let s = 0, o = i.length; s < o; ++s) { const o = i[s]; r = Sn(t, e, o, n, r), e = o } return r } function En(t, e, i, n, r) { for (let s = 0, o = i.length; s < o; ++s) { const o = i[s]; r = wn(t, e, o, n, r), e = o[o.length - 1] } return r } function Tn(t, e, i, n, r, s, o, a, l, h, c) { if (e == i) return h; let u, d; if (0 === r) { if (d = ri(o, a, t[e], t[e + 1]), d < h) { for (u = 0; u < n; ++u)l[u] = t[e + u]; return l.length = n, d } return h } c = c || [NaN, NaN]; let g = e + n; for (; g < i;)if (vn(t, g - n, g, n, o, a, c), d = ri(o, a, c[0], c[1]), d < h) { for (h = d, u = 0; u < n; ++u)l[u] = c[u]; l.length = n, g += n } else g += n * Math.max((Math.sqrt(d) - Math.sqrt(h)) / r | 0, 1); if (s && (vn(t, i - n, e, n, o, a, c), d = ri(o, a, c[0], c[1]), d < h)) { for (h = d, u = 0; u < n; ++u)l[u] = c[u]; l.length = n } return h } function Cn(t, e, i, n, r, s, o, a, l, h, c) { c = c || [NaN, NaN]; for (let u = 0, d = i.length; u < d; ++u) { const d = i[u]; h = Tn(t, e, d, n, r, s, o, a, l, h, c), e = d } return h } function bn(t, e, i, n, r, s, o, a, l, h, c) { c = c || [NaN, NaN]; for (let u = 0, d = i.length; u < d; ++u) { const d = i[u]; h = Cn(t, e, d, n, r, s, o, a, l, h, c), e = d[d.length - 1] } return h } function Rn(t, e, i, n) { for (let n = 0, r = i.length; n < r; ++n)t[e++] = i[n]; return e } function Pn(t, e, i, n) { for (let r = 0, s = i.length; r < s; ++r) { const s = i[r]; for (let i = 0; i < n; ++i)t[e++] = s[i] } return e } function In(t, e, i, n, r) { r = r || []; let s = 0; for (let o = 0, a = i.length; o < a; ++o) { const a = Pn(t, e, i[o], n); r[s++] = a, e = a } return r.length = s, r } function Ln(t, e, i, n, r) { r = r || []; let s = 0; for (let o = 0, a = i.length; o < a; ++o) { const a = In(t, e, i[o], n, r[s]); 0 === a.length && (a[0] = e), r[s++] = a, e = a[a.length - 1] } return r.length = s, r } function Mn(t, e, i, n, r, s, o) { const a = (i - e) / n; if (a < 3) { for (; e < i; e += n)s[o++] = t[e], s[o++] = t[e + 1]; return o } const l = new Array(a); l[0] = 1, l[a - 1] = 1; const h = [e, i - n]; let c = 0; for (; h.length > 0;) { const i = h.pop(), s = h.pop(); let o = 0; const a = t[s], u = t[s + 1], d = t[i], g = t[i + 1]; for (let e = s + n; e < i; e += n) { const i = ni(t[e], t[e + 1], a, u, d, g); i > o && (c = e, o = i) } o > r && (l[(c - e) / n] = 1, s + n < c && h.push(s, c), c + n < i && h.push(c, i)) } for (let i = 0; i < a; ++i)l[i] && (s[o++] = t[e + i * n], s[o++] = t[e + i * n + 1]); return o } function Fn(t, e, i, n, r, s, o, a) { for (let l = 0, h = i.length; l < h; ++l) { const h = i[l]; o = Mn(t, e, h, n, r, s, o), a.push(o), e = h } return o } function An(t, e, i, n, r, s, o) { if (i <= e + n) { for (; e < i; e += n)s[o++] = t[e], s[o++] = t[e + 1]; return o } let a = t[e], l = t[e + 1]; s[o++] = a, s[o++] = l; let h = a, c = l; for (e += n; e < i; e += n)h = t[e], c = t[e + 1], ri(a, l, h, c) > r && (s[o++] = h, s[o++] = c, a = h, l = c); return h == a && c == l || (s[o++] = h, s[o++] = c), o } function On(t, e) { return e * Math.round(t / e) } function Nn(t, e, i, n, r, s, o) { if (e == i) return o; let a, l, h = On(t[e], r), c = On(t[e + 1], r); e += n, s[o++] = h, s[o++] = c; do { if (a = On(t[e], r), l = On(t[e + 1], r), (e += n) == i) return s[o++] = a, s[o++] = l, o } while (a == h && l == c); for (; e < i;) { const i = On(t[e], r), u = On(t[e + 1], r); if (e += n, i == a && u == l) continue; const d = a - h, g = l - c, f = i - h, p = u - c; d * p == g * f && (d < 0 && f < d || d == f || d > 0 && f > d) && (g < 0 && p < g || g == p || g > 0 && p > g) ? (a = i, l = u) : (s[o++] = a, s[o++] = l, h = a, c = l, a = i, l = u) } return s[o++] = a, s[o++] = l, o } function Dn(t, e, i, n, r, s, o, a) { for (let l = 0, h = i.length; l < h; ++l) { const h = i[l]; o = Nn(t, e, h, n, r, s, o), a.push(o), e = h } return o } function kn(t, e, i, n, r, s, o, a) { for (let l = 0, h = i.length; l < h; ++l) { const h = i[l], c = []; o = Dn(t, e, h, n, r, s, o, c), a.push(c), e = h[h.length - 1] } return o } function Gn(t, e, i, n, r) { r = void 0 !== r ? r : []; let s = 0; for (let o = e; o < i; o += n)r[s++] = t.slice(o, o + n); return r.length = s, r } function jn(t, e, i, n, r) { r = void 0 !== r ? r : []; let s = 0; for (let o = 0, a = i.length; o < a; ++o) { const a = i[o]; r[s++] = Gn(t, e, a, n, r[s]), e = a } return r.length = s, r } function Bn(t, e, i, n, r) { r = void 0 !== r ? r : []; let s = 0; for (let o = 0, a = i.length; o < a; ++o) { const a = i[o]; r[s++] = 1 === a.length && a[0] === e ? [] : jn(t, e, a, n, r[s]), e = a[a.length - 1] } return r.length = s, r } function Un(t, e, i, n) { let r = 0, s = t[i - n], o = t[i - n + 1]; for (; e < i; e += n) { const i = t[e], n = t[e + 1]; r += o * i - s * n, s = i, o = n } return r / 2 } function zn(t, e, i, n) { let r = 0; for (let s = 0, o = i.length; s < o; ++s) { const o = i[s]; r += Un(t, e, o, n), e = o } return r } function Xn(t, e, i, n) { let r = 0; for (let s = 0, o = i.length; s < o; ++s) { const o = i[s]; r += zn(t, e, o, n), e = o[o.length - 1] } return r } class Vn extends _n { constructor(t, e) { super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, void 0 === e || Array.isArray(t[0]) ? this.setCoordinates(t, e) : this.setFlatCoordinates(e, t) } clone() { return new Vn(this.flatCoordinates.slice(), this.layout) } closestPointXY(t, e, i, n) { return n < Wt(this.getExtent(), t, e) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(Sn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Tn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, !0, t, e, i, n)) } getArea() { return Un(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride) } getCoordinates() { return Gn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride) } getSimplifiedGeometryInternal(t) { const e = []; return e.length = Mn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e, 0), new Vn(e, "XY") } getType() { return "LinearRing" } intersectsExtent(t) { return !1 } setCoordinates(t, e) { this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Pn(this.flatCoordinates, 0, t, this.stride), this.changed() } } class Wn extends _n { constructor(t, e) { super(), this.setCoordinates(t, e) } clone() { const t = new Wn(this.flatCoordinates.slice(), this.layout); return t.applyProperties(this), t } closestPointXY(t, e, i, n) { const r = this.flatCoordinates, s = ri(t, e, r[0], r[1]); if (s < n) { const t = this.stride; for (let e = 0; e < t; ++e)i[e] = r[e]; return i.length = t, s } return n } getCoordinates() { return this.flatCoordinates ? this.flatCoordinates.slice() : [] } computeExtent(t) { return Qt(this.flatCoordinates, t) } getType() { return "Point" } intersectsExtent(t) { return Kt(t, this.flatCoordinates[0], this.flatCoordinates[1]) } setCoordinates(t, e) { this.setLayout(e, t, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Rn(this.flatCoordinates, 0, t, this.stride), this.changed() } } function Zn(t, e, i, n, r) { return !he(r, (function (r) { return !Yn(t, e, i, n, r[0], r[1]) })) } function Yn(t, e, i, n, r, s) { let o = 0, a = t[i - n], l = t[i - n + 1]; for (; e < i; e += n) { const i = t[e], n = t[e + 1]; l <= s ? n > s && (i - a) * (s - l) - (r - a) * (n - l) > 0 && o++ : n <= s && (i - a) * (s - l) - (r - a) * (n - l) < 0 && o--, a = i, l = n } return 0 !== o } function Kn(t, e, i, n, r, s) { if (0 === i.length) return !1; if (!Yn(t, e, i[0], n, r, s)) return !1; for (let e = 1, o = i.length; e < o; ++e)if (Yn(t, i[e - 1], i[e], n, r, s)) return !1; return !0 } function qn(t, e, i, n, r, s) { if (0 === i.length) return !1; for (let o = 0, a = i.length; o < a; ++o) { const a = i[o]; if (Kn(t, e, a, n, r, s)) return !0; e = a[a.length - 1] } return !1 } function Hn(t, e, i, n, r, s, o) { let l, h, c, u, d, g, f; const p = r[s + 1], m = []; for (let r = 0, s = i.length; r < s; ++r) { const s = i[r]; for (u = t[s - n], g = t[s - n + 1], l = e; l < s; l += n)d = t[l], f = t[l + 1], (p <= g && f <= p || g <= p && p <= f) && (c = (p - g) / (f - g) * (d - u) + u, m.push(c)), u = d, g = f } let _ = NaN, y = -1 / 0; for (m.sort(a), u = m[0], l = 1, h = m.length; l < h; ++l) { d = m[l]; const r = Math.abs(d - u); r > y && (c = (u + d) / 2, Kn(t, e, i, n, c, p) && (_ = c, y = r)), u = d } return isNaN(_) && (_ = r[s]), o ? (o.push(_, p, y), o) : [_, p, y] } function $n(t, e, i, n, r) { let s = []; for (let o = 0, a = i.length; o < a; ++o) { const a = i[o]; s = Hn(t, e, a, n, r, 2 * o, s), e = a[a.length - 1] } return s } function Jn(t, e, i, n, r) { let s; for (e += n; e < i; e += n)if (s = r(t.slice(e - n, e), t.slice(e, e + n)), s) return s; return !1 } function Qn(t, e, i, n, r) { const s = oe([1 / 0, 1 / 0, -1 / 0, -1 / 0], t, e, i, n); return !!we(r, s) && (!!Yt(r, s) || (s[0] >= r[0] && s[2] <= r[2] || (s[1] >= r[1] && s[3] <= r[3] || Jn(t, e, i, n, (function (t, e) { return be(r, t, e) }))))) } function tr(t, e, i, n, r) { for (let s = 0, o = i.length; s < o; ++s) { if (Qn(t, e, i[s], n, r)) return !0; e = i[s] } return !1 } function er(t, e, i, n, r) { return !!Qn(t, e, i, n, r) || (!!Yn(t, e, i, n, r[0], r[1]) || (!!Yn(t, e, i, n, r[0], r[3]) || (!!Yn(t, e, i, n, r[2], r[1]) || !!Yn(t, e, i, n, r[2], r[3])))) } function ir(t, e, i, n, r) { if (!er(t, e, i[0], n, r)) return !1; if (1 === i.length) return !0; for (let e = 1, s = i.length; e < s; ++e)if (Zn(t, i[e - 1], i[e], n, r) && !Qn(t, i[e - 1], i[e], n, r)) return !1; return !0 } function nr(t, e, i, n, r) { for (let s = 0, o = i.length; s < o; ++s) { const o = i[s]; if (ir(t, e, o, n, r)) return !0; e = o[o.length - 1] } return !1 } function rr(t, e, i, n) { for (; e < i - n;) { for (let r = 0; r < n; ++r) { const s = t[e + r]; t[e + r] = t[i - n + r], t[i - n + r] = s } e += n, i -= n } } function sr(t, e, i, n) { let r = 0, s = t[i - n], o = t[i - n + 1]; for (; e < i; e += n) { const i = t[e], n = t[e + 1]; r += (i - s) * (n + o), s = i, o = n } return 0 === r ? void 0 : r > 0 } function or(t, e, i, n, r) { r = void 0 !== r && r; for (let s = 0, o = i.length; s < o; ++s) { const o = i[s], a = sr(t, e, o, n); if (0 === s) { if (r && a || !r && !a) return !1 } else if (r && !a || !r && a) return !1; e = o } return !0 } function ar(t, e, i, n, r) { for (let s = 0, o = i.length; s < o; ++s) { const o = i[s]; if (!or(t, e, o, n, r)) return !1; o.length && (e = o[o.length - 1]) } return !0 } function lr(t, e, i, n, r) { r = void 0 !== r && r; for (let s = 0, o = i.length; s < o; ++s) { const o = i[s], a = sr(t, e, o, n); (0 === s ? r && a || !r && !a : r && !a || !r && a) && rr(t, e, o, n), e = o } return e } function hr(t, e, i, n, r) { for (let s = 0, o = i.length; s < o; ++s)e = lr(t, e, i[s], n, r); return e } function cr(t, e) { const i = []; let n = 0, r = 0; for (let s = 0, o = e.length; s < o; ++s) { const o = e[s]; if (sr(t, n, o, 2)) { if (0 === i.length) continue; i[i.length - 1].push(e[r]) } else i.push(e.slice(r, s + 1)); r = s + 1, n = o } return i } class ur extends _n { constructor(t, e, i) { super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, void 0 !== e && i ? (this.setFlatCoordinates(e, t), this.ends_ = i) : this.setCoordinates(t, e) } appendLinearRing(t) { this.flatCoordinates ? c(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed() } clone() { const t = new ur(this.flatCoordinates.slice(), this.layout, this.ends_.slice()); return t.applyProperties(this), t } closestPointXY(t, e, i, n) { return n < Wt(this.getExtent(), t, e) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(wn(this.flatCoordinates, 0, this.ends_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Cn(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, !0, t, e, i, n)) } containsXY(t, e) { return Kn(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t, e) } getArea() { return zn(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride) } getCoordinates(t) { let e; return void 0 !== t ? (e = this.getOrientedFlatCoordinates().slice(), lr(e, 0, this.ends_, this.stride, t)) : e = this.flatCoordinates, jn(e, 0, this.ends_, this.stride) } getEnds() { return this.ends_ } getFlatInteriorPoint() { if (this.flatInteriorPointRevision_ != this.getRevision()) { const t = ge(this.getExtent()); this.flatInteriorPoint_ = Hn(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t, 0), this.flatInteriorPointRevision_ = this.getRevision() } return this.flatInteriorPoint_ } getInteriorPoint() { return new Wn(this.getFlatInteriorPoint(), "XYM") } getLinearRingCount() { return this.ends_.length } getLinearRing(t) { return t < 0 || this.ends_.length <= t ? null : new Vn(this.flatCoordinates.slice(0 === t ? 0 : this.ends_[t - 1], this.ends_[t]), this.layout) } getLinearRings() { const t = this.layout, e = this.flatCoordinates, i = this.ends_, n = []; let r = 0; for (let s = 0, o = i.length; s < o; ++s) { const o = i[s], a = new Vn(e.slice(r, o), t); n.push(a), r = o } return n } getOrientedFlatCoordinates() { if (this.orientedRevision_ != this.getRevision()) { const t = this.flatCoordinates; or(t, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = lr(this.orientedFlatCoordinates_, 0, this.ends_, this.stride)), this.orientedRevision_ = this.getRevision() } return this.orientedFlatCoordinates_ } getSimplifiedGeometryInternal(t) { const e = [], i = []; return e.length = Dn(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(t), e, 0, i), new ur(e, "XY", i) } getType() { return "Polygon" } intersectsExtent(t) { return ir(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t) } setCoordinates(t, e) { this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []); const i = In(this.flatCoordinates, 0, t, this.stride, this.ends_); this.flatCoordinates.length = 0 === i.length ? 0 : i[i.length - 1], this.changed() } } function dr(t, e, i, n) { i = i || 32; const r = []; for (let s = 0; s < i; ++s)c(r, Oi(t, e, 2 * Math.PI * s / i, n)); return r.push(r[0], r[1]), new ur(r, "XY", [r.length]) } function gr(t) { const e = t[0], i = t[1], n = t[2], r = t[3], s = [e, i, e, r, n, r, n, i, e, i]; return new ur(s, "XY", [s.length]) } function fr(t, e, i) { e = e || 32; const n = t.getStride(), r = t.getLayout(), s = t.getCenter(), o = n * (e + 1), a = new Array(o); for (let t = 0; t < o; t += n) { a[t] = 0, a[t + 1] = 0; for (let e = 2; e < n; e++)a[t + e] = s[e] } const l = [a.length], h = new ur(a, r, l); return pr(h, s, t.getRadius(), i), h } function pr(t, e, i, n) { const r = t.getFlatCoordinates(), s = t.getStride(), o = r.length / s - 1, a = n || 0; for (let t = 0; t <= o; ++t) { const n = t * s, l = a + 2 * li(t, o) * Math.PI / o; r[n] = e[0] + i * Math.cos(l), r[n + 1] = e[1] + i * Math.sin(l) } t.changed() } const mr = "accuracy", _r = "accuracyGeometry", yr = "altitude", xr = "altitudeAccuracy", vr = "heading", Sr = "position", wr = "projection", Er = "speed", Tr = "tracking", Cr = "trackingOptions"; class br extends i { constructor(t) { super(w), this.code = t.code, this.message = t.message } } class Rr extends v { constructor(t, e, i, n) { super(), this.extent = t, this.pixelRatio_ = i, this.resolution = e, this.state = n } changed() { this.dispatchEvent(S) } getExtent() { return this.extent } getImage() { return B() } getPixelRatio() { return this.pixelRatio_ } getResolution() { return this.resolution } getState() { return this.state } load() { B() } } var Pr = 0, Ir = 1, Lr = 2, Mr = 3, Fr = 4; class Ar extends Rr { constructor(t, e, i, n, r, s) { super(t, e, i, Pr), this.src_ = n, this.image_ = new Image, null !== r && (this.image_.crossOrigin = r), this.unlisten_ = null, this.state = Pr, this.imageLoadFunction_ = s } getImage() { return this.image_ } handleImageError_() { this.state = Mr, this.unlistenImage_(), this.changed() } handleImageLoad_() { void 0 === this.resolution && (this.resolution = _e(this.extent) / this.image_.height), this.state = Lr, this.unlistenImage_(), this.changed() } load() { this.state != Pr && this.state != Mr || (this.state = Ir, this.changed(), this.imageLoadFunction_(this, this.src_), this.unlisten_ = Or(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this))) } setImage(t) { this.image_ = t, this.resolution = _e(this.extent) / this.image_.height } unlistenImage_() { this.unlisten_ && (this.unlisten_(), this.unlisten_ = null) } } function Or(t, e, i) { const n = t; let r = !0, s = !1, o = !1; const a = [D(n, M, (function () { o = !0, s || e() }))]; return n.src && yt ? (s = !0, n.decode().then((function () { r && e() })).catch((function (t) { r && (o ? e() : i()) }))) : a.push(D(n, w, i)), function () { r = !1, a.forEach(k) } } class Nr extends Rr { constructor(t, e, i, n, r) { super(t, e, i, void 0 !== r ? Pr : Lr), this.loader_ = void 0 !== r ? r : null, this.canvas_ = n, this.error_ = null } getError() { return this.error_ } handleLoad_(t) { t ? (this.error_ = t, this.state = Mr) : this.state = Lr, this.changed() } load() { this.state == Pr && (this.state = Ir, this.changed(), this.loader_(this.handleLoad_.bind(this))) } getImage() { return this.canvas_ } } function Dr(t, e, i, n) { let r; return r = i && i.length ? i.shift() : _t ? new OffscreenCanvas(t || 300, e || 300) : document.createElement("canvas"), t && (r.width = t), e && (r.height = e), r.getContext("2d", n) } function kr(t) { const e = t.canvas; e.width = 1, e.height = 1, t.clearRect(0, 0, 1, 1) } function Gr(t) { let e = t.offsetWidth; const i = getComputedStyle(t); return e += parseInt(i.marginLeft, 10) + parseInt(i.marginRight, 10), e } function jr(t) { let e = t.offsetHeight; const i = getComputedStyle(t); return e += parseInt(i.marginTop, 10) + parseInt(i.marginBottom, 10), e } function Br(t, e) { const i = e.parentNode; i && i.replaceChild(t, e) } function Ur(t) { return t && t.parentNode ? t.parentNode.removeChild(t) : null } function zr(t) { for (; t.lastChild;)t.removeChild(t.lastChild) } function Xr(t, e) { const i = t.childNodes; for (let n = 0; ; ++n) { const r = i[n], s = e[n]; if (!r && !s) break; r !== s && (r ? s ? t.insertBefore(s, r) : (t.removeChild(r), --n) : t.appendChild(s)) } } class Vr extends st { constructor(t, e, i, n, r, s) { super(t, e, s), this.crossOrigin_ = n, this.src_ = i, this.key = i, this.image_ = new Image, null !== n && (this.image_.crossOrigin = n), this.unlisten_ = null, this.tileLoadFunction_ = r } getImage() { return this.image_ } setImage(t) { this.image_ = t, this.state = J, this.unlistenImage_(), this.changed() } handleImageError_() { this.state = Q, this.unlistenImage_(), this.image_ = function () { const t = Dr(1, 1); return t.fillStyle = "rgba(0,0,0,0)", t.fillRect(0, 0, 1, 1), t.canvas }(), this.changed() } handleImageLoad_() { const t = this.image_; t.naturalWidth && t.naturalHeight ? this.state = J : this.state = tt, this.unlistenImage_(), this.changed() } load() { this.state == Q && (this.state = H, this.image_ = new Image, null !== this.crossOrigin_ && (this.image_.crossOrigin = this.crossOrigin_)), this.state == H && (this.state = $, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = Or(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this))) } unlistenImage_() { this.unlisten_ && (this.unlisten_(), this.unlisten_ = null) } } class Wr { constructor(t, e, i) { this.decay_ = t, this.minVelocity_ = e, this.delay_ = i, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0 } begin() { this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0 } update(t, e) { this.points_.push(t, e, Date.now()) } end() { if (this.points_.length < 6) return !1; const t = Date.now() - this.delay_, e = this.points_.length - 3; if (this.points_[e + 2] < t) return !1; let i = e - 3; for (; i > 0 && this.points_[i + 2] > t;)i -= 3; const n = this.points_[e + 2] - this.points_[i + 2]; if (n < 1e3 / 60) return !1; const r = this.points_[e] - this.points_[i], s = this.points_[e + 1] - this.points_[i + 1]; return this.angle_ = Math.atan2(s, r), this.initialVelocity_ = Math.sqrt(r * r + s * s) / n, this.initialVelocity_ > this.minVelocity_ } getDistance() { return (this.minVelocity_ - this.initialVelocity_) / this.decay_ } getAngle() { return this.angle_ } } const Zr = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i, Yr = /^([a-z]*)$|^hsla?\(.*\)$/i; function Kr(t) { return "string" == typeof t ? t : Qr(t) } function qr(t) { const e = document.createElement("div"); if (e.style.color = t, "" !== e.style.color) { document.body.appendChild(e); const t = getComputedStyle(e).color; return document.body.removeChild(e), t } return "" } const Hr = function () { const t = {}; let e = 0; return function (i) { let n; if (t.hasOwnProperty(i)) n = t[i]; else { if (e >= 1024) { let i = 0; for (const n in t) 0 == (3 & i++) && (delete t[n], --e) } n = function (t) { let e, i, n, r, s; Yr.exec(t) && (t = qr(t)); if (Zr.exec(t)) { const o = t.length - 1; let a; a = o <= 4 ? 1 : 2; const l = 4 === o || 8 === o; e = parseInt(t.substr(1 + 0 * a, a), 16), i = parseInt(t.substr(1 + 1 * a, a), 16), n = parseInt(t.substr(1 + 2 * a, a), 16), r = l ? parseInt(t.substr(1 + 3 * a, a), 16) : 255, 1 == a && (e = (e << 4) + e, i = (i << 4) + i, n = (n << 4) + n, l && (r = (r << 4) + r)), s = [e, i, n, r / 255] } else t.startsWith("rgba(") ? (s = t.slice(5, -1).split(",").map(Number), Jr(s)) : t.startsWith("rgb(") ? (s = t.slice(4, -1).split(",").map(Number), s.push(1), Jr(s)) : at(!1, 14); return s }(i), t[i] = n, ++e } return n } }(); function $r(t) { return Array.isArray(t) ? t : Hr(t) } function Jr(t) { return t[0] = ii(t[0] + .5 | 0, 0, 255), t[1] = ii(t[1] + .5 | 0, 0, 255), t[2] = ii(t[2] + .5 | 0, 0, 255), t[3] = ii(t[3], 0, 1), t } function Qr(t) { let e = t[0]; e != (0 | e) && (e = e + .5 | 0); let i = t[1]; i != (0 | i) && (i = i + .5 | 0); let n = t[2]; n != (0 | n) && (n = n + .5 | 0); return "rgba(" + e + "," + i + "," + n + "," + (void 0 === t[3] ? 1 : Math.round(100 * t[3]) / 100) + ")" } function ts(t) { return Yr.test(t) && (t = qr(t)), Zr.test(t) || t.startsWith("rgba(") || t.startsWith("rgb(") } class es { constructor() { this.cache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 32 } clear() { this.cache_ = {}, this.cacheSize_ = 0 } canExpireCache() { return this.cacheSize_ > this.maxCacheSize_ } expire() { if (this.canExpireCache()) { let t = 0; for (const e in this.cache_) { const i = this.cache_[e]; 0 != (3 & t++) || i.hasListener() || (delete this.cache_[e], --this.cacheSize_) } } } get(t, e, i) { const n = is(t, e, i); return n in this.cache_ ? this.cache_[n] : null } set(t, e, i, n) { const r = is(t, e, i); this.cache_[r] = n, ++this.cacheSize_ } setSize(t) { this.maxCacheSize_ = t, this.expire() } } function is(t, e, i) { return e + ":" + t + ":" + (i ? Kr(i) : "null") } const ns = new es; var rs = "opacity", ss = "visible", os = "extent", as = "zIndex", ls = "maxResolution", hs = "minResolution", cs = "maxZoom", us = "minZoom", ds = "source", gs = "map"; class fs extends V { constructor(t) { super(), this.on, this.once, this.un, this.background_ = t.background; const e = Object.assign({}, t); "object" == typeof t.properties && (delete e.properties, Object.assign(e, t.properties)), e[rs] = void 0 !== t.opacity ? t.opacity : 1, at("number" == typeof e[rs], 64), e[ss] = void 0 === t.visible || t.visible, e[as] = t.zIndex, e[ls] = void 0 !== t.maxResolution ? t.maxResolution : 1 / 0, e[hs] = void 0 !== t.minResolution ? t.minResolution : 0, e[us] = void 0 !== t.minZoom ? t.minZoom : -1 / 0, e[cs] = void 0 !== t.maxZoom ? t.maxZoom : 1 / 0, this.className_ = void 0 !== e.className ? e.className : "ol-layer", delete e.className, this.setProperties(e), this.state_ = null } getBackground() { return this.background_ } getClassName() { return this.className_ } getLayerState(t) { const e = this.state_ || { layer: this, managed: void 0 === t || t }, i = this.getZIndex(); return e.opacity = ii(Math.round(100 * this.getOpacity()) / 100, 0, 1), e.visible = this.getVisible(), e.extent = this.getExtent(), e.zIndex = void 0 !== i || e.managed ? i : 1 / 0, e.maxResolution = this.getMaxResolution(), e.minResolution = Math.max(this.getMinResolution(), 0), e.minZoom = this.getMinZoom(), e.maxZoom = this.getMaxZoom(), this.state_ = e, e } getLayersArray(t) { return B() } getLayerStatesArray(t) { return B() } getExtent() { return this.get(os) } getMaxResolution() { return this.get(ls) } getMinResolution() { return this.get(hs) } getMinZoom() { return this.get(us) } getMaxZoom() { return this.get(cs) } getOpacity() { return this.get(rs) } getSourceState() { return B() } getVisible() { return this.get(ss) } getZIndex() { return this.get(as) } setBackground(t) { this.background_ = t, this.changed() } setExtent(t) { this.set(os, t) } setMaxResolution(t) { this.set(ls, t) } setMinResolution(t) { this.set(hs, t) } setMaxZoom(t) { this.set(cs, t) } setMinZoom(t) { this.set(us, t) } setOpacity(t) { at("number" == typeof t, 64), this.set(rs, t) } setVisible(t) { this.set(ss, t) } setZIndex(t) { this.set(as, t) } disposeInternal() { this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal() } } var ps = "prerender", ms = "postrender", _s = "precompose", ys = "postcompose", xs = "rendercomplete"; class vs extends fs { constructor(t) { const e = Object.assign({}, t); delete e.source, super(e), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.rendered = !1, t.render && (this.render = t.render), t.map && this.setMap(t.map), this.addChangeListener(ds, this.handleSourcePropertyChange_); const i = t.source ? t.source : null; this.setSource(i) } getLayersArray(t) { return (t = t || []).push(this), t } getLayerStatesArray(t) { return (t = t || []).push(this.getLayerState()), t } getSource() { return this.get(ds) || null } getRenderSource() { return this.getSource() } getSourceState() { const t = this.getSource(); return t ? t.getState() : "undefined" } handleSourceChange_() { this.changed() } handleSourcePropertyChange_() { this.sourceChangeKey_ && (k(this.sourceChangeKey_), this.sourceChangeKey_ = null); const t = this.getSource(); t && (this.sourceChangeKey_ = N(t, S, this.handleSourceChange_, this)), this.changed() } getFeatures(t) { return this.renderer_ ? this.renderer_.getFeatures(t) : new Promise((t => t([]))) } getData(t) { return this.renderer_ && this.rendered ? this.renderer_.getData(t) : null } render(t, e) { const i = this.getRenderer(); if (i.prepareFrame(t)) return this.rendered = !0, i.renderFrame(t, e) } unrender() { this.rendered = !1 } setMapInternal(t) { t || this.unrender(), this.set(gs, t) } getMapInternal() { return this.get(gs) } setMap(t) { this.mapPrecomposeKey_ && (k(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), t || this.changed(), this.mapRenderKey_ && (k(this.mapRenderKey_), this.mapRenderKey_ = null), t && (this.mapPrecomposeKey_ = N(t, _s, (function (t) { const e = t.frameState.layerStatesArray, i = this.getLayerState(!1); at(!e.some((function (t) { return t.layer === i.layer })), 67), e.push(i) }), this), this.mapRenderKey_ = N(this, S, t.render, t), this.changed()) } setSource(t) { this.set(ds, t) } getRenderer() { return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_ } hasRenderer() { return !!this.renderer_ } createRenderer() { return null } disposeInternal() { this.renderer_ && (this.renderer_.dispose(), delete this.renderer_), this.setSource(null), super.disposeInternal() } } function Ss(t, e) { if (!t.visible) return !1; const i = e.resolution; if (i < t.minResolution || i >= t.maxResolution) return !1; const n = e.zoom; return n > t.minZoom && n <= t.maxZoom } class ws extends s { constructor(t) { super(), this.map_ = t } dispatchRenderEvent(t, e) { B() } calculateMatrices2D(t) { const e = t.viewState, i = t.coordinateToPixelTransform, n = t.pixelToCoordinateTransform; Mt(i, t.size[0] / 2, t.size[1] / 2, 1 / e.resolution, -1 / e.resolution, -e.rotation, -e.center[0], -e.center[1]), Ft(n, i) } forEachFeatureAtCoordinate(t, e, i, n, r, s, o, a) { let l; const h = e.viewState; function c(t, e, i, n) { return r.call(s, e, t ? i : null, n) } const u = h.projection, d = Pi(t.slice(), u), g = [[0, 0]]; if (u.canWrapX() && n) { const t = Se(u.getExtent()); g.push([-t, 0], [t, 0]) } const f = e.layerStatesArray, p = f.length, m = [], _ = []; for (let n = 0; n < g.length; n++)for (let r = p - 1; r >= 0; --r) { const s = f[r], u = s.layer; if (u.hasRenderer() && Ss(s, h) && o.call(a, u)) { const r = u.getRenderer(), o = u.getSource(); if (r && o) { const a = o.getWrapX() ? d : t, h = c.bind(null, s.managed); _[0] = a[0] + g[n][0], _[1] = a[1] + g[n][1], l = r.forEachFeatureAtCoordinate(_, e, i, h, m) } if (l) return l } } if (0 === m.length) return; const y = 1 / m.length; return m.forEach(((t, e) => t.distanceSq += e * y)), m.sort(((t, e) => t.distanceSq - e.distanceSq)), m.some((t => l = t.callback(t.feature, t.layer, t.geometry))), l } hasFeatureAtCoordinate(t, e, i, n, r, s) { return void 0 !== this.forEachFeatureAtCoordinate(t, e, i, n, g, this, r, s) } getMap() { return this.map_ } renderFrame(t) { B() } scheduleExpireIconCache(t) { ns.canExpireCache() && t.postRenderFunctions.push(Es) } } function Es(t, e) { ns.expire() } class Ts extends i { constructor(t, e, i, n) { super(t), this.inversePixelTransform = e, this.frameState = i, this.context = n } } const Cs = "ol-hidden", bs = "ol-selectable", Rs = "ol-unselectable", Ps = "ol-unsupported", Is = "ol-control", Ls = "ol-collapsed", Ms = new RegExp(["^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)", "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)", "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)", "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?", "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))", "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))", "?\\s*([-,\\\"\\'\\sa-z]+?)\\s*$"].join(""), "i"), Fs = ["style", "variant", "weight", "size", "lineHeight", "family"], As = function (t) { const e = t.match(Ms); if (!e) return null; const i = { lineHeight: "normal", size: "1.2em", style: "normal", weight: "normal", variant: "normal" }; for (let t = 0, n = Fs.length; t < n; ++t) { const n = e[t + 1]; void 0 !== n && (i[Fs[t]] = n) } return i.families = i.family.split(/,\s?/), i }, Os = "10px sans-serif", Ns = "#000", Ds = "round", ks = [], Gs = "round", js = 10, Bs = "#000", Us = "center", zs = "middle", Xs = [0, 0, 0, 0], Vs = new V; let Ws, Zs = null; const Ys = {}, Ks = function () { const t = "32px ", e = ["monospace", "serif"], i = e.length, n = "wmytzilWMYTZIL@#/&?$%10"; let r, s; function o(r, o, a) { let l = !0; for (let h = 0; h < i; ++h) { const i = e[h]; if (s = $s(r + " " + o + " " + t + i, n), a != i) { const e = $s(r + " " + o + " " + t + a + "," + i, n); l = l && e != s } } return !!l } function a() { let t = !0; const e = Vs.getKeys(); for (let i = 0, n = e.length; i < n; ++i) { const n = e[i]; Vs.get(n) < 100 && (o.apply(this, n.split("\n")) ? (y(Ys), Zs = null, Ws = void 0, Vs.set(n, 100)) : (Vs.set(n, Vs.get(n) + 1, !0), t = !1)) } t && (clearInterval(r), r = void 0) } return function (t) { const e = As(t); if (!e) return; const i = e.families; for (let t = 0, n = i.length; t < n; ++t) { const n = i[t], s = e.style + "\n" + e.weight + "\n" + n; void 0 === Vs.get(s) && (Vs.set(s, 100, !0), o(e.style, e.weight, n) || (Vs.set(s, 0, !0), void 0 === r && (r = setInterval(a, 32)))) } } }(), qs = function () { let t; return function (e) { let i = Ys[e]; if (null == i) { if (_t) { const t = As(e), n = Hs(e, "Žg"); i = (isNaN(Number(t.lineHeight)) ? 1.2 : Number(t.lineHeight)) * (n.actualBoundingBoxAscent + n.actualBoundingBoxDescent) } else t || (t = document.createElement("div"), t.innerHTML = "M", t.style.minHeight = "0", t.style.maxHeight = "none", t.style.height = "auto", t.style.padding = "0", t.style.border = "none", t.style.position = "absolute", t.style.display = "block", t.style.left = "-99999px"), t.style.font = e, document.body.appendChild(t), i = t.offsetHeight, document.body.removeChild(t); Ys[e] = i } return i } }(); function Hs(t, e) { return Zs || (Zs = Dr(1, 1)), t != Ws && (Zs.font = t, Ws = Zs.font), Zs.measureText(e) } function $s(t, e) { return Hs(t, e).width } function Js(t, e, i) { if (e in i) return i[e]; const n = e.split("\n").reduce(((e, i) => Math.max(e, $s(t, i))), 0); return i[e] = n, n } function Qs(t, e) { const i = [], n = [], r = []; let s = 0, o = 0, a = 0, l = 0; for (let h = 0, c = e.length; h <= c; h += 2) { const u = e[h]; if ("\n" === u || h === c) { s = Math.max(s, o), r.push(o), o = 0, a += l; continue } const d = e[h + 1] || t.font, g = $s(d, u); i.push(g), o += g; const f = qs(d); n.push(f), l = Math.max(l, f) } return { width: s, height: a, widths: i, heights: n, lineWidths: r } } function to(t, e, i, n, r, s, o, a, l, h, c) { t.save(), 1 !== i && (t.globalAlpha *= i), e && t.setTransform.apply(t, e), n.contextInstructions ? (t.translate(l, h), t.scale(c[0], c[1]), function (t, e) { const i = t.contextInstructions; for (let t = 0, n = i.length; t < n; t += 2)Array.isArray(i[t + 1]) ? e[i[t]].apply(e, i[t + 1]) : e[i[t]] = i[t + 1] }(n, t)) : c[0] < 0 || c[1] < 0 ? (t.translate(l, h), t.scale(c[0], c[1]), t.drawImage(n, r, s, o, a, 0, 0, o, a)) : t.drawImage(n, r, s, o, a, l, h, o * c[0], a * c[1]), t.restore() } class eo extends ws { constructor(t) { super(t), this.fontChangeListenerKey_ = N(Vs, r, t.redrawText.bind(t)), this.element_ = document.createElement("div"); const e = this.element_.style; e.position = "absolute", e.width = "100%", e.height = "100%", e.zIndex = "0", this.element_.className = "ol-unselectable ol-layers"; const i = t.getViewport(); i.insertBefore(this.element_, i.firstChild || null), this.children_ = [], this.renderedVisible_ = !0 } dispatchRenderEvent(t, e) { const i = this.getMap(); if (i.hasListener(t)) { const n = new Ts(t, void 0, e); i.dispatchEvent(n) } } disposeInternal() { k(this.fontChangeListenerKey_), this.element_.parentNode.removeChild(this.element_), super.disposeInternal() } renderFrame(t) { if (!t) return void (this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = !1)); this.calculateMatrices2D(t), this.dispatchRenderEvent(_s, t); const e = t.layerStatesArray.sort((function (t, e) { return t.zIndex - e.zIndex })), i = t.viewState; this.children_.length = 0; const n = []; let r = null; for (let s = 0, o = e.length; s < o; ++s) { const o = e[s]; t.layerIndex = s; const a = o.layer, l = a.getSourceState(); if (!Ss(o, i) || "ready" != l && "undefined" != l) { a.unrender(); continue } const h = a.render(t, r); h && (h !== r && (this.children_.push(h), r = h), "getDeclutter" in a && n.push(a)) } for (let e = n.length - 1; e >= 0; --e)n[e].renderDeclutter(t); Xr(this.element_, this.children_), this.dispatchRenderEvent(ys, t), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = !0), this.scheduleExpireIconCache(t) } } class io extends i { constructor(t, e) { super(t), this.layer = e } } const no = "layers"; class ro extends fs { constructor(t) { t = t || {}; const e = Object.assign({}, t); delete e.layers; let i = t.layers; super(e), this.on, this.once, this.un, this.layersListenerKeys_ = [], this.listenerKeys_ = {}, this.addChangeListener(no, this.handleLayersChanged_), i ? Array.isArray(i) ? i = new q(i.slice(), { unique: !0 }) : at("function" == typeof i.getArray, 43) : i = new q(void 0, { unique: !0 }), this.setLayers(i) } handleLayerChange_() { this.changed() } handleLayersChanged_() { this.layersListenerKeys_.forEach(k), this.layersListenerKeys_.length = 0; const t = this.getLayers(); this.layersListenerKeys_.push(N(t, W, this.handleLayersAdd_, this), N(t, Z, this.handleLayersRemove_, this)); for (const t in this.listenerKeys_) this.listenerKeys_[t].forEach(k); y(this.listenerKeys_); const e = t.getArray(); for (let t = 0, i = e.length; t < i; t++) { const i = e[t]; this.registerLayerListeners_(i), this.dispatchEvent(new io("addlayer", i)) } this.changed() } registerLayerListeners_(t) { const e = [N(t, r, this.handleLayerChange_, this), N(t, S, this.handleLayerChange_, this)]; t instanceof ro && e.push(N(t, "addlayer", this.handleLayerGroupAdd_, this), N(t, "removelayer", this.handleLayerGroupRemove_, this)), this.listenerKeys_[z(t)] = e } handleLayerGroupAdd_(t) { this.dispatchEvent(new io("addlayer", t.layer)) } handleLayerGroupRemove_(t) { this.dispatchEvent(new io("removelayer", t.layer)) } handleLayersAdd_(t) { const e = t.element; this.registerLayerListeners_(e), this.dispatchEvent(new io("addlayer", e)), this.changed() } handleLayersRemove_(t) { const e = t.element, i = z(e); this.listenerKeys_[i].forEach(k), delete this.listenerKeys_[i], this.dispatchEvent(new io("removelayer", e)), this.changed() } getLayers() { return this.get(no) } setLayers(t) { const e = this.getLayers(); if (e) { const t = e.getArray(); for (let e = 0, i = t.length; e < i; ++e)this.dispatchEvent(new io("removelayer", t[e])) } this.set(no, t) } getLayersArray(t) { return t = void 0 !== t ? t : [], this.getLayers().forEach((function (e) { e.getLayersArray(t) })), t } getLayerStatesArray(t) { const e = void 0 !== t ? t : [], i = e.length; this.getLayers().forEach((function (t) { t.getLayerStatesArray(e) })); const n = this.getLayerState(); let r = n.zIndex; t || void 0 !== n.zIndex || (r = 0); for (let t = i, s = e.length; t < s; t++) { const i = e[t]; i.opacity *= n.opacity, i.visible = i.visible && n.visible, i.maxResolution = Math.min(i.maxResolution, n.maxResolution), i.minResolution = Math.max(i.minResolution, n.minResolution), i.minZoom = Math.max(i.minZoom, n.minZoom), i.maxZoom = Math.min(i.maxZoom, n.maxZoom), void 0 !== n.extent && (void 0 !== i.extent ? i.extent = ye(i.extent, n.extent) : i.extent = n.extent), void 0 === i.zIndex && (i.zIndex = r) } return e } getSourceState() { return "ready" } } class so extends i { constructor(t, e, i) { super(t), this.map = e, this.frameState = void 0 !== i ? i : null } } class oo extends so { constructor(t, e, i, n, r, s) { super(t, e, r), this.originalEvent = i, this.pixel_ = null, this.coordinate_ = null, this.dragging = void 0 !== n && n, this.activePointers = s } get pixel() { return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_ } set pixel(t) { this.pixel_ = t } get coordinate() { return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_ } set coordinate(t) { this.coordinate_ = t } preventDefault() { super.preventDefault(), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault() } stopPropagation() { super.stopPropagation(), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation() } } var ao = { SINGLECLICK: "singleclick", CLICK: T, DBLCLICK: C, POINTERDRAG: "pointerdrag", POINTERMOVE: "pointermove", POINTERDOWN: "pointerdown", POINTERUP: "pointerup", POINTEROVER: "pointerover", POINTEROUT: "pointerout", POINTERENTER: "pointerenter", POINTERLEAVE: "pointerleave", POINTERCANCEL: "pointercancel" }, lo = "pointermove", ho = "pointerdown", co = "pointerup", uo = "pointerout"; class go extends v { constructor(t, e) { super(t), this.map_ = t, this.clickTimeoutId_, this.emulateClicks_ = !1, this.dragging_ = !1, this.dragListenerKeys_ = [], this.moveTolerance_ = void 0 === e ? 1 : e, this.down_ = null; const i = this.map_.getViewport(); this.activePointers_ = [], this.trackedTouches_ = {}, this.element_ = i, this.pointerdownListenerKey_ = N(i, ho, this.handlePointerDown_, this), this.originalPointerMoveEvent_, this.relayedListenerKey_ = N(i, lo, this.relayMoveEvent_, this), this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this), this.element_.addEventListener(A, this.boundHandleTouchMove_, !!xt && { passive: !1 }) } emulateClick_(t) { let e = new oo(ao.CLICK, this.map_, t); this.dispatchEvent(e), void 0 !== this.clickTimeoutId_ ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, e = new oo(ao.DBLCLICK, this.map_, t), this.dispatchEvent(e)) : this.clickTimeoutId_ = setTimeout(function () { this.clickTimeoutId_ = void 0; const e = new oo(ao.SINGLECLICK, this.map_, t); this.dispatchEvent(e) }.bind(this), 250) } updateActivePointers_(t) { const e = t, i = e.pointerId; if (e.type == ao.POINTERUP || e.type == ao.POINTERCANCEL) { delete this.trackedTouches_[i]; for (const t in this.trackedTouches_) if (this.trackedTouches_[t].target !== e.target) { delete this.trackedTouches_[t]; break } } else e.type != ao.POINTERDOWN && e.type != ao.POINTERMOVE || (this.trackedTouches_[i] = e); this.activePointers_ = Object.values(this.trackedTouches_) } handlePointerUp_(t) { this.updateActivePointers_(t); const e = new oo(ao.POINTERUP, this.map_, t, void 0, void 0, this.activePointers_); this.dispatchEvent(e), this.emulateClicks_ && !e.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(t) && this.emulateClick_(this.down_), 0 === this.activePointers_.length && (this.dragListenerKeys_.forEach(k), this.dragListenerKeys_.length = 0, this.dragging_ = !1, this.down_ = null) } isMouseActionButton_(t) { return 0 === t.button } handlePointerDown_(t) { this.emulateClicks_ = 0 === this.activePointers_.length, this.updateActivePointers_(t); const e = new oo(ao.POINTERDOWN, this.map_, t, void 0, void 0, this.activePointers_); this.dispatchEvent(e), this.down_ = {}; for (const e in t) { const i = t[e]; this.down_[e] = "function" == typeof i ? p : i } if (0 === this.dragListenerKeys_.length) { const t = this.map_.getOwnerDocument(); this.dragListenerKeys_.push(N(t, ao.POINTERMOVE, this.handlePointerMove_, this), N(t, ao.POINTERUP, this.handlePointerUp_, this), N(this.element_, ao.POINTERCANCEL, this.handlePointerUp_, this)), this.element_.getRootNode && this.element_.getRootNode() !== t && this.dragListenerKeys_.push(N(this.element_.getRootNode(), ao.POINTERUP, this.handlePointerUp_, this)) } } handlePointerMove_(t) { if (this.isMoving_(t)) { this.updateActivePointers_(t), this.dragging_ = !0; const e = new oo(ao.POINTERDRAG, this.map_, t, this.dragging_, void 0, this.activePointers_); this.dispatchEvent(e) } } relayMoveEvent_(t) { this.originalPointerMoveEvent_ = t; const e = !(!this.down_ || !this.isMoving_(t)); this.dispatchEvent(new oo(ao.POINTERMOVE, this.map_, t, e)) } handleTouchMove_(t) { const e = this.originalPointerMoveEvent_; e && !e.defaultPrevented || "boolean" == typeof t.cancelable && !0 !== t.cancelable || t.preventDefault() } isMoving_(t) { return this.dragging_ || Math.abs(t.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(t.clientY - this.down_.clientY) > this.moveTolerance_ } disposeInternal() { this.relayedListenerKey_ && (k(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.element_.removeEventListener(A, this.boundHandleTouchMove_), this.pointerdownListenerKey_ && (k(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach(k), this.dragListenerKeys_.length = 0, this.element_ = null, super.disposeInternal() } } var fo = "postrender", po = "movestart", mo = "moveend", _o = "loadstart", yo = "loadend", xo = "layergroup", vo = "size", So = "target", wo = "view"; const Eo = 1 / 0; class To { constructor(t, e) { this.priorityFunction_ = t, this.keyFunction_ = e, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {} } clear() { this.elements_.length = 0, this.priorities_.length = 0, y(this.queuedElements_) } dequeue() { const t = this.elements_, e = this.priorities_, i = t[0]; 1 == t.length ? (t.length = 0, e.length = 0) : (t[0] = t.pop(), e[0] = e.pop(), this.siftUp_(0)); const n = this.keyFunction_(i); return delete this.queuedElements_[n], i } enqueue(t) { at(!(this.keyFunction_(t) in this.queuedElements_), 31); const e = this.priorityFunction_(t); return e != Eo && (this.elements_.push(t), this.priorities_.push(e), this.queuedElements_[this.keyFunction_(t)] = !0, this.siftDown_(0, this.elements_.length - 1), !0) } getCount() { return this.elements_.length } getLeftChildIndex_(t) { return 2 * t + 1 } getRightChildIndex_(t) { return 2 * t + 2 } getParentIndex_(t) { return t - 1 >> 1 } heapify_() { let t; for (t = (this.elements_.length >> 1) - 1; t >= 0; t--)this.siftUp_(t) } isEmpty() { return 0 === this.elements_.length } isKeyQueued(t) { return t in this.queuedElements_ } isQueued(t) { return this.isKeyQueued(this.keyFunction_(t)) } siftUp_(t) { const e = this.elements_, i = this.priorities_, n = e.length, r = e[t], s = i[t], o = t; for (; t < n >> 1;) { const r = this.getLeftChildIndex_(t), s = this.getRightChildIndex_(t), o = s < n && i[s] < i[r] ? s : r; e[t] = e[o], i[t] = i[o], t = o } e[t] = r, i[t] = s, this.siftDown_(o, t) } siftDown_(t, e) { const i = this.elements_, n = this.priorities_, r = i[e], s = n[e]; for (; e > t;) { const t = this.getParentIndex_(e); if (!(n[t] > s)) break; i[e] = i[t], n[e] = n[t], e = t } i[e] = r, n[e] = s } reprioritize() { const t = this.priorityFunction_, e = this.elements_, i = this.priorities_; let n = 0; const r = e.length; let s, o, a; for (o = 0; o < r; ++o)s = e[o], a = t(s), a == Eo ? delete this.queuedElements_[this.keyFunction_(s)] : (i[n] = a, e[n++] = s); e.length = n, i.length = n, this.heapify_() } } class Co extends To { constructor(t, e) { super((function (e) { return t.apply(null, e) }), (function (t) { return t[0].getKey() })), this.boundHandleTileChange_ = this.handleTileChange.bind(this), this.tileChangeCallback_ = e, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {} } enqueue(t) { const e = super.enqueue(t); if (e) { t[0].addEventListener(S, this.boundHandleTileChange_) } return e } getTilesLoading() { return this.tilesLoading_ } handleTileChange(t) { const e = t.target, i = e.getState(); if (i === J || i === Q || i === tt) { i !== Q && e.removeEventListener(S, this.boundHandleTileChange_); const t = e.getKey(); t in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[t], --this.tilesLoading_), this.tileChangeCallback_() } } loadMoreTiles(t, e) { let i, n, r, s = 0; for (; this.tilesLoading_ < t && s < e && this.getCount() > 0;)n = this.dequeue()[0], r = n.getKey(), i = n.getState(), i !== H || r in this.tilesLoadingKeys_ || (this.tilesLoadingKeys_[r] = !0, ++this.tilesLoading_, ++s, n.load()) } } function bo(t, e, i, n, r) { if (!t || !(i in t.wantedTiles)) return Eo; if (!t.wantedTiles[i][e.getKey()]) return Eo; const s = t.viewState.center, o = n[0] - s[0], a = n[1] - s[1]; return 65536 * Math.log(r) + Math.sqrt(o * o + a * a) / r } var Ro = 0, Po = 1, Io = { CENTER: "center", RESOLUTION: "resolution", ROTATION: "rotation" }; const Lo = 256; function Mo(t, e, i) { return function (n, r, s, o, a) { if (!n) return; if (!r && !e) return n; const l = e ? 0 : s[0] * r, h = e ? 0 : s[1] * r, c = a ? a[0] : 0, u = a ? a[1] : 0; let d = t[0] + l / 2 + c, g = t[2] - l / 2 + c, f = t[1] + h / 2 + u, p = t[3] - h / 2 + u; d > g && (d = (g + d) / 2, g = d), f > p && (f = (p + f) / 2, p = f); let m = ii(n[0], d, g), _ = ii(n[1], f, p); if (o && i && r) { const t = 30 * r; m += -t * Math.log(1 + Math.max(0, d - n[0]) / t) + t * Math.log(1 + Math.max(0, n[0] - g) / t), _ += -t * Math.log(1 + Math.max(0, f - n[1]) / t) + t * Math.log(1 + Math.max(0, n[1] - p) / t) } return [m, _] } } function Fo(t) { return t } function Ao(t, e, i, n) { const r = Se(e) / i[0], s = _e(e) / i[1]; return n ? Math.min(t, Math.max(r, s)) : Math.min(t, Math.min(r, s)) } function Oo(t, e, i) { let n = Math.min(t, e); return n *= Math.log(1 + 50 * Math.max(0, t / e - 1)) / 50 + 1, i && (n = Math.max(n, i), n /= Math.log(1 + 50 * Math.max(0, i / t - 1)) / 50 + 1), ii(n, i / 2, 2 * e) } function No(t, e, i, n) { return e = void 0 === e || e, function (r, s, o, a) { if (void 0 !== r) { const h = t[0], c = t[t.length - 1], u = i ? Ao(h, i, o, n) : h; if (a) return e ? Oo(r, u, c) : ii(r, c, u); const d = Math.min(u, r), g = Math.floor(l(t, d, s)); return t[g] > u && g < t.length - 1 ? t[g + 1] : t[g] } } } function Do(t, e, i, n, r, s) { return n = void 0 === n || n, i = void 0 !== i ? i : 0, function (o, a, l, h) { if (void 0 !== o) { const c = r ? Ao(e, r, l, s) : e; if (h) return n ? Oo(o, c, i) : ii(o, i, c); const u = 1e-9, d = Math.ceil(Math.log(e / c) / Math.log(t) - u), g = -a * (.5 - u) + .5, f = Math.min(c, o), p = Math.floor(Math.log(e / f) / Math.log(t) + g), m = Math.max(d, p); return ii(e / Math.pow(t, m), i, c) } } } function ko(t, e, i, n, r) { return i = void 0 === i || i, function (s, o, a, l) { if (void 0 !== s) { const o = n ? Ao(t, n, a, r) : t; return i && l ? Oo(s, o, e) : ii(s, e, o) } } } function Go(t) { return void 0 !== t ? 0 : void 0 } function jo(t) { return void 0 !== t ? t : void 0 } function Bo(t) { const e = 2 * Math.PI / t; return function (t, i) { return i ? t : void 0 !== t ? t = Math.floor(t / e + .5) * e : void 0 } } function Uo(t) { return t = t || ai(5), function (e, i) { return i ? e : void 0 !== e ? Math.abs(e) <= t ? 0 : e : void 0 } } class zo extends V { constructor(t) { super(), this.on, this.once, this.un, t = Object.assign({}, t), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = Wi(t.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, t.projection && Di(), t.center && (t.center = rn(t.center, this.projection_)), t.extent && (t.extent = on(t.extent, this.projection_)), this.applyOptions_(t) } applyOptions_(t) { const e = Object.assign({}, t); for (const t in Io) delete e[t]; this.setProperties(e, !0); const i = Wo(t); this.maxResolution_ = i.maxResolution, this.minResolution_ = i.minResolution, this.zoomFactor_ = i.zoomFactor, this.resolutions_ = t.resolutions, this.padding_ = t.padding, this.minZoom_ = i.minZoom; const n = Vo(t), r = i.constraint, s = Zo(t); this.constraints_ = { center: n, resolution: r, rotation: s }, this.setRotation(void 0 !== t.rotation ? t.rotation : 0), this.setCenterInternal(void 0 !== t.center ? t.center : null), void 0 !== t.resolution ? this.setResolution(t.resolution) : void 0 !== t.zoom && this.setZoom(t.zoom) } get padding() { return this.padding_ } set padding(t) { let e = this.padding_; this.padding_ = t; const i = this.getCenter(); if (i) { const n = t || [0, 0, 0, 0]; e = e || [0, 0, 0, 0]; const r = this.getResolution(), s = r / 2 * (n[3] - e[3] + e[1] - n[1]), o = r / 2 * (n[0] - e[0] + e[2] - n[2]); this.setCenterInternal([i[0] + s, i[1] - o]) } } getUpdatedOptions_(t) { const e = this.getProperties(); return void 0 !== e.resolution ? e.resolution = this.getResolution() : e.zoom = this.getZoom(), e.center = this.getCenterInternal(), e.rotation = this.getRotation(), Object.assign({}, e, t) } animate(t) { this.isDef() && !this.getAnimating() && this.resolveConstraints(0); const e = new Array(arguments.length); for (let t = 0; t < e.length; ++t) { let i = arguments[t]; i.center && (i = Object.assign({}, i), i.center = rn(i.center, this.getProjection())), i.anchor && (i = Object.assign({}, i), i.anchor = rn(i.anchor, this.getProjection())), e[t] = i } this.animateInternal.apply(this, e) } animateInternal(t) { let e, i = arguments.length; i > 1 && "function" == typeof arguments[i - 1] && (e = arguments[i - 1], --i); let n = 0; for (; n < i && !this.isDef(); ++n) { const t = arguments[n]; t.center && this.setCenterInternal(t.center), void 0 !== t.zoom ? this.setZoom(t.zoom) : t.resolution && this.setResolution(t.resolution), void 0 !== t.rotation && this.setRotation(t.rotation) } if (n === i) return void (e && Xo(e, !0)); let r = Date.now(), s = this.targetCenter_.slice(), o = this.targetResolution_, a = this.targetRotation_; const l = []; for (; n < i; ++n) { const t = arguments[n], i = { start: r, complete: !1, anchor: t.anchor, duration: void 0 !== t.duration ? t.duration : 1e3, easing: t.easing || nt, callback: e }; if (t.center && (i.sourceCenter = s, i.targetCenter = t.center.slice(), s = i.targetCenter), void 0 !== t.zoom ? (i.sourceResolution = o, i.targetResolution = this.getResolutionForZoom(t.zoom), o = i.targetResolution) : t.resolution && (i.sourceResolution = o, i.targetResolution = t.resolution, o = i.targetResolution), void 0 !== t.rotation) { i.sourceRotation = a; const e = li(t.rotation - a + Math.PI, 2 * Math.PI) - Math.PI; i.targetRotation = a + e, a = i.targetRotation } Yo(i) ? i.complete = !0 : r += i.duration, l.push(i) } this.animations_.push(l), this.setHint(Ro, 1), this.updateAnimations_() } getAnimating() { return this.hints_[Ro] > 0 } getInteracting() { return this.hints_[Po] > 0 } cancelAnimations() { let t; this.setHint(Ro, -this.hints_[Ro]); for (let e = 0, i = this.animations_.length; e < i; ++e) { const i = this.animations_[e]; if (i[0].callback && Xo(i[0].callback, !1), !t) for (let e = 0, n = i.length; e < n; ++e) { const n = i[e]; if (!n.complete) { t = n.anchor; break } } } this.animations_.length = 0, this.cancelAnchor_ = t, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN } updateAnimations_() { if (void 0 !== this.updateAnimationKey_ && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating()) return; const t = Date.now(); let e = !1; for (let i = this.animations_.length - 1; i >= 0; --i) { const n = this.animations_[i]; let r = !0; for (let i = 0, s = n.length; i < s; ++i) { const s = n[i]; if (s.complete) continue; const o = t - s.start; let a = s.duration > 0 ? o / s.duration : 1; a >= 1 ? (s.complete = !0, a = 1) : r = !1; const l = s.easing(a); if (s.sourceCenter) { const t = s.sourceCenter[0], e = s.sourceCenter[1], i = s.targetCenter[0], n = s.targetCenter[1]; this.nextCenter_ = s.targetCenter; const r = t + l * (i - t), o = e + l * (n - e); this.targetCenter_ = [r, o] } if (s.sourceResolution && s.targetResolution) { const t = 1 === l ? s.targetResolution : s.sourceResolution + l * (s.targetResolution - s.sourceResolution); if (s.anchor) { const e = this.getViewportSize_(this.getRotation()), i = this.constraints_.resolution(t, 0, e, !0); this.targetCenter_ = this.calculateCenterZoom(i, s.anchor) } this.nextResolution_ = s.targetResolution, this.targetResolution_ = t, this.applyTargetState_(!0) } if (void 0 !== s.sourceRotation && void 0 !== s.targetRotation) { const t = 1 === l ? li(s.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : s.sourceRotation + l * (s.targetRotation - s.sourceRotation); if (s.anchor) { const e = this.constraints_.rotation(t, !0); this.targetCenter_ = this.calculateCenterRotate(e, s.anchor) } this.nextRotation_ = s.targetRotation, this.targetRotation_ = t } if (this.applyTargetState_(!0), e = !0, !s.complete) break } if (r) { this.animations_[i] = null, this.setHint(Ro, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN; const t = n[0].callback; t && Xo(t, !0) } } this.animations_ = this.animations_.filter(Boolean), e && void 0 === this.updateAnimationKey_ && (this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this))) } calculateCenterRotate(t, e) { let i; const n = this.getCenterInternal(); return void 0 !== n && (i = [n[0] - e[0], n[1] - e[1]], wi(i, t - this.getRotation()), mi(i, e)), i } calculateCenterZoom(t, e) { let i; const n = this.getCenterInternal(), r = this.getResolution(); if (void 0 !== n && void 0 !== r) { i = [e[0] - t * (e[0] - n[0]) / r, e[1] - t * (e[1] - n[1]) / r] } return i } getViewportSize_(t) { const e = this.viewportSize_; if (t) { const i = e[0], n = e[1]; return [Math.abs(i * Math.cos(t)) + Math.abs(n * Math.sin(t)), Math.abs(i * Math.sin(t)) + Math.abs(n * Math.cos(t))] } return e } setViewportSize(t) { this.viewportSize_ = Array.isArray(t) ? t.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0) } getCenter() { const t = this.getCenterInternal(); return t ? nn(t, this.getProjection()) : t } getCenterInternal() { return this.get(Io.CENTER) } getConstraints() { return this.constraints_ } getConstrainResolution() { return this.get("constrainResolution") } getHints(t) { return void 0 !== t ? (t[0] = this.hints_[0], t[1] = this.hints_[1], t) : this.hints_.slice() } calculateExtent(t) { return sn(this.calculateExtentInternal(t), this.getProjection()) } calculateExtentInternal(t) { t = t || this.getViewportSizeMinusPadding_(); const e = this.getCenterInternal(); at(e, 1); const i = this.getResolution(); at(void 0 !== i, 2); const n = this.getRotation(); return at(void 0 !== n, 3), pe(e, i, n, t) } getMaxResolution() { return this.maxResolution_ } getMinResolution() { return this.minResolution_ } getMaxZoom() { return this.getZoomForResolution(this.minResolution_) } setMaxZoom(t) { this.applyOptions_(this.getUpdatedOptions_({ maxZoom: t })) } getMinZoom() { return this.getZoomForResolution(this.maxResolution_) } setMinZoom(t) { this.applyOptions_(this.getUpdatedOptions_({ minZoom: t })) } setConstrainResolution(t) { this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: t })) } getProjection() { return this.projection_ } getResolution() { return this.get(Io.RESOLUTION) } getResolutions() { return this.resolutions_ } getResolutionForExtent(t, e) { return this.getResolutionForExtentInternal(on(t, this.getProjection()), e) } getResolutionForExtentInternal(t, e) { e = e || this.getViewportSizeMinusPadding_(); const i = Se(t) / e[0], n = _e(t) / e[1]; return Math.max(i, n) } getResolutionForValueFunction(t) { t = t || 2; const e = this.getConstrainedResolution(this.maxResolution_), i = this.minResolution_, n = Math.log(e / i) / Math.log(t); return function (i) { return e / Math.pow(t, i * n) } } getRotation() { return this.get(Io.ROTATION) } getValueForResolutionFunction(t) { const e = Math.log(t || 2), i = this.getConstrainedResolution(this.maxResolution_), n = this.minResolution_, r = Math.log(i / n) / e; return function (t) { return Math.log(i / t) / e / r } } getViewportSizeMinusPadding_(t) { let e = this.getViewportSize_(t); const i = this.padding_; return i && (e = [e[0] - i[1] - i[3], e[1] - i[0] - i[2]]), e } getState() { const t = this.getProjection(), e = this.getResolution(), i = this.getRotation(); let n = this.getCenterInternal(); const r = this.padding_; if (r) { const t = this.getViewportSizeMinusPadding_(); n = Ko(n, this.getViewportSize_(), [t[0] / 2 + r[3], t[1] / 2 + r[0]], e, i) } return { center: n.slice(0), projection: void 0 !== t ? t : null, resolution: e, nextCenter: this.nextCenter_, nextResolution: this.nextResolution_, nextRotation: this.nextRotation_, rotation: i, zoom: this.getZoom() } } getZoom() { let t; const e = this.getResolution(); return void 0 !== e && (t = this.getZoomForResolution(e)), t } getZoomForResolution(t) { let e, i, n = this.minZoom_ || 0; if (this.resolutions_) { const r = l(this.resolutions_, t, 1); n = r, e = this.resolutions_[r], i = r == this.resolutions_.length - 1 ? 2 : e / this.resolutions_[r + 1] } else e = this.maxResolution_, i = this.zoomFactor_; return n + Math.log(e / t) / Math.log(i) } getResolutionForZoom(t) { if (this.resolutions_) { if (this.resolutions_.length <= 1) return 0; const e = ii(Math.floor(t), 0, this.resolutions_.length - 2), i = this.resolutions_[e] / this.resolutions_[e + 1]; return this.resolutions_[e] / Math.pow(i, ii(t - e, 0, 1)) } return this.maxResolution_ / Math.pow(this.zoomFactor_, t - this.minZoom_) } fit(t, e) { let i; if (at(Array.isArray(t) || "function" == typeof t.getSimplifiedGeometry, 24), Array.isArray(t)) { at(!Ee(t), 25); i = gr(on(t, this.getProjection())) } else if ("Circle" === t.getType()) { const e = on(t.getExtent(), this.getProjection()); i = gr(e), i.rotate(this.getRotation(), ge(e)) } else { const e = en(); i = e ? t.clone().transform(e, this.getProjection()) : t } this.fitInternal(i, e) } rotatedExtentForGeometry(t) { const e = this.getRotation(), i = Math.cos(e), n = Math.sin(-e), r = t.getFlatCoordinates(), s = t.getStride(); let o = 1 / 0, a = 1 / 0, l = -1 / 0, h = -1 / 0; for (let t = 0, e = r.length; t < e; t += s) { const e = r[t] * i - r[t + 1] * n, s = r[t] * n + r[t + 1] * i; o = Math.min(o, e), a = Math.min(a, s), l = Math.max(l, e), h = Math.max(h, s) } return [o, a, l, h] } fitInternal(t, e) { let i = (e = e || {}).size; i || (i = this.getViewportSizeMinusPadding_()); const n = void 0 !== e.padding ? e.padding : [0, 0, 0, 0], r = void 0 !== e.nearest && e.nearest; let s; s = void 0 !== e.minResolution ? e.minResolution : void 0 !== e.maxZoom ? this.getResolutionForZoom(e.maxZoom) : 0; const o = this.rotatedExtentForGeometry(t); let a = this.getResolutionForExtentInternal(o, [i[0] - n[1] - n[3], i[1] - n[0] - n[2]]); a = isNaN(a) ? s : Math.max(a, s), a = this.getConstrainedResolution(a, r ? 0 : 1); const l = this.getRotation(), h = Math.sin(l), c = Math.cos(l), u = ge(o); u[0] += (n[1] - n[3]) / 2 * a, u[1] += (n[0] - n[2]) / 2 * a; const d = u[0] * c - u[1] * h, g = u[1] * c + u[0] * h, f = this.getConstrainedCenter([d, g], a), m = e.callback ? e.callback : p; void 0 !== e.duration ? this.animateInternal({ resolution: a, center: f, duration: e.duration, easing: e.easing }, m) : (this.targetResolution_ = a, this.targetCenter_ = f, this.applyTargetState_(!1, !0), Xo(m, !0)) } centerOn(t, e, i) { this.centerOnInternal(rn(t, this.getProjection()), e, i) } centerOnInternal(t, e, i) { this.setCenterInternal(Ko(t, e, i, this.getResolution(), this.getRotation())) } calculateCenterShift(t, e, i, n) { let r; const s = this.padding_; if (s && t) { const o = this.getViewportSizeMinusPadding_(-i), a = Ko(t, n, [o[0] / 2 + s[3], o[1] / 2 + s[0]], e, i); r = [t[0] - a[0], t[1] - a[1]] } return r } isDef() { return !!this.getCenterInternal() && void 0 !== this.getResolution() } adjustCenter(t) { const e = nn(this.targetCenter_, this.getProjection()); this.setCenter([e[0] + t[0], e[1] + t[1]]) } adjustCenterInternal(t) { const e = this.targetCenter_; this.setCenterInternal([e[0] + t[0], e[1] + t[1]]) } adjustResolution(t, e) { e = e && rn(e, this.getProjection()), this.adjustResolutionInternal(t, e) } adjustResolutionInternal(t, e) { const i = this.getAnimating() || this.getInteracting(), n = this.getViewportSize_(this.getRotation()), r = this.constraints_.resolution(this.targetResolution_ * t, 0, n, i); e && (this.targetCenter_ = this.calculateCenterZoom(r, e)), this.targetResolution_ *= t, this.applyTargetState_() } adjustZoom(t, e) { this.adjustResolution(Math.pow(this.zoomFactor_, -t), e) } adjustRotation(t, e) { e && (e = rn(e, this.getProjection())), this.adjustRotationInternal(t, e) } adjustRotationInternal(t, e) { const i = this.getAnimating() || this.getInteracting(), n = this.constraints_.rotation(this.targetRotation_ + t, i); e && (this.targetCenter_ = this.calculateCenterRotate(n, e)), this.targetRotation_ += t, this.applyTargetState_() } setCenter(t) { this.setCenterInternal(t ? rn(t, this.getProjection()) : t) } setCenterInternal(t) { this.targetCenter_ = t, this.applyTargetState_() } setHint(t, e) { return this.hints_[t] += e, this.changed(), this.hints_[t] } setResolution(t) { this.targetResolution_ = t, this.applyTargetState_() } setRotation(t) { this.targetRotation_ = t, this.applyTargetState_() } setZoom(t) { this.setResolution(this.getResolutionForZoom(t)) } applyTargetState_(t, e) { const i = this.getAnimating() || this.getInteracting() || e, n = this.constraints_.rotation(this.targetRotation_, i), r = this.getViewportSize_(n), s = this.constraints_.resolution(this.targetResolution_, 0, r, i), o = this.constraints_.center(this.targetCenter_, s, r, i, this.calculateCenterShift(this.targetCenter_, s, n, r)); this.get(Io.ROTATION) !== n && this.set(Io.ROTATION, n), this.get(Io.RESOLUTION) !== s && (this.set(Io.RESOLUTION, s), this.set("zoom", this.getZoom(), !0)), o && this.get(Io.CENTER) && Si(this.get(Io.CENTER), o) || this.set(Io.CENTER, o), this.getAnimating() && !t && this.cancelAnimations(), this.cancelAnchor_ = void 0 } resolveConstraints(t, e, i) { t = void 0 !== t ? t : 200; const n = e || 0, r = this.constraints_.rotation(this.targetRotation_), s = this.getViewportSize_(r), o = this.constraints_.resolution(this.targetResolution_, n, s), a = this.constraints_.center(this.targetCenter_, o, s, !1, this.calculateCenterShift(this.targetCenter_, o, r, s)); if (0 === t && !this.cancelAnchor_) return this.targetResolution_ = o, this.targetRotation_ = r, this.targetCenter_ = a, void this.applyTargetState_(); i = i || (0 === t ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, this.getResolution() === o && this.getRotation() === r && this.getCenterInternal() && Si(this.getCenterInternal(), a) || (this.getAnimating() && this.cancelAnimations(), this.animateInternal({ rotation: r, center: a, resolution: o, duration: t, easing: it, anchor: i })) } beginInteraction() { this.resolveConstraints(0), this.setHint(Po, 1) } endInteraction(t, e, i) { i = i && rn(i, this.getProjection()), this.endInteractionInternal(t, e, i) } endInteractionInternal(t, e, i) { this.setHint(Po, -1), this.resolveConstraints(t, e, i) } getConstrainedCenter(t, e) { const i = this.getViewportSize_(this.getRotation()); return this.constraints_.center(t, e || this.getResolution(), i) } getConstrainedZoom(t, e) { const i = this.getResolutionForZoom(t); return this.getZoomForResolution(this.getConstrainedResolution(i, e)) } getConstrainedResolution(t, e) { e = e || 0; const i = this.getViewportSize_(this.getRotation()); return this.constraints_.resolution(t, e, i) } } function Xo(t, e) { setTimeout((function () { t(e) }), 0) } function Vo(t) { if (void 0 !== t.extent) { const e = void 0 === t.smoothExtentConstraint || t.smoothExtentConstraint; return Mo(t.extent, t.constrainOnlyCenter, e) } const e = Wi(t.projection, "EPSG:3857"); if (!0 !== t.multiWorld && e.isGlobal()) { const t = e.getExtent().slice(); return t[0] = -1 / 0, t[2] = 1 / 0, Mo(t, !1, !1) } return Fo } function Wo(t) { let e, i, n; let r = void 0 !== t.minZoom ? t.minZoom : 0, s = void 0 !== t.maxZoom ? t.maxZoom : 28; const o = void 0 !== t.zoomFactor ? t.zoomFactor : 2, a = void 0 !== t.multiWorld && t.multiWorld, l = void 0 === t.smoothResolutionConstraint || t.smoothResolutionConstraint, h = void 0 !== t.showFullExtent && t.showFullExtent, c = Wi(t.projection, "EPSG:3857"), u = c.getExtent(); let d = t.constrainOnlyCenter, g = t.extent; if (a || g || !c.isGlobal() || (d = !1, g = u), void 0 !== t.resolutions) { const o = t.resolutions; i = o[r], n = void 0 !== o[s] ? o[s] : o[o.length - 1], e = t.constrainResolution ? No(o, l, !d && g, h) : ko(i, n, l, !d && g, h) } else { const a = (u ? Math.max(Se(u), _e(u)) : 360 * Fe.degrees / c.getMetersPerUnit()) / Lo / Math.pow(2, 0), f = a / Math.pow(2, 28); i = t.maxResolution, void 0 !== i ? r = 0 : i = a / Math.pow(o, r), n = t.minResolution, void 0 === n && (n = void 0 !== t.maxZoom ? void 0 !== t.maxResolution ? i / Math.pow(o, s) : a / Math.pow(o, s) : f), s = r + Math.floor(Math.log(i / n) / Math.log(o)), n = i / Math.pow(o, s - r), e = t.constrainResolution ? Do(o, i, n, l, !d && g, h) : ko(i, n, l, !d && g, h) } return { constraint: e, maxResolution: i, minResolution: n, minZoom: r, zoomFactor: o } } function Zo(t) { if (void 0 === t.enableRotation || t.enableRotation) { const e = t.constrainRotation; return void 0 === e || !0 === e ? Uo() : !1 === e ? jo : "number" == typeof e ? Bo(e) : jo } return Go } function Yo(t) { return !(t.sourceCenter && t.targetCenter && !Si(t.sourceCenter, t.targetCenter)) && (t.sourceResolution === t.targetResolution && t.sourceRotation === t.targetRotation) } function Ko(t, e, i, n, r) { const s = Math.cos(-r); let o = Math.sin(-r), a = t[0] * s - t[1] * o, l = t[1] * s + t[0] * o; a += (e[0] / 2 - i[0]) * n, l += (i[1] - e[1] / 2) * n, o = -o; return [a * s - l * o, l * s + a * o] } class qo extends V { constructor(t) { super(); const e = t.element; !e || t.target || e.style.pointerEvents || (e.style.pointerEvents = "auto"), this.element = e || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], t.render && (this.render = t.render), t.target && this.setTarget(t.target) } disposeInternal() { Ur(this.element), super.disposeInternal() } getMap() { return this.map_ } setMap(t) { this.map_ && Ur(this.element); for (let t = 0, e = this.listenerKeys.length; t < e; ++t)k(this.listenerKeys[t]); if (this.listenerKeys.length = 0, this.map_ = t, t) { (this.target_ ? this.target_ : t.getOverlayContainerStopEvent()).appendChild(this.element), this.render !== p && this.listenerKeys.push(N(t, fo, this.render, this)), t.render() } } render(t) { } setTarget(t) { this.target_ = "string" == typeof t ? document.getElementById(t) : t } } class Ho extends qo { constructor(t) { t = t || {}, super({ element: document.createElement("div"), render: t.render, target: t.target }), this.ulElement_ = document.createElement("ul"), this.collapsed_ = void 0 === t.collapsed || t.collapsed, this.userCollapsed_ = this.collapsed_, this.overrideCollapsible_ = void 0 !== t.collapsible, this.collapsible_ = void 0 === t.collapsible || t.collapsible, this.collapsible_ || (this.collapsed_ = !1); const e = void 0 !== t.className ? t.className : "ol-attribution", i = void 0 !== t.tipLabel ? t.tipLabel : "Attributions", n = void 0 !== t.expandClassName ? t.expandClassName : e + "-expand", r = void 0 !== t.collapseLabel ? t.collapseLabel : "›", s = void 0 !== t.collapseClassName ? t.collapseClassName : e + "-collapse"; "string" == typeof r ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = r, this.collapseLabel_.className = s) : this.collapseLabel_ = r; const o = void 0 !== t.label ? t.label : "i"; "string" == typeof o ? (this.label_ = document.createElement("span"), this.label_.textContent = o, this.label_.className = n) : this.label_ = o; const a = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_; this.toggleButton_ = document.createElement("button"), this.toggleButton_.setAttribute("type", "button"), this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)), this.toggleButton_.title = i, this.toggleButton_.appendChild(a), this.toggleButton_.addEventListener(T, this.handleClick_.bind(this), !1); const l = e + " " + "ol-unselectable " + Is + (this.collapsed_ && this.collapsible_ ? " ol-collapsed" : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), h = this.element; h.className = l, h.appendChild(this.toggleButton_), h.appendChild(this.ulElement_), this.renderedAttributions_ = [], this.renderedVisible_ = !0 } collectSourceAttributions_(t) { const e = {}, i = []; let n = !0; const r = t.layerStatesArray; for (let s = 0, o = r.length; s < o; ++s) { const o = r[s]; if (!Ss(o, t.viewState)) continue; const a = o.layer.getSource(); if (!a) continue; const l = a.getAttributions(); if (!l) continue; const h = l(t); if (h) if (n = n && !1 !== a.getAttributionsCollapsible(), Array.isArray(h)) for (let t = 0, n = h.length; t < n; ++t)h[t] in e || (i.push(h[t]), e[h[t]] = !0); else h in e || (i.push(h), e[h] = !0) } return this.overrideCollapsible_ || this.setCollapsible(n), i } updateElement_(t) { if (!t) return void (this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1)); const e = this.collectSourceAttributions_(t), i = e.length > 0; if (this.renderedVisible_ != i && (this.element.style.display = i ? "" : "none", this.renderedVisible_ = i), !u(e, this.renderedAttributions_)) { zr(this.ulElement_); for (let t = 0, i = e.length; t < i; ++t) { const i = document.createElement("li"); i.innerHTML = e[t], this.ulElement_.appendChild(i) } this.renderedAttributions_ = e } } handleClick_(t) { t.preventDefault(), this.handleToggle_(), this.userCollapsed_ = this.collapsed_ } handleToggle_() { this.element.classList.toggle(Ls), this.collapsed_ ? Br(this.collapseLabel_, this.label_) : Br(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_, this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)) } getCollapsible() { return this.collapsible_ } setCollapsible(t) { this.collapsible_ !== t && (this.collapsible_ = t, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_()) } setCollapsed(t) { this.userCollapsed_ = t, this.collapsible_ && this.collapsed_ !== t && this.handleToggle_() } getCollapsed() { return this.collapsed_ } render(t) { this.updateElement_(t.frameState) } } class $o extends qo { constructor(t) { t = t || {}, super({ element: document.createElement("div"), render: t.render, target: t.target }); const e = void 0 !== t.className ? t.className : "ol-rotate", i = void 0 !== t.label ? t.label : "⇧", n = void 0 !== t.compassClassName ? t.compassClassName : "ol-compass"; this.label_ = null, "string" == typeof i ? (this.label_ = document.createElement("span"), this.label_.className = n, this.label_.textContent = i) : (this.label_ = i, this.label_.classList.add(n)); const r = t.tipLabel ? t.tipLabel : "Reset rotation", s = document.createElement("button"); s.className = e + "-reset", s.setAttribute("type", "button"), s.title = r, s.appendChild(this.label_), s.addEventListener(T, this.handleClick_.bind(this), !1); const o = e + " " + "ol-unselectable " + Is, a = this.element; a.className = o, a.appendChild(s), this.callResetNorth_ = t.resetNorth ? t.resetNorth : void 0, this.duration_ = void 0 !== t.duration ? t.duration : 250, this.autoHide_ = void 0 === t.autoHide || t.autoHide, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(Cs) } handleClick_(t) { t.preventDefault(), void 0 !== this.callResetNorth_ ? this.callResetNorth_() : this.resetNorth_() } resetNorth_() { const t = this.getMap().getView(); if (!t) return; const e = t.getRotation(); void 0 !== e && (this.duration_ > 0 && e % (2 * Math.PI) != 0 ? t.animate({ rotation: 0, duration: this.duration_, easing: it }) : t.setRotation(0)) } render(t) { const e = t.frameState; if (!e) return; const i = e.viewState.rotation; if (i != this.rotation_) { const t = "rotate(" + i + "rad)"; if (this.autoHide_) { const t = this.element.classList.contains(Cs); t || 0 !== i ? t && 0 !== i && this.element.classList.remove(Cs) : this.element.classList.add(Cs) } this.label_.style.transform = t } this.rotation_ = i } } class Jo extends qo { constructor(t) { t = t || {}, super({ element: document.createElement("div"), target: t.target }); const e = void 0 !== t.className ? t.className : "ol-zoom", i = void 0 !== t.delta ? t.delta : 1, n = void 0 !== t.zoomInClassName ? t.zoomInClassName : e + "-in", r = void 0 !== t.zoomOutClassName ? t.zoomOutClassName : e + "-out", s = void 0 !== t.zoomInLabel ? t.zoomInLabel : "+", o = void 0 !== t.zoomOutLabel ? t.zoomOutLabel : "–", a = void 0 !== t.zoomInTipLabel ? t.zoomInTipLabel : "Zoom in", l = void 0 !== t.zoomOutTipLabel ? t.zoomOutTipLabel : "Zoom out", h = document.createElement("button"); h.className = n, h.setAttribute("type", "button"), h.title = a, h.appendChild("string" == typeof s ? document.createTextNode(s) : s), h.addEventListener(T, this.handleClick_.bind(this, i), !1); const c = document.createElement("button"); c.className = r, c.setAttribute("type", "button"), c.title = l, c.appendChild("string" == typeof o ? document.createTextNode(o) : o), c.addEventListener(T, this.handleClick_.bind(this, -i), !1); const u = e + " " + "ol-unselectable " + Is, d = this.element; d.className = u, d.appendChild(h), d.appendChild(c), this.duration_ = void 0 !== t.duration ? t.duration : 250 } handleClick_(t, e) { e.preventDefault(), this.zoomByDelta_(t) } zoomByDelta_(t) { const e = this.getMap().getView(); if (!e) return; const i = e.getZoom(); if (void 0 !== i) { const n = e.getConstrainedZoom(i + t); this.duration_ > 0 ? (e.getAnimating() && e.cancelAnimations(), e.animate({ zoom: n, duration: this.duration_, easing: it })) : e.setZoom(n) } } } function Qo(t) { t = t || {}; const e = new q; (void 0 === t.zoom || t.zoom) && e.push(new Jo(t.zoomOptions)); (void 0 === t.rotate || t.rotate) && e.push(new $o(t.rotateOptions)); return (void 0 === t.attribution || t.attribution) && e.push(new Ho(t.attributionOptions)), e } var ta = "active"; class ea extends V { constructor(t) { super(), this.on, this.once, this.un, t && t.handleEvent && (this.handleEvent = t.handleEvent), this.map_ = null, this.setActive(!0) } getActive() { return this.get(ta) } getMap() { return this.map_ } handleEvent(t) { return !0 } setActive(t) { this.set(ta, t) } setMap(t) { this.map_ = t } } function ia(t, e, i) { const n = t.getCenterInternal(); if (n) { const r = [n[0] + e[0], n[1] + e[1]]; t.animateInternal({ duration: void 0 !== i ? i : 250, easing: rt, center: t.getConstrainedCenter(r) }) } } function na(t, e, i, n) { const r = t.getZoom(); if (void 0 === r) return; const s = t.getConstrainedZoom(r + e), o = t.getResolutionForZoom(s); t.getAnimating() && t.cancelAnimations(), t.animate({ resolution: o, anchor: i, duration: void 0 !== n ? n : 250, easing: it }) } class ra extends ea { constructor(t) { super(), t = t || {}, this.delta_ = t.delta ? t.delta : 1, this.duration_ = void 0 !== t.duration ? t.duration : 250 } handleEvent(t) { let e = !1; if (t.type == ao.DBLCLICK) { const i = t.originalEvent, n = t.map, r = t.coordinate, s = i.shiftKey ? -this.delta_ : this.delta_; na(n.getView(), s, r, this.duration_), i.preventDefault(), e = !0 } return !e } } class sa extends ea { constructor(t) { super(t = t || {}), t.handleDownEvent && (this.handleDownEvent = t.handleDownEvent), t.handleDragEvent && (this.handleDragEvent = t.handleDragEvent), t.handleMoveEvent && (this.handleMoveEvent = t.handleMoveEvent), t.handleUpEvent && (this.handleUpEvent = t.handleUpEvent), t.stopDown && (this.stopDown = t.stopDown), this.handlingDownUpSequence = !1, this.targetPointers = [] } getPointerCount() { return this.targetPointers.length } handleDownEvent(t) { return !1 } handleDragEvent(t) { } handleEvent(t) { if (!t.originalEvent) return !0; let e = !1; if (this.updateTrackedPointers_(t), this.handlingDownUpSequence) { if (t.type == ao.POINTERDRAG) this.handleDragEvent(t), t.originalEvent.preventDefault(); else if (t.type == ao.POINTERUP) { const e = this.handleUpEvent(t); this.handlingDownUpSequence = e && this.targetPointers.length > 0 } } else if (t.type == ao.POINTERDOWN) { const i = this.handleDownEvent(t); this.handlingDownUpSequence = i, e = this.stopDown(i) } else t.type == ao.POINTERMOVE && this.handleMoveEvent(t); return !e } handleMoveEvent(t) { } handleUpEvent(t) { return !1 } stopDown(t) { return t } updateTrackedPointers_(t) { t.activePointers && (this.targetPointers = t.activePointers) } } function oa(t) { const e = t.length; let i = 0, n = 0; for (let r = 0; r < e; r++)i += t[r].clientX, n += t[r].clientY; return [i / e, n / e] } function aa(t) { const e = arguments; return function (t) { let i = !0; for (let n = 0, r = e.length; n < r && (i = i && e[n](t), i); ++n); return i } } const la = function (t) { const e = t.originalEvent; return e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey }, ha = function (t) { const e = t.originalEvent; return e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey }, ca = function (t) { const e = t.map.getTargetElement(), i = t.map.getOwnerDocument().activeElement; return e.contains(i) }, ua = function (t) { return !t.map.getTargetElement().hasAttribute("tabindex") || ca(t) }, da = g, ga = function (t) { const e = t.originalEvent; return 0 == e.button && !(ft && pt && e.ctrlKey) }, fa = f, pa = function (t) { return t.type == ao.SINGLECLICK }, ma = function (t) { const e = t.originalEvent; return !e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey }, _a = function (t) { const e = t.originalEvent; return !e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey }, ya = function (t) { const e = t.originalEvent, i = e.target.tagName; return "INPUT" !== i && "SELECT" !== i && "TEXTAREA" !== i && !e.target.isContentEditable }, xa = function (t) { const e = t.originalEvent; return at(void 0 !== e, 56), "mouse" == e.pointerType }, va = function (t) { const e = t.originalEvent; return at(void 0 !== e, 56), e.isPrimary && 0 === e.button }; class Sa extends sa { constructor(t) { super({ stopDown: f }), t = t || {}, this.kinetic_ = t.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.panning_ = !1; const e = t.condition ? t.condition : aa(ma, va); this.condition_ = t.onFocusOnly ? aa(ua, e) : e, this.noKinetic_ = !1 } handleDragEvent(t) { this.panning_ || (this.panning_ = !0, this.getMap().getView().beginInteraction()); const e = this.targetPointers, i = oa(e); if (e.length == this.lastPointersCount_) { if (this.kinetic_ && this.kinetic_.update(i[0], i[1]), this.lastCentroid) { const e = [this.lastCentroid[0] - i[0], i[1] - this.lastCentroid[1]], n = t.map.getView(); Ei(e, n.getResolution()), wi(e, n.getRotation()), n.adjustCenterInternal(e) } } else this.kinetic_ && this.kinetic_.begin(); this.lastCentroid = i, this.lastPointersCount_ = e.length, t.originalEvent.preventDefault() } handleUpEvent(t) { const e = t.map, i = e.getView(); if (0 === this.targetPointers.length) { if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) { const t = this.kinetic_.getDistance(), n = this.kinetic_.getAngle(), r = i.getCenterInternal(), s = e.getPixelFromCoordinateInternal(r), o = e.getCoordinateFromPixelInternal([s[0] - t * Math.cos(n), s[1] - t * Math.sin(n)]); i.animateInternal({ center: i.getConstrainedCenter(o), duration: 500, easing: it }) } return this.panning_ && (this.panning_ = !1, i.endInteraction()), !1 } return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, !0 } handleDownEvent(t) { if (this.targetPointers.length > 0 && this.condition_(t)) { const e = t.map.getView(); return this.lastCentroid = null, e.getAnimating() && e.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, !0 } return !1 } } class wa extends sa { constructor(t) { t = t || {}, super({ stopDown: f }), this.condition_ = t.condition ? t.condition : ha, this.lastAngle_ = void 0, this.duration_ = void 0 !== t.duration ? t.duration : 250 } handleDragEvent(t) { if (!xa(t)) return; const e = t.map, i = e.getView(); if (i.getConstraints().rotation === Go) return; const n = e.getSize(), r = t.pixel, s = Math.atan2(n[1] / 2 - r[1], r[0] - n[0] / 2); if (void 0 !== this.lastAngle_) { const t = s - this.lastAngle_; i.adjustRotationInternal(-t) } this.lastAngle_ = s } handleUpEvent(t) { if (!xa(t)) return !0; return t.map.getView().endInteraction(this.duration_), !1 } handleDownEvent(t) { if (!xa(t)) return !1; if (ga(t) && this.condition_(t)) { return t.map.getView().beginInteraction(), this.lastAngle_ = void 0, !0 } return !1 } } class Ea extends s { constructor(t) { super(), this.geometry_ = null, this.element_ = document.createElement("div"), this.element_.style.position = "absolute", this.element_.style.pointerEvents = "auto", this.element_.className = "ol-box " + t, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null } disposeInternal() { this.setMap(null) } render_() { const t = this.startPixel_, e = this.endPixel_, i = "px", n = this.element_.style; n.left = Math.min(t[0], e[0]) + i, n.top = Math.min(t[1], e[1]) + i, n.width = Math.abs(e[0] - t[0]) + i, n.height = Math.abs(e[1] - t[1]) + i } setMap(t) { if (this.map_) { this.map_.getOverlayContainer().removeChild(this.element_); const t = this.element_.style; t.left = "inherit", t.top = "inherit", t.width = "inherit", t.height = "inherit" } this.map_ = t, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_) } setPixels(t, e) { this.startPixel_ = t, this.endPixel_ = e, this.createOrUpdateGeometry(), this.render_() } createOrUpdateGeometry() { const t = this.startPixel_, e = this.endPixel_, i = [t, [t[0], e[1]], e, [e[0], t[1]]].map(this.map_.getCoordinateFromPixelInternal, this.map_); i[4] = i[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([i]) : this.geometry_ = new ur([i]) } getGeometry() { return this.geometry_ } } const Ta = "boxstart", Ca = "boxdrag", ba = "boxend", Ra = "boxcancel"; class Pa extends i { constructor(t, e, i) { super(t), this.coordinate = e, this.mapBrowserEvent = i } } class Ia extends sa { constructor(t) { super(), this.on, this.once, this.un, t = t || {}, this.box_ = new Ea(t.className || "ol-dragbox"), this.minArea_ = void 0 !== t.minArea ? t.minArea : 64, t.onBoxEnd && (this.onBoxEnd = t.onBoxEnd), this.startPixel_ = null, this.condition_ = t.condition ? t.condition : ga, this.boxEndCondition_ = t.boxEndCondition ? t.boxEndCondition : this.defaultBoxEndCondition } defaultBoxEndCondition(t, e, i) { const n = i[0] - e[0], r = i[1] - e[1]; return n * n + r * r >= this.minArea_ } getGeometry() { return this.box_.getGeometry() } handleDragEvent(t) { this.box_.setPixels(this.startPixel_, t.pixel), this.dispatchEvent(new Pa(Ca, t.coordinate, t)) } handleUpEvent(t) { this.box_.setMap(null); const e = this.boxEndCondition_(t, this.startPixel_, t.pixel); return e && this.onBoxEnd(t), this.dispatchEvent(new Pa(e ? ba : Ra, t.coordinate, t)), !1 } handleDownEvent(t) { return !!this.condition_(t) && (this.startPixel_ = t.pixel, this.box_.setMap(t.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(new Pa(Ta, t.coordinate, t)), !0) } onBoxEnd(t) { } } class La extends Ia { constructor(t) { super({ condition: (t = t || {}).condition ? t.condition : _a, className: t.className || "ol-dragzoom", minArea: t.minArea }), this.duration_ = void 0 !== t.duration ? t.duration : 200, this.out_ = void 0 !== t.out && t.out } onBoxEnd(t) { const e = this.getMap().getView(); let i = this.getGeometry(); if (this.out_) { const t = e.rotatedExtentForGeometry(i), n = e.getResolutionForExtentInternal(t), r = e.getResolution() / n; i = i.clone(), i.scale(r * r) } e.fitInternal(i, { duration: this.duration_, easing: it }) } } var Ma = 37, Fa = 38, Aa = 39, Oa = 40; class Na extends ea { constructor(t) { super(), t = t || {}, this.defaultCondition_ = function (t) { return ma(t) && ya(t) }, this.condition_ = void 0 !== t.condition ? t.condition : this.defaultCondition_, this.duration_ = void 0 !== t.duration ? t.duration : 100, this.pixelDelta_ = void 0 !== t.pixelDelta ? t.pixelDelta : 128 } handleEvent(t) { let e = !1; if (t.type == I) { const i = t.originalEvent, n = i.keyCode; if (this.condition_(t) && (n == Oa || n == Ma || n == Aa || n == Fa)) { const r = t.map.getView(), s = r.getResolution() * this.pixelDelta_; let o = 0, a = 0; n == Oa ? a = -s : n == Ma ? o = -s : n == Aa ? o = s : a = s; const l = [o, a]; wi(l, r.getRotation()), ia(r, l, this.duration_), i.preventDefault(), e = !0 } } return !e } } class Da extends ea { constructor(t) { super(), t = t || {}, this.condition_ = t.condition ? t.condition : ya, this.delta_ = t.delta ? t.delta : 1, this.duration_ = void 0 !== t.duration ? t.duration : 100 } handleEvent(t) { let e = !1; if (t.type == I || t.type == L) { const i = t.originalEvent, n = i.charCode; if (this.condition_(t) && (n == "+".charCodeAt(0) || n == "-".charCodeAt(0))) { const r = t.map, s = n == "+".charCodeAt(0) ? this.delta_ : -this.delta_; na(r.getView(), s, void 0, this.duration_), i.preventDefault(), e = !0 } } return !e } } class ka extends ea { constructor(t) { super(t = t || {}), this.totalDelta_ = 0, this.lastDelta_ = 0, this.maxDelta_ = void 0 !== t.maxDelta ? t.maxDelta : 1, this.duration_ = void 0 !== t.duration ? t.duration : 250, this.timeout_ = void 0 !== t.timeout ? t.timeout : 80, this.useAnchor_ = void 0 === t.useAnchor || t.useAnchor, this.constrainResolution_ = void 0 !== t.constrainResolution && t.constrainResolution; const e = t.condition ? t.condition : da; this.condition_ = t.onFocusOnly ? aa(ua, e) : e, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_, this.deltaPerZoom_ = 300 } endInteraction_() { this.trackpadTimeoutId_ = void 0; const t = this.getMap(); if (!t) return; t.getView().endInteraction(void 0, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_) } handleEvent(t) { if (!this.condition_(t)) return !0; if (t.type !== O) return !0; const e = t.map, i = t.originalEvent; let n; if (i.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = t.coordinate), t.type == O && (n = i.deltaY, ut && i.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (n /= mt), i.deltaMode === WheelEvent.DOM_DELTA_LINE && (n *= 40)), 0 === n) return !1; this.lastDelta_ = n; const r = Date.now(); void 0 === this.startTime_ && (this.startTime_ = r), (!this.mode_ || r - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(n) < 4 ? "trackpad" : "wheel"); const s = e.getView(); if ("trackpad" === this.mode_ && !s.getConstrainResolution() && !this.constrainResolution_) return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (s.getAnimating() && s.cancelAnimations(), s.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_), s.adjustZoom(-n / this.deltaPerZoom_, this.lastAnchor_), this.startTime_ = r, !1; this.totalDelta_ += n; const o = Math.max(this.timeout_ - (r - this.startTime_), 0); return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, e), o), !1 } handleWheelZoom_(t) { const e = t.getView(); e.getAnimating() && e.cancelAnimations(); let i = -ii(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_; (e.getConstrainResolution() || this.constrainResolution_) && (i = i ? i > 0 ? 1 : -1 : 0), na(e, i, this.lastAnchor_, this.duration_), this.mode_ = void 0, this.totalDelta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0 } setMouseAnchor(t) { this.useAnchor_ = t, t || (this.lastAnchor_ = null) } } class Ga extends sa { constructor(t) { const e = t = t || {}; e.stopDown || (e.stopDown = f), super(e), this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.threshold_ = void 0 !== t.threshold ? t.threshold : .3, this.duration_ = void 0 !== t.duration ? t.duration : 250 } handleDragEvent(t) { let e = 0; const i = this.targetPointers[0], n = this.targetPointers[1], r = Math.atan2(n.clientY - i.clientY, n.clientX - i.clientX); if (void 0 !== this.lastAngle_) { const t = r - this.lastAngle_; this.rotationDelta_ += t, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0), e = t } this.lastAngle_ = r; const s = t.map, o = s.getView(); if (o.getConstraints().rotation === Go) return; const a = s.getViewport().getBoundingClientRect(), l = oa(this.targetPointers); l[0] -= a.left, l[1] -= a.top, this.anchor_ = s.getCoordinateFromPixelInternal(l), this.rotating_ && (s.render(), o.adjustRotationInternal(e, this.anchor_)) } handleUpEvent(t) { if (this.targetPointers.length < 2) { return t.map.getView().endInteraction(this.duration_), !1 } return !0 } handleDownEvent(t) { if (this.targetPointers.length >= 2) { const e = t.map; return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.handlingDownUpSequence || e.getView().beginInteraction(), !0 } return !1 } } class ja extends sa { constructor(t) { const e = t = t || {}; e.stopDown || (e.stopDown = f), super(e), this.anchor_ = null, this.duration_ = void 0 !== t.duration ? t.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1 } handleDragEvent(t) { let e = 1; const i = this.targetPointers[0], n = this.targetPointers[1], r = i.clientX - n.clientX, s = i.clientY - n.clientY, o = Math.sqrt(r * r + s * s); void 0 !== this.lastDistance_ && (e = this.lastDistance_ / o), this.lastDistance_ = o; const a = t.map, l = a.getView(); 1 != e && (this.lastScaleDelta_ = e); const h = a.getViewport().getBoundingClientRect(), c = oa(this.targetPointers); c[0] -= h.left, c[1] -= h.top, this.anchor_ = a.getCoordinateFromPixelInternal(c), a.render(), l.adjustResolutionInternal(e, this.anchor_) } handleUpEvent(t) { if (this.targetPointers.length < 2) { const e = t.map.getView(), i = this.lastScaleDelta_ > 1 ? 1 : -1; return e.endInteraction(this.duration_, i), !1 } return !0 } handleDownEvent(t) { if (this.targetPointers.length >= 2) { const e = t.map; return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || e.getView().beginInteraction(), !0 } return !1 } } function Ba(t) { t = t || {}; const e = new q, i = new Wr(-.005, .05, 100); (void 0 === t.altShiftDragRotate || t.altShiftDragRotate) && e.push(new wa); (void 0 === t.doubleClickZoom || t.doubleClickZoom) && e.push(new ra({ delta: t.zoomDelta, duration: t.zoomDuration })); (void 0 === t.dragPan || t.dragPan) && e.push(new Sa({ onFocusOnly: t.onFocusOnly, kinetic: i })); (void 0 === t.pinchRotate || t.pinchRotate) && e.push(new Ga); (void 0 === t.pinchZoom || t.pinchZoom) && e.push(new ja({ duration: t.zoomDuration })); (void 0 === t.keyboard || t.keyboard) && (e.push(new Na), e.push(new Da({ delta: t.zoomDelta, duration: t.zoomDuration }))); (void 0 === t.mouseWheelZoom || t.mouseWheelZoom) && e.push(new ka({ onFocusOnly: t.onFocusOnly, duration: t.zoomDuration })); return (void 0 === t.shiftDragZoom || t.shiftDragZoom) && e.push(new La({ duration: t.zoomDuration })), e } function Ua(t, e, i) { return void 0 === i && (i = [0, 0]), i[0] = t[0] + 2 * e, i[1] = t[1] + 2 * e, i } function za(t) { return t[0] > 0 && t[1] > 0 } function Xa(t, e, i) { return void 0 === i && (i = [0, 0]), i[0] = t[0] * e + .5 | 0, i[1] = t[1] * e + .5 | 0, i } function Va(t, e) { return Array.isArray(t) ? t : (void 0 === e ? e = [t, t] : (e[0] = t, e[1] = t), e) } function Wa(t) { t instanceof vs ? t.setMapInternal(null) : t instanceof ro && t.getLayers().forEach(Wa) } function Za(t, e) { if (t instanceof vs) t.setMapInternal(e); else if (t instanceof ro) { const i = t.getLayers().getArray(); for (let t = 0, n = i.length; t < n; ++t)Za(i[t], e) } } class Ya extends V { constructor(t) { super(), t = t || {}, this.on, this.once, this.un; const e = function (t) { let e = null; void 0 !== t.keyboardEventTarget && (e = "string" == typeof t.keyboardEventTarget ? document.getElementById(t.keyboardEventTarget) : t.keyboardEventTarget); const i = {}, n = t.layers && "function" == typeof t.layers.getLayers ? t.layers : new ro({ layers: t.layers }); let r, s, o; i[xo] = n, i[So] = t.target, i[wo] = t.view instanceof zo ? t.view : new zo, void 0 !== t.controls && (Array.isArray(t.controls) ? r = new q(t.controls.slice()) : (at("function" == typeof t.controls.getArray, 47), r = t.controls)); void 0 !== t.interactions && (Array.isArray(t.interactions) ? s = new q(t.interactions.slice()) : (at("function" == typeof t.interactions.getArray, 48), s = t.interactions)); void 0 !== t.overlays ? Array.isArray(t.overlays) ? o = new q(t.overlays.slice()) : (at("function" == typeof t.overlays.getArray, 49), o = t.overlays) : o = new q; return { controls: r, interactions: s, keyboardEventTarget: e, overlays: o, values: i } }(t); this.renderComplete_, this.loaded_ = !0, this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this), this.maxTilesLoading_ = void 0 !== t.maxTilesLoading ? t.maxTilesLoading : 16, this.pixelRatio_ = void 0 !== t.pixelRatio ? t.pixelRatio : mt, this.postRenderTimeoutHandle_, this.animationDelayKey_, this.animationDelay_ = this.animationDelay_.bind(this), this.coordinateToPixelTransform_ = [1, 0, 0, 1, 0, 0], this.pixelToCoordinateTransform_ = [1, 0, 0, 1, 0, 0], this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, this.viewport_ = document.createElement("div"), this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""), this.viewport_.style.position = "relative", this.viewport_.style.overflow = "hidden", this.viewport_.style.width = "100%", this.viewport_.style.height = "100%", this.overlayContainer_ = document.createElement("div"), this.overlayContainer_.style.position = "absolute", this.overlayContainer_.style.zIndex = "0", this.overlayContainer_.style.width = "100%", this.overlayContainer_.style.height = "100%", this.overlayContainer_.style.pointerEvents = "none", this.overlayContainer_.className = "ol-overlaycontainer", this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement("div"), this.overlayContainerStopEvent_.style.position = "absolute", this.overlayContainerStopEvent_.style.zIndex = "0", this.overlayContainerStopEvent_.style.width = "100%", this.overlayContainerStopEvent_.style.height = "100%", this.overlayContainerStopEvent_.style.pointerEvents = "none", this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", this.viewport_.appendChild(this.overlayContainerStopEvent_), this.mapBrowserEventHandler_ = null, this.moveTolerance_ = t.moveTolerance, this.keyboardEventTarget_ = e.keyboardEventTarget, this.targetChangeHandlerKeys_ = null, this.controls = e.controls || Qo(), this.interactions = e.interactions || Ba({ onFocusOnly: !0 }), this.overlays_ = e.overlays, this.overlayIdIndex_ = {}, this.renderer_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new Co(this.getTilePriority.bind(this), this.handleTileChange_.bind(this)), this.addChangeListener(xo, this.handleLayerGroupChanged_), this.addChangeListener(wo, this.handleViewChanged_), this.addChangeListener(vo, this.handleSizeChanged_), this.addChangeListener(So, this.handleTargetChanged_), this.setProperties(e.values); const i = this; !t.view || t.view instanceof zo || t.view.then((function (t) { i.setView(new zo(t)) })), this.controls.addEventListener(W, function (t) { t.element.setMap(this) }.bind(this)), this.controls.addEventListener(Z, function (t) { t.element.setMap(null) }.bind(this)), this.interactions.addEventListener(W, function (t) { t.element.setMap(this) }.bind(this)), this.interactions.addEventListener(Z, function (t) { t.element.setMap(null) }.bind(this)), this.overlays_.addEventListener(W, function (t) { this.addOverlayInternal_(t.element) }.bind(this)), this.overlays_.addEventListener(Z, function (t) { const e = t.element.getId(); void 0 !== e && delete this.overlayIdIndex_[e.toString()], t.element.setMap(null) }.bind(this)), this.controls.forEach(function (t) { t.setMap(this) }.bind(this)), this.interactions.forEach(function (t) { t.setMap(this) }.bind(this)), this.overlays_.forEach(this.addOverlayInternal_.bind(this)) } addControl(t) { this.getControls().push(t) } addInteraction(t) { this.getInteractions().push(t) } addLayer(t) { this.getLayerGroup().getLayers().push(t) } handleLayerAdd_(t) { Za(t.layer, this) } addOverlay(t) { this.getOverlays().push(t) } addOverlayInternal_(t) { const e = t.getId(); void 0 !== e && (this.overlayIdIndex_[e.toString()] = t), t.setMap(this) } disposeInternal() { this.controls.clear(), this.interactions.clear(), this.overlays_.clear(), this.setTarget(null), super.disposeInternal() } forEachFeatureAtPixel(t, e, i) { if (!this.frameState_ || !this.renderer_) return; const n = this.getCoordinateFromPixelInternal(t), r = void 0 !== (i = void 0 !== i ? i : {}).hitTolerance ? i.hitTolerance : 0, s = void 0 !== i.layerFilter ? i.layerFilter : g, o = !1 !== i.checkWrapped; return this.renderer_.forEachFeatureAtCoordinate(n, this.frameState_, r, o, e, null, s, null) } getFeaturesAtPixel(t, e) { const i = []; return this.forEachFeatureAtPixel(t, (function (t) { i.push(t) }), e), i } getAllLayers() { const t = []; return function e(i) { i.forEach((function (i) { i instanceof ro ? e(i.getLayers()) : t.push(i) })) }(this.getLayers()), t } hasFeatureAtPixel(t, e) { if (!this.frameState_ || !this.renderer_) return !1; const i = this.getCoordinateFromPixelInternal(t), n = void 0 !== (e = void 0 !== e ? e : {}).layerFilter ? e.layerFilter : g, r = void 0 !== e.hitTolerance ? e.hitTolerance : 0, s = !1 !== e.checkWrapped; return this.renderer_.hasFeatureAtCoordinate(i, this.frameState_, r, s, n, null) } getEventCoordinate(t) { return this.getCoordinateFromPixel(this.getEventPixel(t)) } getEventCoordinateInternal(t) { return this.getCoordinateFromPixelInternal(this.getEventPixel(t)) } getEventPixel(t) { const e = this.viewport_.getBoundingClientRect(), i = "changedTouches" in t ? t.changedTouches[0] : t; return [i.clientX - e.left, i.clientY - e.top] } getTarget() { return this.get(So) } getTargetElement() { const t = this.getTarget(); return void 0 !== t ? "string" == typeof t ? document.getElementById(t) : t : null } getCoordinateFromPixel(t) { return nn(this.getCoordinateFromPixelInternal(t), this.getView().getProjection()) } getCoordinateFromPixelInternal(t) { const e = this.frameState_; return e ? bt(e.pixelToCoordinateTransform, t.slice()) : null } getControls() { return this.controls } getOverlays() { return this.overlays_ } getOverlayById(t) { const e = this.overlayIdIndex_[t.toString()]; return void 0 !== e ? e : null } getInteractions() { return this.interactions } getLayerGroup() { return this.get(xo) } setLayers(t) { const e = this.getLayerGroup(); if (t instanceof q) return void e.setLayers(t); const i = e.getLayers(); i.clear(), i.extend(t) } getLayers() { return this.getLayerGroup().getLayers() } getLoadingOrNotReady() { const t = this.getLayerGroup().getLayerStatesArray(); for (let e = 0, i = t.length; e < i; ++e) { const i = t[e]; if (!i.visible) continue; const n = i.layer.getRenderer(); if (n && !n.ready) return !0; const r = i.layer.getSource(); if (r && r.loading) return !0 } return !1 } getPixelFromCoordinate(t) { const e = rn(t, this.getView().getProjection()); return this.getPixelFromCoordinateInternal(e) } getPixelFromCoordinateInternal(t) { const e = this.frameState_; return e ? bt(e.coordinateToPixelTransform, t.slice(0, 2)) : null } getRenderer() { return this.renderer_ } getSize() { return this.get(vo) } getView() { return this.get(wo) } getViewport() { return this.viewport_ } getOverlayContainer() { return this.overlayContainer_ } getOverlayContainerStopEvent() { return this.overlayContainerStopEvent_ } getOwnerDocument() { const t = this.getTargetElement(); return t ? t.ownerDocument : document } getTilePriority(t, e, i, n) { return bo(this.frameState_, t, e, i, n) } handleBrowserEvent(t, e) { e = e || t.type; const i = new oo(e, this, t); this.handleMapBrowserEvent(i) } handleMapBrowserEvent(t) { if (!this.frameState_) return; const e = t.originalEvent, i = e.type; if (i === ho || i === O || i === I) { const t = this.getOwnerDocument(), i = this.viewport_.getRootNode ? this.viewport_.getRootNode() : t, n = e.target; if (this.overlayContainerStopEvent_.contains(n) || !(i === t ? t.documentElement : i).contains(n)) return } if (t.frameState = this.frameState_, !1 !== this.dispatchEvent(t)) { const e = this.getInteractions().getArray().slice(); for (let i = e.length - 1; i >= 0; i--) { const n = e[i]; if (n.getMap() !== this || !n.getActive() || !this.getTargetElement()) continue; if (!n.handleEvent(t) || t.propagationStopped) break } } } handlePostRender() { const t = this.frameState_, e = this.tileQueue_; if (!e.isEmpty()) { let i = this.maxTilesLoading_, n = i; if (t) { const e = t.viewHints; if (e[Ro] || e[Po]) { const e = Date.now() - t.time > 8; i = e ? 0 : 8, n = e ? 0 : 2 } } e.getTilesLoading() < i && (e.reprioritize(), e.loadMoreTiles(i, n)) } t && this.renderer_ && !t.animate && (!0 === this.renderComplete_ ? (this.hasListener(xs) && this.renderer_.dispatchRenderEvent(xs, t), !1 === this.loaded_ && (this.loaded_ = !0, this.dispatchEvent(new so(yo, this, t)))) : !0 === this.loaded_ && (this.loaded_ = !1, this.dispatchEvent(new so(_o, this, t)))); const i = this.postRenderFunctions_; for (let e = 0, n = i.length; e < n; ++e)i[e](this, t); i.length = 0 } handleSizeChanged_() { this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render() } handleTargetChanged_() { if (this.mapBrowserEventHandler_) { for (let t = 0, e = this.targetChangeHandlerKeys_.length; t < e; ++t)k(this.targetChangeHandlerKeys_[t]); this.targetChangeHandlerKeys_ = null, this.viewport_.removeEventListener(E, this.boundHandleBrowserEvent_), this.viewport_.removeEventListener(O, this.boundHandleBrowserEvent_), this.mapBrowserEventHandler_.dispose(), this.mapBrowserEventHandler_ = null, Ur(this.viewport_) } const t = this.getTargetElement(); if (t) { t.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = new eo(this)), this.mapBrowserEventHandler_ = new go(this, this.moveTolerance_); for (const t in ao) this.mapBrowserEventHandler_.addEventListener(ao[t], this.handleMapBrowserEvent.bind(this)); this.viewport_.addEventListener(E, this.boundHandleBrowserEvent_, !1), this.viewport_.addEventListener(O, this.boundHandleBrowserEvent_, !!xt && { passive: !1 }); const e = this.getOwnerDocument().defaultView, i = this.keyboardEventTarget_ ? this.keyboardEventTarget_ : t; this.targetChangeHandlerKeys_ = [N(i, I, this.handleBrowserEvent, this), N(i, L, this.handleBrowserEvent, this), N(e, F, this.updateSize, this)] } else this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0); this.updateSize() } handleTileChange_() { this.render() } handleViewPropertyChanged_() { this.render() } handleViewChanged_() { this.viewPropertyListenerKey_ && (k(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && (k(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null); const t = this.getView(); t && (this.updateViewportSize_(), this.viewPropertyListenerKey_ = N(t, r, this.handleViewPropertyChanged_, this), this.viewChangeListenerKey_ = N(t, S, this.handleViewPropertyChanged_, this), t.resolveConstraints(0)), this.render() } handleLayerGroupChanged_() { this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(k), this.layerGroupPropertyListenerKeys_ = null); const t = this.getLayerGroup(); t && (this.handleLayerAdd_(new io("addlayer", t)), this.layerGroupPropertyListenerKeys_ = [N(t, r, this.render, this), N(t, S, this.render, this), N(t, "addlayer", this.handleLayerAdd_, this), N(t, "removelayer", this.handleLayerRemove_, this)]), this.render() } isRendered() { return !!this.frameState_ } animationDelay_() { this.animationDelayKey_ = void 0, this.renderFrame_(Date.now()) } renderSync() { this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_() } redrawText() { const t = this.getLayerGroup().getLayerStatesArray(); for (let e = 0, i = t.length; e < i; ++e) { const i = t[e].layer; i.hasRenderer() && i.getRenderer().handleFontsChanged() } } render() { this.renderer_ && void 0 === this.animationDelayKey_ && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_)) } removeControl(t) { return this.getControls().remove(t) } removeInteraction(t) { return this.getInteractions().remove(t) } removeLayer(t) { return this.getLayerGroup().getLayers().remove(t) } handleLayerRemove_(t) { Wa(t.layer) } removeOverlay(t) { return this.getOverlays().remove(t) } renderFrame_(t) { const e = this.getSize(), i = this.getView(), n = this.frameState_; let r = null; if (void 0 !== e && za(e) && i && i.isDef()) { const n = i.getHints(this.frameState_ ? this.frameState_.viewHints : void 0), s = i.getState(); if (r = { animate: !1, coordinateToPixelTransform: this.coordinateToPixelTransform_, declutterTree: null, extent: pe(s.center, s.resolution, s.rotation, e), index: this.frameIndex_++, layerIndex: 0, layerStatesArray: this.getLayerGroup().getLayerStatesArray(), pixelRatio: this.pixelRatio_, pixelToCoordinateTransform: this.pixelToCoordinateTransform_, postRenderFunctions: [], size: e, tileQueue: this.tileQueue_, time: t, usedTiles: {}, viewState: s, viewHints: n, wantedTiles: {}, mapId: z(this), renderTargets: {} }, s.nextCenter && s.nextResolution) { const t = isNaN(s.nextRotation) ? s.rotation : s.nextRotation; r.nextExtent = pe(s.nextCenter, s.nextResolution, t, e) } } if (this.frameState_ = r, this.renderer_.renderFrame(r), r) { if (r.animate && this.render(), Array.prototype.push.apply(this.postRenderFunctions_, r.postRenderFunctions), n) { (!this.previousExtent_ || !Ee(this.previousExtent_) && !ee(r.extent, this.previousExtent_)) && (this.dispatchEvent(new so(po, this, n)), this.previousExtent_ = Jt(this.previousExtent_)) } this.previousExtent_ && !r.viewHints[Ro] && !r.viewHints[Po] && !ee(r.extent, this.previousExtent_) && (this.dispatchEvent(new so(mo, this, r)), Vt(r.extent, this.previousExtent_)) } this.dispatchEvent(new so(fo, this, r)), this.renderComplete_ = this.hasListener(_o) || this.hasListener(yo) || this.hasListener(xs) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0, this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout((() => { this.postRenderTimeoutHandle_ = void 0, this.handlePostRender() }), 0)) } setLayerGroup(t) { const e = this.getLayerGroup(); e && this.handleLayerRemove_(new io("removelayer", e)), this.set(xo, t) } setSize(t) { this.set(vo, t) } setTarget(t) { this.set(So, t) } setView(t) { if (!t || t instanceof zo) return void this.set(wo, t); this.set(wo, new zo); const e = this; t.then((function (t) { e.setView(new zo(t)) })) } updateSize() { const t = this.getTargetElement(); let e; if (t) { const i = getComputedStyle(t), n = t.offsetWidth - parseFloat(i.borderLeftWidth) - parseFloat(i.paddingLeft) - parseFloat(i.paddingRight) - parseFloat(i.borderRightWidth), r = t.offsetHeight - parseFloat(i.borderTopWidth) - parseFloat(i.paddingTop) - parseFloat(i.paddingBottom) - parseFloat(i.borderBottomWidth); isNaN(n) || isNaN(r) || (e = [n, r], !za(e) && (t.offsetWidth || t.offsetHeight || t.getClientRects().length) && console.warn("No map visible because the map container's width or height are 0.")) } this.setSize(e), this.updateViewportSize_() } updateViewportSize_() { const t = this.getView(); if (t) { let e; const i = getComputedStyle(this.viewport_); i.width && i.height && (e = [parseInt(i.width, 10), parseInt(i.height, 10)]), t.setViewportSize(e) } } } const Ka = "element", qa = "map", Ha = "offset", $a = "position", Ja = "positioning"; class Qa extends V { constructor(t) { super(), this.on, this.once, this.un, this.options = t, this.id = t.id, this.insertFirst = void 0 === t.insertFirst || t.insertFirst, this.stopEvent = void 0 === t.stopEvent || t.stopEvent, this.element = document.createElement("div"), this.element.className = void 0 !== t.className ? t.className : "ol-overlay-container ol-selectable", this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.autoPan = !0 === t.autoPan ? {} : t.autoPan || void 0, this.rendered = { transform_: "", visible: !0 }, this.mapPostrenderListenerKey = null, this.addChangeListener(Ka, this.handleElementChanged), this.addChangeListener(qa, this.handleMapChanged), this.addChangeListener(Ha, this.handleOffsetChanged), this.addChangeListener($a, this.handlePositionChanged), this.addChangeListener(Ja, this.handlePositioningChanged), void 0 !== t.element && this.setElement(t.element), this.setOffset(void 0 !== t.offset ? t.offset : [0, 0]), this.setPositioning(t.positioning || "top-left"), void 0 !== t.position && this.setPosition(t.position) } getElement() { return this.get(Ka) } getId() { return this.id } getMap() { return this.get(qa) || null } getOffset() { return this.get(Ha) } getPosition() { return this.get($a) } getPositioning() { return this.get(Ja) } handleElementChanged() { zr(this.element); const t = this.getElement(); t && this.element.appendChild(t) } handleMapChanged() { this.mapPostrenderListenerKey && (Ur(this.element), k(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null); const t = this.getMap(); if (t) { this.mapPostrenderListenerKey = N(t, fo, this.render, this), this.updatePixelPosition(); const e = this.stopEvent ? t.getOverlayContainerStopEvent() : t.getOverlayContainer(); this.insertFirst ? e.insertBefore(this.element, e.childNodes[0] || null) : e.appendChild(this.element), this.performAutoPan() } } render() { this.updatePixelPosition() } handleOffsetChanged() { this.updatePixelPosition() } handlePositionChanged() { this.updatePixelPosition(), this.performAutoPan() } handlePositioningChanged() { this.updatePixelPosition() } setElement(t) { this.set(Ka, t) } setMap(t) { this.set(qa, t) } setOffset(t) { this.set(Ha, t) } setPosition(t) { this.set($a, t) } performAutoPan() { this.autoPan && this.panIntoView(this.autoPan) } panIntoView(t) { const e = this.getMap(); if (!e || !e.getTargetElement() || !this.get($a)) return; const i = this.getRect(e.getTargetElement(), e.getSize()), n = this.getElement(), r = this.getRect(n, [Gr(n), jr(n)]), s = void 0 === (t = t || {}).margin ? 20 : t.margin; if (!Yt(i, r)) { const n = r[0] - i[0], o = i[2] - r[2], a = r[1] - i[1], l = i[3] - r[3], h = [0, 0]; if (n < 0 ? h[0] = n - s : o < 0 && (h[0] = Math.abs(o) + s), a < 0 ? h[1] = a - s : l < 0 && (h[1] = Math.abs(l) + s), 0 !== h[0] || 0 !== h[1]) { const i = e.getView().getCenterInternal(), n = e.getPixelFromCoordinateInternal(i); if (!n) return; const r = [n[0] + h[0], n[1] + h[1]], s = t.animation || {}; e.getView().animateInternal({ center: e.getCoordinateFromPixelInternal(r), duration: s.duration, easing: s.easing }) } } } getRect(t, e) { const i = t.getBoundingClientRect(), n = i.left + window.pageXOffset, r = i.top + window.pageYOffset; return [n, r, n + e[0], r + e[1]] } setPositioning(t) { this.set(Ja, t) } setVisible(t) { this.rendered.visible !== t && (this.element.style.display = t ? "" : "none", this.rendered.visible = t) } updatePixelPosition() { const t = this.getMap(), e = this.getPosition(); if (!t || !t.isRendered() || !e) return void this.setVisible(!1); const i = t.getPixelFromCoordinate(e), n = t.getSize(); this.updateRenderedPosition(i, n) } updateRenderedPosition(t, e) { const i = this.element.style, n = this.getOffset(), r = this.getPositioning(); this.setVisible(!0); let s = "0%", o = "0%"; "bottom-right" == r || "center-right" == r || "top-right" == r ? s = "-100%" : "bottom-center" != r && "center-center" != r && "top-center" != r || (s = "-50%"), "bottom-left" == r || "bottom-center" == r || "bottom-right" == r ? o = "-100%" : "center-left" != r && "center-center" != r && "center-right" != r || (o = "-50%"); const a = `translate(${s}, ${o}) translate(${Math.round(t[0] + n[0]) + "px"}, ${Math.round(t[1] + n[1]) + "px"})`; this.rendered.transform_ != a && (this.rendered.transform_ = a, i.transform = a) } getOptions() { return this.options } } class tl { constructor(t) { this.highWaterMark = void 0 !== t ? t : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null } canExpireCache() { return this.highWaterMark > 0 && this.getCount() > this.highWaterMark } expireCache(t) { for (; this.canExpireCache();)this.pop() } clear() { this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null } containsKey(t) { return this.entries_.hasOwnProperty(t) } forEach(t) { let e = this.oldest_; for (; e;)t(e.value_, e.key_, this), e = e.newer } get(t, e) { const i = this.entries_[t]; return at(void 0 !== i, 15), i === this.newest_ || (i === this.oldest_ ? (this.oldest_ = this.oldest_.newer, this.oldest_.older = null) : (i.newer.older = i.older, i.older.newer = i.newer), i.newer = null, i.older = this.newest_, this.newest_.newer = i, this.newest_ = i), i.value_ } remove(t) { const e = this.entries_[t]; return at(void 0 !== e, 15), e === this.newest_ ? (this.newest_ = e.older, this.newest_ && (this.newest_.newer = null)) : e === this.oldest_ ? (this.oldest_ = e.newer, this.oldest_ && (this.oldest_.older = null)) : (e.newer.older = e.older, e.older.newer = e.newer), delete this.entries_[t], --this.count_, e.value_ } getCount() { return this.count_ } getKeys() { const t = new Array(this.count_); let e, i = 0; for (e = this.newest_; e; e = e.older)t[i++] = e.key_; return t } getValues() { const t = new Array(this.count_); let e, i = 0; for (e = this.newest_; e; e = e.older)t[i++] = e.value_; return t } peekLast() { return this.oldest_.value_ } peekLastKey() { return this.oldest_.key_ } peekFirstKey() { return this.newest_.key_ } peek(t) { if (this.containsKey(t)) return this.entries_[t].value_ } pop() { const t = this.oldest_; return delete this.entries_[t.key_], t.newer && (t.newer.older = null), this.oldest_ = t.newer, this.oldest_ || (this.newest_ = null), --this.count_, t.value_ } replace(t, e) { this.get(t), this.entries_[t].value_ = e } set(t, e) { at(!(t in this.entries_), 16); const i = { key_: t, newer: null, older: this.newest_, value_: e }; this.newest_ ? this.newest_.newer = i : this.oldest_ = i, this.newest_ = i, this.entries_[t] = i, ++this.count_ } setSize(t) { this.highWaterMark = t } } function el(t, e, i, n) { return void 0 !== n ? (n[0] = t, n[1] = e, n[2] = i, n) : [t, e, i] } function il(t, e, i) { return t + "/" + e + "/" + i } function nl(t) { return il(t[0], t[1], t[2]) } function rl(t) { const [e, i, n] = t.substring(t.lastIndexOf("/") + 1, t.length).split(",").map(Number); return il(e, i, n) } function sl(t) { return t.split("/").map(Number) } function ol(t) { return (t[1] << t[0]) + t[2] } function al(t, e) { const i = t[0], n = t[1], r = t[2]; if (e.getMinZoom() > i || i > e.getMaxZoom()) return !1; const s = e.getFullTileRange(i); return !s || s.containsXY(n, r) } class ll extends tl { clear() { for (; this.getCount() > 0;)this.pop().release(); super.clear() } expireCache(t) { for (; this.canExpireCache();) { if (this.peekLast().getKey() in t) break; this.pop().release() } } pruneExceptNewestZ() { if (0 === this.getCount()) return; const t = sl(this.peekFirstKey())[0]; this.forEach(function (e) { e.tileCoord[0] !== t && (this.remove(nl(e.tileCoord)), e.release()) }.bind(this)) } } class hl { constructor(t, e, i, n) { this.minX = t, this.maxX = e, this.minY = i, this.maxY = n } contains(t) { return this.containsXY(t[1], t[2]) } containsTileRange(t) { return this.minX <= t.minX && t.maxX <= this.maxX && this.minY <= t.minY && t.maxY <= this.maxY } containsXY(t, e) { return this.minX <= t && t <= this.maxX && this.minY <= e && e <= this.maxY } equals(t) { return this.minX == t.minX && this.minY == t.minY && this.maxX == t.maxX && this.maxY == t.maxY } extend(t) { t.minX < this.minX && (this.minX = t.minX), t.maxX > this.maxX && (this.maxX = t.maxX), t.minY < this.minY && (this.minY = t.minY), t.maxY > this.maxY && (this.maxY = t.maxY) } getHeight() { return this.maxY - this.minY + 1 } getSize() { return [this.getWidth(), this.getHeight()] } getWidth() { return this.maxX - this.minX + 1 } intersects(t) { return this.minX <= t.maxX && this.maxX >= t.minX && this.minY <= t.maxY && this.maxY >= t.minY } } function cl(t, e, i, n, r) { return void 0 !== r ? (r.minX = t, r.maxX = e, r.minY = i, r.maxY = n, r) : new hl(t, e, i, n) } const ul = []; class dl extends st { constructor(t, e, i, n) { super(t, e, { transition: 0 }), this.context_ = {}, this.executorGroups = {}, this.declutterExecutorGroups = {}, this.loadingSourceTiles = 0, this.hitDetectionImageData = {}, this.replayState_ = {}, this.sourceTiles = [], this.errorTileKeys = {}, this.wantedResolution, this.getSourceTiles = n.bind(void 0, this), this.wrappedTileCoord = i } getContext(t) { const e = z(t); return e in this.context_ || (this.context_[e] = Dr(1, 1, ul)), this.context_[e] } hasContext(t) { return z(t) in this.context_ } getImage(t) { return this.hasContext(t) ? this.getContext(t).canvas : null } getReplayState(t) { const e = z(t); return e in this.replayState_ || (this.replayState_[e] = { dirty: !1, renderedRenderOrder: null, renderedResolution: NaN, renderedRevision: -1, renderedTileResolution: NaN, renderedTileRevision: -1, renderedTileZ: -1 }), this.replayState_[e] } load() { this.getSourceTiles() } release() { for (const t in this.context_) { const e = this.context_[t]; kr(e), ul.push(e.canvas), delete this.context_[t] } super.release() } } class gl extends st { constructor(t, e, i, n, r, s) { super(t, e, s), this.extent = null, this.format_ = n, this.features_ = null, this.loader_, this.projection = null, this.resolution, this.tileLoadFunction_ = r, this.url_ = i, this.key = i } getFormat() { return this.format_ } getFeatures() { return this.features_ } load() { this.state == H && (this.setState($), this.tileLoadFunction_(this, this.url_), this.loader_ && this.loader_(this.extent, this.resolution, this.projection)) } onLoad(t, e) { this.setFeatures(t) } onError() { this.setState(Q) } setFeatures(t) { this.features_ = t, this.setState(J) } setLoader(t) { this.loader_ = t } } function fl(t) { return Array.isArray(t) ? Qr(t) : t } let pl, ml = !1; function _l(t, e, i, n, r, s, o) { const a = new XMLHttpRequest; a.open("GET", "function" == typeof t ? t(i, n, r) : t, !0), "arraybuffer" == e.getType() && (a.responseType = "arraybuffer"), a.withCredentials = ml, a.onload = function (t) { if (!a.status || a.status >= 200 && a.status < 300) { const t = e.getType(); let n; "json" == t || "text" == t ? n = a.responseText : "xml" == t ? (n = a.responseXML, n || (n = (new DOMParser).parseFromString(a.responseText, "application/xml"))) : "arraybuffer" == t && (n = a.response), n ? s(e.readFeatures(n, { extent: i, featureProjection: r }), e.readProjection(n)) : o() } else o() }, a.onerror = o, a.send() } function yl(t, e) { return function (i, n, r, s, o) { const a = this; _l(t, e, i, n, r, (function (t, e) { a.addFeatures(t), void 0 !== s && s(t) }), o || p) } } function xl(t, e) { return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]] } function vl(t, e, i, n) { const r = document.createElement("script"), s = "olc_" + z(e); function o() { delete window[s], r.parentNode.removeChild(r) } r.async = !0, r.src = t + (t.includes("?") ? "&" : "?") + (n || "callback") + "=" + s; const a = setTimeout((function () { o(), i && i() }), 1e4); window[s] = function (t) { clearTimeout(a), o(), e(t) }, document.head.appendChild(r) } class Sl extends Error { constructor(t) { super("Unexpected response status: " + t.status), this.name = "ResponseError", this.response = t } } class wl extends Error { constructor(t) { super("Failed to issue request"), this.name = "ClientError", this.client = t } } function El(t) { return new Promise((function (e, i) { const n = new XMLHttpRequest; n.addEventListener("load", (function (t) { const n = t.target; if (!n.status || n.status >= 200 && n.status < 300) { let t; try { t = JSON.parse(n.responseText) } catch (t) { const e = "Error parsing response text as JSON: " + t.message; return void i(new Error(e)) } e(t) } else i(new Sl(n)) })), n.addEventListener("error", (function (t) { i(new wl(t.target)) })), n.open("GET", t), n.setRequestHeader("Accept", "application/json"), n.send() })) } function Tl(t, e) { return e.includes("://") ? e : new URL(e, t).href } class Cl { drawCustom(t, e, i, n) { } drawGeometry(t) { } setStyle(t) { } drawCircle(t, e) { } drawFeature(t, e) { } drawGeometryCollection(t, e) { } drawLineString(t, e) { } drawMultiLineString(t, e) { } drawMultiPoint(t, e) { } drawMultiPolygon(t, e) { } drawPoint(t, e) { } drawPolygon(t, e) { } drawText(t, e) { } setFillStrokeStyle(t, e) { } setImageStyle(t, e) { } setTextStyle(t, e) { } } class bl extends Cl { constructor(t, e, i, n, r, s, o) { super(), this.context_ = t, this.pixelRatio_ = e, this.extent_ = i, this.transform_ = n, this.viewRotation_ = r, this.squaredTolerance_ = s, this.userTransform_ = o, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = !1, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = !1, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = [1, 0, 0, 1, 0, 0] } drawImages_(t, e, i, n) { if (!this.image_) return; const r = un(t, e, i, n, this.transform_, this.pixelCoordinates_), s = this.context_, o = this.tmpLocalTransform_, a = s.globalAlpha; 1 != this.imageOpacity_ && (s.globalAlpha = a * this.imageOpacity_); let l = this.imageRotation_; this.imageRotateWithView_ && (l += this.viewRotation_); for (let t = 0, e = r.length; t < e; t += 2) { const e = r[t] - this.imageAnchorX_, i = r[t + 1] - this.imageAnchorY_; if (0 !== l || 1 != this.imageScale_[0] || 1 != this.imageScale_[1]) { const t = e + this.imageAnchorX_, n = i + this.imageAnchorY_; Mt(o, t, n, 1, 1, l, -t, -n), s.setTransform.apply(s, o), s.translate(t, n), s.scale(this.imageScale_[0], this.imageScale_[1]), s.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_), s.setTransform(1, 0, 0, 1, 0, 0) } else s.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, e, i, this.imageWidth_, this.imageHeight_) } 1 != this.imageOpacity_ && (s.globalAlpha = a) } drawText_(t, e, i, n) { if (!this.textState_ || "" === this.text_) return; this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_); const r = un(t, e, i, n, this.transform_, this.pixelCoordinates_), s = this.context_; let o = this.textRotation_; for (this.textRotateWithView_ && (o += this.viewRotation_); e < i; e += n) { const t = r[e] + this.textOffsetX_, i = r[e + 1] + this.textOffsetY_; 0 !== o || 1 != this.textScale_[0] || 1 != this.textScale_[1] ? (s.translate(t - this.textOffsetX_, i - this.textOffsetY_), s.rotate(o), s.translate(this.textOffsetX_, this.textOffsetY_), s.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && s.strokeText(this.text_, 0, 0), this.textFillState_ && s.fillText(this.text_, 0, 0), s.setTransform(1, 0, 0, 1, 0, 0)) : (this.textStrokeState_ && s.strokeText(this.text_, t, i), this.textFillState_ && s.fillText(this.text_, t, i)) } } moveToLineTo_(t, e, i, n, r) { const s = this.context_, o = un(t, e, i, n, this.transform_, this.pixelCoordinates_); s.moveTo(o[0], o[1]); let a = o.length; r && (a -= 2); for (let t = 2; t < a; t += 2)s.lineTo(o[t], o[t + 1]); return r && s.closePath(), i } drawRings_(t, e, i, n) { for (let r = 0, s = i.length; r < s; ++r)e = this.moveToLineTo_(t, e, i[r], n, !0); return e } drawCircle(t) { if (we(this.extent_, t.getExtent())) { if (this.fillState_ || this.strokeState_) { this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_); const e = xn(t, this.transform_, this.pixelCoordinates_), i = e[2] - e[0], n = e[3] - e[1], r = Math.sqrt(i * i + n * n), s = this.context_; s.beginPath(), s.arc(e[0], e[1], r, 0, 2 * Math.PI), this.fillState_ && s.fill(), this.strokeState_ && s.stroke() } "" !== this.text_ && this.drawText_(t.getCenter(), 0, 2, 2) } } setStyle(t) { this.setFillStrokeStyle(t.getFill(), t.getStroke()), this.setImageStyle(t.getImage()), this.setTextStyle(t.getText()) } setTransform(t) { this.transform_ = t } drawGeometry(t) { switch (t.getType()) { case "Point": this.drawPoint(t); break; case "LineString": this.drawLineString(t); break; case "Polygon": this.drawPolygon(t); break; case "MultiPoint": this.drawMultiPoint(t); break; case "MultiLineString": this.drawMultiLineString(t); break; case "MultiPolygon": this.drawMultiPolygon(t); break; case "GeometryCollection": this.drawGeometryCollection(t); break; case "Circle": this.drawCircle(t) } } drawFeature(t, e) { const i = e.getGeometryFunction()(t); i && we(this.extent_, i.getExtent()) && (this.setStyle(e), this.drawGeometry(i)) } drawGeometryCollection(t) { const e = t.getGeometriesArray(); for (let t = 0, i = e.length; t < i; ++t)this.drawGeometry(e[t]) } drawPoint(t) { this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)); const e = t.getFlatCoordinates(), i = t.getStride(); this.image_ && this.drawImages_(e, 0, e.length, i), "" !== this.text_ && this.drawText_(e, 0, e.length, i) } drawMultiPoint(t) { this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)); const e = t.getFlatCoordinates(), i = t.getStride(); this.image_ && this.drawImages_(e, 0, e.length, i), "" !== this.text_ && this.drawText_(e, 0, e.length, i) } drawLineString(t) { if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), we(this.extent_, t.getExtent())) { if (this.strokeState_) { this.setContextStrokeState_(this.strokeState_); const e = this.context_, i = t.getFlatCoordinates(); e.beginPath(), this.moveToLineTo_(i, 0, i.length, t.getStride(), !1), e.stroke() } if ("" !== this.text_) { const e = t.getFlatMidpoint(); this.drawText_(e, 0, 2, 2) } } } drawMultiLineString(t) { this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)); const e = t.getExtent(); if (we(this.extent_, e)) { if (this.strokeState_) { this.setContextStrokeState_(this.strokeState_); const e = this.context_, i = t.getFlatCoordinates(); let n = 0; const r = t.getEnds(), s = t.getStride(); e.beginPath(); for (let t = 0, e = r.length; t < e; ++t)n = this.moveToLineTo_(i, n, r[t], s, !1); e.stroke() } if ("" !== this.text_) { const e = t.getFlatMidpoints(); this.drawText_(e, 0, e.length, 2) } } } drawPolygon(t) { if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), we(this.extent_, t.getExtent())) { if (this.strokeState_ || this.fillState_) { this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_); const e = this.context_; e.beginPath(), this.drawRings_(t.getOrientedFlatCoordinates(), 0, t.getEnds(), t.getStride()), this.fillState_ && e.fill(), this.strokeState_ && e.stroke() } if ("" !== this.text_) { const e = t.getFlatInteriorPoint(); this.drawText_(e, 0, 2, 2) } } } drawMultiPolygon(t) { if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), we(this.extent_, t.getExtent())) { if (this.strokeState_ || this.fillState_) { this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_); const e = this.context_, i = t.getOrientedFlatCoordinates(); let n = 0; const r = t.getEndss(), s = t.getStride(); e.beginPath(); for (let t = 0, e = r.length; t < e; ++t) { const e = r[t]; n = this.drawRings_(i, n, e, s) } this.fillState_ && e.fill(), this.strokeState_ && e.stroke() } if ("" !== this.text_) { const e = t.getFlatInteriorPoints(); this.drawText_(e, 0, e.length, 2) } } } setContextFillState_(t) { const e = this.context_, i = this.contextFillState_; i ? i.fillStyle != t.fillStyle && (i.fillStyle = t.fillStyle, e.fillStyle = t.fillStyle) : (e.fillStyle = t.fillStyle, this.contextFillState_ = { fillStyle: t.fillStyle }) } setContextStrokeState_(t) { const e = this.context_, i = this.contextStrokeState_; i ? (i.lineCap != t.lineCap && (i.lineCap = t.lineCap, e.lineCap = t.lineCap), u(i.lineDash, t.lineDash) || e.setLineDash(i.lineDash = t.lineDash), i.lineDashOffset != t.lineDashOffset && (i.lineDashOffset = t.lineDashOffset, e.lineDashOffset = t.lineDashOffset), i.lineJoin != t.lineJoin && (i.lineJoin = t.lineJoin, e.lineJoin = t.lineJoin), i.lineWidth != t.lineWidth && (i.lineWidth = t.lineWidth, e.lineWidth = t.lineWidth), i.miterLimit != t.miterLimit && (i.miterLimit = t.miterLimit, e.miterLimit = t.miterLimit), i.strokeStyle != t.strokeStyle && (i.strokeStyle = t.strokeStyle, e.strokeStyle = t.strokeStyle)) : (e.lineCap = t.lineCap, e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset, e.lineJoin = t.lineJoin, e.lineWidth = t.lineWidth, e.miterLimit = t.miterLimit, e.strokeStyle = t.strokeStyle, this.contextStrokeState_ = { lineCap: t.lineCap, lineDash: t.lineDash, lineDashOffset: t.lineDashOffset, lineJoin: t.lineJoin, lineWidth: t.lineWidth, miterLimit: t.miterLimit, strokeStyle: t.strokeStyle }) } setContextTextState_(t) { const e = this.context_, i = this.contextTextState_, n = t.textAlign ? t.textAlign : Us; i ? (i.font != t.font && (i.font = t.font, e.font = t.font), i.textAlign != n && (i.textAlign = n, e.textAlign = n), i.textBaseline != t.textBaseline && (i.textBaseline = t.textBaseline, e.textBaseline = t.textBaseline)) : (e.font = t.font, e.textAlign = n, e.textBaseline = t.textBaseline, this.contextTextState_ = { font: t.font, textAlign: n, textBaseline: t.textBaseline }) } setFillStrokeStyle(t, e) { if (t) { const e = t.getColor(); this.fillState_ = { fillStyle: fl(e || Ns) } } else this.fillState_ = null; if (e) { const t = e.getColor(), i = e.getLineCap(), n = e.getLineDash(), r = e.getLineDashOffset(), s = e.getLineJoin(), o = e.getWidth(), a = e.getMiterLimit(), l = n || ks; this.strokeState_ = { lineCap: void 0 !== i ? i : Ds, lineDash: 1 === this.pixelRatio_ ? l : l.map((t => t * this.pixelRatio_)), lineDashOffset: (r || 0) * this.pixelRatio_, lineJoin: void 0 !== s ? s : Gs, lineWidth: (void 0 !== o ? o : 1) * this.pixelRatio_, miterLimit: void 0 !== a ? a : js, strokeStyle: fl(t || Bs) } } else this.strokeState_ = null } setImageStyle(t) { let e; if (!t || !(e = t.getSize())) return void (this.image_ = null); const i = t.getPixelRatio(this.pixelRatio_), n = t.getAnchor(), r = t.getOrigin(); this.image_ = t.getImage(this.pixelRatio_), this.imageAnchorX_ = n[0] * i, this.imageAnchorY_ = n[1] * i, this.imageHeight_ = e[1] * i, this.imageOpacity_ = t.getOpacity(), this.imageOriginX_ = r[0], this.imageOriginY_ = r[1], this.imageRotateWithView_ = t.getRotateWithView(), this.imageRotation_ = t.getRotation(); const s = t.getScaleArray(); this.imageScale_ = [s[0] * this.pixelRatio_ / i, s[1] * this.pixelRatio_ / i], this.imageWidth_ = e[0] * i } setTextStyle(t) { if (t) { const e = t.getFill(); if (e) { const t = e.getColor(); this.textFillState_ = { fillStyle: fl(t || Ns) } } else this.textFillState_ = null; const i = t.getStroke(); if (i) { const t = i.getColor(), e = i.getLineCap(), n = i.getLineDash(), r = i.getLineDashOffset(), s = i.getLineJoin(), o = i.getWidth(), a = i.getMiterLimit(); this.textStrokeState_ = { lineCap: void 0 !== e ? e : Ds, lineDash: n || ks, lineDashOffset: r || 0, lineJoin: void 0 !== s ? s : Gs, lineWidth: void 0 !== o ? o : 1, miterLimit: void 0 !== a ? a : js, strokeStyle: fl(t || Bs) } } else this.textStrokeState_ = null; const n = t.getFont(), r = t.getOffsetX(), s = t.getOffsetY(), o = t.getRotateWithView(), a = t.getRotation(), l = t.getScaleArray(), h = t.getText(), c = t.getTextAlign(), u = t.getTextBaseline(); this.textState_ = { font: void 0 !== n ? n : Os, textAlign: void 0 !== c ? c : Us, textBaseline: void 0 !== u ? u : zs }, this.text_ = void 0 !== h ? Array.isArray(h) ? h.reduce(((t, e, i) => t + (i % 2 ? " " : e)), "") : h : "", this.textOffsetX_ = void 0 !== r ? this.pixelRatio_ * r : 0, this.textOffsetY_ = void 0 !== s ? this.pixelRatio_ * s : 0, this.textRotateWithView_ = void 0 !== o && o, this.textRotation_ = void 0 !== a ? a : 0, this.textScale_ = [this.pixelRatio_ * l[0], this.pixelRatio_ * l[1]] } else this.text_ = "" } } const Rl = { Point: function (t, e, i, n, r) { const s = i.getImage(), o = i.getText(); let a; if (s) { if (s.getImageState() != Lr) return; let l = t; if (r) { const h = s.getDeclutterMode(); if ("none" !== h) if (l = r, "obstacle" === h) { const r = t.getBuilder(i.getZIndex(), "Image"); r.setImageStyle(s, a), r.drawPoint(e, n) } else o && o.getText() && (a = {}) } const h = l.getBuilder(i.getZIndex(), "Image"); h.setImageStyle(s, a), h.drawPoint(e, n) } if (o && o.getText()) { let s = t; r && (s = r); const l = s.getBuilder(i.getZIndex(), "Text"); l.setTextStyle(o, a), l.drawText(e, n) } }, LineString: function (t, e, i, n, r) { const s = i.getStroke(); if (s) { const r = t.getBuilder(i.getZIndex(), "LineString"); r.setFillStrokeStyle(null, s), r.drawLineString(e, n) } const o = i.getText(); if (o && o.getText()) { const s = (r || t).getBuilder(i.getZIndex(), "Text"); s.setTextStyle(o), s.drawText(e, n) } }, Polygon: function (t, e, i, n, r) { const s = i.getFill(), o = i.getStroke(); if (s || o) { const r = t.getBuilder(i.getZIndex(), "Polygon"); r.setFillStrokeStyle(s, o), r.drawPolygon(e, n) } const a = i.getText(); if (a && a.getText()) { const s = (r || t).getBuilder(i.getZIndex(), "Text"); s.setTextStyle(a), s.drawText(e, n) } }, MultiPoint: function (t, e, i, n, r) { const s = i.getImage(), o = i.getText(); let a; if (s) { if (s.getImageState() != Lr) return; let l = t; if (r) { const h = s.getDeclutterMode(); if ("none" !== h) if (l = r, "obstacle" === h) { const r = t.getBuilder(i.getZIndex(), "Image"); r.setImageStyle(s, a), r.drawMultiPoint(e, n) } else o && o.getText() && (a = {}) } const h = l.getBuilder(i.getZIndex(), "Image"); h.setImageStyle(s, a), h.drawMultiPoint(e, n) } if (o && o.getText()) { let s = t; r && (s = r); const l = s.getBuilder(i.getZIndex(), "Text"); l.setTextStyle(o, a), l.drawText(e, n) } }, MultiLineString: function (t, e, i, n, r) { const s = i.getStroke(); if (s) { const r = t.getBuilder(i.getZIndex(), "LineString"); r.setFillStrokeStyle(null, s), r.drawMultiLineString(e, n) } const o = i.getText(); if (o && o.getText()) { const s = (r || t).getBuilder(i.getZIndex(), "Text"); s.setTextStyle(o), s.drawText(e, n) } }, MultiPolygon: function (t, e, i, n, r) { const s = i.getFill(), o = i.getStroke(); if (o || s) { const r = t.getBuilder(i.getZIndex(), "Polygon"); r.setFillStrokeStyle(s, o), r.drawMultiPolygon(e, n) } const a = i.getText(); if (a && a.getText()) { const s = (r || t).getBuilder(i.getZIndex(), "Text"); s.setTextStyle(a), s.drawText(e, n) } }, GeometryCollection: function (t, e, i, n, r) { const s = e.getGeometriesArray(); let o, a; for (o = 0, a = s.length; o < a; ++o) { (0, Rl[s[o].getType()])(t, s[o], i, n, r) } }, Circle: function (t, e, i, n, r) { const s = i.getFill(), o = i.getStroke(); if (s || o) { const r = t.getBuilder(i.getZIndex(), "Circle"); r.setFillStrokeStyle(s, o), r.drawCircle(e, n) } const a = i.getText(); if (a && a.getText()) { const s = (r || t).getBuilder(i.getZIndex(), "Text"); s.setTextStyle(a), s.drawText(e, n) } } }; function Pl(t, e) { return parseInt(z(t), 10) - parseInt(z(e), 10) } function Il(t, e) { const i = Ll(t, e); return i * i } function Ll(t, e) { return .5 * t / e } function Ml(t, e, i, n, r, s, o) { let a = !1; const l = i.getImage(); if (l) { const t = l.getImageState(); t == Lr || t == Mr ? l.unlistenImageChange(r) : (t == Pr && l.load(), l.listenImageChange(r), a = !0) } return function (t, e, i, n, r, s) { const o = i.getGeometryFunction()(e); if (!o) return; const a = o.simplifyTransformed(n, r); if (i.getRenderer()) Fl(t, a, i, e); else { (0, Rl[a.getType()])(t, a, i, e, s) } }(t, e, i, n, s, o), a } function Fl(t, e, i, n) { if ("GeometryCollection" == e.getType()) { const r = e.getGeometries(); for (let e = 0, s = r.length; e < s; ++e)Fl(t, r[e], i, n); return } t.getBuilder(i.getZIndex(), "Default").drawCustom(e, n, i.getRenderer(), i.getHitDetectionRenderer()) } function Al(t) { if (!(t.context instanceof CanvasRenderingContext2D)) throw new Error("Only works for render events from Canvas 2D layers"); const e = t.inversePixelTransform[0], i = t.frameState, n = Et(t.inversePixelTransform.slice(), i.coordinateToPixelTransform), r = Il(i.viewState.resolution, e); let s; const o = en(); return o && (s = qi(o, i.viewState.projection)), new bl(t.context, e, i.extent, n, i.viewState.rotation, r, s) } let Ol; const Nl = []; function Dl(t, e, i, n, r) { t.beginPath(), t.moveTo(0, 0), t.lineTo(e, i), t.lineTo(n, r), t.closePath(), t.save(), t.clip(), t.fillRect(0, 0, Math.max(e, n) + 1, Math.max(i, r)), t.restore() } function kl(t, e) { return Math.abs(t[4 * e] - 210) > 2 || Math.abs(t[4 * e + 3] - 191.25) > 2 } function Gl(t, e, i, n) { const r = $i(i, e, t); let s = zi(e, n, i); const o = e.getMetersPerUnit(); void 0 !== o && (s *= o); const a = t.getMetersPerUnit(); void 0 !== a && (s /= a); const l = t.getExtent(); if (!l || Zt(l, r)) { const e = zi(t, s, r) / s; isFinite(e) && e > 0 && (s /= e) } return s } function jl(t, e, i, n) { const r = ge(i); let s = Gl(t, e, r, n); return (!isFinite(s) || s <= 0) && he(i, (function (i) { return s = Gl(t, e, i, n), isFinite(s) && s > 0 })), s } function Bl(t, e, i, n, r, s, o, a, l, h, c, u) { const d = Dr(Math.round(i * t), Math.round(i * e), Nl); if (u || (d.imageSmoothingEnabled = !1), 0 === l.length) return d.canvas; function g(t) { return Math.round(t * i) / i } d.scale(i, i), d.globalCompositeOperation = "lighter"; const f = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; l.forEach((function (t, e, i) { ne(f, t.extent) })); const p = Se(f), m = _e(f), _ = Dr(Math.round(i * p / n), Math.round(i * m / n)); u || (_.imageSmoothingEnabled = !1); const y = i / n; l.forEach((function (t, e, i) { const n = t.extent[0] - f[0], r = -(t.extent[3] - f[3]), s = Se(t.extent), o = _e(t.extent); t.image.width > 0 && t.image.height > 0 && _.drawImage(t.image, h, h, t.image.width - 2 * h, t.image.height - 2 * h, n * y, r * y, s * y, o * y) })); const x = xe(o); return a.getTriangles().forEach((function (t, e, r) { const o = t.source, a = t.target; let l = o[0][0], h = o[0][1], c = o[1][0], p = o[1][1], m = o[2][0], y = o[2][1]; const v = g((a[0][0] - x[0]) / s), S = g(-(a[0][1] - x[1]) / s), w = g((a[1][0] - x[0]) / s), E = g(-(a[1][1] - x[1]) / s), T = g((a[2][0] - x[0]) / s), C = g(-(a[2][1] - x[1]) / s), b = l, R = h; l = 0, h = 0, c -= b, p -= R, m -= b, y -= R; const P = si([[c, p, 0, 0, w - v], [m, y, 0, 0, T - v], [0, 0, c, p, E - S], [0, 0, m, y, C - S]]); if (P) { if (d.save(), d.beginPath(), function () { if (void 0 === Ol) { const t = document.createElement("canvas").getContext("2d"); t.globalCompositeOperation = "lighter", t.fillStyle = "rgba(210, 0, 0, 0.75)", Dl(t, 4, 5, 4, 0), Dl(t, 4, 5, 0, 5); const e = t.getImageData(0, 0, 3, 3).data; Ol = kl(e, 0) || kl(e, 4) || kl(e, 8) } return Ol }() || !u) { d.moveTo(w, E); const t = 4, e = v - w, i = S - E; for (let n = 0; n < t; n++)d.lineTo(w + g((n + 1) * e / t), E + g(n * i / (t - 1))), n != t - 1 && d.lineTo(w + g((n + 1) * e / t), E + g((n + 1) * i / (t - 1))); d.lineTo(T, C) } else d.moveTo(w, E), d.lineTo(v, S), d.lineTo(T, C); d.clip(), d.transform(P[0], P[2], P[1], P[3], v, S), d.translate(f[0] - b, f[3] - R), d.scale(n / i, -n / i), d.drawImage(_.canvas, 0, 0), d.restore() } })), c && (d.save(), d.globalCompositeOperation = "source-over", d.strokeStyle = "black", d.lineWidth = 1, a.getTriangles().forEach((function (t, e, i) { const n = t.target, r = (n[0][0] - x[0]) / s, o = -(n[0][1] - x[1]) / s, a = (n[1][0] - x[0]) / s, l = -(n[1][1] - x[1]) / s, h = (n[2][0] - x[0]) / s, c = -(n[2][1] - x[1]) / s; d.beginPath(), d.moveTo(a, l), d.lineTo(r, o), d.lineTo(h, c), d.closePath(), d.stroke() })), d.restore()), d.canvas } class Ul { constructor(t, e, i, n, r, s) { this.sourceProj_ = t, this.targetProj_ = e; let o = {}; const a = Hi(this.targetProj_, this.sourceProj_); this.transformInv_ = function (t) { const e = t[0] + "/" + t[1]; return o[e] || (o[e] = a(t)), o[e] }, this.maxSourceExtent_ = n, this.errorThresholdSquared_ = r * r, this.triangles_ = [], this.wrapsXInSource_ = !1, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!n && !!this.sourceProj_.getExtent() && Se(n) == Se(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? Se(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? Se(this.targetProj_.getExtent()) : null; const l = xe(i), h = ve(i), c = de(i), u = ue(i), d = this.transformInv_(l), g = this.transformInv_(h), f = this.transformInv_(c), p = this.transformInv_(u), m = 10 + (s ? Math.max(0, Math.ceil(Math.log2(ce(i) / (s * s * 256 * 256)))) : 0); if (this.addQuad_(l, h, c, u, d, g, f, p, m), this.wrapsXInSource_) { let t = 1 / 0; this.triangles_.forEach((function (e, i, n) { t = Math.min(t, e.source[0][0], e.source[1][0], e.source[2][0]) })), this.triangles_.forEach(function (e) { if (Math.max(e.source[0][0], e.source[1][0], e.source[2][0]) - t > this.sourceWorldWidth_ / 2) { const i = [[e.source[0][0], e.source[0][1]], [e.source[1][0], e.source[1][1]], [e.source[2][0], e.source[2][1]]]; i[0][0] - t > this.sourceWorldWidth_ / 2 && (i[0][0] -= this.sourceWorldWidth_), i[1][0] - t > this.sourceWorldWidth_ / 2 && (i[1][0] -= this.sourceWorldWidth_), i[2][0] - t > this.sourceWorldWidth_ / 2 && (i[2][0] -= this.sourceWorldWidth_); const n = Math.min(i[0][0], i[1][0], i[2][0]); Math.max(i[0][0], i[1][0], i[2][0]) - n < this.sourceWorldWidth_ / 2 && (e.source = i) } }.bind(this)) } o = {} } addTriangle_(t, e, i, n, r, s) { this.triangles_.push({ source: [n, r, s], target: [t, e, i] }) } addQuad_(t, e, i, n, r, s, o, a, l) { const h = zt([r, s, o, a]), c = this.sourceWorldWidth_ ? Se(h) / this.sourceWorldWidth_ : null, u = this.sourceWorldWidth_, d = this.sourceProj_.canWrapX() && c > .5 && c < 1; let g = !1; if (l > 0) { if (this.targetProj_.isGlobal() && this.targetWorldWidth_) { g = Se(zt([t, e, i, n])) / this.targetWorldWidth_ > .25 || g } !d && this.sourceProj_.isGlobal() && c && (g = c > .25 || g) } if (!g && this.maxSourceExtent_ && isFinite(h[0]) && isFinite(h[1]) && isFinite(h[2]) && isFinite(h[3]) && !we(h, this.maxSourceExtent_)) return; let f = 0; if (!(g || isFinite(r[0]) && isFinite(r[1]) && isFinite(s[0]) && isFinite(s[1]) && isFinite(o[0]) && isFinite(o[1]) && isFinite(a[0]) && isFinite(a[1]))) if (l > 0) g = !0; else if (f = (isFinite(r[0]) && isFinite(r[1]) ? 0 : 8) + (isFinite(s[0]) && isFinite(s[1]) ? 0 : 4) + (isFinite(o[0]) && isFinite(o[1]) ? 0 : 2) + (isFinite(a[0]) && isFinite(a[1]) ? 0 : 1), 1 != f && 2 != f && 4 != f && 8 != f) return; if (l > 0) { if (!g) { const e = [(t[0] + i[0]) / 2, (t[1] + i[1]) / 2], n = this.transformInv_(e); let s; if (d) { s = (li(r[0], u) + li(o[0], u)) / 2 - li(n[0], u) } else s = (r[0] + o[0]) / 2 - n[0]; const a = (r[1] + o[1]) / 2 - n[1]; g = s * s + a * a > this.errorThresholdSquared_ } if (g) { if (Math.abs(t[0] - i[0]) <= Math.abs(t[1] - i[1])) { const h = [(e[0] + i[0]) / 2, (e[1] + i[1]) / 2], c = this.transformInv_(h), u = [(n[0] + t[0]) / 2, (n[1] + t[1]) / 2], d = this.transformInv_(u); this.addQuad_(t, e, h, u, r, s, c, d, l - 1), this.addQuad_(u, h, i, n, d, c, o, a, l - 1) } else { const h = [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2], c = this.transformInv_(h), u = [(i[0] + n[0]) / 2, (i[1] + n[1]) / 2], d = this.transformInv_(u); this.addQuad_(t, h, u, n, r, c, d, a, l - 1), this.addQuad_(h, e, i, u, c, s, o, d, l - 1) } return } } if (d) { if (!this.canWrapXInSource_) return; this.wrapsXInSource_ = !0 } 0 == (11 & f) && this.addTriangle_(t, i, n, r, o, a), 0 == (14 & f) && this.addTriangle_(t, i, e, r, o, s), f && (0 == (13 & f) && this.addTriangle_(e, n, t, s, a, r), 0 == (7 & f) && this.addTriangle_(e, n, i, s, a, o)) } calculateSourceExtent() { const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; return this.triangles_.forEach((function (e, i, n) { const r = e.source; re(t, r[0]), re(t, r[1]), re(t, r[2]) })), t } getTriangles() { return this.triangles_ } } class zl extends st { constructor(t, e, i, n, r, s, o, a, l, h, c, u) { super(r, H, { interpolate: !!u }), this.renderEdges_ = void 0 !== c && c, this.pixelRatio_ = o, this.gutter_ = a, this.canvas_ = null, this.sourceTileGrid_ = e, this.targetTileGrid_ = n, this.wrappedTileCoord_ = s || r, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0; const d = n.getTileCoordExtent(this.wrappedTileCoord_), g = this.targetTileGrid_.getExtent(); let f = this.sourceTileGrid_.getExtent(); const p = g ? ye(d, g) : d; if (0 === ce(p)) return void (this.state = tt); const m = t.getExtent(); m && (f = f ? ye(f, m) : m); const _ = n.getResolution(this.wrappedTileCoord_[0]), y = jl(t, i, p, _); if (!isFinite(y) || y <= 0) return void (this.state = tt); const x = void 0 !== h ? h : .5; if (this.triangulation_ = new Ul(t, i, p, f, y * x, _), 0 === this.triangulation_.getTriangles().length) return void (this.state = tt); this.sourceZ_ = e.getZForResolution(y); let v = this.triangulation_.calculateSourceExtent(); if (f && (t.canWrapX() ? (v[1] = ii(v[1], f[1], f[3]), v[3] = ii(v[3], f[1], f[3])) : v = ye(v, f)), ce(v)) { const t = e.getTileRangeForExtentAndZ(v, this.sourceZ_); for (let e = t.minX; e <= t.maxX; e++)for (let i = t.minY; i <= t.maxY; i++) { const t = l(this.sourceZ_, e, i, o); t && this.sourceTiles_.push(t) } 0 === this.sourceTiles_.length && (this.state = tt) } else this.state = tt } getImage() { return this.canvas_ } reproject_() { const t = []; if (this.sourceTiles_.forEach(function (e, i, n) { e && e.getState() == J && t.push({ extent: this.sourceTileGrid_.getTileCoordExtent(e.tileCoord), image: e.getImage() }) }.bind(this)), this.sourceTiles_.length = 0, 0 === t.length) this.state = Q; else { const e = this.wrappedTileCoord_[0], i = this.targetTileGrid_.getTileSize(e), n = "number" == typeof i ? i : i[0], r = "number" == typeof i ? i : i[1], s = this.targetTileGrid_.getResolution(e), o = this.sourceTileGrid_.getResolution(this.sourceZ_), a = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_); this.canvas_ = Bl(n, r, this.pixelRatio_, o, this.sourceTileGrid_.getExtent(), s, a, this.triangulation_, t, this.gutter_, this.renderEdges_, this.interpolate), this.state = J } this.changed() } load() { if (this.state == H) { this.state = $, this.changed(); let t = 0; this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(function (e, i, n) { const r = e.getState(); if (r == H || r == $) { t++; const i = N(e, S, (function (n) { const r = e.getState(); r != J && r != Q && r != tt || (k(i), t--, 0 === t && (this.unlistenSources_(), this.reproject_())) }), this); this.sourcesListenerKeys_.push(i) } }.bind(this)), 0 === t ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach((function (t, e, i) { t.getState() == H && t.load() })) } } unlistenSources_() { this.sourcesListenerKeys_.forEach(k), this.sourcesListenerKeys_ = null } release() { this.canvas_ && (kr(this.canvas_.getContext("2d")), Nl.push(this.canvas_), this.canvas_ = null), super.release() } } var Xl = "tileloadstart", Vl = "tileloadend", Wl = "tileloaderror"; class Zl extends V { constructor(t) { super(), this.projection = Ui(t.projection), this.attributions_ = Yl(t.attributions), this.attributionsCollapsible_ = void 0 === t.attributionsCollapsible || t.attributionsCollapsible, this.loading = !1, this.state_ = void 0 !== t.state ? t.state : "ready", this.wrapX_ = void 0 !== t.wrapX && t.wrapX, this.interpolate_ = !!t.interpolate, this.viewResolver = null, this.viewRejector = null; const e = this; this.viewPromise_ = new Promise((function (t, i) { e.viewResolver = t, e.viewRejector = i })) } getAttributions() { return this.attributions_ } getAttributionsCollapsible() { return this.attributionsCollapsible_ } getProjection() { return this.projection } getResolutions() { return B() } getView() { return this.viewPromise_ } getState() { return this.state_ } getWrapX() { return this.wrapX_ } getInterpolate() { return this.interpolate_ } refresh() { this.changed() } setAttributions(t) { this.attributions_ = Yl(t), this.changed() } setState(t) { this.state_ = t, this.changed() } } function Yl(t) { return t ? Array.isArray(t) ? function (e) { return t } : "function" == typeof t ? t : function (e) { return [t] } : null } const Kl = [0, 0, 0]; class ql { constructor(t) { let e; if (this.minZoom = void 0 !== t.minZoom ? t.minZoom : 0, this.resolutions_ = t.resolutions, at(d(this.resolutions_, (function (t, e) { return e - t }), !0), 17), !t.origins) for (let t = 0, i = this.resolutions_.length - 1; t < i; ++t)if (e) { if (this.resolutions_[t] / this.resolutions_[t + 1] !== e) { e = void 0; break } } else e = this.resolutions_[t] / this.resolutions_[t + 1]; this.zoomFactor_ = e, this.maxZoom = this.resolutions_.length - 1, this.origin_ = void 0 !== t.origin ? t.origin : null, this.origins_ = null, void 0 !== t.origins && (this.origins_ = t.origins, at(this.origins_.length == this.resolutions_.length, 20)); const i = t.extent; void 0 === i || this.origin_ || this.origins_ || (this.origin_ = xe(i)), at(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18), this.tileSizes_ = null, void 0 !== t.tileSizes && (this.tileSizes_ = t.tileSizes, at(this.tileSizes_.length == this.resolutions_.length, 19)), this.tileSize_ = void 0 !== t.tileSize ? t.tileSize : this.tileSizes_ ? null : Lo, at(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22), this.extent_ = void 0 !== i ? i : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], void 0 !== t.sizes ? this.fullTileRanges_ = t.sizes.map((function (t, e) { const n = new hl(Math.min(0, t[0]), Math.max(t[0] - 1, -1), Math.min(0, t[1]), Math.max(t[1] - 1, -1)); if (i) { const t = this.getTileRangeForExtentAndZ(i, e); n.minX = Math.max(t.minX, n.minX), n.maxX = Math.min(t.maxX, n.maxX), n.minY = Math.max(t.minY, n.minY), n.maxY = Math.min(t.maxY, n.maxY) } return n }), this) : i && this.calculateTileRanges_(i) } forEachTileCoord(t, e, i) { const n = this.getTileRangeForExtentAndZ(t, e); for (let t = n.minX, r = n.maxX; t <= r; ++t)for (let r = n.minY, s = n.maxY; r <= s; ++r)i([e, t, r]) } forEachTileCoordParentTileRange(t, e, i, n) { let r, s, o, a = null, l = t[0] - 1; for (2 === this.zoomFactor_ ? (s = t[1], o = t[2]) : a = this.getTileCoordExtent(t, n); l >= this.minZoom;) { if (2 === this.zoomFactor_ ? (s = Math.floor(s / 2), o = Math.floor(o / 2), r = cl(s, s, o, o, i)) : r = this.getTileRangeForExtentAndZ(a, l, i), e(l, r)) return !0; --l } return !1 } getExtent() { return this.extent_ } getMaxZoom() { return this.maxZoom } getMinZoom() { return this.minZoom } getOrigin(t) { return this.origin_ ? this.origin_ : this.origins_[t] } getResolution(t) { return this.resolutions_[t] } getResolutions() { return this.resolutions_ } getTileCoordChildTileRange(t, e, i) { if (t[0] < this.maxZoom) { if (2 === this.zoomFactor_) { const i = 2 * t[1], n = 2 * t[2]; return cl(i, i + 1, n, n + 1, e) } const n = this.getTileCoordExtent(t, i || this.tmpExtent_); return this.getTileRangeForExtentAndZ(n, t[0] + 1, e) } return null } getTileRangeForTileCoordAndZ(t, e, i) { if (e > this.maxZoom || e < this.minZoom) return null; const n = t[0], r = t[1], s = t[2]; if (e === n) return cl(r, s, r, s, i); if (this.zoomFactor_) { const t = Math.pow(this.zoomFactor_, e - n), o = Math.floor(r * t), a = Math.floor(s * t); if (e < n) return cl(o, o, a, a, i); return cl(o, Math.floor(t * (r + 1)) - 1, a, Math.floor(t * (s + 1)) - 1, i) } const o = this.getTileCoordExtent(t, this.tmpExtent_); return this.getTileRangeForExtentAndZ(o, e, i) } getTileRangeExtent(t, e, i) { const n = this.getOrigin(t), r = this.getResolution(t), s = Va(this.getTileSize(t), this.tmpSize_), o = n[0] + e.minX * s[0] * r, a = n[0] + (e.maxX + 1) * s[0] * r; return $t(o, n[1] + e.minY * s[1] * r, a, n[1] + (e.maxY + 1) * s[1] * r, i) } getTileRangeForExtentAndZ(t, e, i) { const n = Kl; this.getTileCoordForXYAndZ_(t[0], t[3], e, !1, n); const r = n[1], s = n[2]; return this.getTileCoordForXYAndZ_(t[2], t[1], e, !0, n), cl(r, n[1], s, n[2], i) } getTileCoordCenter(t) { const e = this.getOrigin(t[0]), i = this.getResolution(t[0]), n = Va(this.getTileSize(t[0]), this.tmpSize_); return [e[0] + (t[1] + .5) * n[0] * i, e[1] - (t[2] + .5) * n[1] * i] } getTileCoordExtent(t, e) { const i = this.getOrigin(t[0]), n = this.getResolution(t[0]), r = Va(this.getTileSize(t[0]), this.tmpSize_), s = i[0] + t[1] * r[0] * n, o = i[1] - (t[2] + 1) * r[1] * n; return $t(s, o, s + r[0] * n, o + r[1] * n, e) } getTileCoordForCoordAndResolution(t, e, i) { return this.getTileCoordForXYAndResolution_(t[0], t[1], e, !1, i) } getTileCoordForXYAndResolution_(t, e, i, n, r) { const s = this.getZForResolution(i), o = i / this.getResolution(s), a = this.getOrigin(s), l = Va(this.getTileSize(s), this.tmpSize_); let h = o * (t - a[0]) / i / l[0], c = o * (a[1] - e) / i / l[1]; return n ? (h = gi(h, 5) - 1, c = gi(c, 5) - 1) : (h = di(h, 5), c = di(c, 5)), el(s, h, c, r) } getTileCoordForXYAndZ_(t, e, i, n, r) { const s = this.getOrigin(i), o = this.getResolution(i), a = Va(this.getTileSize(i), this.tmpSize_); let l = (t - s[0]) / o / a[0], h = (s[1] - e) / o / a[1]; return n ? (l = gi(l, 5) - 1, h = gi(h, 5) - 1) : (l = di(l, 5), h = di(h, 5)), el(i, l, h, r) } getTileCoordForCoordAndZ(t, e, i) { return this.getTileCoordForXYAndZ_(t[0], t[1], e, !1, i) } getTileCoordResolution(t) { return this.resolutions_[t[0]] } getTileSize(t) { return this.tileSize_ ? this.tileSize_ : this.tileSizes_[t] } getFullTileRange(t) { return this.fullTileRanges_ ? this.fullTileRanges_[t] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, t) : null } getZForResolution(t, e) { return ii(l(this.resolutions_, t, e || 0), this.minZoom, this.maxZoom) } tileCoordIntersectsViewport(t, e) { return er(e, 0, e.length, 2, this.getTileCoordExtent(t)) } calculateTileRanges_(t) { const e = this.resolutions_.length, i = new Array(e); for (let n = this.minZoom; n < e; ++n)i[n] = this.getTileRangeForExtentAndZ(t, n); this.fullTileRanges_ = i } } function Hl(t) { let e = t.getDefaultTileGrid(); return e || (e = eh(t), t.setDefaultTileGrid(e)), e } function $l(t, e, i) { const n = e[0], r = t.getTileCoordCenter(e), s = ih(i); if (Zt(s, r)) return e; { const e = Se(s), i = Math.ceil((s[0] - r[0]) / e); return r[0] += e * i, t.getTileCoordForCoordAndZ(r, n) } } function Jl(t, e, i, n) { n = void 0 !== n ? n : "top-left"; const r = th(t, e, i); return new ql({ extent: t, origin: fe(t, n), resolutions: r, tileSize: i }) } function Ql(t) { const e = t || {}, i = e.extent || Ui("EPSG:3857").getExtent(), n = { extent: i, minZoom: e.minZoom, tileSize: e.tileSize, resolutions: th(i, e.maxZoom, e.tileSize, e.maxResolution) }; return new ql(n) } function th(t, e, i, n) { e = void 0 !== e ? e : 42, i = Va(void 0 !== i ? i : Lo); const r = _e(t), s = Se(t); n = n > 0 ? n : Math.max(s / i[0], r / i[1]); const o = e + 1, a = new Array(o); for (let t = 0; t < o; ++t)a[t] = n / Math.pow(2, t); return a } function eh(t, e, i, n) { return Jl(ih(t), e, i, n) } function ih(t) { let e = (t = Ui(t)).getExtent(); if (!e) { const i = 180 * Fe.degrees / t.getMetersPerUnit(); e = $t(-i, -i, i, i) } return e } class nh extends Zl { constructor(t) { super({ attributions: t.attributions, attributionsCollapsible: t.attributionsCollapsible, projection: t.projection, state: t.state, wrapX: t.wrapX, interpolate: t.interpolate }), this.on, this.once, this.un, this.opaque_ = void 0 !== t.opaque && t.opaque, this.tilePixelRatio_ = void 0 !== t.tilePixelRatio ? t.tilePixelRatio : 1, this.tileGrid = void 0 !== t.tileGrid ? t.tileGrid : null; const e = [256, 256]; this.tileGrid && Va(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), e), this.tileCache = new ll(t.cacheSize || 0), this.tmpSize = [0, 0], this.key_ = t.key || "", this.tileOptions = { transition: t.transition, interpolate: t.interpolate }, this.zDirection = t.zDirection ? t.zDirection : 0 } canExpireCache() { return this.tileCache.canExpireCache() } expireCache(t, e) { const i = this.getTileCacheForProjection(t); i && i.expireCache(e) } forEachLoadedTile(t, e, i, n) { const r = this.getTileCacheForProjection(t); if (!r) return !1; let s, o, a, l = !0; for (let t = i.minX; t <= i.maxX; ++t)for (let h = i.minY; h <= i.maxY; ++h)o = il(e, t, h), a = !1, r.containsKey(o) && (s = r.get(o), a = s.getState() === J, a && (a = !1 !== n(s))), a || (l = !1); return l } getGutterForProjection(t) { return 0 } getKey() { return this.key_ } setKey(t) { this.key_ !== t && (this.key_ = t, this.changed()) } getOpaque(t) { return this.opaque_ } getResolutions() { return this.tileGrid ? this.tileGrid.getResolutions() : null } getTile(t, e, i, n, r) { return B() } getTileGrid() { return this.tileGrid } getTileGridForProjection(t) { return this.tileGrid ? this.tileGrid : Hl(t) } getTileCacheForProjection(t) { const e = this.getProjection(); return at(null === e || Ki(e, t), 68), this.tileCache } getTilePixelRatio(t) { return this.tilePixelRatio_ } getTilePixelSize(t, e, i) { const n = this.getTileGridForProjection(i), r = this.getTilePixelRatio(e), s = Va(n.getTileSize(t), this.tmpSize); return 1 == r ? s : Xa(s, r, this.tmpSize) } getTileCoordForTileUrlFunction(t, e) { e = void 0 !== e ? e : this.getProjection(); const i = this.getTileGridForProjection(e); return this.getWrapX() && e.isGlobal() && (t = $l(i, t, e)), al(t, i) ? t : null } clear() { this.tileCache.clear() } refresh() { this.clear(), super.refresh() } updateCacheSize(t, e) { const i = this.getTileCacheForProjection(e); t > i.highWaterMark && (i.highWaterMark = t) } useTile(t, e, i, n) { } } class rh extends i { constructor(t, e) { super(t), this.tile = e } } function sh(t, e) { const i = /\{z\}/g, n = /\{x\}/g, r = /\{y\}/g, s = /\{-y\}/g; return function (o, a, l) { return o ? t.replace(i, o[0].toString()).replace(n, o[1].toString()).replace(r, o[2].toString()).replace(s, (function () { const t = o[0], i = e.getFullTileRange(t); at(i, 55); return (i.getHeight() - o[2] - 1).toString() })) : void 0 } } function oh(t, e) { const i = t.length, n = new Array(i); for (let r = 0; r < i; ++r)n[r] = sh(t[r], e); return ah(n) } function ah(t) { return 1 === t.length ? t[0] : function (e, i, n) { if (e) { const r = li(ol(e), t.length); return t[r](e, i, n) } } } function lh(t, e, i) { } function hh(t) { const e = []; let i = /\{([a-z])-([a-z])\}/.exec(t); if (i) { const n = i[1].charCodeAt(0), r = i[2].charCodeAt(0); let s; for (s = n; s <= r; ++s)e.push(t.replace(i[0], String.fromCharCode(s))); return e } if (i = /\{(\d+)-(\d+)\}/.exec(t), i) { const n = parseInt(i[2], 10); for (let r = parseInt(i[1], 10); r <= n; r++)e.push(t.replace(i[0], r.toString())); return e } return e.push(t), e } class ch extends nh { constructor(t) { super({ attributions: t.attributions, cacheSize: t.cacheSize, opaque: t.opaque, projection: t.projection, state: t.state, tileGrid: t.tileGrid, tilePixelRatio: t.tilePixelRatio, wrapX: t.wrapX, transition: t.transition, interpolate: t.interpolate, key: t.key, attributionsCollapsible: t.attributionsCollapsible, zDirection: t.zDirection }), this.generateTileUrlFunction_ = this.tileUrlFunction === ch.prototype.tileUrlFunction, this.tileLoadFunction = t.tileLoadFunction, t.tileUrlFunction && (this.tileUrlFunction = t.tileUrlFunction), this.urls = null, t.urls ? this.setUrls(t.urls) : t.url && this.setUrl(t.url), this.tileLoadingKeys_ = {} } getTileLoadFunction() { return this.tileLoadFunction } getTileUrlFunction() { return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction } getUrls() { return this.urls } handleTileChange(t) { const e = t.target, i = z(e), n = e.getState(); let r; n == $ ? (this.tileLoadingKeys_[i] = !0, r = Xl) : i in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[i], r = n == Q ? Wl : n == J ? Vl : void 0), null != r && this.dispatchEvent(new rh(r, e)) } setTileLoadFunction(t) { this.tileCache.clear(), this.tileLoadFunction = t, this.changed() } setTileUrlFunction(t, e) { this.tileUrlFunction = t, this.tileCache.pruneExceptNewestZ(), void 0 !== e ? this.setKey(e) : this.changed() } setUrl(t) { const e = hh(t); this.urls = e, this.setUrls(e) } setUrls(t) { this.urls = t; const e = t.join("\n"); this.generateTileUrlFunction_ ? this.setTileUrlFunction(oh(t, this.tileGrid), e) : this.setKey(e) } tileUrlFunction(t, e, i) { } useTile(t, e, i) { const n = il(t, e, i); this.tileCache.containsKey(n) && this.tileCache.get(n) } } class uh extends ch { constructor(t) { super({ attributions: t.attributions, cacheSize: t.cacheSize, opaque: t.opaque, projection: t.projection, state: t.state, tileGrid: t.tileGrid, tileLoadFunction: t.tileLoadFunction ? t.tileLoadFunction : dh, tilePixelRatio: t.tilePixelRatio, tileUrlFunction: t.tileUrlFunction, url: t.url, urls: t.urls, wrapX: t.wrapX, transition: t.transition, interpolate: void 0 === t.interpolate || t.interpolate, key: t.key, attributionsCollapsible: t.attributionsCollapsible, zDirection: t.zDirection }), this.crossOrigin = void 0 !== t.crossOrigin ? t.crossOrigin : null, this.tileClass = void 0 !== t.tileClass ? t.tileClass : Vr, this.tileCacheForProjection = {}, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = t.reprojectionErrorThreshold, this.renderReprojectionEdges_ = !1 } canExpireCache() { if (this.tileCache.canExpireCache()) return !0; for (const t in this.tileCacheForProjection) if (this.tileCacheForProjection[t].canExpireCache()) return !0; return !1 } expireCache(t, e) { const i = this.getTileCacheForProjection(t); this.tileCache.expireCache(this.tileCache == i ? e : {}); for (const t in this.tileCacheForProjection) { const n = this.tileCacheForProjection[t]; n.expireCache(n == i ? e : {}) } } getGutterForProjection(t) { return this.getProjection() && t && !Ki(this.getProjection(), t) ? 0 : this.getGutter() } getGutter() { return 0 } getKey() { let t = super.getKey(); return this.getInterpolate() || (t += ":disable-interpolation"), t } getOpaque(t) { return !(this.getProjection() && t && !Ki(this.getProjection(), t)) && super.getOpaque(t) } getTileGridForProjection(t) { const e = this.getProjection(); if (!this.tileGrid || e && !Ki(e, t)) { const e = z(t); return e in this.tileGridForProjection || (this.tileGridForProjection[e] = Hl(t)), this.tileGridForProjection[e] } return this.tileGrid } getTileCacheForProjection(t) { const e = this.getProjection(); if (!e || Ki(e, t)) return this.tileCache; { const e = z(t); return e in this.tileCacheForProjection || (this.tileCacheForProjection[e] = new ll(this.tileCache.highWaterMark)), this.tileCacheForProjection[e] } } createTile_(t, e, i, n, r, s) { const o = [t, e, i], a = this.getTileCoordForTileUrlFunction(o, r), l = a ? this.tileUrlFunction(a, n, r) : void 0, h = new this.tileClass(o, void 0 !== l ? H : tt, void 0 !== l ? l : "", this.crossOrigin, this.tileLoadFunction, this.tileOptions); return h.key = s, h.addEventListener(S, this.handleTileChange.bind(this)), h } getTile(t, e, i, n, r) { const s = this.getProjection(); if (s && r && !Ki(s, r)) { const o = this.getTileCacheForProjection(r), a = [t, e, i]; let l; const h = nl(a); o.containsKey(h) && (l = o.get(h)); const c = this.getKey(); if (l && l.key == c) return l; { const t = this.getTileGridForProjection(s), e = this.getTileGridForProjection(r), i = this.getTileCoordForTileUrlFunction(a, r), u = new zl(s, t, r, e, a, i, this.getTilePixelRatio(n), this.getGutter(), function (t, e, i, n) { return this.getTileInternal(t, e, i, n, s) }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.getInterpolate()); return u.key = c, l ? (u.interimTile = l, u.refreshInterimChain(), o.replace(h, u)) : o.set(h, u), u } } return this.getTileInternal(t, e, i, n, s || r) } getTileInternal(t, e, i, n, r) { let s = null; const o = il(t, e, i), a = this.getKey(); if (this.tileCache.containsKey(o)) { if (s = this.tileCache.get(o), s.key != a) { const l = s; s = this.createTile_(t, e, i, n, r, a), l.getState() == H ? s.interimTile = l.interimTile : s.interimTile = l, s.refreshInterimChain(), this.tileCache.replace(o, s) } } else s = this.createTile_(t, e, i, n, r, a), this.tileCache.set(o, s); return s } setRenderReprojectionEdges(t) { if (this.renderReprojectionEdges_ != t) { this.renderReprojectionEdges_ = t; for (const t in this.tileCacheForProjection) this.tileCacheForProjection[t].clear(); this.changed() } } setTileGridForProjection(t, e) { const i = Ui(t); if (i) { const t = z(i); t in this.tileGridForProjection || (this.tileGridForProjection[t] = e) } } clear() { super.clear(); for (const t in this.tileCacheForProjection) this.tileCacheForProjection[t].clear() } } function dh(t, e) { t.getImage().src = e } function gh(t) { const e = t[0], i = new Array(e); let n, r, s = 1 << e - 1; for (n = 0; n < e; ++n)r = 48, t[1] & s && (r += 1), t[2] & s && (r += 2), i[n] = String.fromCharCode(r), s >>= 1; return i.join("") } class fh extends uh { constructor(t) { const e = void 0 !== (t = t || {}).projection ? t.projection : "EPSG:3857", i = void 0 !== t.tileGrid ? t.tileGrid : Ql({ extent: ih(e), maxResolution: t.maxResolution, maxZoom: t.maxZoom, minZoom: t.minZoom, tileSize: t.tileSize }); super({ attributions: t.attributions, cacheSize: t.cacheSize, crossOrigin: t.crossOrigin, interpolate: t.interpolate, opaque: t.opaque, projection: e, reprojectionErrorThreshold: t.reprojectionErrorThreshold, tileGrid: i, tileLoadFunction: t.tileLoadFunction, tilePixelRatio: t.tilePixelRatio, tileUrlFunction: t.tileUrlFunction, url: t.url, urls: t.urls, wrapX: void 0 === t.wrapX || t.wrapX, transition: t.transition, attributionsCollapsible: t.attributionsCollapsible, zDirection: t.zDirection }), this.gutter_ = void 0 !== t.gutter ? t.gutter : 0 } getGutter() { return this.gutter_ } } function ph(t, e, i, n, r) { mh(t, e, i || 0, n || t.length - 1, r || yh) } function mh(t, e, i, n, r) { for (; n > i;) { if (n - i > 600) { var s = n - i + 1, o = e - i + 1, a = Math.log(s), l = .5 * Math.exp(2 * a / 3), h = .5 * Math.sqrt(a * l * (s - l) / s) * (o - s / 2 < 0 ? -1 : 1); mh(t, e, Math.max(i, Math.floor(e - o * l / s + h)), Math.min(n, Math.floor(e + (s - o) * l / s + h)), r) } var c = t[e], u = i, d = n; for (_h(t, i, e), r(t[n], c) > 0 && _h(t, i, n); u < d;) { for (_h(t, u, d), u++, d--; r(t[u], c) < 0;)u++; for (; r(t[d], c) > 0;)d-- } 0 === r(t[i], c) ? _h(t, i, d) : _h(t, ++d, n), d <= e && (i = d + 1), e <= d && (n = d - 1) } } function _h(t, e, i) { var n = t[e]; t[e] = t[i], t[i] = n } function yh(t, e) { return t < e ? -1 : t > e ? 1 : 0 } class xh { constructor(t = 9) { this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), this.clear() } all() { return this._all(this.data, []) } search(t) { let e = this.data; const i = []; if (!Lh(t, e)) return i; const n = this.toBBox, r = []; for (; e;) { for (let s = 0; s < e.children.length; s++) { const o = e.children[s], a = e.leaf ? n(o) : o; Lh(t, a) && (e.leaf ? i.push(o) : Ih(t, a) ? this._all(o, i) : r.push(o)) } e = r.pop() } return i } collides(t) { let e = this.data; if (!Lh(t, e)) return !1; const i = []; for (; e;) { for (let n = 0; n < e.children.length; n++) { const r = e.children[n], s = e.leaf ? this.toBBox(r) : r; if (Lh(t, s)) { if (e.leaf || Ih(t, s)) return !0; i.push(r) } } e = i.pop() } return !1 } load(t) { if (!t || !t.length) return this; if (t.length < this._minEntries) { for (let e = 0; e < t.length; e++)this.insert(t[e]); return this } let e = this._build(t.slice(), 0, t.length - 1, 0); if (this.data.children.length) if (this.data.height === e.height) this._splitRoot(this.data, e); else { if (this.data.height < e.height) { const t = this.data; this.data = e, e = t } this._insert(e, this.data.height - e.height - 1, !0) } else this.data = e; return this } insert(t) { return t && this._insert(t, this.data.height - 1), this } clear() { return this.data = Mh([]), this } remove(t, e) { if (!t) return this; let i = this.data; const n = this.toBBox(t), r = [], s = []; let o, a, l; for (; i || r.length;) { if (i || (i = r.pop(), a = r[r.length - 1], o = s.pop(), l = !0), i.leaf) { const n = vh(t, i.children, e); if (-1 !== n) return i.children.splice(n, 1), r.push(i), this._condense(r), this } l || i.leaf || !Ih(i, n) ? a ? (o++, i = a.children[o], l = !1) : i = null : (r.push(i), s.push(o), o = 0, a = i, i = i.children[0]) } return this } toBBox(t) { return t } compareMinX(t, e) { return t.minX - e.minX } compareMinY(t, e) { return t.minY - e.minY } toJSON() { return this.data } fromJSON(t) { return this.data = t, this } _all(t, e) { const i = []; for (; t;)t.leaf ? e.push(...t.children) : i.push(...t.children), t = i.pop(); return e } _build(t, e, i, n) { const r = i - e + 1; let s, o = this._maxEntries; if (r <= o) return s = Mh(t.slice(e, i + 1)), Sh(s, this.toBBox), s; n || (n = Math.ceil(Math.log(r) / Math.log(o)), o = Math.ceil(r / Math.pow(o, n - 1))), s = Mh([]), s.leaf = !1, s.height = n; const a = Math.ceil(r / o), l = a * Math.ceil(Math.sqrt(o)); Fh(t, e, i, l, this.compareMinX); for (let r = e; r <= i; r += l) { const e = Math.min(r + l - 1, i); Fh(t, r, e, a, this.compareMinY); for (let i = r; i <= e; i += a) { const r = Math.min(i + a - 1, e); s.children.push(this._build(t, i, r, n - 1)) } } return Sh(s, this.toBBox), s } _chooseSubtree(t, e, i, n) { for (; n.push(e), !e.leaf && n.length - 1 !== i;) { let i, n = 1 / 0, o = 1 / 0; for (let a = 0; a < e.children.length; a++) { const l = e.children[a], h = bh(l), c = (r = t, s = l, (Math.max(s.maxX, r.maxX) - Math.min(s.minX, r.minX)) * (Math.max(s.maxY, r.maxY) - Math.min(s.minY, r.minY)) - h); c < o ? (o = c, n = h < n ? h : n, i = l) : c === o && h < n && (n = h, i = l) } e = i || e.children[0] } var r, s; return e } _insert(t, e, i) { const n = i ? t : this.toBBox(t), r = [], s = this._chooseSubtree(n, this.data, e, r); for (s.children.push(t), Eh(s, n); e >= 0 && r[e].children.length > this._maxEntries;)this._split(r, e), e--; this._adjustParentBBoxes(n, r, e) } _split(t, e) { const i = t[e], n = i.children.length, r = this._minEntries; this._chooseSplitAxis(i, r, n); const s = this._chooseSplitIndex(i, r, n), o = Mh(i.children.splice(s, i.children.length - s)); o.height = i.height, o.leaf = i.leaf, Sh(i, this.toBBox), Sh(o, this.toBBox), e ? t[e - 1].children.push(o) : this._splitRoot(i, o) } _splitRoot(t, e) { this.data = Mh([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, Sh(this.data, this.toBBox) } _chooseSplitIndex(t, e, i) { let n, r = 1 / 0, s = 1 / 0; for (let o = e; o <= i - e; o++) { const e = wh(t, 0, o, this.toBBox), a = wh(t, o, i, this.toBBox), l = Ph(e, a), h = bh(e) + bh(a); l < r ? (r = l, n = o, s = h < s ? h : s) : l === r && h < s && (s = h, n = o) } return n || i - e } _chooseSplitAxis(t, e, i) { const n = t.leaf ? this.compareMinX : Th, r = t.leaf ? this.compareMinY : Ch; this._allDistMargin(t, e, i, n) < this._allDistMargin(t, e, i, r) && t.children.sort(n) } _allDistMargin(t, e, i, n) { t.children.sort(n); const r = this.toBBox, s = wh(t, 0, e, r), o = wh(t, i - e, i, r); let a = Rh(s) + Rh(o); for (let n = e; n < i - e; n++) { const e = t.children[n]; Eh(s, t.leaf ? r(e) : e), a += Rh(s) } for (let n = i - e - 1; n >= e; n--) { const e = t.children[n]; Eh(o, t.leaf ? r(e) : e), a += Rh(o) } return a } _adjustParentBBoxes(t, e, i) { for (let n = i; n >= 0; n--)Eh(e[n], t) } _condense(t) { for (let e, i = t.length - 1; i >= 0; i--)0 === t[i].children.length ? i > 0 ? (e = t[i - 1].children, e.splice(e.indexOf(t[i]), 1)) : this.clear() : Sh(t[i], this.toBBox) } } function vh(t, e, i) { if (!i) return e.indexOf(t); for (let n = 0; n < e.length; n++)if (i(t, e[n])) return n; return -1 } function Sh(t, e) { wh(t, 0, t.children.length, e, t) } function wh(t, e, i, n, r) { r || (r = Mh(null)), r.minX = 1 / 0, r.minY = 1 / 0, r.maxX = -1 / 0, r.maxY = -1 / 0; for (let s = e; s < i; s++) { const e = t.children[s]; Eh(r, t.leaf ? n(e) : e) } return r } function Eh(t, e) { return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t } function Th(t, e) { return t.minX - e.minX } function Ch(t, e) { return t.minY - e.minY } function bh(t) { return (t.maxX - t.minX) * (t.maxY - t.minY) } function Rh(t) { return t.maxX - t.minX + (t.maxY - t.minY) } function Ph(t, e) { const i = Math.max(t.minX, e.minX), n = Math.max(t.minY, e.minY), r = Math.min(t.maxX, e.maxX), s = Math.min(t.maxY, e.maxY); return Math.max(0, r - i) * Math.max(0, s - n) } function Ih(t, e) { return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY } function Lh(t, e) { return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY } function Mh(t) { return { children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 } } function Fh(t, e, i, n, r) { const s = [e, i]; for (; s.length;) { if ((i = s.pop()) - (e = s.pop()) <= n) continue; const o = e + Math.ceil((i - e) / n / 2) * n; ph(t, o, e, i, r), s.push(e, o, o, i) } } class Ah { constructor(t) { this.rbush_ = new xh(t), this.items_ = {} } insert(t, e) { const i = { minX: t[0], minY: t[1], maxX: t[2], maxY: t[3], value: e }; this.rbush_.insert(i), this.items_[z(e)] = i } load(t, e) { const i = new Array(e.length); for (let n = 0, r = e.length; n < r; n++) { const r = t[n], s = e[n], o = { minX: r[0], minY: r[1], maxX: r[2], maxY: r[3], value: s }; i[n] = o, this.items_[z(s)] = o } this.rbush_.load(i) } remove(t) { const e = z(t), i = this.items_[e]; return delete this.items_[e], null !== this.rbush_.remove(i) } update(t, e) { const i = this.items_[z(e)]; ee([i.minX, i.minY, i.maxX, i.maxY], t) || (this.remove(e), this.insert(t, e)) } getAll() { return this.rbush_.all().map((function (t) { return t.value })) } getInExtent(t) { const e = { minX: t[0], minY: t[1], maxX: t[2], maxY: t[3] }; return this.rbush_.search(e).map((function (t) { return t.value })) } forEach(t) { return this.forEach_(this.getAll(), t) } forEachInExtent(t, e) { return this.forEach_(this.getInExtent(t), e) } forEach_(t, e) { let i; for (let n = 0, r = t.length; n < r; n++)if (i = e(t[n]), i) return i; return i } isEmpty() { return x(this.items_) } clear() { this.rbush_.clear(), this.items_ = {} } getExtent(t) { const e = this.rbush_.toJSON(); return $t(e.minX, e.minY, e.maxX, e.maxY, t) } concat(t) { this.rbush_.load(t.rbush_.all()); for (const e in t.items_) this.items_[e] = t.items_[e] } } var Oh = "addfeature", Nh = "changefeature", Dh = "clear", kh = "removefeature", Gh = "featuresloadstart", jh = "featuresloadend", Bh = "featuresloaderror"; class Uh extends i { constructor(t, e, i) { super(t), this.feature = e, this.features = i } } class zh extends Zl { constructor(t) { super({ attributions: (t = t || {}).attributions, interpolate: !0, projection: void 0, state: "ready", wrapX: void 0 === t.wrapX || t.wrapX }), this.on, this.once, this.un, this.loader_ = p, this.format_ = t.format, this.overlaps_ = void 0 === t.overlaps || t.overlaps, this.url_ = t.url, void 0 !== t.loader ? this.loader_ = t.loader : void 0 !== this.url_ && (at(this.format_, 7), this.loader_ = yl(this.url_, this.format_)), this.strategy_ = void 0 !== t.strategy ? t.strategy : xl; const e = void 0 === t.useSpatialIndex || t.useSpatialIndex; let i, n; this.featuresRtree_ = e ? new Ah : null, this.loadedExtentsRtree_ = new Ah, this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null, Array.isArray(t.features) ? n = t.features : t.features && (i = t.features, n = i.getArray()), e || void 0 !== i || (i = new q(n)), void 0 !== n && this.addFeaturesInternal(n), void 0 !== i && this.bindFeaturesCollection_(i) } addFeature(t) { this.addFeatureInternal(t), this.changed() } addFeatureInternal(t) { const e = z(t); if (!this.addToIndex_(e, t)) return void (this.featuresCollection_ && this.featuresCollection_.remove(t)); this.setupChangeEvents_(e, t); const i = t.getGeometry(); if (i) { const e = i.getExtent(); this.featuresRtree_ && this.featuresRtree_.insert(e, t) } else this.nullGeometryFeatures_[e] = t; this.dispatchEvent(new Uh(Oh, t)) } setupChangeEvents_(t, e) { this.featureChangeKeys_[t] = [N(e, S, this.handleFeatureChange_, this), N(e, r, this.handleFeatureChange_, this)] } addToIndex_(t, e) { let i = !0; const n = e.getId(); return void 0 !== n && (n.toString() in this.idIndex_ ? i = !1 : this.idIndex_[n.toString()] = e), i && (at(!(t in this.uidIndex_), 30), this.uidIndex_[t] = e), i } addFeatures(t) { this.addFeaturesInternal(t), this.changed() } addFeaturesInternal(t) { const e = [], i = [], n = []; for (let e = 0, n = t.length; e < n; e++) { const n = t[e], r = z(n); this.addToIndex_(r, n) && i.push(n) } for (let t = 0, r = i.length; t < r; t++) { const r = i[t], s = z(r); this.setupChangeEvents_(s, r); const o = r.getGeometry(); if (o) { const t = o.getExtent(); e.push(t), n.push(r) } else this.nullGeometryFeatures_[s] = r } if (this.featuresRtree_ && this.featuresRtree_.load(e, n), this.hasListener(Oh)) for (let t = 0, e = i.length; t < e; t++)this.dispatchEvent(new Uh(Oh, i[t])) } bindFeaturesCollection_(t) { let e = !1; this.addEventListener(Oh, (function (i) { e || (e = !0, t.push(i.feature), e = !1) })), this.addEventListener(kh, (function (i) { e || (e = !0, t.remove(i.feature), e = !1) })), t.addEventListener(W, function (t) { e || (e = !0, this.addFeature(t.element), e = !1) }.bind(this)), t.addEventListener(Z, function (t) { e || (e = !0, this.removeFeature(t.element), e = !1) }.bind(this)), this.featuresCollection_ = t } clear(t) { if (t) { for (const t in this.featureChangeKeys_) { this.featureChangeKeys_[t].forEach(k) } this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}) } else if (this.featuresRtree_) { const t = function (t) { this.removeFeatureInternal(t) }.bind(this); this.featuresRtree_.forEach(t); for (const t in this.nullGeometryFeatures_) this.removeFeatureInternal(this.nullGeometryFeatures_[t]) } this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {}; const e = new Uh(Dh); this.dispatchEvent(e), this.changed() } forEachFeature(t) { if (this.featuresRtree_) return this.featuresRtree_.forEach(t); this.featuresCollection_ && this.featuresCollection_.forEach(t) } forEachFeatureAtCoordinateDirect(t, e) { const i = [t[0], t[1], t[0], t[1]]; return this.forEachFeatureInExtent(i, (function (i) { return i.getGeometry().intersectsCoordinate(t) ? e(i) : void 0 })) } forEachFeatureInExtent(t, e) { if (this.featuresRtree_) return this.featuresRtree_.forEachInExtent(t, e); this.featuresCollection_ && this.featuresCollection_.forEach(e) } forEachFeatureIntersectingExtent(t, e) { return this.forEachFeatureInExtent(t, (function (i) { if (i.getGeometry().intersectsExtent(t)) { const t = e(i); if (t) return t } })) } getFeaturesCollection() { return this.featuresCollection_ } getFeatures() { let t; return this.featuresCollection_ ? t = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (t = this.featuresRtree_.getAll(), x(this.nullGeometryFeatures_) || c(t, Object.values(this.nullGeometryFeatures_))), t } getFeaturesAtCoordinate(t) { const e = []; return this.forEachFeatureAtCoordinateDirect(t, (function (t) { e.push(t) })), e } getFeaturesInExtent(t, e) { if (this.featuresRtree_) { if (!(e && e.canWrapX() && this.getWrapX())) return this.featuresRtree_.getInExtent(t); const i = Ie(t, e); return [].concat(...i.map((t => this.featuresRtree_.getInExtent(t)))) } return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [] } getClosestFeatureToCoordinate(t, e) { const i = t[0], n = t[1]; let r = null; const s = [NaN, NaN]; let o = 1 / 0; const a = [-1 / 0, -1 / 0, 1 / 0, 1 / 0]; return e = e || g, this.featuresRtree_.forEachInExtent(a, (function (t) { if (e(t)) { const e = t.getGeometry(), l = o; if (o = e.closestPointXY(i, n, s, o), o < l) { r = t; const e = Math.sqrt(o); a[0] = i - e, a[1] = n - e, a[2] = i + e, a[3] = n + e } } })), r } getExtent(t) { return this.featuresRtree_.getExtent(t) } getFeatureById(t) { const e = this.idIndex_[t.toString()]; return void 0 !== e ? e : null } getFeatureByUid(t) { const e = this.uidIndex_[t]; return void 0 !== e ? e : null } getFormat() { return this.format_ } getOverlaps() { return this.overlaps_ } getUrl() { return this.url_ } handleFeatureChange_(t) { const e = t.target, i = z(e), n = e.getGeometry(); if (n) { const t = n.getExtent(); i in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[i], this.featuresRtree_ && this.featuresRtree_.insert(t, e)) : this.featuresRtree_ && this.featuresRtree_.update(t, e) } else i in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(e), this.nullGeometryFeatures_[i] = e); const r = e.getId(); if (void 0 !== r) { const t = r.toString(); this.idIndex_[t] !== e && (this.removeFromIdIndex_(e), this.idIndex_[t] = e) } else this.removeFromIdIndex_(e), this.uidIndex_[i] = e; this.changed(), this.dispatchEvent(new Uh(Nh, e)) } hasFeature(t) { const e = t.getId(); return void 0 !== e ? e in this.idIndex_ : z(t) in this.uidIndex_ } isEmpty() { return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && x(this.nullGeometryFeatures_) : !this.featuresCollection_ || 0 === this.featuresCollection_.getLength() } loadFeatures(t, e, i) { const n = this.loadedExtentsRtree_, r = this.strategy_(t, e, i); for (let t = 0, s = r.length; t < s; ++t) { const s = r[t]; n.forEachInExtent(s, (function (t) { return Yt(t.extent, s) })) || (++this.loadingExtentsCount_, this.dispatchEvent(new Uh(Gh)), this.loader_.call(this, s, e, i, function (t) { --this.loadingExtentsCount_, this.dispatchEvent(new Uh(jh, void 0, t)) }.bind(this), function () { --this.loadingExtentsCount_, this.dispatchEvent(new Uh(Bh)) }.bind(this)), n.insert(s, { extent: s.slice() })) } this.loading = !(this.loader_.length < 4) && this.loadingExtentsCount_ > 0 } refresh() { this.clear(!0), this.loadedExtentsRtree_.clear(), super.refresh() } removeLoadedExtent(t) { const e = this.loadedExtentsRtree_; let i; e.forEachInExtent(t, (function (e) { if (ee(e.extent, t)) return i = e, !0 })), i && e.remove(i) } removeFeature(t) { if (!t) return; const e = z(t); e in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[e] : this.featuresRtree_ && this.featuresRtree_.remove(t); this.removeFeatureInternal(t) && this.changed() } removeFeatureInternal(t) { const e = z(t), i = this.featureChangeKeys_[e]; if (!i) return; i.forEach(k), delete this.featureChangeKeys_[e]; const n = t.getId(); return void 0 !== n && delete this.idIndex_[n.toString()], delete this.uidIndex_[e], this.dispatchEvent(new Uh(kh, t)), t } removeFromIdIndex_(t) { let e = !1; for (const i in this.idIndex_) if (this.idIndex_[i] === t) { delete this.idIndex_[i], e = !0; break } return e } setLoader(t) { this.loader_ = t } setUrl(t) { at(this.format_, 7), this.url_ = t, this.setLoader(yl(t, this.format_)) } } class Xh extends nh { constructor(t) { const e = void 0 === t.projection ? "EPSG:3857" : t.projection; let i = t.tileGrid; void 0 === i && e && (i = Ql({ extent: ih(e), maxResolution: t.maxResolution, maxZoom: t.maxZoom, minZoom: t.minZoom, tileSize: t.tileSize })), super({ cacheSize: .1, attributions: t.attributions, attributionsCollapsible: t.attributionsCollapsible, projection: e, tileGrid: i, opaque: t.opaque, state: t.state, wrapX: t.wrapX, transition: t.transition, interpolate: t.interpolate }), this.gutter_ = void 0 !== t.gutter ? t.gutter : 0, this.tileSize_ = t.tileSize ? Va(t.tileSize) : null, this.tileSizes_ = null, this.tileLoadingKeys_ = {}, this.loader_ = t.loader, this.handleTileChange_ = this.handleTileChange_.bind(this), this.bandCount = void 0 === t.bandCount ? 4 : t.bandCount } setTileSizes(t) { this.tileSizes_ = t } getTileSize(t) { if (this.tileSizes_) return this.tileSizes_[t]; if (this.tileSize_) return this.tileSize_; const e = this.getTileGrid(); return e ? Va(e.getTileSize(t)) : [256, 256] } getGutterForProjection(t) { return this.gutter_ } setLoader(t) { this.loader_ = t } getTile(t, e, i, n, r) { const s = this.getTileSize(t), o = il(t, e, i); if (this.tileCache.containsKey(o)) return this.tileCache.get(o); const a = this.loader_; const l = Object.assign({ tileCoord: [t, e, i], loader: function () { return _((function () { return a(t, e, i) })) }, size: s }, this.tileOptions), h = new ot(l); return h.key = this.getKey(), h.addEventListener(S, this.handleTileChange_), this.tileCache.set(o, h), h } handleTileChange_(t) { const e = t.target, i = z(e), n = e.getState(); let r; n == $ ? (this.tileLoadingKeys_[i] = !0, r = Xl) : i in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[i], r = n == Q ? Wl : n == J ? Vl : void 0), r && this.dispatchEvent(new rh(r, e)) } } function Vh(t, e) { if (!t) return !1; if (!0 === t) return !0; if (3 !== e.getSamplesPerPixel()) return !1; const i = e.fileDirectory.PhotometricInterpretation, n = GeoTIFF.globals.photometricInterpretations; return i === n.CMYK || i === n.YCbCr || i === n.CIELab || i === n.ICCLab } const Wh = "STATISTICS_MAXIMUM", Zh = "STATISTICS_MINIMUM"; let Yh; function Kh(t) { try { return t.getBoundingBox() } catch (e) { const i = t.fileDirectory; return [0, 0, i.ImageWidth, i.ImageLength] } } function qh(t) { try { return t.getOrigin().slice(0, 2) } catch (e) { return [0, t.fileDirectory.ImageLength] } } function Hh(t, e) { try { return t.getResolution(e) } catch (i) { return [e.fileDirectory.ImageWidth / t.fileDirectory.ImageWidth, e.fileDirectory.ImageHeight / t.fileDirectory.ImageHeight] } } function $h(t) { const e = t.geoKeys; if (!e) return null; if (e.ProjectedCSTypeGeoKey) { const t = "EPSG:" + e.ProjectedCSTypeGeoKey; let i = Ui(t); if (!i) { const n = Me(e.ProjLinearUnitsGeoKey); n && (i = new Ae({ code: t, units: n })) } return i } if (e.GeographicTypeGeoKey) { const t = "EPSG:" + e.GeographicTypeGeoKey; let i = Ui(t); if (!i) { const n = Me(e.GeogAngularUnitsGeoKey); n && (i = new Ae({ code: t, units: n })) } return i } return null } function Jh(t) { return t.getImageCount().then((function (e) { const i = new Array(e); for (let n = 0; n < e; ++n)i[n] = t.getImage(n); return Promise.all(i) })) } function Qh(t, e) { let i; return i = t.blob ? GeoTIFF.fromBlob(t.blob) : t.overviews ? GeoTIFF.fromUrls(t.url, t.overviews, e) : GeoTIFF.fromUrl(t.url, e), i.then(Jh) } function tc(t, e, i, n, r) { if (Array.isArray(t)) { const s = t.length; if (!Array.isArray(e) || s != e.length) { const t = new Error(n); throw r(t), t } for (let o = 0; o < s; ++o)tc(t[o], e[o], i, n, r) } else if (Math.abs(t - e) > i * t) throw new Error(n) } function ec(t) { return t instanceof Int8Array ? 127 : t instanceof Uint8Array || t instanceof Uint8ClampedArray ? 255 : t instanceof Int16Array ? 32767 : t instanceof Uint16Array ? 65535 : t instanceof Int32Array ? 2147483647 : t instanceof Uint32Array ? 4294967295 : t instanceof Float32Array ? 34e37 : 255 } class ic extends Xh { constructor(t) { super({ state: "loading", tileGrid: null, projection: null, opaque: t.opaque, transition: t.transition, interpolate: !1 !== t.interpolate, wrapX: t.wrapX }), this.sourceInfo_ = t.sources; const e = this.sourceInfo_.length; this.sourceOptions_ = t.sourceOptions, this.sourceImagery_ = new Array(e), this.sourceMasks_ = new Array(e), this.resolutionFactors_ = new Array(e), this.samplesPerPixel_, this.nodataValues_, this.metadata_, this.normalize_ = !1 !== t.normalize, this.addAlpha_ = !1, this.error_ = null, this.convertToRGB_ = t.convertToRGB || !1, this.setKey(this.sourceInfo_.map((t => t.url)).join(",")); const i = this, n = new Array(e); for (let t = 0; t < e; ++t)n[t] = Qh(this.sourceInfo_[t], this.sourceOptions_); Promise.all(n).then((function (t) { i.configure_(t) })).catch((function (t) { console.error(t), i.error_ = t, i.setState("error") })) } getError() { return this.error_ } configure_(t) { let e, i, n, r, s; const o = new Array(t.length), a = new Array(t.length), l = new Array(t.length); let h = 0; const c = t.length; for (let u = 0; u < c; ++u) { const c = [], d = []; t[u].forEach((t => { 4 == (4 & (t.fileDirectory.NewSubfileType || 0)) ? d.push(t) : c.push(t) })); const g = c.length; if (d.length > 0 && d.length !== g) throw new Error(`Expected one mask per image found ${d.length} masks and ${g} images`); let f, p; const m = new Array(g), _ = new Array(g), y = new Array(g); a[u] = new Array(g), l[u] = new Array(g); for (let t = 0; t < g; ++t) { const e = c[t], i = e.getGDALNoData(); l[u][t] = e.getGDALMetadata(0), a[u][t] = i; const n = this.sourceInfo_[u].bands; o[u] = n ? n.length : e.getSamplesPerPixel(); const r = g - (t + 1); f || (f = Kh(e)), p || (p = qh(e)); const s = Hh(e, c[0]); y[r] = s[0]; const h = [e.getTileWidth(), e.getTileHeight()]; m[r] = h; const d = s[0] / Math.abs(s[1]); _[r] = [h[0], h[1] / d] } if (e ? ye(e, f, e) : e = f, i) { tc(i, p, 0, `Origin mismatch for source ${u}, got [${p}] but expected [${i}]`, this.viewRejector) } else i = p; if (s) { s.length - h > y.length && (h = s.length - y.length); const t = s[s.length - 1] / y[y.length - 1]; this.resolutionFactors_[u] = t; const e = y.map((e => e * t)), i = `Resolution mismatch for source ${u}, got [${e}] but expected [${s}]`; tc(s.slice(h, s.length), e, .02, i, this.viewRejector) } else s = y, this.resolutionFactors_[u] = 1; n ? tc(n.slice(h, n.length), _, .01, `Tile size mismatch for source ${u}`, this.viewRejector) : n = _, r ? tc(r.slice(h, r.length), m, 0, `Tile size mismatch for source ${u}`, this.viewRejector) : r = m, this.sourceImagery_[u] = c.reverse(), this.sourceMasks_[u] = d.reverse() } for (let t = 0, e = this.sourceImagery_.length; t < e; ++t) { const e = this.sourceImagery_[t]; for (; e.length < s.length;)e.unshift(void 0) } if (!this.getProjection()) { const e = t[0]; for (let t = e.length - 1; t >= 0; --t) { const i = $h(e[t]); if (i) { this.projection = i; break } } } this.samplesPerPixel_ = o, this.nodataValues_ = a, this.metadata_ = l; t: for (let t = 0; t < c; ++t) { if (void 0 !== this.sourceInfo_[t].nodata) { this.addAlpha_ = !0; break } if (this.sourceMasks_[t].length) { this.addAlpha_ = !0; break } const e = a[t], i = this.sourceInfo_[t].bands; if (i) { for (let t = 0; t < i.length; ++t)if (null !== e[i[t] - 1]) { this.addAlpha_ = !0; break t } } else for (let t = 0; t < e.length; ++t)if (null !== e[t]) { this.addAlpha_ = !0; break t } } let u = this.addAlpha_ ? 1 : 0; for (let t = 0; t < c; ++t)u += o[t]; this.bandCount = u; const d = new ql({ extent: e, minZoom: h, origin: i, resolutions: s, tileSizes: n }); this.tileGrid = d, this.setTileSizes(r), this.setLoader(this.loadTile_.bind(this)), this.setState("ready"); let g = 0; 1 === s.length && (s = [2 * s[0], s[0]], g = 1), this.viewResolver({ showFullExtent: !0, projection: this.projection, resolutions: s, center: nn(ge(e), this.projection), extent: sn(e, this.projection), zoom: g }) } loadTile_(t, e, i) { const n = this.getTileSize(t), r = this.sourceImagery_.length, s = new Array(2 * r), o = this.nodataValues_, a = this.sourceInfo_, l = (Yh || (Yh = new GeoTIFF.Pool), Yh); for (let h = 0; h < r; ++h) { const c = a[h], u = this.resolutionFactors_[h], d = [Math.round(e * (n[0] * u)), Math.round(i * (n[1] * u)), Math.round((e + 1) * (n[0] * u)), Math.round((i + 1) * (n[1] * u))], g = this.sourceImagery_[h][t]; let f, p; c.bands && (f = c.bands.map((function (t) { return t - 1 }))), p = "nodata" in c && null !== c.nodata ? c.nodata : f ? f.map((function (t) { return o[h][t] })) : o[h]; const m = { window: d, width: n[0], height: n[1], samples: f, fillValue: p, pool: l, interleave: !1 }; Vh(this.convertToRGB_, g) ? s[h] = g.readRGB(m) : s[h] = g.readRasters(m); const _ = r + h, y = this.sourceMasks_[h][t]; y ? s[_] = y.readRasters({ window: d, width: n[0], height: n[1], samples: [0], pool: l, interleave: !1 }) : s[_] = Promise.resolve(null) } return Promise.all(s).then(this.composeTile_.bind(this, n)).catch((function (t) { throw console.error(t), t })) } composeTile_(t, e) { const i = this.metadata_, n = this.sourceInfo_, r = this.sourceImagery_.length, s = this.bandCount, o = this.samplesPerPixel_, a = this.nodataValues_, l = this.normalize_, h = this.addAlpha_, c = t[0] * t[1], u = c * s; let d; d = l ? new Uint8Array(u) : new Float32Array(u); let g = 0; for (let t = 0; t < c; ++t) { let s = h; for (let c = 0; c < r; ++c) { const u = n[c]; let p, m, _ = u.min, y = u.max; if (l) { const t = i[c][0]; void 0 === _ && (_ = t && Zh in t ? parseFloat(t.STATISTICS_MINIMUM) : (f = e[c][0]) instanceof Int8Array ? -128 : f instanceof Int16Array ? -32768 : f instanceof Int32Array ? -2147483648 : f instanceof Float32Array ? 12e-39 : 0), void 0 === y && (y = t && Wh in t ? parseFloat(t.STATISTICS_MAXIMUM) : ec(e[c][0])), p = 255 / (y - _), m = -_ * p } for (let i = 0; i < o[c]; ++i) { const n = e[c][i][t]; let r; if (r = l ? ii(p * n + m, 0, 255) : n, h) { let t = u.nodata; if (void 0 === t) { let e; e = u.bands ? u.bands[i] - 1 : i, t = a[c][e] } const e = isNaN(t); (!e && n !== t || e && !isNaN(n)) && (s = !1, d[g] = r) } else d[g] = r; g++ } if (!s) { const i = e[r + c]; i && !i[0][t] && (s = !0) } } h && (s || (d[g] = 255), g++) } var f; return d } } ic.prototype.getView; class nc extends Vr { constructor(t, e, i, n, r, s, o) { super(e, i, n, r, s, o), this.zoomifyImage_ = null, this.tileSize_ = t } getImage() { if (this.zoomifyImage_) return this.zoomifyImage_; const t = super.getImage(); if (this.state == J) { const e = this.tileSize_; if (t.width == e[0] && t.height == e[1]) return this.zoomifyImage_ = t, t; { const i = Dr(e[0], e[1]); return i.drawImage(t, 0, 0), this.zoomifyImage_ = i.canvas, i.canvas } } return t } } const rc = "version1", sc = "version2", oc = "version3", ac = {}; ac[rc] = { level0: { supports: [], formats: [], qualities: ["native"] }, level1: { supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"], formats: ["jpg"], qualities: ["native"] }, level2: { supports: ["regionByPx", "regionByPct", "sizeByW", "sizeByH", "sizeByPct", "sizeByConfinedWh", "sizeByWh"], formats: ["jpg", "png"], qualities: ["native", "color", "grey", "bitonal"] } }, ac[sc] = { level0: { supports: [], formats: ["jpg"], qualities: ["default"] }, level1: { supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"], formats: ["jpg"], qualities: ["default"] }, level2: { supports: ["regionByPx", "regionByPct", "sizeByW", "sizeByH", "sizeByPct", "sizeByConfinedWh", "sizeByDistortedWh", "sizeByWh"], formats: ["jpg", "png"], qualities: ["default", "bitonal"] } }, ac[oc] = { level0: { supports: [], formats: ["jpg"], qualities: ["default"] }, level1: { supports: ["regionByPx", "regionSquare", "sizeByW", "sizeByH", "sizeByWh"], formats: ["jpg"], qualities: ["default"] }, level2: { supports: ["regionByPx", "regionSquare", "regionByPct", "sizeByW", "sizeByH", "sizeByPct", "sizeByConfinedWh", "sizeByWh"], formats: ["jpg", "png"], qualities: ["default"] } }, ac.none = { none: { supports: [], formats: [], qualities: [] } }; const lc = /^https?:\/\/library\.stanford\.edu\/iiif\/image-api\/(?:1\.1\/)?compliance\.html#level[0-2]$/, hc = /^https?:\/\/iiif\.io\/api\/image\/2\/level[0-2](?:\.json)?$/, cc = /(^https?:\/\/iiif\.io\/api\/image\/3\/level[0-2](?:\.json)?$)|(^level[0-2]$)/; const uc = {}; uc[rc] = function (t) { let e = t.getComplianceLevelSupportedFeatures(); return void 0 === e && (e = ac[rc].level0), { url: void 0 === t.imageInfo["@id"] ? void 0 : t.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""), supports: e.supports, formats: [...e.formats, void 0 === t.imageInfo.formats ? [] : t.imageInfo.formats], qualities: [...e.qualities, void 0 === t.imageInfo.qualities ? [] : t.imageInfo.qualities], resolutions: t.imageInfo.scale_factors, tileSize: void 0 !== t.imageInfo.tile_width ? void 0 !== t.imageInfo.tile_height ? [t.imageInfo.tile_width, t.imageInfo.tile_height] : [t.imageInfo.tile_width, t.imageInfo.tile_width] : null != t.imageInfo.tile_height ? [t.imageInfo.tile_height, t.imageInfo.tile_height] : void 0 } }, uc[sc] = function (t) { const e = t.getComplianceLevelSupportedFeatures(), i = Array.isArray(t.imageInfo.profile) && t.imageInfo.profile.length > 1, n = i && t.imageInfo.profile[1].supports ? t.imageInfo.profile[1].supports : [], r = i && t.imageInfo.profile[1].formats ? t.imageInfo.profile[1].formats : [], s = i && t.imageInfo.profile[1].qualities ? t.imageInfo.profile[1].qualities : []; return { url: t.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""), sizes: void 0 === t.imageInfo.sizes ? void 0 : t.imageInfo.sizes.map((function (t) { return [t.width, t.height] })), tileSize: void 0 === t.imageInfo.tiles ? void 0 : [t.imageInfo.tiles.map((function (t) { return t.width }))[0], t.imageInfo.tiles.map((function (t) { return void 0 === t.height ? t.width : t.height }))[0]], resolutions: void 0 === t.imageInfo.tiles ? void 0 : t.imageInfo.tiles.map((function (t) { return t.scaleFactors }))[0], supports: [...e.supports, ...n], formats: [...e.formats, ...r], qualities: [...e.qualities, ...s] } }, uc[oc] = function (t) { const e = t.getComplianceLevelSupportedFeatures(), i = void 0 === t.imageInfo.extraFormats ? e.formats : [...e.formats, ...t.imageInfo.extraFormats], n = void 0 !== t.imageInfo.preferredFormats && Array.isArray(t.imageInfo.preferredFormats) && t.imageInfo.preferredFormats.length > 0 ? t.imageInfo.preferredFormats.filter((function (t) { return ["jpg", "png", "gif"].includes(t) })).reduce((function (t, e) { return void 0 === t && i.includes(e) ? e : t }), void 0) : void 0; return { url: t.imageInfo.id, sizes: void 0 === t.imageInfo.sizes ? void 0 : t.imageInfo.sizes.map((function (t) { return [t.width, t.height] })), tileSize: void 0 === t.imageInfo.tiles ? void 0 : [t.imageInfo.tiles.map((function (t) { return t.width }))[0], t.imageInfo.tiles.map((function (t) { return t.height }))[0]], resolutions: void 0 === t.imageInfo.tiles ? void 0 : t.imageInfo.tiles.map((function (t) { return t.scaleFactors }))[0], supports: void 0 === t.imageInfo.extraFeatures ? e.supports : [...e.supports, ...t.imageInfo.extraFeatures], formats: i, qualities: void 0 === t.imageInfo.extraQualities ? e.qualities : [...e.qualities, ...t.imageInfo.extraQualities], preferredFormat: n } }; function dc(t) { return t.toLocaleString("en", { maximumFractionDigits: 10 }) } class gc extends Rr { constructor(t, e, i, n, r, s, o) { const a = t.getExtent(), l = e.getExtent(), h = l ? ye(i, l) : i, c = Gl(t, e, ge(h), n), u = new Ul(t, e, h, a, .5 * c, n), d = s(u.calculateSourceExtent(), c, r), g = d ? Pr : Fr, f = d ? d.getPixelRatio() : 1; super(i, n, f, g), this.targetProj_ = e, this.maxSourceExtent_ = a, this.triangulation_ = u, this.targetResolution_ = n, this.targetExtent_ = i, this.sourceImage_ = d, this.sourcePixelRatio_ = f, this.interpolate_ = o, this.canvas_ = null, this.sourceListenerKey_ = null } disposeInternal() { this.state == Ir && this.unlistenSource_(), super.disposeInternal() } getImage() { return this.canvas_ } getProjection() { return this.targetProj_ } reproject_() { const t = this.sourceImage_.getState(); if (t == Lr) { const t = Se(this.targetExtent_) / this.targetResolution_, e = _e(this.targetExtent_) / this.targetResolution_; this.canvas_ = Bl(t, e, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [{ extent: this.sourceImage_.getExtent(), image: this.sourceImage_.getImage() }], 0, void 0, this.interpolate_) } this.state = t, this.changed() } load() { if (this.state == Pr) { this.state = Ir, this.changed(); const t = this.sourceImage_.getState(); t == Lr || t == Mr ? this.reproject_() : (this.sourceListenerKey_ = N(this.sourceImage_, S, (function (t) { const e = this.sourceImage_.getState(); e != Lr && e != Mr || (this.unlistenSource_(), this.reproject_()) }), this), this.sourceImage_.load()) } } unlistenSource_() { k(this.sourceListenerKey_), this.sourceListenerKey_ = null } } const fc = "imageloadstart", pc = "imageloadend", mc = "imageloaderror"; class _c extends i { constructor(t, e) { super(t), this.image = e } } class yc extends Zl { constructor(t) { super({ attributions: t.attributions, projection: t.projection, state: t.state, interpolate: void 0 === t.interpolate || t.interpolate }), this.on, this.once, this.un, this.resolutions_ = void 0 !== t.resolutions ? t.resolutions : null, this.reprojectedImage_ = null, this.reprojectedRevision_ = 0 } getResolutions() { return this.resolutions_ } findNearestResolution(t) { if (this.resolutions_) { const e = l(this.resolutions_, t, 0); t = this.resolutions_[e] } return t } getImage(t, e, i, n) { const r = this.getProjection(); if (r && n && !Ki(r, n)) { if (this.reprojectedImage_) { if (this.reprojectedRevision_ == this.getRevision() && Ki(this.reprojectedImage_.getProjection(), n) && this.reprojectedImage_.getResolution() == e && ee(this.reprojectedImage_.getExtent(), t)) return this.reprojectedImage_; this.reprojectedImage_.dispose(), this.reprojectedImage_ = null } return this.reprojectedImage_ = new gc(r, n, t, e, i, function (t, e, i) { return this.getImageInternal(t, e, i, r) }.bind(this), this.getInterpolate()), this.reprojectedRevision_ = this.getRevision(), this.reprojectedImage_ } return r && (n = r), this.getImageInternal(t, e, i, n) } getImageInternal(t, e, i, n) { return B() } handleImageChange(t) { const e = t.target; let i; switch (e.getState()) { case Ir: this.loading = !0, i = fc; break; case Lr: this.loading = !1, i = pc; break; case Mr: this.loading = !1, i = mc; break; default: return }this.hasListener(i) && this.dispatchEvent(new _c(i, e)) } } function xc(t, e) { t.getImage().src = e } function vc(t, e) { const i = []; Object.keys(e).forEach((function (t) { null !== e[t] && void 0 !== e[t] && i.push(t + "=" + encodeURIComponent(e[t])) })); const n = i.join("&"); return t = t.replace(/[?&]$/, ""), (t += t.includes("?") ? "&" : "?") + n } const Sc = "1.3.0", wc = [101, 101]; const Ec = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.'; class Tc extends vs { constructor(t) { super(t = t || {}) } } class Cc extends G { constructor(t) { super(), this.ready = !0, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = t, this.declutterExecutorGroup = null } getFeatures(t) { return B() } getData(t) { return null } prepareFrame(t) { return B() } renderFrame(t, e) { return B() } loadedTileCallback(t, e, i) { t[e] || (t[e] = {}), t[e][i.tileCoord.toString()] = i } createLoadedTileFinder(t, e, i) { return function (n, r) { const s = this.loadedTileCallback.bind(this, i, n); return t.forEachLoadedTile(e, n, r, s) }.bind(this) } forEachFeatureAtCoordinate(t, e, i, n, r) { } getLayer() { return this.layer_ } handleFontsChanged() { } handleImageChange_(t) { t.target.getState() === Lr && this.renderIfReadyAndVisible() } loadImage(t) { let e = t.getState(); return e != Lr && e != Mr && t.addEventListener(S, this.boundHandleImageChange_), e == Pr && (t.load(), e = t.getState()), e == Lr } renderIfReadyAndVisible() { const t = this.getLayer(); t && t.getVisible() && "ready" === t.getSourceState() && t.changed() } disposeInternal() { delete this.layer_, super.disposeInternal() } } const bc = []; let Rc = null; class Pc extends Cc { constructor(t) { super(t), this.container = null, this.renderedResolution, this.tempTransform = [1, 0, 0, 1, 0, 0], this.pixelTransform = [1, 0, 0, 1, 0, 0], this.inversePixelTransform = [1, 0, 0, 1, 0, 0], this.context = null, this.containerReused = !1, this.pixelContext_ = null, this.frameState = null } getImageData(t, e, i) { let n; Rc || function () { const t = document.createElement("canvas"); t.width = 1, t.height = 1, Rc = t.getContext("2d") }(), Rc.clearRect(0, 0, 1, 1); try { Rc.drawImage(t, e, i, 1, 1, 0, 0, 1, 1), n = Rc.getImageData(0, 0, 1, 1).data } catch (t) { return Rc = null, null } return n } getBackground(t) { let e = this.getLayer().getBackground(); return "function" == typeof e && (e = e(t.viewState.resolution)), e || void 0 } useContainer(t, e, i) { const n = this.getLayer().getClassName(); let r, s; if (t && t.className === n && (!i || t && t.style.backgroundColor && u($r(t.style.backgroundColor), $r(i)))) { const e = t.firstElementChild; e instanceof HTMLCanvasElement && (s = e.getContext("2d")) } if (s && s.canvas.style.transform === e ? (this.container = t, this.context = s, this.containerReused = !0) : this.containerReused && (this.container = null, this.context = null, this.containerReused = !1), !this.container) { r = document.createElement("div"), r.className = n; let t = r.style; t.position = "absolute", t.width = "100%", t.height = "100%", s = Dr(); const e = s.canvas; r.appendChild(e), t = e.style, t.position = "absolute", t.left = "0", t.transformOrigin = "top left", this.container = r, this.context = s } this.containerReused || !i || this.container.style.backgroundColor || (this.container.style.backgroundColor = i) } clipUnrotated(t, e, i) { const n = xe(i), r = ve(i), s = de(i), o = ue(i); bt(e.coordinateToPixelTransform, n), bt(e.coordinateToPixelTransform, r), bt(e.coordinateToPixelTransform, s), bt(e.coordinateToPixelTransform, o); const a = this.inversePixelTransform; bt(a, n), bt(a, r), bt(a, s), bt(a, o), t.save(), t.beginPath(), t.moveTo(Math.round(n[0]), Math.round(n[1])), t.lineTo(Math.round(r[0]), Math.round(r[1])), t.lineTo(Math.round(s[0]), Math.round(s[1])), t.lineTo(Math.round(o[0]), Math.round(o[1])), t.clip() } dispatchRenderEvent_(t, e, i) { const n = this.getLayer(); if (n.hasListener(t)) { const r = new Ts(t, this.inversePixelTransform, i, e); n.dispatchEvent(r) } } preRender(t, e) { this.frameState = e, this.dispatchRenderEvent_(ps, t, e) } postRender(t, e) { this.dispatchRenderEvent_(ms, t, e) } getRenderTransform(t, e, i, n, r, s, o) { const a = r / 2, l = s / 2, h = n / e, c = -h, u = -t[0] + o, d = -t[1]; return Mt(this.tempTransform, a, l, h, c, -i, u, d) } disposeInternal() { delete this.frameState, super.disposeInternal() } } class Ic extends Pc { constructor(t) { super(t), this.image_ = null } getImage() { return this.image_ ? this.image_.getImage() : null } prepareFrame(t) { const e = t.layerStatesArray[t.layerIndex], i = t.pixelRatio, n = t.viewState, r = n.resolution, s = this.getLayer().getSource(), o = t.viewHints; let a = t.extent; if (void 0 !== e.extent && (a = ye(a, on(e.extent, n.projection))), !o[Ro] && !o[Po] && !Ee(a)) if (s) { const t = n.projection, e = s.getImage(a, r, i, t); e && (this.loadImage(e) ? this.image_ = e : e.getState() === Fr && (this.image_ = null)) } else this.image_ = null; return !!this.image_ } getData(t) { const e = this.frameState; if (!e) return null; const i = this.getLayer(), n = bt(e.pixelToCoordinateTransform, t.slice()), r = i.getExtent(); if (r && !Zt(r, n)) return null; const s = this.image_.getExtent(), o = this.image_.getImage(), a = Se(s), l = Math.floor(o.width * ((n[0] - s[0]) / a)); if (l < 0 || l >= o.width) return null; const h = _e(s), c = Math.floor(o.height * ((s[3] - n[1]) / h)); return c < 0 || c >= o.height ? null : this.getImageData(o, l, c) } renderFrame(t, e) { const i = this.image_, n = i.getExtent(), r = i.getResolution(), s = i.getPixelRatio(), o = t.layerStatesArray[t.layerIndex], a = t.pixelRatio, l = t.viewState, h = l.center, c = a * r / (l.resolution * s), u = t.extent, d = l.resolution, g = l.rotation, f = Math.round(Se(u) / d * a), p = Math.round(_e(u) / d * a); Mt(this.pixelTransform, t.size[0] / 2, t.size[1] / 2, 1 / a, 1 / a, g, -f / 2, -p / 2), Ft(this.inversePixelTransform, this.pixelTransform); const m = Nt(this.pixelTransform); this.useContainer(e, m, this.getBackground(t)); const _ = this.context, y = _.canvas; y.width != f || y.height != p ? (y.width = f, y.height = p) : this.containerReused || _.clearRect(0, 0, f, p); let x = !1, v = !0; if (o.extent) { const e = on(o.extent, l.projection); v = we(e, t.extent), x = v && !Yt(e, t.extent), x && this.clipUnrotated(_, t, e) } const S = i.getImage(), w = Mt(this.tempTransform, f / 2, p / 2, c, c, 0, s * (n[0] - h[0]) / r, s * (h[1] - n[3]) / r); this.renderedResolution = r * a / s; const E = S.width * w[0], T = S.height * w[3]; if (this.getLayer().getSource().getInterpolate() || (_.imageSmoothingEnabled = !1), this.preRender(_, t), v && E >= .5 && T >= .5) { const t = w[4], e = w[5], i = o.opacity; let n; 1 !== i && (n = _.globalAlpha, _.globalAlpha = i), _.drawImage(S, 0, 0, +S.width, +S.height, t, e, E, T), 1 !== i && (_.globalAlpha = n) } return this.postRender(_, t), x && _.restore(), _.imageSmoothingEnabled = !0, m !== y.style.transform && (y.style.transform = m), this.container } } class Lc extends Tc { constructor(t) { super(t) } createRenderer() { return new Ic(this) } getData(t) { return super.getData(t) } } var Mc = "preload", Fc = "useInterimTilesOnError"; class Ac extends vs { constructor(t) { t = t || {}; const e = Object.assign({}, t); delete e.preload, delete e.useInterimTilesOnError, super(e), this.on, this.once, this.un, this.setPreload(void 0 !== t.preload ? t.preload : 0), this.setUseInterimTilesOnError(void 0 === t.useInterimTilesOnError || t.useInterimTilesOnError) } getPreload() { return this.get(Mc) } setPreload(t) { this.set(Mc, t) } getUseInterimTilesOnError() { return this.get(Fc) } setUseInterimTilesOnError(t) { this.set(Fc, t) } getData(t) { return super.getData(t) } } class Oc extends Pc { constructor(t) { super(t), this.extentChanged = !0, this.renderedExtent_ = null, this.renderedPixelRatio, this.renderedProjection = null, this.renderedRevision, this.renderedTiles = [], this.newTiles_ = !1, this.tmpExtent = [1 / 0, 1 / 0, -1 / 0, -1 / 0], this.tmpTileRange_ = new hl(0, 0, 0, 0) } isDrawableTile(t) { const e = this.getLayer(), i = t.getState(), n = e.getUseInterimTilesOnError(); return i == J || i == tt || i == Q && !n } getTile(t, e, i, n) { const r = n.pixelRatio, s = n.viewState.projection, o = this.getLayer(); let a = o.getSource().getTile(t, e, i, r, s); return a.getState() == Q && o.getUseInterimTilesOnError() && o.getPreload() > 0 && (this.newTiles_ = !0), this.isDrawableTile(a) || (a = a.getInterimTile()), a } getData(t) { const e = this.frameState; if (!e) return null; const i = this.getLayer(), n = bt(e.pixelToCoordinateTransform, t.slice()), r = i.getExtent(); if (r && !Zt(r, n)) return null; const s = e.pixelRatio, o = e.viewState.projection, a = e.viewState, l = i.getRenderSource(), h = l.getTileGridForProjection(a.projection), c = l.getTilePixelRatio(e.pixelRatio); for (let t = h.getZForResolution(a.resolution); t >= h.getMinZoom(); --t) { const e = h.getTileCoordForCoordAndZ(n, t), i = l.getTile(t, e[1], e[2], s, o); if (!(i instanceof Vr || i instanceof zl) || i instanceof zl && i.getState() === tt) return null; if (i.getState() !== J) continue; const r = h.getOrigin(t), u = Va(h.getTileSize(t)), d = h.getResolution(t), g = Math.floor(c * ((n[0] - r[0]) / d - e[1] * u[0])), f = Math.floor(c * ((r[1] - n[1]) / d - e[2] * u[1])), p = Math.round(c * l.getGutterForProjection(a.projection)); return this.getImageData(i.getImage(), g + p, f + p) } return null } loadedTileCallback(t, e, i) { return !!this.isDrawableTile(i) && super.loadedTileCallback(t, e, i) } prepareFrame(t) { return !!this.getLayer().getSource() } renderFrame(t, e) { const i = t.layerStatesArray[t.layerIndex], n = t.viewState, r = n.projection, s = n.resolution, o = n.center, l = n.rotation, h = t.pixelRatio, c = this.getLayer(), u = c.getSource(), d = u.getRevision(), g = u.getTileGridForProjection(r), f = g.getZForResolution(s, u.zDirection), p = g.getResolution(f); let m = t.extent; const _ = t.viewState.resolution, y = u.getTilePixelRatio(h), x = Math.round(Se(m) / _ * h), v = Math.round(_e(m) / _ * h), S = i.extent && on(i.extent, r); S && (m = ye(m, on(i.extent, r))); const w = p * x / 2 / y, E = p * v / 2 / y, T = [o[0] - w, o[1] - E, o[0] + w, o[1] + E], C = g.getTileRangeForExtentAndZ(m, f), b = {}; b[f] = {}; const R = this.createLoadedTileFinder(u, r, b), P = this.tmpExtent, I = this.tmpTileRange_; this.newTiles_ = !1; const L = l ? me(n.center, _, l, t.size) : void 0; for (let e = C.minX; e <= C.maxX; ++e)for (let n = C.minY; n <= C.maxY; ++n) { if (l && !g.tileCoordIntersectsViewport([f, e, n], L)) continue; const r = this.getTile(f, e, n, t); if (this.isDrawableTile(r)) { const e = z(this); if (r.getState() == J) { b[f][r.tileCoord.toString()] = r; let t = r.inTransition(e); t && 1 !== i.opacity && (r.endTransition(e), t = !1), this.newTiles_ || !t && this.renderedTiles.includes(r) || (this.newTiles_ = !0) } if (1 === r.getAlpha(e, t.time)) continue } const s = g.getTileCoordChildTileRange(r.tileCoord, I, P); let o = !1; s && (o = R(f + 1, s)), o || g.forEachTileCoordParentTileRange(r.tileCoord, R, I, P) } const M = p / s * h / y; Mt(this.pixelTransform, t.size[0] / 2, t.size[1] / 2, 1 / h, 1 / h, l, -x / 2, -v / 2); const F = Nt(this.pixelTransform); this.useContainer(e, F, this.getBackground(t)); const A = this.context, O = A.canvas; Ft(this.inversePixelTransform, this.pixelTransform), Mt(this.tempTransform, x / 2, v / 2, M, M, 0, -x / 2, -v / 2), O.width != x || O.height != v ? (O.width = x, O.height = v) : this.containerReused || A.clearRect(0, 0, x, v), S && this.clipUnrotated(A, t, S), u.getInterpolate() || (A.imageSmoothingEnabled = !1), this.preRender(A, t), this.renderedTiles.length = 0; let N, D, k, G = Object.keys(b).map(Number); G.sort(a), 1 !== i.opacity || this.containerReused && !u.getOpaque(t.viewState.projection) ? (N = [], D = []) : G = G.reverse(); for (let e = G.length - 1; e >= 0; --e) { const i = G[e], n = u.getTilePixelSize(i, h, r), s = g.getResolution(i) / p, o = n[0] * s * M, a = n[1] * s * M, l = g.getTileCoordForCoordAndZ(xe(T), i), c = g.getTileCoordExtent(l), d = bt(this.tempTransform, [y * (c[0] - T[0]) / p, y * (T[3] - c[3]) / p]), m = y * u.getGutterForProjection(r), _ = b[i]; for (const e in _) { const n = _[e], r = n.tileCoord, s = l[1] - r[1], h = Math.round(d[0] - (s - 1) * o), c = l[2] - r[2], g = Math.round(d[1] - (c - 1) * a), p = Math.round(d[0] - s * o), y = Math.round(d[1] - c * a), x = h - p, v = g - y, S = f === i, w = S && 1 !== n.getAlpha(z(this), t.time); let E = !1; if (!w) if (N) { k = [p, y, p + x, y, p + x, y + v, p, y + v]; for (let t = 0, e = N.length; t < e; ++t)if (f !== i && i < D[t]) { const e = N[t]; we([p, y, p + x, y + v], [e[0], e[3], e[4], e[7]]) && (E || (A.save(), E = !0), A.beginPath(), A.moveTo(k[0], k[1]), A.lineTo(k[2], k[3]), A.lineTo(k[4], k[5]), A.lineTo(k[6], k[7]), A.moveTo(e[6], e[7]), A.lineTo(e[4], e[5]), A.lineTo(e[2], e[3]), A.lineTo(e[0], e[1]), A.clip()) } N.push(k), D.push(i) } else A.clearRect(p, y, x, v); this.drawTileImage(n, t, p, y, x, v, m, S), N && !w ? (E && A.restore(), this.renderedTiles.unshift(n)) : this.renderedTiles.push(n), this.updateUsedTiles(t.usedTiles, u, n) } } return this.renderedRevision = d, this.renderedResolution = p, this.extentChanged = !this.renderedExtent_ || !ee(this.renderedExtent_, T), this.renderedExtent_ = T, this.renderedPixelRatio = h, this.renderedProjection = r, this.manageTilePyramid(t, u, g, h, r, m, f, c.getPreload()), this.scheduleExpireCache(t, u), this.postRender(A, t), i.extent && A.restore(), A.imageSmoothingEnabled = !0, F !== O.style.transform && (O.style.transform = F), this.container } drawTileImage(t, e, i, n, r, s, o, a) { const l = this.getTileImage(t); if (!l) return; const h = z(this), c = e.layerStatesArray[e.layerIndex], u = c.opacity * (a ? t.getAlpha(h, e.time) : 1), d = u !== this.context.globalAlpha; d && (this.context.save(), this.context.globalAlpha = u), this.context.drawImage(l, o, o, l.width - 2 * o, l.height - 2 * o, i, n, r, s), d && this.context.restore(), u !== c.opacity ? e.animate = !0 : a && t.endTransition(h) } getImage() { const t = this.context; return t ? t.canvas : null } getTileImage(t) { return t.getImage() } scheduleExpireCache(t, e) { if (e.canExpireCache()) { const i = function (t, e, i) { const n = z(t); n in i.usedTiles && t.expireCache(i.viewState.projection, i.usedTiles[n]) }.bind(null, e); t.postRenderFunctions.push(i) } } updateUsedTiles(t, e, i) { const n = z(e); n in t || (t[n] = {}), t[n][i.getKey()] = !0 } manageTilePyramid(t, e, i, n, r, s, o, a, l) { const h = z(e); h in t.wantedTiles || (t.wantedTiles[h] = {}); const c = t.wantedTiles[h], u = t.tileQueue, d = i.getMinZoom(), g = t.viewState.rotation, f = g ? me(t.viewState.center, t.viewState.resolution, g, t.size) : void 0; let p, m, _, y, x, v, S = 0; for (v = d; v <= o; ++v)for (m = i.getTileRangeForExtentAndZ(s, v, m), _ = i.getResolution(v), y = m.minX; y <= m.maxX; ++y)for (x = m.minY; x <= m.maxY; ++x)g && !i.tileCoordIntersectsViewport([v, y, x], f) || (o - v <= a ? (++S, p = e.getTile(v, y, x, n, r), p.getState() == H && (c[p.getKey()] = !0, u.isKeyQueued(p.getKey()) || u.enqueue([p, h, i.getTileCoordCenter(p.tileCoord), _])), void 0 !== l && l(p)) : e.useTile(v, y, x, r)); e.updateCacheSize(S, r) } } class Nc extends Ac { constructor(t) { super(t) } createRenderer() { return new Oc(this) } } let Dc, kc = !0; try { new ImageData(10, 10) } catch (t) { kc = !1 } function Gc(t, e, i) { if (kc) return new ImageData(t, e, i); Dc || (Dc = document.createElement("canvas").getContext("2d")); const n = Dc.createImageData(e, i); return n.data.set(t), n } function jc(t) { let e = !0; try { new ImageData(10, 10) } catch (t) { e = !1 } function i(t, i, n) { return e ? new ImageData(t, i, n) : { data: t, width: i, height: n } } return function (e) { const n = e.buffers, r = e.meta, s = e.imageOps, o = e.width, a = e.height, l = n.length, h = n[0].byteLength; if (s) { const e = new Array(l); for (let t = 0; t < l; ++t)e[t] = i(new Uint8ClampedArray(n[t]), o, a); return t(e, r).data.buffer } const c = new Uint8ClampedArray(h), u = new Array(l), d = new Array(l); for (let t = 0; t < l; ++t)u[t] = new Uint8ClampedArray(n[t]), d[t] = [0, 0, 0, 0]; for (let e = 0; e < h; e += 4) { for (let t = 0; t < l; ++t) { const i = u[t]; d[t][0] = i[e], d[t][1] = i[e + 1], d[t][2] = i[e + 2], d[t][3] = i[e + 3] } const i = t(d, r); c[e] = i[0], c[e + 1] = i[1], c[e + 2] = i[2], c[e + 3] = i[3] } return c.buffer } } function Bc(t, e) { const i = Object.keys(t.lib || {}).map((function (e) { return "const " + e + " = " + t.lib[e].toString() + ";" })).concat(["const __minion__ = (" + jc.toString() + ")(", t.operation.toString(), ");", 'self.addEventListener("message", function(event) {', "  const buffer = __minion__(event.data);", "  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);", "});"]), n = new Worker("undefined" == typeof Blob ? "data:text/javascript;base64," + Buffer.from(i.join("\n"), "binary").toString("base64") : URL.createObjectURL(new Blob(i, { type: "text/javascript" }))); return n.addEventListener("message", e), n } class Uc extends s { constructor(t) { let e; super(), this._imageOps = !!t.imageOps, e = 0 === t.threads ? 0 : this._imageOps ? 1 : t.threads || 1; const i = new Array(e); if (e) for (let n = 0; n < e; ++n)i[n] = Bc(t, this._onWorkerMessage.bind(this, n)); else i[0] = function (t, e) { const i = jc(t.operation); let n = !1; return { postMessage: function (t) { setTimeout((function () { n || e({ data: { buffer: i(t), meta: t.meta } }) }), 0) }, terminate: function () { n = !0 } } }(t, this._onWorkerMessage.bind(this, 0)); this._workers = i, this._queue = [], this._maxQueueLength = t.queue || 1 / 0, this._running = 0, this._dataLookup = {}, this._job = null } process(t, e, i) { this._enqueue({ inputs: t, meta: e, callback: i }), this._dispatch() } _enqueue(t) { for (this._queue.push(t); this._queue.length > this._maxQueueLength;)this._queue.shift().callback(null, null) } _dispatch() { if (this._running || 0 === this._queue.length) return; const t = this._queue.shift(); this._job = t; const e = t.inputs[0].width, i = t.inputs[0].height, n = t.inputs.map((function (t) { return t.data.buffer })), r = this._workers.length; if (this._running = r, 1 === r) return void this._workers[0].postMessage({ buffers: n, meta: t.meta, imageOps: this._imageOps, width: e, height: i }, n); const s = t.inputs[0].data.length, o = 4 * Math.ceil(s / 4 / r); for (let s = 0; s < r; ++s) { const r = s * o, a = []; for (let t = 0, e = n.length; t < e; ++t)a.push(n[t].slice(r, r + o)); this._workers[s].postMessage({ buffers: a, meta: t.meta, imageOps: this._imageOps, width: e, height: i }, a) } } _onWorkerMessage(t, e) { this.disposed || (this._dataLookup[t] = e.data, --this._running, 0 === this._running && this._resolveJob()) } _resolveJob() { const t = this._job, e = this._workers.length; let i, n; if (1 === e) i = new Uint8ClampedArray(this._dataLookup[0].buffer), n = this._dataLookup[0].meta; else { const r = t.inputs[0].data.length; i = new Uint8ClampedArray(r), n = new Array(e); const s = 4 * Math.ceil(r / 4 / e); for (let t = 0; t < e; ++t) { const e = this._dataLookup[t].buffer, r = t * s; i.set(new Uint8ClampedArray(e), r), n[t] = this._dataLookup[t].meta } } this._job = null, this._dataLookup = {}, t.callback(null, Gc(i, t.inputs[0].width, t.inputs[0].height), n), this._dispatch() } disposeInternal() { for (let t = 0; t < this._workers.length; ++t)this._workers[t].terminate(); this._workers.length = 0 } } const zc = "beforeoperations", Xc = "afteroperations"; class Vc extends i { constructor(t, e, i) { super(t), this.extent = e.extent, this.resolution = e.viewState.resolution / e.pixelRatio, this.data = i } } class Wc extends yc { constructor(t) { super({ projection: null }), this.on, this.once, this.un, this.processor_ = null, this.operationType_ = void 0 !== t.operationType ? t.operationType : "pixel", this.threads_ = void 0 !== t.threads ? t.threads : 1, this.layers_ = function (t) { const e = t.length, i = new Array(e); for (let n = 0; n < e; ++n)i[n] = Kc(t[n]); return i }(t.sources); const e = this.changed.bind(this); for (let t = 0, i = this.layers_.length; t < i; ++t)this.layers_[t].addEventListener(S, e); var i; this.tileQueue_ = new Co((function () { return 1 }), this.changed.bind(this)), this.requestedFrameState_, this.renderedImageCanvas_ = null, this.renderedRevision_, this.frameState_ = { animate: !1, coordinateToPixelTransform: [1, 0, 0, 1, 0, 0], declutterTree: null, extent: null, index: 0, layerIndex: 0, layerStatesArray: (i = this.layers_, i.map((function (t) { return t.getLayerState() }))), pixelRatio: 1, pixelToCoordinateTransform: [1, 0, 0, 1, 0, 0], postRenderFunctions: [], size: [0, 0], tileQueue: this.tileQueue_, time: Date.now(), usedTiles: {}, viewState: { rotation: 0 }, viewHints: [], wantedTiles: {}, mapId: z(this), renderTargets: {} }, this.setAttributions((function (e) { const i = []; for (let n = 0, r = t.sources.length; n < r; ++n) { const r = t.sources[n], s = (r instanceof Zl ? r : r.getSource()).getAttributions(); if ("function" == typeof s) { const t = s(e); i.push.apply(i, t) } } return 0 !== i.length ? i : null })), void 0 !== t.operation && this.setOperation(t.operation, t.lib) } setOperation(t, e) { this.processor_ && this.processor_.dispose(), this.processor_ = new Uc({ operation: t, imageOps: "image" === this.operationType_, queue: 1, lib: e, threads: this.threads_ }), this.changed() } updateFrameState_(t, e, i) { const n = Object.assign({}, this.frameState_); n.viewState = Object.assign({}, n.viewState); const r = ge(t); n.extent = t.slice(), n.size[0] = Math.round(Se(t) / e), n.size[1] = Math.round(_e(t) / e), n.time = Date.now(); const s = n.viewState; return s.center = r, s.projection = i, s.resolution = e, n } allSourcesReady_() { let t, e = !0; for (let i = 0, n = this.layers_.length; i < n; ++i)if (t = this.layers_[i].getSource(), "ready" !== t.getState()) { e = !1; break } return e } getImage(t, e, i, n) { if (!this.allSourcesReady_()) return null; const r = this.updateFrameState_(t, e, n); if (this.requestedFrameState_ = r, this.renderedImageCanvas_) { const i = this.renderedImageCanvas_.getResolution(), n = this.renderedImageCanvas_.getExtent(); e === i && ee(t, n) || (this.renderedImageCanvas_ = null) } return this.renderedImageCanvas_ && this.getRevision() === this.renderedRevision_ || this.processSources_(), r.tileQueue.loadMoreTiles(16, 16), r.animate && requestAnimationFrame(this.changed.bind(this)), this.renderedImageCanvas_ } processSources_() { const t = this.requestedFrameState_, e = this.layers_.length, i = new Array(e); for (let n = 0; n < e; ++n) { t.layerIndex = n; const e = Yc(this.layers_[n], t); if (!e) return; i[n] = e } const n = {}; this.dispatchEvent(new Vc(zc, t, n)), this.processor_.process(i, n, this.onWorkerComplete_.bind(this, t)) } onWorkerComplete_(t, e, i, n) { if (e || !i) return; const r = t.extent, s = t.viewState.resolution; if (s !== this.requestedFrameState_.viewState.resolution || !ee(r, this.requestedFrameState_.extent)) return; let o; if (this.renderedImageCanvas_) o = this.renderedImageCanvas_.getImage().getContext("2d"); else { o = Dr(Math.round(Se(r) / s), Math.round(_e(r) / s)), this.renderedImageCanvas_ = new Nr(r, s, 1, o.canvas) } o.putImageData(i, 0, 0), this.changed(), this.renderedRevision_ = this.getRevision(), this.dispatchEvent(new Vc(Xc, t, n)), t.animate && requestAnimationFrame(this.changed.bind(this)) } disposeInternal() { this.processor_ && this.processor_.dispose(), super.disposeInternal() } } Wc.prototype.dispose; let Zc = null; function Yc(t, e) { const i = t.getRenderer(); if (!i) throw new Error("Unsupported layer type: " + t); if (!i.prepareFrame(e)) return null; const n = e.size[0], r = e.size[1]; if (0 === n || 0 === r) return null; const s = i.renderFrame(e, null); let o; if (s instanceof HTMLCanvasElement) o = s; else { if (s && (o = s.firstElementChild), !(o instanceof HTMLCanvasElement)) throw new Error("Unsupported rendered element: " + o); if (o.width === n && o.height === r) { return o.getContext("2d").getImageData(0, 0, n, r) } } if (Zc) { const t = Zc.canvas; t.width !== n || t.height !== r ? Zc = Dr(n, r) : Zc.clearRect(0, 0, n, r) } else Zc = Dr(n, r); return Zc.drawImage(o, 0, 0, n, r), Zc.getImageData(0, 0, n, r) } function Kc(t) { let e; return t instanceof Zl ? t instanceof nh ? e = new Nc({ source: t }) : t instanceof yc && (e = new Lc({ source: t })) : e = t, e } const qc = ['Map tiles by <a href="https://stamen.com/" target="_blank">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">CC BY 3.0</a>.', Ec], Hc = { terrain: { extension: "jpg", opaque: !0 }, "terrain-background": { extension: "jpg", opaque: !0 }, "terrain-labels": { extension: "png", opaque: !1 }, "terrain-lines": { extension: "png", opaque: !1 }, "toner-background": { extension: "png", opaque: !0 }, toner: { extension: "png", opaque: !0 }, "toner-hybrid": { extension: "png", opaque: !1 }, "toner-labels": { extension: "png", opaque: !1 }, "toner-lines": { extension: "png", opaque: !1 }, "toner-lite": { extension: "png", opaque: !0 }, watercolor: { extension: "jpg", opaque: !0 } }, $c = { terrain: { minZoom: 0, maxZoom: 18 }, toner: { minZoom: 0, maxZoom: 20 }, watercolor: { minZoom: 0, maxZoom: 18 } }; class Jc extends st { constructor(t, e, i, n, r, s) { super(t, e), this.src_ = i, this.extent_ = n, this.preemptive_ = r, this.grid_ = null, this.keys_ = null, this.data_ = null, this.jsonp_ = s } getImage() { return null } getData(t) { if (!this.grid_ || !this.keys_) return null; const e = (t[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]), i = (t[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]), n = this.grid_[Math.floor((1 - i) * this.grid_.length)]; if ("string" != typeof n) return null; let r = n.charCodeAt(Math.floor(e * n.length)); r >= 93 && r--, r >= 35 && r--, r -= 32; let s = null; if (r in this.keys_) { const t = this.keys_[r]; s = this.data_ && t in this.data_ ? this.data_[t] : t } return s } forDataAtCoordinate(t, e, i) { this.state == tt && !0 === i ? (this.state = H, D(this, S, (function (i) { e(this.getData(t)) }), this), this.loadInternal_()) : !0 === i ? setTimeout(function () { e(this.getData(t)) }.bind(this), 0) : e(this.getData(t)) } getKey() { return this.src_ } handleError_() { this.state = Q, this.changed() } handleLoad_(t) { this.grid_ = t.grid, this.keys_ = t.keys, this.data_ = t.data, this.state = J, this.changed() } loadInternal_() { if (this.state == H) if (this.state = $, this.jsonp_) vl(this.src_, this.handleLoad_.bind(this), this.handleError_.bind(this)); else { const t = new XMLHttpRequest; t.addEventListener("load", this.onXHRLoad_.bind(this)), t.addEventListener("error", this.onXHRError_.bind(this)), t.open("GET", this.src_), t.send() } } onXHRLoad_(t) { const e = t.target; if (!e.status || e.status >= 200 && e.status < 300) { let t; try { t = JSON.parse(e.responseText) } catch (t) { return void this.handleError_() } this.handleLoad_(t) } else this.handleError_() } onXHRError_(t) { this.handleError_() } load() { this.preemptive_ ? this.loadInternal_() : this.setState(tt) } } class Qc extends ch { constructor(t) { const e = t.projection || "EPSG:3857", i = t.extent || ih(e), n = t.tileGrid || Ql({ extent: i, maxResolution: t.maxResolution, maxZoom: void 0 !== t.maxZoom ? t.maxZoom : 22, minZoom: t.minZoom, tileSize: t.tileSize || 512 }); super({ attributions: t.attributions, attributionsCollapsible: t.attributionsCollapsible, cacheSize: t.cacheSize, interpolate: !0, opaque: !1, projection: e, state: t.state, tileGrid: n, tileLoadFunction: t.tileLoadFunction ? t.tileLoadFunction : tu, tileUrlFunction: t.tileUrlFunction, url: t.url, urls: t.urls, wrapX: void 0 === t.wrapX || t.wrapX, transition: t.transition, zDirection: void 0 === t.zDirection ? 1 : t.zDirection }), this.format_ = t.format ? t.format : null, this.sourceTileCache = new ll(this.tileCache.highWaterMark), this.overlaps_ = null == t.overlaps || t.overlaps, this.tileClass = t.tileClass ? t.tileClass : gl, this.tileGrids_ = {} } getFeaturesInExtent(t) { const e = [], i = this.tileCache; if (0 === i.getCount()) return e; const n = sl(i.peekFirstKey())[0], r = this.tileGrid; return i.forEach((function (i) { if (i.tileCoord[0] !== n || i.getState() !== J) return; const s = i.getSourceTiles(); for (let i = 0, n = s.length; i < n; ++i) { const n = s[i], o = n.tileCoord; if (we(t, r.getTileCoordExtent(o))) { const i = n.getFeatures(); if (i) for (let n = 0, r = i.length; n < r; ++n) { const r = i[n], s = r.getGeometry(); we(t, s.getExtent()) && e.push(r) } } } })), e } getOverlaps() { return this.overlaps_ } clear() { this.tileCache.clear(), this.sourceTileCache.clear() } expireCache(t, e) { const i = this.getTileCacheForProjection(t), n = Object.keys(e).reduce(((t, e) => { const n = rl(e), r = i.peek(n); if (r) { const e = r.sourceTiles; for (let i = 0, n = e.length; i < n; ++i)t[e[i].getKey()] = !0 } return t }), {}); super.expireCache(t, e), this.sourceTileCache.expireCache(n) } getSourceTiles(t, e, i) { if (i.getState() === H) { i.setState($); const n = i.wrappedTileCoord, r = this.getTileGridForProjection(e), s = r.getTileCoordExtent(n), o = n[0], a = r.getResolution(o); Xt(s, -a, s); const l = this.tileGrid, h = l.getExtent(); h && ye(s, h, s); const c = l.getZForResolution(a, this.zDirection); l.forEachTileCoord(s, c, (n => { const r = this.tileUrlFunction(n, t, e), s = this.sourceTileCache.containsKey(r) ? this.sourceTileCache.get(r) : new this.tileClass(n, r ? H : tt, r, this.format_, this.tileLoadFunction); i.sourceTiles.push(s); const o = s.getState(); if (o < J) { const t = e => { this.handleTileChange(e); const n = s.getState(); if (n === J || n === Q) { const e = s.getKey(); e in i.errorTileKeys ? s.getState() === J && delete i.errorTileKeys[e] : i.loadingSourceTiles--, n === Q ? i.errorTileKeys[e] = !0 : s.removeEventListener(S, t), 0 === i.loadingSourceTiles && i.setState(x(i.errorTileKeys) ? J : Q) } }; s.addEventListener(S, t), i.loadingSourceTiles++ } o === H && (s.extent = l.getTileCoordExtent(n), s.projection = e, s.resolution = l.getResolution(n[0]), this.sourceTileCache.set(r, s), s.load()) })), i.loadingSourceTiles || i.setState(i.sourceTiles.some((t => t.getState() === Q)) ? Q : J) } return i.sourceTiles } getTile(t, e, i, n, r) { const s = il(t, e, i), o = this.getKey(); let a; if (this.tileCache.containsKey(s) && (a = this.tileCache.get(s), a.key === o)) return a; const l = [t, e, i]; let h = this.getTileCoordForTileUrlFunction(l, r); const c = this.getTileGrid().getExtent(), u = this.getTileGridForProjection(r); if (h && c) { const e = u.getTileCoordExtent(h); Xt(e, -u.getResolution(t), e), we(c, e) || (h = null) } let d = !0; if (null !== h) { const e = this.tileGrid, i = u.getResolution(t), s = e.getZForResolution(i, 1), o = u.getTileCoordExtent(h); Xt(o, -i, o), e.forEachTileCoord(o, s, function (t) { d = d && !this.tileUrlFunction(t, n, r) }.bind(this)) } const g = new dl(l, d ? tt : H, h, this.getSourceTiles.bind(this, n, r)); return g.key = o, a ? (g.interimTile = a, g.refreshInterimChain(), this.tileCache.replace(s, g)) : this.tileCache.set(s, g), g } getTileGridForProjection(t) { const e = t.getCode(); let i = this.tileGrids_[e]; if (!i) { const t = this.tileGrid, n = t.getResolutions().slice(), r = n.map((function (e, i) { return t.getOrigin(i) })), s = n.map((function (e, i) { return t.getTileSize(i) })), o = 43; for (let t = n.length; t < o; ++t)n.push(n[t - 1] / 2), r.push(r[t - 1]), s.push(s[t - 1]); i = new ql({ extent: t.getExtent(), origins: r, resolutions: n, tileSizes: s }), this.tileGrids_[e] = i } return i } getTilePixelRatio(t) { return t } getTilePixelSize(t, e, i) { const n = Va(this.getTileGridForProjection(i).getTileSize(t), this.tmpSize); return [Math.round(n[0] * e), Math.round(n[1] * e)] } updateCacheSize(t, e) { super.updateCacheSize(2 * t, e), this.sourceTileCache.highWaterMark = this.getTileCacheForProjection(e).highWaterMark } } function tu(t, e) { t.setLoader((function (i, n, r) { _l(e, t.getFormat(), i, n, r, t.onLoad.bind(t), t.onError.bind(t)) })) } class eu extends ql { constructor(t) { super({ extent: t.extent, origin: t.origin, origins: t.origins, resolutions: t.resolutions, tileSize: t.tileSize, tileSizes: t.tileSizes, sizes: t.sizes }), this.matrixIds_ = t.matrixIds } getMatrixId(t) { return this.matrixIds_[t] } getMatrixIds() { return this.matrixIds_ } } function iu(t, e, i) { const n = [], r = [], s = [], o = [], a = []; i = void 0 !== i ? i : []; const l = Ui(t.SupportedCRS), h = l.getMetersPerUnit(), c = "ne" == l.getAxisOrientation().substr(0, 2); return t.TileMatrix.sort((function (t, e) { return e.ScaleDenominator - t.ScaleDenominator })), t.TileMatrix.forEach((function (e) { let l; if (l = !(i.length > 0) || i.find((function (i) { return e.Identifier == i.TileMatrix || !e.Identifier.includes(":") && t.Identifier + ":" + e.Identifier === i.TileMatrix })), l) { r.push(e.Identifier); const t = 28e-5 * e.ScaleDenominator / h, i = e.TileWidth, l = e.TileHeight; c ? s.push([e.TopLeftCorner[1], e.TopLeftCorner[0]]) : s.push(e.TopLeftCorner), n.push(t), o.push(i == l ? i : [i, l]), a.push([e.MatrixWidth, e.MatrixHeight]) } })), new eu({ extent: e, origins: s, resolutions: n, matrixIds: r, tileSizes: o, sizes: a }) } const nu = 34962, ru = 34963, su = 35044, ou = 35048, au = 5126, lu = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"]; function hu(t, e) { e = Object.assign({ preserveDrawingBuffer: !0, antialias: !gt }, e); const i = lu.length; for (let n = 0; n < i; ++n)try { const i = t.getContext(lu[n], e); if (i) return i } catch (t) { } return null } let cu; const uu = "http://www.w3.org/2001/XMLSchema-instance"; function du(t, e) { return Du().createElementNS(t, e) } function gu(t, e) { return fu(t, e, []).join("") } function fu(t, e, i) { if (t.nodeType == Node.CDATA_SECTION_NODE || t.nodeType == Node.TEXT_NODE) e ? i.push(String(t.nodeValue).replace(/(\r\n|\r|\n)/g, "")) : i.push(t.nodeValue); else { let n; for (n = t.firstChild; n; n = n.nextSibling)fu(n, e, i) } return i } function pu(t) { return "documentElement" in t } function mu(t, e, i) { return t.getAttributeNS(e, i) || "" } function _u(t) { return (new DOMParser).parseFromString(t, "application/xml") } function yu(t, e) { return function (i, n) { const r = t.call(void 0 !== e ? e : this, i, n); if (void 0 !== r) { c(n[n.length - 1], r) } } } function xu(t, e) { return function (i, n) { const r = t.call(void 0 !== e ? e : this, i, n); if (void 0 !== r) { n[n.length - 1].push(r) } } } function vu(t, e) { return function (i, n) { const r = t.call(void 0 !== e ? e : this, i, n); void 0 !== r && (n[n.length - 1] = r) } } function Su(t, e, i) { return function (n, r) { const s = t.call(void 0 !== i ? i : this, n, r); if (void 0 !== s) { const t = r[r.length - 1], i = void 0 !== e ? e : n.localName; let o; i in t ? o = t[i] : (o = [], t[i] = o), o.push(s) } } } function wu(t, e, i) { return function (n, r) { const s = t.call(void 0 !== i ? i : this, n, r); if (void 0 !== s) { r[r.length - 1][void 0 !== e ? e : n.localName] = s } } } function Eu(t, e) { return function (i, n, r) { t.call(void 0 !== e ? e : this, i, n, r); r[r.length - 1].node.appendChild(i) } } function Tu(t, e) { let i, n; return function (e, r, s) { if (void 0 === i) { i = {}; const r = {}; r[e.localName] = t, i[e.namespaceURI] = r, n = Cu(e.localName) } Mu(i, n, r, s) } } function Cu(t, e) { return function (i, n, r) { const s = n[n.length - 1].node; let o = t; void 0 === o && (o = r); return du(void 0 !== e ? e : s.namespaceURI, o) } } const bu = Cu(); function Ru(t, e) { const i = e.length, n = new Array(i); for (let r = 0; r < i; ++r)n[r] = t[e[r]]; return n } function Pu(t, e, i) { let n, r; for (i = void 0 !== i ? i : {}, n = 0, r = t.length; n < r; ++n)i[t[n]] = e; return i } function Iu(t, e, i, n) { let r; for (r = e.firstElementChild; r; r = r.nextElementSibling) { const e = t[r.namespaceURI]; if (void 0 !== e) { const t = e[r.localName]; void 0 !== t && t.call(n, r, i) } } } function Lu(t, e, i, n, r) { return n.push(t), Iu(e, i, n, r), n.pop() } function Mu(t, e, i, n, r, s) { const o = (void 0 !== r ? r : i).length; let a, l; for (let h = 0; h < o; ++h)a = i[h], void 0 !== a && (l = e.call(void 0 !== s ? s : this, a, n, void 0 !== r ? r[h] : void 0), void 0 !== l && t[l.namespaceURI][l.localName].call(s, l, a, n)) } function Fu(t, e, i, n, r, s, o) { return r.push(t), Mu(e, i, n, r, s, o), r.pop() } let Au, Ou; function Nu() { return void 0 === Au && "undefined" != typeof XMLSerializer && (Au = new XMLSerializer), Au } function Du() { return void 0 === Ou && "undefined" != typeof document && (Ou = document.implementation.createDocument("", "", null)), Ou } const ku = su; class Gu { constructor(t, e) { this.array = null, this.type = t, at(t === nu || t === ru, 62), this.usage = void 0 !== e ? e : ku } ofSize(t) { this.array = new (ju(this.type))(t) } fromArray(t) { this.array = ju(this.type).from(t) } fromArrayBuffer(t) { this.array = new (ju(this.type))(t) } getType() { return this.type } getArray() { return this.array } getUsage() { return this.usage } getSize() { return this.array ? this.array.length : 0 } } function ju(t) { switch (t) { case nu: return Float32Array; case ru: return Uint32Array; default: return Float32Array } } var Bu = "webglcontextlost", Uu = "webglcontextrestored"; class zu { constructor(t) { this.gl_ = t.webGlContext; const e = this.gl_; this.scaleRatio_ = t.scaleRatio || 1, this.renderTargetTexture_ = e.createTexture(), this.renderTargetTextureSize_ = null, this.frameBuffer_ = e.createFramebuffer(); const i = e.createShader(e.VERTEX_SHADER); e.shaderSource(i, t.vertexShader || "\n  precision mediump float;\n  \n  attribute vec2 a_position;\n  varying vec2 v_texCoord;\n  varying vec2 v_screenCoord;\n  \n  uniform vec2 u_screenSize;\n   \n  void main() {\n    v_texCoord = a_position * 0.5 + 0.5;\n    v_screenCoord = v_texCoord * u_screenSize;\n    gl_Position = vec4(a_position, 0.0, 1.0);\n  }\n"), e.compileShader(i); const n = e.createShader(e.FRAGMENT_SHADER); e.shaderSource(n, t.fragmentShader || "\n  precision mediump float;\n   \n  uniform sampler2D u_image;\n  uniform float u_opacity;\n   \n  varying vec2 v_texCoord;\n   \n  void main() {\n    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n  }\n"), e.compileShader(n), this.renderTargetProgram_ = e.createProgram(), e.attachShader(this.renderTargetProgram_, i), e.attachShader(this.renderTargetProgram_, n), e.linkProgram(this.renderTargetProgram_), this.renderTargetVerticesBuffer_ = e.createBuffer(); e.bindBuffer(e.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), e.bufferData(e.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1]), e.STATIC_DRAW), this.renderTargetAttribLocation_ = e.getAttribLocation(this.renderTargetProgram_, "a_position"), this.renderTargetUniformLocation_ = e.getUniformLocation(this.renderTargetProgram_, "u_screenSize"), this.renderTargetOpacityLocation_ = e.getUniformLocation(this.renderTargetProgram_, "u_opacity"), this.renderTargetTextureLocation_ = e.getUniformLocation(this.renderTargetProgram_, "u_image"), this.uniforms_ = [], t.uniforms && Object.keys(t.uniforms).forEach(function (i) { this.uniforms_.push({ value: t.uniforms[i], location: e.getUniformLocation(this.renderTargetProgram_, i) }) }.bind(this)) } getGL() { return this.gl_ } init(t) { const e = this.getGL(), i = [e.drawingBufferWidth * this.scaleRatio_, e.drawingBufferHeight * this.scaleRatio_]; if (e.bindFramebuffer(e.FRAMEBUFFER, this.getFrameBuffer()), e.viewport(0, 0, i[0], i[1]), !this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== i[0] || this.renderTargetTextureSize_[1] !== i[1]) { this.renderTargetTextureSize_ = i; const t = 0, n = e.RGBA, r = 0, s = e.RGBA, o = e.UNSIGNED_BYTE, a = null; e.bindTexture(e.TEXTURE_2D, this.renderTargetTexture_), e.texImage2D(e.TEXTURE_2D, t, n, i[0], i[1], r, s, o, a), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this.renderTargetTexture_, 0) } } apply(t, e, i, n) { const r = this.getGL(), s = t.size; if (r.bindFramebuffer(r.FRAMEBUFFER, e ? e.getFrameBuffer() : null), r.activeTexture(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, this.renderTargetTexture_), !e) { const e = z(r.canvas); if (!t.renderTargets[e]) { const i = r.getContextAttributes(); i && i.preserveDrawingBuffer && (r.clearColor(0, 0, 0, 0), r.clear(r.COLOR_BUFFER_BIT)), t.renderTargets[e] = !0 } } r.enable(r.BLEND), r.blendFunc(r.ONE, r.ONE_MINUS_SRC_ALPHA), r.viewport(0, 0, r.drawingBufferWidth, r.drawingBufferHeight), r.bindBuffer(r.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), r.useProgram(this.renderTargetProgram_), r.enableVertexAttribArray(this.renderTargetAttribLocation_), r.vertexAttribPointer(this.renderTargetAttribLocation_, 2, r.FLOAT, !1, 0, 0), r.uniform2f(this.renderTargetUniformLocation_, s[0], s[1]), r.uniform1i(this.renderTargetTextureLocation_, 0); const o = t.layerStatesArray[t.layerIndex].opacity; r.uniform1f(this.renderTargetOpacityLocation_, o), this.applyUniforms(t), i && i(r, t), r.drawArrays(r.TRIANGLES, 0, 6), n && n(r, t) } getFrameBuffer() { return this.frameBuffer_ } applyUniforms(t) { const e = this.getGL(); let i, n = 1; this.uniforms_.forEach((function (r) { if (i = "function" == typeof r.value ? r.value(t) : r.value, i instanceof HTMLCanvasElement || i instanceof ImageData) r.texture || (r.texture = e.createTexture()), e.activeTexture(e[`TEXTURE${n}`]), e.bindTexture(e.TEXTURE_2D, r.texture), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), i instanceof ImageData ? e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, i.width, i.height, 0, e.UNSIGNED_BYTE, new Uint8Array(i.data)) : e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, i), e.uniform1i(r.location, n++); else if (Array.isArray(i)) switch (i.length) { case 2: return void e.uniform2f(r.location, i[0], i[1]); case 3: return void e.uniform3f(r.location, i[0], i[1], i[2]); case 4: return void e.uniform4f(r.location, i[0], i[1], i[2], i[3]); default: return } else "number" == typeof i && e.uniform1f(r.location, i) })) } } function Xu() { return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] } function Vu(t, e) { return t[0] = e[0], t[1] = e[1], t[4] = e[2], t[5] = e[3], t[12] = e[4], t[13] = e[5], t } const Wu = "u_projectionMatrix", Zu = "u_offsetScaleMatrix", Yu = "u_offsetRotateMatrix", Ku = "u_time", qu = "u_zoom", Hu = "u_resolution", $u = "u_sizePx", Ju = "u_pixelRatio", Qu = { UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123, UNSIGNED_INT: 5125, FLOAT: au }, td = {}; function ed(t) { return "shared/" + t } let id = 0; class nd extends s { constructor(t) { super(), t = t || {}, this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this), this.boundHandleWebGLContextRestored_ = this.handleWebGLContextRestored.bind(this), this.canvasCacheKey_ = t.canvasCacheKey ? ed(t.canvasCacheKey) : function () { const t = "unique/" + id; return id += 1, t }(), this.canvas_ = function (t) { let e = td[t]; if (!e) { const i = document.createElement("canvas"); i.style.position = "absolute", i.style.left = "0", e = { users: 0, canvas: i }, td[t] = e } return e.users += 1, e.canvas }(this.canvasCacheKey_), this.gl_ = hu(this.canvas_), this.bufferCache_ = {}, this.extensionCache_ = {}, this.currentProgram_ = null, this.canvas_.addEventListener(Bu, this.boundHandleWebGLContextLost_), this.canvas_.addEventListener(Uu, this.boundHandleWebGLContextRestored_), this.offsetRotateMatrix_ = [1, 0, 0, 1, 0, 0], this.offsetScaleMatrix_ = [1, 0, 0, 1, 0, 0], this.tmpMat4_ = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], this.uniformLocations_ = {}, this.attribLocations_ = {}, this.uniforms_ = [], t.uniforms && this.setUniforms(t.uniforms); const e = this.getGL(); this.postProcessPasses_ = t.postProcesses ? t.postProcesses.map((function (t) { return new zu({ webGlContext: e, scaleRatio: t.scaleRatio, vertexShader: t.vertexShader, fragmentShader: t.fragmentShader, uniforms: t.uniforms }) })) : [new zu({ webGlContext: e })], this.shaderCompileErrors_ = null, this.startTime_ = Date.now() } setUniforms(t) { this.uniforms_ = []; for (const e in t) this.uniforms_.push({ name: e, value: t[e] }); this.uniformLocations_ = {} } canvasCacheKeyMatches(t) { return this.canvasCacheKey_ === ed(t) } getExtension(t) { if (t in this.extensionCache_) return this.extensionCache_[t]; const e = this.gl_.getExtension(t); return this.extensionCache_[t] = e, e } bindBuffer(t) { const e = this.getGL(), i = z(t); let n = this.bufferCache_[i]; if (!n) { n = { buffer: t, webGlBuffer: e.createBuffer() }, this.bufferCache_[i] = n } e.bindBuffer(t.getType(), n.webGlBuffer) } flushBufferData(t) { const e = this.getGL(); this.bindBuffer(t), e.bufferData(t.getType(), t.getArray(), t.getUsage()) } deleteBuffer(t) { const e = this.getGL(), i = z(t), n = this.bufferCache_[i]; n && !e.isContextLost() && e.deleteBuffer(n.webGlBuffer), delete this.bufferCache_[i] } disposeInternal() { this.canvas_.removeEventListener(Bu, this.boundHandleWebGLContextLost_), this.canvas_.removeEventListener(Uu, this.boundHandleWebGLContextRestored_), function (t) { const e = td[t]; if (!e) return; if (e.users -= 1, e.users > 0) return; const i = hu(e.canvas).getExtension("WEBGL_lose_context"); i && i.loseContext(), delete td[t] }(this.canvasCacheKey_), delete this.gl_, delete this.canvas_ } prepareDraw(t, e) { const i = this.getGL(), n = this.getCanvas(), r = t.size, s = t.pixelRatio; n.width = r[0] * s, n.height = r[1] * s, n.style.width = r[0] + "px", n.style.height = r[1] + "px"; for (let e = this.postProcessPasses_.length - 1; e >= 0; e--)this.postProcessPasses_[e].init(t); i.bindTexture(i.TEXTURE_2D, null), i.clearColor(0, 0, 0, 0), i.clear(i.COLOR_BUFFER_BIT), i.enable(i.BLEND), i.blendFunc(i.ONE, e ? i.ZERO : i.ONE_MINUS_SRC_ALPHA) } prepareDrawToRenderTarget(t, e, i) { const n = this.getGL(), r = e.getSize(); n.bindFramebuffer(n.FRAMEBUFFER, e.getFramebuffer()), n.viewport(0, 0, r[0], r[1]), n.bindTexture(n.TEXTURE_2D, e.getTexture()), n.clearColor(0, 0, 0, 0), n.clear(n.COLOR_BUFFER_BIT), n.enable(n.BLEND), n.blendFunc(n.ONE, i ? n.ZERO : n.ONE_MINUS_SRC_ALPHA) } drawElements(t, e) { const i = this.getGL(); this.getExtension("OES_element_index_uint"); const n = i.UNSIGNED_INT, r = e - t, s = 4 * t; i.drawElements(i.TRIANGLES, r, n, s) } finalizeDraw(t, e, i) { for (let n = 0, r = this.postProcessPasses_.length; n < r; n++)n === r - 1 ? this.postProcessPasses_[n].apply(t, null, e, i) : this.postProcessPasses_[n].apply(t, this.postProcessPasses_[n + 1]) } getCanvas() { return this.canvas_ } getGL() { return this.gl_ } applyFrameState(t) { const e = t.size, i = t.viewState.rotation, n = t.pixelRatio, r = wt(this.offsetScaleMatrix_); Pt(r, 2 / e[0], 2 / e[1]); const s = wt(this.offsetRotateMatrix_); 0 !== i && Rt(s, -i), this.setUniformMatrixValue(Zu, Vu(this.tmpMat4_, r)), this.setUniformMatrixValue(Yu, Vu(this.tmpMat4_, s)), this.setUniformFloatValue(Ku, .001 * (Date.now() - this.startTime_)), this.setUniformFloatValue(qu, t.viewState.zoom), this.setUniformFloatValue(Hu, t.viewState.resolution), this.setUniformFloatValue(Ju, n), this.setUniformFloatVec2($u, [e[0], e[1]]) } applyUniforms(t) { const e = this.getGL(); let i, n = 0; this.uniforms_.forEach(function (r) { if (i = "function" == typeof r.value ? r.value(t) : r.value, i instanceof HTMLCanvasElement || i instanceof HTMLImageElement || i instanceof ImageData) { r.texture || (r.prevValue = void 0, r.texture = e.createTexture()), e.activeTexture(e[`TEXTURE${n}`]), e.bindTexture(e.TEXTURE_2D, r.texture), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE); (!(i instanceof HTMLImageElement) || i.complete) && r.prevValue !== i && (r.prevValue = i, e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, i)), e.uniform1i(this.getUniformLocation(r.name), n++) } else if (Array.isArray(i) && 6 === i.length) this.setUniformMatrixValue(r.name, Vu(this.tmpMat4_, i)); else if (Array.isArray(i) && i.length <= 4) switch (i.length) { case 2: return void e.uniform2f(this.getUniformLocation(r.name), i[0], i[1]); case 3: return void e.uniform3f(this.getUniformLocation(r.name), i[0], i[1], i[2]); case 4: return void e.uniform4f(this.getUniformLocation(r.name), i[0], i[1], i[2], i[3]); default: return } else "number" == typeof i && e.uniform1f(this.getUniformLocation(r.name), i) }.bind(this)) } useProgram(t, e) { this.getGL().useProgram(t), this.currentProgram_ = t, this.uniformLocations_ = {}, this.attribLocations_ = {}, this.applyFrameState(e), this.applyUniforms(e) } compileShader(t, e) { const i = this.getGL(), n = i.createShader(e); return i.shaderSource(n, t), i.compileShader(n), n } getProgram(t, e) { const i = this.getGL(), n = this.compileShader(t, i.FRAGMENT_SHADER), r = this.compileShader(e, i.VERTEX_SHADER), s = i.createProgram(); if (i.attachShader(s, n), i.attachShader(s, r), i.linkProgram(s), !i.getShaderParameter(n, i.COMPILE_STATUS)) { const t = `Fragment shader compliation failed: ${i.getShaderInfoLog(n)}`; throw new Error(t) } if (i.deleteShader(n), !i.getShaderParameter(r, i.COMPILE_STATUS)) { const t = `Vertex shader compilation failed: ${i.getShaderInfoLog(r)}`; throw new Error(t) } if (i.deleteShader(r), !i.getProgramParameter(s, i.LINK_STATUS)) { const t = `GL program linking failed: ${i.getShaderInfoLog(r)}`; throw new Error(t) } return s } getUniformLocation(t) { return void 0 === this.uniformLocations_[t] && (this.uniformLocations_[t] = this.getGL().getUniformLocation(this.currentProgram_, t)), this.uniformLocations_[t] } getAttributeLocation(t) { return void 0 === this.attribLocations_[t] && (this.attribLocations_[t] = this.getGL().getAttribLocation(this.currentProgram_, t)), this.attribLocations_[t] } makeProjectionTransform(t, e) { const i = t.size, n = t.viewState.rotation, r = t.viewState.resolution, s = t.viewState.center; return wt(e), Mt(e, 0, 0, 2 / (r * i[0]), 2 / (r * i[1]), -n, -s[0], -s[1]), e } setUniformFloatValue(t, e) { this.getGL().uniform1f(this.getUniformLocation(t), e) } setUniformFloatVec2(t, e) { this.getGL().uniform2fv(this.getUniformLocation(t), e) } setUniformFloatVec4(t, e) { this.getGL().uniform4fv(this.getUniformLocation(t), e) } setUniformMatrixValue(t, e) { this.getGL().uniformMatrix4fv(this.getUniformLocation(t), !1, e) } enableAttributeArray_(t, e, i, n, r) { const s = this.getAttributeLocation(t); s < 0 || (this.getGL().enableVertexAttribArray(s), this.getGL().vertexAttribPointer(s, e, i, !1, n, r)) } enableAttributes(t) { const e = rd(t); let i = 0; for (let n = 0; n < t.length; n++) { const r = t[n]; this.enableAttributeArray_(r.name, r.size, r.type || au, e, i), i += r.size * sd(r.type) } } handleWebGLContextLost() { y(this.bufferCache_), this.currentProgram_ = null } handleWebGLContextRestored() { } createTexture(t, e, i) { const n = this.getGL(); i = i || n.createTexture(); const r = n.RGBA, s = n.RGBA, o = n.UNSIGNED_BYTE; return n.bindTexture(n.TEXTURE_2D, i), e ? n.texImage2D(n.TEXTURE_2D, 0, r, s, o, e) : n.texImage2D(n.TEXTURE_2D, 0, r, t[0], t[1], 0, s, o, null), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), i } } function rd(t) { let e = 0; for (let i = 0; i < t.length; i++) { const n = t[i]; e += n.size * sd(n.type) } return e } function sd(t) { switch (t) { case Qu.UNSIGNED_BYTE: return Uint8Array.BYTES_PER_ELEMENT; case Qu.UNSIGNED_SHORT: return Uint16Array.BYTES_PER_ELEMENT; case Qu.UNSIGNED_INT: return Uint32Array.BYTES_PER_ELEMENT; case Qu.FLOAT: default: return Float32Array.BYTES_PER_ELEMENT } } class od { constructor(t, e) { this.name = t, this.data = e, this.texture_ = null } getTexture(t) { if (!this.texture_) { const e = t.createTexture(); t.bindTexture(t.TEXTURE_2D, e), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, this.data.length / 4, 1, 0, t.RGBA, t.UNSIGNED_BYTE, this.data), this.texture_ = e } return this.texture_ } } const ad = new Uint8Array(4); class ld { constructor(t, e) { this.helper_ = t; const i = t.getGL(); this.texture_ = i.createTexture(), this.framebuffer_ = i.createFramebuffer(), this.size_ = e || [1, 1], this.data_ = new Uint8Array(0), this.dataCacheDirty_ = !0, this.updateSize_() } setSize(t) { u(t, this.size_) || (this.size_[0] = t[0], this.size_[1] = t[1], this.updateSize_()) } getSize() { return this.size_ } clearCachedData() { this.dataCacheDirty_ = !0 } readAll() { if (this.dataCacheDirty_) { const t = this.size_, e = this.helper_.getGL(); e.bindFramebuffer(e.FRAMEBUFFER, this.framebuffer_), e.readPixels(0, 0, t[0], t[1], e.RGBA, e.UNSIGNED_BYTE, this.data_), this.dataCacheDirty_ = !1 } return this.data_ } readPixel(t, e) { if (t < 0 || e < 0 || t > this.size_[0] || e >= this.size_[1]) return ad[0] = 0, ad[1] = 0, ad[2] = 0, ad[3] = 0, ad; this.readAll(); const i = Math.floor(t) + (this.size_[1] - Math.floor(e) - 1) * this.size_[0]; return ad[0] = this.data_[4 * i], ad[1] = this.data_[4 * i + 1], ad[2] = this.data_[4 * i + 2], ad[3] = this.data_[4 * i + 3], ad } getTexture() { return this.texture_ } getFramebuffer() { return this.framebuffer_ } updateSize_() { const t = this.size_, e = this.helper_.getGL(); this.texture_ = this.helper_.createTexture(t, null, this.texture_), e.bindFramebuffer(e.FRAMEBUFFER, this.framebuffer_), e.viewport(0, 0, t[0], t[1]), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this.texture_, 0), this.data_ = new Uint8Array(t[0] * t[1] * 4) } } function hd(t, e, i) { const n = i ? t.LINEAR : t.NEAREST; t.bindTexture(t.TEXTURE_2D, e), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, n), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, n) } function cd(t, e, i, n, r, s) { const o = t.getGL(); let a, l; if (i instanceof Float32Array) { a = o.FLOAT, t.getExtension("OES_texture_float"); l = null !== t.getExtension("OES_texture_float_linear") } else a = o.UNSIGNED_BYTE, l = !0; hd(o, e, s && l); const h = i.byteLength / n[1]; let c, u = 1; switch (h % 8 == 0 ? u = 8 : h % 4 == 0 ? u = 4 : h % 2 == 0 && (u = 2), r) { case 1: c = o.LUMINANCE; break; case 2: c = o.LUMINANCE_ALPHA; break; case 3: c = o.RGB; break; case 4: c = o.RGBA; break; default: throw new Error(`Unsupported number of bands: ${r}`) }const d = o.getParameter(o.UNPACK_ALIGNMENT); o.pixelStorei(o.UNPACK_ALIGNMENT, u), o.texImage2D(o.TEXTURE_2D, 0, c, n[0], n[1], 0, c, a, i), o.pixelStorei(o.UNPACK_ALIGNMENT, d) } let ud = null; class dd extends v { constructor(t) { super(), this.tile, this.textures = [], this.handleTileChange_ = this.handleTileChange_.bind(this), this.renderSize_ = Va(t.grid.getTileSize(t.tile.tileCoord[0])), this.gutter_ = t.gutter || 0, this.bandCount = NaN, this.helper_ = t.helper; const e = new Gu(nu, su); e.fromArray([0, 1, 1, 1, 1, 0, 0, 0]), this.helper_.flushBufferData(e), this.coords = e, this.setTile(t.tile) } setTile(t) { if (t !== this.tile) if (this.tile && this.tile.removeEventListener(S, this.handleTileChange_), this.tile = t, this.textures.length = 0, this.loaded = t.getState() === J, this.loaded) this.uploadTile_(); else { if (t instanceof Vr) { const e = t.getImage(); e instanceof Image && !e.crossOrigin && (e.crossOrigin = "anonymous") } t.addEventListener(S, this.handleTileChange_) } } uploadTile_() { const t = this.helper_, e = t.getGL(), i = this.tile; if (i instanceof Vr || i instanceof zl) { const t = e.createTexture(); return this.textures.push(t), this.bandCount = 4, void function (t, e, i, n) { hd(t, e, n), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, i) }(e, t, i.getImage(), i.interpolate) } const n = i.getSize(), r = [n[0] + 2 * this.gutter_, n[1] + 2 * this.gutter_], s = i.getData(), o = s instanceof Float32Array, a = r[0] * r[1], l = o ? Float32Array : Uint8Array, h = l.BYTES_PER_ELEMENT, c = s.byteLength / r[1]; this.bandCount = Math.floor(c / h / r[0]); const u = Math.ceil(this.bandCount / 4); if (1 === u) { const n = e.createTexture(); return this.textures.push(n), void cd(t, n, s, r, this.bandCount, i.interpolate) } const d = new Array(u); for (let t = 0; t < u; ++t) { const i = e.createTexture(); this.textures.push(i); const n = t < u - 1 ? 4 : (this.bandCount - 1) % 4 + 1; d[t] = new l(a * n) } let g = 0, f = 0; const p = r[0] * this.bandCount; for (let t = 0; t < r[1]; ++t) { for (let t = 0; t < p; ++t) { const e = s[f + t], i = Math.floor(g / this.bandCount), n = t % this.bandCount, r = d[Math.floor(n / 4)]; r[i * (r.length / a) + n % 4] = e, ++g } f += c / h } for (let e = 0; e < u; ++e) { const n = this.textures[e], s = d[e]; cd(t, n, s, r, s.length / a, i.interpolate) } } handleTileChange_() { this.tile.getState() === J && (this.loaded = !0, this.uploadTile_(), this.dispatchEvent(S)) } disposeInternal() { const t = this.helper_.getGL(); this.helper_.deleteBuffer(this.coords); for (let e = 0; e < this.textures.length; ++e)t.deleteTexture(this.textures[e]); this.tile.removeEventListener(S, this.handleTileChange_) } getPixelData(t, e) { if (!this.loaded) return null; const i = this.renderSize_[0], n = this.renderSize_[1], r = this.gutter_; if (this.tile instanceof ot) { const s = this.tile.getSize(), o = s[0], a = s[1], l = o + 2 * r, h = a + 2 * r, c = r + Math.floor(o * (t / i)), u = r + Math.floor(a * (e / n)), d = this.tile.getData(); if (d instanceof DataView) { const t = d.byteLength / (l * h), e = t * (u * l + c), i = d.buffer.slice(e, e + t); return new DataView(i) } const g = this.bandCount * (u * l + c); return d.slice(g, g + this.bandCount) } ud || function () { const t = document.createElement("canvas"); t.width = 1, t.height = 1, ud = t.getContext("2d") }(), ud.clearRect(0, 0, 1, 1); const s = this.tile.getImage(), o = s.width - 2 * r, a = s.height - 2 * r, l = r + Math.floor(o * (t / i)), h = r + Math.floor(a * (e / n)); let c; try { ud.drawImage(s, l, h, 1, 1, 0, 0, 1, 1), c = ud.getImageData(0, 0, 1, 1).data } catch (t) { return ud = null, null } return c } } class gd extends Cc { constructor(t, e) { super(t), e = e || {}, this.inversePixelTransform_ = [1, 0, 0, 1, 0, 0], this.pixelContext_ = null, this.postProcesses_ = e.postProcesses, this.uniforms_ = e.uniforms, this.helper, t.addChangeListener(gs, this.removeHelper.bind(this)), this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this), this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this) } dispatchPreComposeEvent(t, e) { const i = this.getLayer(); if (i.hasListener(_s)) { const n = new Ts(_s, void 0, e, t); i.dispatchEvent(n) } } dispatchPostComposeEvent(t, e) { const i = this.getLayer(); if (i.hasListener(ys)) { const n = new Ts(ys, void 0, e, t); i.dispatchEvent(n) } } reset(t) { this.uniforms_ = t.uniforms, this.helper && this.helper.setUniforms(this.uniforms_) } removeHelper() { this.helper && (this.helper.dispose(), delete this.helper) } prepareFrame(t) { if (this.getLayer().getRenderSource()) { let e, i = !0, n = -1; for (let r = 0, s = t.layerStatesArray.length; r < s; r++) { const s = t.layerStatesArray[r].layer, o = s.getRenderer(); if (!(o instanceof gd)) { i = !0; continue } const a = s.getClassName(); if ((i || a !== e) && (n += 1, i = !1), e = a, o === this) break } const r = "map/" + t.mapId + "/group/" + n; this.helper && this.helper.canvasCacheKeyMatches(r) || (this.removeHelper(), this.helper = new nd({ postProcesses: this.postProcesses_, uniforms: this.uniforms_, canvasCacheKey: r }), e && (this.helper.getCanvas().className = e), this.afterHelperCreated()) } return this.prepareFrameInternal(t) } afterHelperCreated() { } prepareFrameInternal(t) { return !0 } disposeInternal() { this.removeHelper(), super.disposeInternal() } dispatchRenderEvent_(t, e, i) { const n = this.getLayer(); if (n.hasListener(t)) { Mt(this.inversePixelTransform_, 0, 0, i.pixelRatio, -i.pixelRatio, 0, 0, -i.size[1]); const r = new Ts(t, this.inversePixelTransform_, i, e); n.dispatchEvent(r) } } preRender(t, e) { this.dispatchRenderEvent_(ps, t, e) } postRender(t, e) { this.dispatchRenderEvent_(ms, t, e) } } const fd = { TILE_TEXTURE_ARRAY: "u_tileTextures", TILE_TRANSFORM: "u_tileTransform", TRANSITION_ALPHA: "u_transitionAlpha", DEPTH: "u_depth", TEXTURE_PIXEL_WIDTH: "u_texturePixelWidth", TEXTURE_PIXEL_HEIGHT: "u_texturePixelHeight", TEXTURE_RESOLUTION: "u_textureResolution", TEXTURE_ORIGIN_X: "u_textureOriginX", TEXTURE_ORIGIN_Y: "u_textureOriginY", RENDER_EXTENT: "u_renderExtent", RESOLUTION: "u_resolution", ZOOM: "u_zoom" }, pd = { TEXTURE_COORD: "a_textureCoord" }, md = [{ name: pd.TEXTURE_COORD, size: 2, type: Qu.FLOAT }], _d = {}; function yd(t) { return 2 * (1 - 1 / (t + 1)) - 1 } function xd(t, e, i) { i in t || (t[i] = []), t[i].push(e) } function vd(t, e) { const i = t.layerStatesArray[t.layerIndex]; i.extent && (e = ye(e, on(i.extent, t.viewState.projection))); const n = i.layer.getRenderSource(); if (!n.getWrapX()) { const i = n.getTileGridForProjection(t.viewState.projection).getExtent(); i && (e = ye(e, i)) } return e } function Sd(t, e) { return `${t.getKey()},${nl(e)}` } class wd extends gd { constructor(t, e) { super(t, { uniforms: e.uniforms }), this.renderComplete = !1, this.tileTransform_ = [1, 0, 0, 1, 0, 0], this.tempMat4_ = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], this.tempTileRange_ = new hl(0, 0, 0, 0), this.tempTileCoord_ = el(0, 0, 0), this.tempSize_ = [0, 0], this.program_, this.vertexShader_ = e.vertexShader, this.fragmentShader_ = e.fragmentShader, this.indices_ = new Gu(ru, su), this.indices_.fromArray([0, 1, 3, 1, 2, 3]); const i = void 0 !== e.cacheSize ? e.cacheSize : 512; this.tileTextureCache_ = new tl(i), this.paletteTextures_ = e.paletteTextures || [], this.frameState_ = null, this.projection_ = void 0 } reset(t) { super.reset({ uniforms: t.uniforms }), this.vertexShader_ = t.vertexShader, this.fragmentShader_ = t.fragmentShader, this.paletteTextures_ = t.paletteTextures || [], this.helper && (this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_)) } afterHelperCreated() { this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_), this.helper.flushBufferData(this.indices_) } isDrawableTile_(t) { const e = this.getLayer(), i = t.getState(), n = e.getUseInterimTilesOnError(); return i == J || i == tt || i == Q && !n } prepareFrameInternal(t) { this.projection_ ? t.viewState.projection !== this.projection_ && (this.clearCache(), this.projection_ = t.viewState.projection) : this.projection_ = t.viewState.projection; const e = this.getLayer().getRenderSource(); return !!e && (!Ee(vd(t, t.extent)) && "ready" === e.getState()) } enqueueTiles(t, e, i, n, r) { const s = t.viewState, o = this.getLayer(), a = o.getRenderSource(), l = a.getTileGridForProjection(s.projection), h = a.getGutterForProjection(s.projection), c = z(a); c in t.wantedTiles || (t.wantedTiles[c] = {}); const u = t.wantedTiles[c], d = this.tileTextureCache_, g = o.getMapInternal(), f = Math.max(i - r, l.getMinZoom(), l.getZForResolution(Math.min(o.getMaxResolution(), g ? g.getView().getResolutionForZoom(Math.max(o.getMinZoom(), 0)) : l.getResolution(0)), a.zDirection)); for (let r = i; r >= f; --r) { const i = l.getTileRangeForExtentAndZ(e, r, this.tempTileRange_), o = l.getResolution(r); for (let e = i.minX; e <= i.maxX; ++e)for (let g = i.minY; g <= i.maxY; ++g) { const i = el(r, e, g, this.tempTileCoord_), f = Sd(a, i); let p, m; if (d.containsKey(f) && (p = d.get(f), m = p.tile), !p || p.tile.key !== a.getKey()) if (m = a.getTile(r, e, g, t.pixelRatio, s.projection), p) if (this.isDrawableTile_(m)) p.setTile(m); else { const t = m.getInterimTile(); p.setTile(t) } else p = new dd({ tile: m, grid: l, helper: this.helper, gutter: h }), d.set(f, p); xd(n, p, r); const _ = m.getKey(); u[_] = !0, m.getState() === H && (t.tileQueue.isKeyQueued(_) || t.tileQueue.enqueue([m, c, l.getTileCoordCenter(i), o])) } } } renderFrame(t) { this.frameState_ = t, this.renderComplete = !0; const e = this.helper.getGL(); this.preRender(e, t); const i = t.viewState, n = this.getLayer(), r = n.getRenderSource(), s = r.getTileGridForProjection(i.projection), o = r.getGutterForProjection(i.projection), l = vd(t, t.extent), h = s.getZForResolution(i.resolution, r.zDirection), c = {}, u = n.getPreload(); if (t.nextExtent) { const e = s.getZForResolution(i.nextResolution, r.zDirection), n = vd(t, t.nextExtent); this.enqueueTiles(t, n, e, c, u) } this.enqueueTiles(t, l, h, c, 0), u > 0 && setTimeout((() => { this.enqueueTiles(t, l, h - 1, c, u - 1) }), 0); const d = {}, g = z(this), f = t.time; let p = !1; const m = c[h]; for (let t = 0, e = m.length; t < e; ++t) { const e = m[t], i = e.tile; if (i instanceof zl && i.getState() === tt) continue; const n = i.tileCoord; if (e.loaded) { const t = i.getAlpha(g, f); if (1 === t) { i.endTransition(g); continue } p = !0; d[nl(n)] = t } this.renderComplete = !1; if (this.findAltTiles_(s, n, h + 1, c)) continue; const r = s.getMinZoom(); for (let t = h - 1; t >= r; --t) { if (this.findAltTiles_(s, n, t, c)) break } } this.helper.useProgram(this.program_, t), this.helper.prepareDraw(t, !p); const _ = Object.keys(c).map(Number).sort(a), y = i.center[0], x = i.center[1]; for (let n = 0, r = _.length; n < r; ++n) { const r = _[n], a = s.getResolution(r), h = Va(s.getTileSize(r), this.tempSize_), u = s.getOrigin(r), g = h[0] + 2 * o, f = h[1] + 2 * o, p = g / f, m = (y - u[0]) / (h[0] * a), v = (u[1] - x) / (h[1] * a), S = i.resolution / a, w = yd(r), E = c[r]; for (let n = 0, r = E.length; n < r; ++n) { const r = E[n]; if (!r.loaded) continue; const c = r.tile.tileCoord, _ = nl(c), y = c[1], x = c[2]; wt(this.tileTransform_), Pt(this.tileTransform_, 2 / (t.size[0] * S / g), -2 / (t.size[1] * S / g)), Rt(this.tileTransform_, i.rotation), Pt(this.tileTransform_, 1, 1 / p), Lt(this.tileTransform_, (h[0] * (y - m) - o) / g, (h[1] * (x - v) - o) / f), this.helper.setUniformMatrixValue(fd.TILE_TRANSFORM, Vu(this.tempMat4_, this.tileTransform_)), this.helper.bindBuffer(r.coords), this.helper.bindBuffer(this.indices_), this.helper.enableAttributes(md); let T = 0; for (; T < r.textures.length;) { const t = "TEXTURE" + T, i = `${fd.TILE_TEXTURE_ARRAY}[${T}]`; e.activeTexture(e[t]), e.bindTexture(e.TEXTURE_2D, r.textures[T]), e.uniform1i(this.helper.getUniformLocation(i), T), ++T } for (let t = 0; t < this.paletteTextures_.length; ++t) { const i = this.paletteTextures_[t]; e.activeTexture(e["TEXTURE" + T]); const n = i.getTexture(e); e.bindTexture(e.TEXTURE_2D, n), e.uniform1i(this.helper.getUniformLocation(i.name), T), ++T } const C = _ in d ? d[_] : 1; C < 1 && (t.animate = !0), this.helper.setUniformFloatValue(fd.TRANSITION_ALPHA, C), this.helper.setUniformFloatValue(fd.DEPTH, w), this.helper.setUniformFloatValue(fd.TEXTURE_PIXEL_WIDTH, g), this.helper.setUniformFloatValue(fd.TEXTURE_PIXEL_HEIGHT, f), this.helper.setUniformFloatValue(fd.TEXTURE_RESOLUTION, a), this.helper.setUniformFloatValue(fd.TEXTURE_ORIGIN_X, u[0] + y * h[0] * a - o * a), this.helper.setUniformFloatValue(fd.TEXTURE_ORIGIN_Y, u[1] - x * h[1] * a + o * a); let b = l; o > 0 && (b = s.getTileCoordExtent(c), ye(b, l, b)), this.helper.setUniformFloatVec4(fd.RENDER_EXTENT, b), this.helper.setUniformFloatValue(fd.RESOLUTION, i.resolution), this.helper.setUniformFloatValue(fd.ZOOM, i.zoom), this.helper.drawElements(0, this.indices_.getSize()) } } this.helper.finalizeDraw(t, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent); const v = this.helper.getCanvas(), S = this.tileTextureCache_; for (; S.canExpireCache();) { S.pop().dispose() } return t.postRenderFunctions.push((function (t, e) { r.updateCacheSize(.1, e.viewState.projection), r.expireCache(e.viewState.projection, _d) })), this.postRender(e, t), v } getData(t) { if (!this.helper.getGL()) return null; const e = this.frameState_; if (!e) return null; const i = this.getLayer(), n = bt(e.pixelToCoordinateTransform, t.slice()), r = e.viewState, s = i.getExtent(); if (s && !Zt(on(s, r.projection), n)) return null; const o = i.getSources(zt([n]), r.resolution); let a, l, h; for (a = o.length - 1; a >= 0; --a)if (l = o[a], "ready" === l.getState()) { if (h = l.getTileGridForProjection(r.projection), l.getWrapX()) break; const t = h.getExtent(); if (!t || Zt(t, n)) break } if (a < 0) return null; const c = this.tileTextureCache_; for (let t = h.getZForResolution(r.resolution); t >= h.getMinZoom(); --t) { const e = h.getTileCoordForCoordAndZ(n, t), i = Sd(l, e); if (!c.containsKey(i)) continue; const r = c.get(i), s = r.tile; if (s instanceof zl && s.getState() === tt) return null; if (!r.loaded) continue; const o = h.getOrigin(t), a = Va(h.getTileSize(t)), u = h.getResolution(t), d = (n[0] - o[0]) / u - e[1] * a[0], g = (o[1] - n[1]) / u - e[2] * a[1]; return r.getPixelData(d, g) } return null } findAltTiles_(t, e, i, n) { const r = t.getTileRangeForTileCoordAndZ(e, i, this.tempTileRange_); if (!r) return !1; let s = !0; const o = this.tileTextureCache_, a = this.getLayer().getRenderSource(); for (let t = r.minX; t <= r.maxX; ++t)for (let e = r.minY; e <= r.maxY; ++e) { const r = Sd(a, [i, t, e]); let l = !1; if (o.containsKey(r)) { const t = o.get(r); t.loaded && (xd(n, t, i), l = !0) } l || (s = !1) } return s } clearCache() { const t = this.tileTextureCache_; t.forEach((t => t.dispose())), t.clear() } removeHelper() { this.helper && this.clearCache(), super.removeHelper() } disposeInternal() { const t = this.helper; if (t) { t.getGL().deleteProgram(this.program_), delete this.program_, t.deleteBuffer(this.indices_) } super.disposeInternal(), delete this.indices_, delete this.tileTextureCache_, delete this.frameState_ } } const Ed = 1, Td = 2, Cd = 4, bd = 8, Rd = 16, Pd = 31, Id = 0, Ld = {}; function Md(t) { if ("number" == typeof t) return Ed; if ("boolean" == typeof t) return bd; if ("string" == typeof t) return ts(t) ? Cd | Td : Td; if (!Array.isArray(t)) throw new Error(`Unhandled value type: ${JSON.stringify(t)}`); const e = t; if (e.every((function (t) { return "number" == typeof t }))) return 3 === e.length || 4 === e.length ? Cd | Rd : Rd; if ("string" != typeof e[0]) throw new Error(`Expected an expression operator but received: ${JSON.stringify(e)}`); const i = Ld[e[0]]; if (void 0 === i) throw new Error(`Unrecognized expression operator: ${JSON.stringify(e)}`); return i.getReturnType(e.slice(1)) } function Fd(t) { return Math.log2(t) % 1 == 0 } function Ad(t) { const e = t.toString(); return e.includes(".") ? e : e + ".0" } function Od(t) { if (t.length < 2 || t.length > 4) throw new Error("`formatArray` can only output `vec2`, `vec3` or `vec4` arrays."); return `vec${t.length}(${t.map(Ad).join(", ")})` } function Nd(t) { const e = $r(t).slice(); return e.length < 4 && e.push(1), Od(e.map((function (t, e) { return e < 3 ? t / 255 : t }))) } function Dd(t, e) { return void 0 === t.stringLiteralsMap[e] && (t.stringLiteralsMap[e] = Object.keys(t.stringLiteralsMap).length), t.stringLiteralsMap[e] } function kd(t, e) { return Ad(Dd(t, e)) } function Gd(t, e, i) { if (Array.isArray(e) && "string" == typeof e[0]) { const n = Ld[e[0]]; if (void 0 === n) throw new Error(`Unrecognized expression operator: ${JSON.stringify(e)}`); return n.toGlsl(t, e.slice(1), i) } const n = Md(e); if ((n & Ed) > 0) return Ad(e); if ((n & bd) > 0) return e.toString(); if ((n & Td) > 0 && (void 0 === i || i == Td)) return kd(t, e.toString()); if ((n & Cd) > 0 && (void 0 === i || i == Cd)) return Nd(e); if ((n & Rd) > 0) return Od(e); throw new Error(`Unexpected expression ${e} (expected type ${i})`) } function jd(t) { if (!(Md(t) & Ed)) throw new Error(`A numeric value was expected, got ${JSON.stringify(t)} instead`) } function Bd(t) { for (let e = 0; e < t.length; e++)jd(t[e]) } function Ud(t) { if (!(Md(t) & Td)) throw new Error(`A string value was expected, got ${JSON.stringify(t)} instead`) } function zd(t) { if (!(Md(t) & bd)) throw new Error(`A boolean value was expected, got ${JSON.stringify(t)} instead`) } function Xd(t, e) { if (t.length !== e) throw new Error(`Exactly ${e} arguments were expected, got ${t.length} instead`) } function Vd(t, e) { if (t.length < e) throw new Error(`At least ${e} arguments were expected, got ${t.length} instead`) } function Wd(t, e) { if (t.length > e) throw new Error(`At most ${e} arguments were expected, got ${t.length} instead`) } function Zd(t) { if (t.length % 2 != 0) throw new Error(`An even amount of arguments was expected, got ${t} instead`) } function Yd(t, e) { if (!Fd(e)) throw new Error(`Could not infer only one type from the following expression: ${JSON.stringify(t)}`) } function Kd(t) { return "u_var_" + t } Ld.get = { getReturnType: function (t) { return Pd }, toGlsl: function (t, e) { Xd(e, 1), Ud(e[0]); const i = e[0].toString(); t.attributes.includes(i) || t.attributes.push(i); return (t.inFragmentShader ? "v_" : "a_") + i } }, Ld.var = { getReturnType: function (t) { return Pd }, toGlsl: function (t, e) { Xd(e, 1), Ud(e[0]); const i = e[0].toString(); return t.variables.includes(i) || t.variables.push(i), Kd(i) } }; const qd = "u_paletteTextures"; Ld.palette = { getReturnType: function (t) { return Cd }, toGlsl: function (t, e) { Xd(e, 2), jd(e[0]); const i = Gd(t, e[0]), n = e[1]; if (!Array.isArray(n)) throw new Error("The second argument of palette must be an array"); const r = n.length, s = new Uint8Array(4 * r); for (let t = 0; t < r; t++) { const e = n[t]; let i; if ("string" == typeof e) i = Hr(e); else { if (!Array.isArray(e)) throw new Error("The second argument of palette must be an array of strings or colors"); const t = e.length; if (4 === t) i = e; else { if (3 !== t) throw new Error(`Expected palette color to have 3 or 4 values, got ${t}`); i = [e[0], e[1], e[2], 1] } } const r = 4 * t; s[r] = i[0], s[r + 1] = i[1], s[r + 2] = i[2], s[r + 3] = 255 * i[3] } t.paletteTextures || (t.paletteTextures = []); const o = `u_paletteTextures[${t.paletteTextures.length}]`, a = new od(o, s); return t.paletteTextures.push(a), `texture2D(${o}, vec2((${i} + 0.5) / ${r}.0, 0.5))` } }; const Hd = "getBandValue"; function $d(t) { return { getReturnType: function (t) { return bd }, toGlsl: function (e, i) { Xd(i, 2); let n = Pd; for (let t = 0; t < i.length; t++)n &= Md(i[t]); if (n === Id) throw new Error(`All arguments should be of compatible type, got ${JSON.stringify(i)} instead`); return n &= ~Cd, `(${Gd(e, i[0], n)} ${t} ${Gd(e, i[1], n)})` } } } function Jd(t) { return { getReturnType: function (t) { return bd }, toGlsl: function (e, i) { Vd(i, 2); for (let t = 0; t < i.length; t++)zd(i[t]); let n = ""; return n = i.map((t => Gd(e, t))).join(` ${t} `), n = `(${n})`, n } } } Ld.band = { getReturnType: function (t) { return Ed }, toGlsl: function (t, e) { Vd(e, 1), Wd(e, 3); const i = e[0]; if (!(Hd in t.functions)) { let e = ""; const i = t.bandCount || 1; for (let t = 0; t < i; t++) { const n = Math.floor(t / 4); let r = t % 4; t === i - 1 && 1 === r && (r = 3); e += `\n          if (band == ${t + 1}.0) {\n            return texture2D(${`${fd.TILE_TEXTURE_ARRAY}[${n}]`}, v_textureCoord + vec2(dx, dy))[${r}];\n          }\n        ` } t.functions.getBandValue = `\n        float getBandValue(float band, float xOffset, float yOffset) {\n          float dx = xOffset / ${fd.TEXTURE_PIXEL_WIDTH};\n          float dy = yOffset / ${fd.TEXTURE_PIXEL_HEIGHT};\n          ${e}\n        }\n      ` } return `getBandValue(${Gd(t, i)}, ${Gd(t, e[1] || 0)}, ${Gd(t, e[2] || 0)})` } }, Ld.time = { getReturnType: function (t) { return Ed }, toGlsl: function (t, e) { return Xd(e, 0), "u_time" } }, Ld.zoom = { getReturnType: function (t) { return Ed }, toGlsl: function (t, e) { return Xd(e, 0), "u_zoom" } }, Ld.resolution = { getReturnType: function (t) { return Ed }, toGlsl: function (t, e) { return Xd(e, 0), "u_resolution" } }, Ld["*"] = { getReturnType: function (t) { return Ed }, toGlsl: function (t, e) { return Xd(e, 2), Bd(e), `(${Gd(t, e[0])} * ${Gd(t, e[1])})` } }, Ld["/"] = { getReturnType: function (t) { return Ed }, toGlsl: function (t, e) { return Xd(e, 2), Bd(e), `(${Gd(t, e[0])} / ${Gd(t, e[1])})` } }, Ld["+"] = { getReturnType: function (t) { return Ed }, toGlsl: function (t, e) { return Xd(e, 2), Bd(e), `(${Gd(t, e[0])} + ${Gd(t, e[1])})` } }, Ld["-"] = { getReturnType: function (t) { return Ed }, toGlsl: function (t, e) { return Xd(e, 2), Bd(e), `(${Gd(t, e[0])} - ${Gd(t, e[1])})` } }, Ld.clamp = { getReturnType: function (t) { return Ed }, toGlsl: function (t, e) { Xd(e, 3), Bd(e); const i = Gd(t, e[1]), n = Gd(t, e[2]); return `clamp(${Gd(t, e[0])}, ${i}, ${n})` } }, Ld["%"] = { getReturnType: function (t) { return Ed }, toGlsl: function (t, e) { return Xd(e, 2), Bd(e), `mod(${Gd(t, e[0])}, ${Gd(t, e[1])})` } }, Ld["^"] = { getReturnType: function (t) { return Ed }, toGlsl: function (t, e) { return Xd(e, 2), Bd(e), `pow(${Gd(t, e[0])}, ${Gd(t, e[1])})` } }, Ld.abs = { getReturnType: function (t) { return Ed }, toGlsl: function (t, e) { return Xd(e, 1), Bd(e), `abs(${Gd(t, e[0])})` } }, Ld.floor = { getReturnType: function (t) { return Ed }, toGlsl: function (t, e) { return Xd(e, 1), Bd(e), `floor(${Gd(t, e[0])})` } }, Ld.round = { getReturnType: function (t) { return Ed }, toGlsl: function (t, e) { return Xd(e, 1), Bd(e), `floor(${Gd(t, e[0])} + 0.5)` } }, Ld.ceil = { getReturnType: function (t) { return Ed }, toGlsl: function (t, e) { return Xd(e, 1), Bd(e), `ceil(${Gd(t, e[0])})` } }, Ld.sin = { getReturnType: function (t) { return Ed }, toGlsl: function (t, e) { return Xd(e, 1), Bd(e), `sin(${Gd(t, e[0])})` } }, Ld.cos = { getReturnType: function (t) { return Ed }, toGlsl: function (t, e) { return Xd(e, 1), Bd(e), `cos(${Gd(t, e[0])})` } }, Ld.atan = { getReturnType: function (t) { return Ed }, toGlsl: function (t, e) { return Vd(e, 1), Wd(e, 2), Bd(e), 2 === e.length ? `atan(${Gd(t, e[0])}, ${Gd(t, e[1])})` : `atan(${Gd(t, e[0])})` } }, Ld[">"] = { getReturnType: function (t) { return bd }, toGlsl: function (t, e) { return Xd(e, 2), Bd(e), `(${Gd(t, e[0])} > ${Gd(t, e[1])})` } }, Ld[">="] = { getReturnType: function (t) { return bd }, toGlsl: function (t, e) { return Xd(e, 2), Bd(e), `(${Gd(t, e[0])} >= ${Gd(t, e[1])})` } }, Ld["<"] = { getReturnType: function (t) { return bd }, toGlsl: function (t, e) { return Xd(e, 2), Bd(e), `(${Gd(t, e[0])} < ${Gd(t, e[1])})` } }, Ld["<="] = { getReturnType: function (t) { return bd }, toGlsl: function (t, e) { return Xd(e, 2), Bd(e), `(${Gd(t, e[0])} <= ${Gd(t, e[1])})` } }, Ld["=="] = $d("=="), Ld["!="] = $d("!="), Ld["!"] = { getReturnType: function (t) { return bd }, toGlsl: function (t, e) { return Xd(e, 1), zd(e[0]), `(!${Gd(t, e[0])})` } }, Ld.all = Jd("&&"), Ld.any = Jd("||"), Ld.between = { getReturnType: function (t) { return bd }, toGlsl: function (t, e) { Xd(e, 3), Bd(e); const i = Gd(t, e[1]), n = Gd(t, e[2]), r = Gd(t, e[0]); return `(${r} >= ${i} && ${r} <= ${n})` } }, Ld.array = { getReturnType: function (t) { return Rd }, toGlsl: function (t, e) { Vd(e, 2), Wd(e, 4), Bd(e); const i = e.map((function (e) { return Gd(t, e, Ed) })); return `vec${e.length}(${i.join(", ")})` } }, Ld.color = { getReturnType: function (t) { return Cd }, toGlsl: function (t, e) { Vd(e, 3), Wd(e, 4), Bd(e); const i = e; 3 === e.length && i.push(1); const n = e.map((function (e, i) { return Gd(t, e, Ed) + (i < 3 ? " / 255.0" : "") })); return `vec${e.length}(${n.join(", ")})` } }, Ld.interpolate = { getReturnType: function (t) { let e = Cd | Ed; for (let i = 3; i < t.length; i += 2)e &= Md(t[i]); return e }, toGlsl: function (t, e, i) { Zd(e), Vd(e, 6); const n = e[0]; let r; switch (n[0]) { case "linear": r = 1; break; case "exponential": r = n[1]; break; default: r = null }if (!r) throw new Error(`Invalid interpolation type for "interpolate" operator, received: ${JSON.stringify(n)}`); i = void 0 !== i ? i : Pd; const s = Ld.interpolate.getReturnType(e) & i; Yd(e, s); const o = Gd(t, e[1]), a = Ad(r); let l = ""; for (let i = 2; i < e.length - 2; i += 2) { const n = Gd(t, e[i]), r = l || Gd(t, e[i + 1], s), h = Gd(t, e[i + 2]); l = `mix(${r}, ${Gd(t, e[i + 3], s)}, pow(clamp((${o} - ${n}) / (${h} - ${n}), 0.0, 1.0), ${a}))` } return l } }, Ld.match = { getReturnType: function (t) { let e = Pd; for (let i = 2; i < t.length; i += 2)e &= Md(t[i]); return e &= Md(t[t.length - 1]), e }, toGlsl: function (t, e, i) { Zd(e), Vd(e, 4), i = void 0 !== i ? i : Pd; const n = Ld.match.getReturnType(e) & i; Yd(e, n); const r = Gd(t, e[0]), s = Gd(t, e[e.length - 1], n); let o = null; for (let i = e.length - 3; i >= 1; i -= 2) { o = `(${r} == ${Gd(t, e[i])} ? ${Gd(t, e[i + 1], n)} : ${o || s})` } return o } }, Ld.case = { getReturnType: function (t) { let e = Pd; for (let i = 1; i < t.length; i += 2)e &= Md(t[i]); return e &= Md(t[t.length - 1]), e }, toGlsl: function (t, e, i) { !function (t) { if (t.length % 2 == 0) throw new Error(`An odd amount of arguments was expected, got ${t} instead`) }(e), Vd(e, 3), i = void 0 !== i ? i : Pd; const n = Ld.case.getReturnType(e) & i; Yd(e, n); for (let t = 0; t < e.length - 1; t += 2)zd(e[t]); const r = Gd(t, e[e.length - 1], n); let s = null; for (let i = e.length - 3; i >= 0; i -= 2) { s = `(${Gd(t, e[i])} ? ${Gd(t, e[i + 1], n)} : ${s || r})` } return s } }; class Qd { constructor() { this.uniforms = [], this.attributes = [], this.varyings = [], this.sizeExpression = "vec2(1.0)", this.rotationExpression = "0.0", this.offsetExpression = "vec2(0.0)", this.colorExpression = "vec4(1.0)", this.texCoordExpression = "vec4(0.0, 0.0, 1.0, 1.0)", this.discardExpression = "false", this.rotateWithView = !1 } addUniform(t) { return this.uniforms.push(t), this } addAttribute(t) { return this.attributes.push(t), this } addVarying(t, e, i) { return this.varyings.push({ name: t, type: e, expression: i }), this } setSizeExpression(t) { return this.sizeExpression = t, this } setRotationExpression(t) { return this.rotationExpression = t, this } setSymbolOffsetExpression(t) { return this.offsetExpression = t, this } setColorExpression(t) { return this.colorExpression = t, this } setTextureCoordinateExpression(t) { return this.texCoordExpression = t, this } setFragmentDiscardExpression(t) { return this.discardExpression = t, this } setSymbolRotateWithView(t) { return this.rotateWithView = t, this } getSizeExpression() { return this.sizeExpression } getOffsetExpression() { return this.offsetExpression } getColorExpression() { return this.colorExpression } getTextureCoordinateExpression() { return this.texCoordExpression } getFragmentDiscardExpression() { return this.discardExpression } getSymbolVertexShader(t) { const e = this.rotateWithView ? "u_offsetScaleMatrix * u_offsetRotateMatrix" : "u_offsetScaleMatrix"; let i = this.attributes, n = this.varyings; return t && (i = i.concat("vec4 a_hitColor"), n = n.concat({ name: "v_hitColor", type: "vec4", expression: "a_hitColor" })), `precision mediump float;\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n${this.uniforms.map((function (t) { return "uniform " + t + ";" })).join("\n")}\nattribute vec2 a_position;\nattribute float a_index;\n${i.map((function (t) { return "attribute " + t + ";" })).join("\n")}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n${n.map((function (t) { return "varying " + t.type + " " + t.name + ";" })).join("\n")}\nvoid main(void) {\n  mat4 offsetMatrix = ${e};\n  vec2 halfSize = ${this.sizeExpression} * 0.5;\n  vec2 offset = ${this.offsetExpression};\n  float angle = ${this.rotationExpression};\n  float offsetX;\n  float offsetY;\n  if (a_index == 0.0) {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  } else if (a_index == 1.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else if (a_index == 2.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  }\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  vec4 texCoord = ${this.texCoordExpression};\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\n  v_texCoord = vec2(u, v);\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v_quadCoord = vec2(u, v);\n${n.map((function (t) { return "  " + t.name + " = " + t.expression + ";" })).join("\n")}\n}` } getSymbolFragmentShader(t) { const e = t ? "  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;" : ""; let i = this.varyings; return t && (i = i.concat({ name: "v_hitColor", type: "vec4", expression: "a_hitColor" })), `precision mediump float;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n${this.uniforms.map((function (t) { return "uniform " + t + ";" })).join("\n")}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n${i.map((function (t) { return "varying " + t.type + " " + t.name + ";" })).join("\n")}\nvoid main(void) {\n  if (${this.discardExpression}) { discard; }\n  gl_FragColor = ${this.colorExpression};\n  gl_FragColor.rgb *= gl_FragColor.a;\n${e}\n}` } } function tg(t) { const e = t.symbol, i = void 0 !== e.size ? e.size : 1, n = e.color || "white", r = e.textureCoord || [0, 0, 1, 1], s = e.offset || [0, 0], o = void 0 !== e.opacity ? e.opacity : 1, a = void 0 !== e.rotation ? e.rotation : 0, l = { inFragmentShader: !1, variables: [], attributes: [], stringLiteralsMap: {}, functions: {} }, h = Gd(l, i, Rd | Ed), c = Gd(l, s, Rd), u = Gd(l, r, Rd), d = Gd(l, a, Ed), g = { inFragmentShader: !0, variables: l.variables, attributes: [], stringLiteralsMap: l.stringLiteralsMap, functions: {} }, f = Gd(g, n, Cd), p = Gd(g, o, Ed); let m = "1.0"; const _ = `vec2(${Gd(g, i, Rd | Ed)}).x`; switch (e.symbolType) { case "square": case "image": break; case "circle": m = `(1.0-smoothstep(1.-4./${_},1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))`; break; case "triangle": const t = "(v_quadCoord*2.-1.)", i = `(atan(${t}.x,${t}.y))`; m = `(1.0-smoothstep(.5-3./${_},.5,cos(floor(.5+${i}/2.094395102)*2.094395102-${i})*length(${t})))`; break; default: throw new Error("Unexpected symbol type: " + e.symbolType) }const y = (new Qd).setSizeExpression(`vec2(${h})`).setRotationExpression(d).setSymbolOffsetExpression(c).setTextureCoordinateExpression(u).setSymbolRotateWithView(!!e.rotateWithView).setColorExpression(`vec4(${f}.rgb, ${f}.a * ${p} * ${m})`); if (t.filter) { const e = Gd(g, t.filter, bd); y.setFragmentDiscardExpression(`!${e}`) } const x = {}; if (g.variables.forEach((function (e) { const i = Kd(e); y.addUniform(`float ${i}`), x[i] = function () { if (!t.variables || void 0 === t.variables[e]) throw new Error(`The following variable is missing from the style: ${e}`); let i = t.variables[e]; return "string" == typeof i && (i = Dd(l, i)), void 0 !== i ? i : -9999999 } })), "image" === e.symbolType && e.src) { const t = new Image; t.crossOrigin = void 0 === e.crossOrigin ? "anonymous" : e.crossOrigin, t.src = e.src, y.addUniform("sampler2D u_texture").setColorExpression(y.getColorExpression() + " * texture2D(u_texture, v_texCoord)"), x.u_texture = t } return g.attributes.forEach((function (t) { l.attributes.includes(t) || l.attributes.push(t), y.addVarying(`v_${t}`, "float", `a_${t}`) })), l.attributes.forEach((function (t) { y.addAttribute(`float a_${t}`) })), { builder: y, attributes: l.attributes.map((function (t) { return { name: t, callback: function (e, i) { let n = i[t]; return "string" == typeof n && (n = Dd(l, n)), void 0 !== n ? n : -9999999 } } })), uniforms: x } } class eg { constructor(t) { this.opacity_ = t.opacity, this.rotateWithView_ = t.rotateWithView, this.rotation_ = t.rotation, this.scale_ = t.scale, this.scaleArray_ = Va(t.scale), this.displacement_ = t.displacement, this.declutterMode_ = t.declutterMode } clone() { const t = this.getScale(); return new eg({ opacity: this.getOpacity(), scale: Array.isArray(t) ? t.slice() : t, rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), displacement: this.getDisplacement().slice(), declutterMode: this.getDeclutterMode() }) } getOpacity() { return this.opacity_ } getRotateWithView() { return this.rotateWithView_ } getRotation() { return this.rotation_ } getScale() { return this.scale_ } getScaleArray() { return this.scaleArray_ } getDisplacement() { return this.displacement_ } getDeclutterMode() { return this.declutterMode_ } getAnchor() { return B() } getImage(t) { return B() } getHitDetectionImage() { return B() } getPixelRatio(t) { return 1 } getImageState() { return B() } getImageSize() { return B() } getOrigin() { return B() } getSize() { return B() } setDisplacement(t) { this.displacement_ = t } setOpacity(t) { this.opacity_ = t } setRotateWithView(t) { this.rotateWithView_ = t } setRotation(t) { this.rotation_ = t } setScale(t) { this.scale_ = t, this.scaleArray_ = Va(t) } listenImageChange(t) { B() } load() { B() } unlistenImageChange(t) { B() } } class ig extends eg { constructor(t) { super({ opacity: 1, rotateWithView: void 0 !== t.rotateWithView && t.rotateWithView, rotation: void 0 !== t.rotation ? t.rotation : 0, scale: void 0 !== t.scale ? t.scale : 1, displacement: void 0 !== t.displacement ? t.displacement : [0, 0], declutterMode: t.declutterMode }), this.canvas_ = void 0, this.hitDetectionCanvas_ = null, this.fill_ = void 0 !== t.fill ? t.fill : null, this.origin_ = [0, 0], this.points_ = t.points, this.radius_ = void 0 !== t.radius ? t.radius : t.radius1, this.radius2_ = t.radius2, this.angle_ = void 0 !== t.angle ? t.angle : 0, this.stroke_ = void 0 !== t.stroke ? t.stroke : null, this.size_ = null, this.renderOptions_ = null, this.render() } clone() { const t = this.getScale(), e = new ig({ fill: this.getFill() ? this.getFill().clone() : void 0, points: this.getPoints(), radius: this.getRadius(), radius2: this.getRadius2(), angle: this.getAngle(), stroke: this.getStroke() ? this.getStroke().clone() : void 0, rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), scale: Array.isArray(t) ? t.slice() : t, displacement: this.getDisplacement().slice(), declutterMode: this.getDeclutterMode() }); return e.setOpacity(this.getOpacity()), e } getAnchor() { const t = this.size_; if (!t) return null; const e = this.getDisplacement(), i = this.getScaleArray(); return [t[0] / 2 - e[0] / i[0], t[1] / 2 + e[1] / i[1]] } getAngle() { return this.angle_ } getFill() { return this.fill_ } setFill(t) { this.fill_ = t, this.render() } getHitDetectionImage() { return this.hitDetectionCanvas_ || this.createHitDetectionCanvas_(this.renderOptions_), this.hitDetectionCanvas_ } getImage(t) { let e = this.canvas_[t]; if (!e) { const i = this.renderOptions_, n = Dr(i.size * t, i.size * t); this.draw_(i, n, t), e = n.canvas, this.canvas_[t] = e } return e } getPixelRatio(t) { return t } getImageSize() { return this.size_ } getImageState() { return Lr } getOrigin() { return this.origin_ } getPoints() { return this.points_ } getRadius() { return this.radius_ } getRadius2() { return this.radius2_ } getSize() { return this.size_ } getStroke() { return this.stroke_ } setStroke(t) { this.stroke_ = t, this.render() } listenImageChange(t) { } load() { } unlistenImageChange(t) { } calculateLineJoinSize_(t, e, i) { if (0 === e || this.points_ === 1 / 0 || "bevel" !== t && "miter" !== t) return e; let n = this.radius_, r = void 0 === this.radius2_ ? n : this.radius2_; if (n < r) { const t = n; n = r, r = t } const s = void 0 === this.radius2_ ? this.points_ : 2 * this.points_, o = 2 * Math.PI / s, a = r * Math.sin(o), l = n - Math.sqrt(r * r - a * a), h = Math.sqrt(a * a + l * l), c = h / a; if ("miter" === t && c <= i) return c * e; const u = e / 2 / c, d = e / 2 * (l / h), g = Math.sqrt((n + u) * (n + u) + d * d) - n; if (void 0 === this.radius2_ || "bevel" === t) return 2 * g; const f = n * Math.sin(o), p = r - Math.sqrt(n * n - f * f), m = Math.sqrt(f * f + p * p) / f; if (m <= i) { const t = m * e / 2 - r - n; return 2 * Math.max(g, t) } return 2 * g } createRenderOptions() { let t, e = Gs, i = 0, n = null, r = 0, s = 0; this.stroke_ && (t = this.stroke_.getColor(), null === t && (t = Bs), t = fl(t), s = this.stroke_.getWidth(), void 0 === s && (s = 1), n = this.stroke_.getLineDash(), r = this.stroke_.getLineDashOffset(), e = this.stroke_.getLineJoin(), void 0 === e && (e = Gs), i = this.stroke_.getMiterLimit(), void 0 === i && (i = js)); const o = this.calculateLineJoinSize_(e, s, i), a = Math.max(this.radius_, this.radius2_ || 0); return { strokeStyle: t, strokeWidth: s, size: Math.ceil(2 * a + o), lineDash: n, lineDashOffset: r, lineJoin: e, miterLimit: i } } render() { this.renderOptions_ = this.createRenderOptions(); const t = this.renderOptions_.size; this.canvas_ = {}, this.size_ = [t, t] } draw_(t, e, i) { if (e.scale(i, i), e.translate(t.size / 2, t.size / 2), this.createPath_(e), this.fill_) { let t = this.fill_.getColor(); null === t && (t = Ns), e.fillStyle = fl(t), e.fill() } this.stroke_ && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke()) } createHitDetectionCanvas_(t) { if (this.fill_) { let e = this.fill_.getColor(), i = 0; if ("string" == typeof e && (e = $r(e)), null === e ? i = 1 : Array.isArray(e) && (i = 4 === e.length ? e[3] : 1), 0 === i) { const e = Dr(t.size, t.size); this.hitDetectionCanvas_ = e.canvas, this.drawHitDetectionCanvas_(t, e) } } this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.getImage(1)) } createPath_(t) { let e = this.points_; const i = this.radius_; if (e === 1 / 0) t.arc(0, 0, i, 0, 2 * Math.PI); else { const n = void 0 === this.radius2_ ? i : this.radius2_; void 0 !== this.radius2_ && (e *= 2); const r = this.angle_ - Math.PI / 2, s = 2 * Math.PI / e; for (let o = 0; o < e; o++) { const e = r + o * s, a = o % 2 == 0 ? i : n; t.lineTo(a * Math.cos(e), a * Math.sin(e)) } t.closePath() } } drawHitDetectionCanvas_(t, e) { e.translate(t.size / 2, t.size / 2), this.createPath_(e), e.fillStyle = Ns, e.fill(), this.stroke_ && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke()) } } class ng extends ig { constructor(t) { super({ points: 1 / 0, fill: (t = t || { radius: 5 }).fill, radius: t.radius, stroke: t.stroke, scale: void 0 !== t.scale ? t.scale : 1, rotation: void 0 !== t.rotation ? t.rotation : 0, rotateWithView: void 0 !== t.rotateWithView && t.rotateWithView, displacement: void 0 !== t.displacement ? t.displacement : [0, 0], declutterMode: t.declutterMode }) } clone() { const t = this.getScale(), e = new ng({ fill: this.getFill() ? this.getFill().clone() : void 0, stroke: this.getStroke() ? this.getStroke().clone() : void 0, radius: this.getRadius(), scale: Array.isArray(t) ? t.slice() : t, rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), displacement: this.getDisplacement().slice(), declutterMode: this.getDeclutterMode() }); return e.setOpacity(this.getOpacity()), e } setRadius(t) { this.radius_ = t, this.render() } } class rg { constructor(t) { t = t || {}, this.color_ = void 0 !== t.color ? t.color : null } clone() { const t = this.getColor(); return new rg({ color: Array.isArray(t) ? t.slice() : t || void 0 }) } getColor() { return this.color_ } setColor(t) { this.color_ = t } } let sg = null; class og extends v { constructor(t, e, i, n, r, s) { super(), this.hitDetectionImage_ = null, this.image_ = t, this.crossOrigin_ = n, this.canvas_ = {}, this.color_ = s, this.unlisten_ = null, this.imageState_ = r, this.size_ = i, this.src_ = e, this.tainted_ } initializeImage_() { this.image_ = new Image, null !== this.crossOrigin_ && (this.image_.crossOrigin = this.crossOrigin_) } isTainted_() { if (void 0 === this.tainted_ && this.imageState_ === Lr) { sg || (sg = Dr(1, 1)), sg.drawImage(this.image_, 0, 0); try { sg.getImageData(0, 0, 1, 1), this.tainted_ = !1 } catch (t) { sg = null, this.tainted_ = !0 } } return !0 === this.tainted_ } dispatchChangeEvent_() { this.dispatchEvent(S) } handleImageError_() { this.imageState_ = Mr, this.unlistenImage_(), this.dispatchChangeEvent_() } handleImageLoad_() { this.imageState_ = Lr, this.size_ ? (this.image_.width = this.size_[0], this.image_.height = this.size_[1]) : this.size_ = [this.image_.width, this.image_.height], this.unlistenImage_(), this.dispatchChangeEvent_() } getImage(t) { return this.image_ || this.initializeImage_(), this.replaceColor_(t), this.canvas_[t] ? this.canvas_[t] : this.image_ } getPixelRatio(t) { return this.replaceColor_(t), this.canvas_[t] ? t : 1 } getImageState() { return this.imageState_ } getHitDetectionImage() { if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_) if (this.isTainted_()) { const t = this.size_[0], e = this.size_[1], i = Dr(t, e); i.fillRect(0, 0, t, e), this.hitDetectionImage_ = i.canvas } else this.hitDetectionImage_ = this.image_; return this.hitDetectionImage_ } getSize() { return this.size_ } getSrc() { return this.src_ } load() { if (this.imageState_ === Pr) { this.image_ || this.initializeImage_(), this.imageState_ = Ir; try { this.image_.src = this.src_ } catch (t) { this.handleImageError_() } this.unlisten_ = Or(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this)) } } replaceColor_(t) { if (!this.color_ || this.canvas_[t] || this.imageState_ !== Lr) return; const e = this.image_, i = document.createElement("canvas"); i.width = Math.ceil(e.width * t), i.height = Math.ceil(e.height * t); const n = i.getContext("2d"); n.scale(t, t), n.drawImage(e, 0, 0), n.globalCompositeOperation = "multiply", n.fillStyle = Kr(this.color_), n.fillRect(0, 0, i.width / t, i.height / t), n.globalCompositeOperation = "destination-in", n.drawImage(e, 0, 0), this.canvas_[t] = i } unlistenImage_() { this.unlisten_ && (this.unlisten_(), this.unlisten_ = null) } } function ag(t, e, i, n, r, s) { let o = ns.get(e, n, s); return o || (o = new og(t, e, i, n, r, s), ns.set(e, n, s, o)), o } class lg extends eg { constructor(t) { const e = void 0 !== (t = t || {}).opacity ? t.opacity : 1, i = void 0 !== t.rotation ? t.rotation : 0, n = void 0 !== t.scale ? t.scale : 1, r = void 0 !== t.rotateWithView && t.rotateWithView; super({ opacity: e, rotation: i, scale: n, displacement: void 0 !== t.displacement ? t.displacement : [0, 0], rotateWithView: r, declutterMode: t.declutterMode }), this.anchor_ = void 0 !== t.anchor ? t.anchor : [.5, .5], this.normalizedAnchor_ = null, this.anchorOrigin_ = void 0 !== t.anchorOrigin ? t.anchorOrigin : "top-left", this.anchorXUnits_ = void 0 !== t.anchorXUnits ? t.anchorXUnits : "fraction", this.anchorYUnits_ = void 0 !== t.anchorYUnits ? t.anchorYUnits : "fraction", this.crossOrigin_ = void 0 !== t.crossOrigin ? t.crossOrigin : null; const s = void 0 !== t.img ? t.img : null; this.imgSize_ = t.imgSize; let o = t.src; at(!(void 0 !== o && s), 4), at(!s || s && this.imgSize_, 5), void 0 !== o && 0 !== o.length || !s || (o = s.src || z(s)), at(void 0 !== o && o.length > 0, 6); const a = void 0 !== t.src ? Pr : Lr; this.color_ = void 0 !== t.color ? $r(t.color) : null, this.iconImage_ = ag(s, o, void 0 !== this.imgSize_ ? this.imgSize_ : null, this.crossOrigin_, a, this.color_), this.offset_ = void 0 !== t.offset ? t.offset : [0, 0], this.offsetOrigin_ = void 0 !== t.offsetOrigin ? t.offsetOrigin : "top-left", this.origin_ = null, this.size_ = void 0 !== t.size ? t.size : null } clone() { const t = this.getScale(); return new lg({ anchor: this.anchor_.slice(), anchorOrigin: this.anchorOrigin_, anchorXUnits: this.anchorXUnits_, anchorYUnits: this.anchorYUnits_, color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0, crossOrigin: this.crossOrigin_, imgSize: this.imgSize_, offset: this.offset_.slice(), offsetOrigin: this.offsetOrigin_, opacity: this.getOpacity(), rotateWithView: this.getRotateWithView(), rotation: this.getRotation(), scale: Array.isArray(t) ? t.slice() : t, size: null !== this.size_ ? this.size_.slice() : void 0, src: this.getSrc(), displacement: this.getDisplacement().slice(), declutterMode: this.getDeclutterMode() }) } getAnchor() { let t = this.normalizedAnchor_; if (!t) { t = this.anchor_; const e = this.getSize(); if ("fraction" == this.anchorXUnits_ || "fraction" == this.anchorYUnits_) { if (!e) return null; t = this.anchor_.slice(), "fraction" == this.anchorXUnits_ && (t[0] *= e[0]), "fraction" == this.anchorYUnits_ && (t[1] *= e[1]) } if ("top-left" != this.anchorOrigin_) { if (!e) return null; t === this.anchor_ && (t = this.anchor_.slice()), "top-right" != this.anchorOrigin_ && "bottom-right" != this.anchorOrigin_ || (t[0] = -t[0] + e[0]), "bottom-left" != this.anchorOrigin_ && "bottom-right" != this.anchorOrigin_ || (t[1] = -t[1] + e[1]) } this.normalizedAnchor_ = t } const e = this.getDisplacement(), i = this.getScaleArray(); return [t[0] - e[0] / i[0], t[1] + e[1] / i[1]] } setAnchor(t) { this.anchor_ = t, this.normalizedAnchor_ = null } getColor() { return this.color_ } getImage(t) { return this.iconImage_.getImage(t) } getPixelRatio(t) { return this.iconImage_.getPixelRatio(t) } getImageSize() { return this.iconImage_.getSize() } getImageState() { return this.iconImage_.getImageState() } getHitDetectionImage() { return this.iconImage_.getHitDetectionImage() } getOrigin() { if (this.origin_) return this.origin_; let t = this.offset_; if ("top-left" != this.offsetOrigin_) { const e = this.getSize(), i = this.iconImage_.getSize(); if (!e || !i) return null; t = t.slice(), "top-right" != this.offsetOrigin_ && "bottom-right" != this.offsetOrigin_ || (t[0] = i[0] - e[0] - t[0]), "bottom-left" != this.offsetOrigin_ && "bottom-right" != this.offsetOrigin_ || (t[1] = i[1] - e[1] - t[1]) } return this.origin_ = t, this.origin_ } getSrc() { return this.iconImage_.getSrc() } getSize() { return this.size_ ? this.size_ : this.iconImage_.getSize() } listenImageChange(t) { this.iconImage_.addEventListener(S, t) } load() { this.iconImage_.load() } unlistenImageChange(t) { this.iconImage_.removeEventListener(S, t) } } class hg { constructor(t) { t = t || {}, this.color_ = void 0 !== t.color ? t.color : null, this.lineCap_ = t.lineCap, this.lineDash_ = void 0 !== t.lineDash ? t.lineDash : null, this.lineDashOffset_ = t.lineDashOffset, this.lineJoin_ = t.lineJoin, this.miterLimit_ = t.miterLimit, this.width_ = t.width } clone() { const t = this.getColor(); return new hg({ color: Array.isArray(t) ? t.slice() : t || void 0, lineCap: this.getLineCap(), lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0, lineDashOffset: this.getLineDashOffset(), lineJoin: this.getLineJoin(), miterLimit: this.getMiterLimit(), width: this.getWidth() }) } getColor() { return this.color_ } getLineCap() { return this.lineCap_ } getLineDash() { return this.lineDash_ } getLineDashOffset() { return this.lineDashOffset_ } getLineJoin() { return this.lineJoin_ } getMiterLimit() { return this.miterLimit_ } getWidth() { return this.width_ } setColor(t) { this.color_ = t } setLineCap(t) { this.lineCap_ = t } setLineDash(t) { this.lineDash_ = t } setLineDashOffset(t) { this.lineDashOffset_ = t } setLineJoin(t) { this.lineJoin_ = t } setMiterLimit(t) { this.miterLimit_ = t } setWidth(t) { this.width_ = t } } class cg { constructor(t) { t = t || {}, this.geometry_ = null, this.geometryFunction_ = pg, void 0 !== t.geometry && this.setGeometry(t.geometry), this.fill_ = void 0 !== t.fill ? t.fill : null, this.image_ = void 0 !== t.image ? t.image : null, this.renderer_ = void 0 !== t.renderer ? t.renderer : null, this.hitDetectionRenderer_ = void 0 !== t.hitDetectionRenderer ? t.hitDetectionRenderer : null, this.stroke_ = void 0 !== t.stroke ? t.stroke : null, this.text_ = void 0 !== t.text ? t.text : null, this.zIndex_ = t.zIndex } clone() { let t = this.getGeometry(); return t && "object" == typeof t && (t = t.clone()), new cg({ geometry: t, fill: this.getFill() ? this.getFill().clone() : void 0, image: this.getImage() ? this.getImage().clone() : void 0, renderer: this.getRenderer(), stroke: this.getStroke() ? this.getStroke().clone() : void 0, text: this.getText() ? this.getText().clone() : void 0, zIndex: this.getZIndex() }) } getRenderer() { return this.renderer_ } setRenderer(t) { this.renderer_ = t } setHitDetectionRenderer(t) { this.hitDetectionRenderer_ = t } getHitDetectionRenderer() { return this.hitDetectionRenderer_ } getGeometry() { return this.geometry_ } getGeometryFunction() { return this.geometryFunction_ } getFill() { return this.fill_ } setFill(t) { this.fill_ = t } getImage() { return this.image_ } setImage(t) { this.image_ = t } getStroke() { return this.stroke_ } setStroke(t) { this.stroke_ = t } getText() { return this.text_ } setText(t) { this.text_ = t } getZIndex() { return this.zIndex_ } setGeometry(t) { "function" == typeof t ? this.geometryFunction_ = t : "string" == typeof t ? this.geometryFunction_ = function (e) { return e.get(t) } : t ? void 0 !== t && (this.geometryFunction_ = function () { return t }) : this.geometryFunction_ = pg, this.geometry_ = t } setZIndex(t) { this.zIndex_ = t } } function ug(t) { let e; if ("function" == typeof t) e = t; else { let i; if (Array.isArray(t)) i = t; else { at("function" == typeof t.getZIndex, 41); i = [t] } e = function () { return i } } return e } let dg = null; function gg(t, e) { if (!dg) { const t = new rg({ color: "rgba(255,255,255,0.4)" }), e = new hg({ color: "#3399CC", width: 1.25 }); dg = [new cg({ image: new ng({ fill: t, stroke: e, radius: 5 }), fill: t, stroke: e })] } return dg } function fg() { const t = {}, e = [255, 255, 255, 1], i = [0, 153, 255, 1]; return t.Polygon = [new cg({ fill: new rg({ color: [255, 255, 255, .5] }) })], t.MultiPolygon = t.Polygon, t.LineString = [new cg({ stroke: new hg({ color: e, width: 5 }) }), new cg({ stroke: new hg({ color: i, width: 3 }) })], t.MultiLineString = t.LineString, t.Circle = t.Polygon.concat(t.LineString), t.Point = [new cg({ image: new ng({ radius: 6, fill: new rg({ color: i }), stroke: new hg({ color: e, width: 1.5 }) }), zIndex: 1 / 0 })], t.MultiPoint = t.Point, t.GeometryCollection = t.Polygon.concat(t.LineString, t.Point), t } function pg(t) { return t.getGeometry() } class mg { constructor(t) { t = t || {}, this.font_ = t.font, this.rotation_ = t.rotation, this.rotateWithView_ = t.rotateWithView, this.scale_ = t.scale, this.scaleArray_ = Va(void 0 !== t.scale ? t.scale : 1), this.text_ = t.text, this.textAlign_ = t.textAlign, this.justify_ = t.justify, this.textBaseline_ = t.textBaseline, this.fill_ = void 0 !== t.fill ? t.fill : new rg({ color: "#333" }), this.maxAngle_ = void 0 !== t.maxAngle ? t.maxAngle : Math.PI / 4, this.placement_ = void 0 !== t.placement ? t.placement : "point", this.overflow_ = !!t.overflow, this.stroke_ = void 0 !== t.stroke ? t.stroke : null, this.offsetX_ = void 0 !== t.offsetX ? t.offsetX : 0, this.offsetY_ = void 0 !== t.offsetY ? t.offsetY : 0, this.backgroundFill_ = t.backgroundFill ? t.backgroundFill : null, this.backgroundStroke_ = t.backgroundStroke ? t.backgroundStroke : null, this.padding_ = void 0 === t.padding ? null : t.padding } clone() { const t = this.getScale(); return new mg({ font: this.getFont(), placement: this.getPlacement(), maxAngle: this.getMaxAngle(), overflow: this.getOverflow(), rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), scale: Array.isArray(t) ? t.slice() : t, text: this.getText(), textAlign: this.getTextAlign(), justify: this.getJustify(), textBaseline: this.getTextBaseline(), fill: this.getFill() ? this.getFill().clone() : void 0, stroke: this.getStroke() ? this.getStroke().clone() : void 0, offsetX: this.getOffsetX(), offsetY: this.getOffsetY(), backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0, backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0, padding: this.getPadding() || void 0 }) } getOverflow() { return this.overflow_ } getFont() { return this.font_ } getMaxAngle() { return this.maxAngle_ } getPlacement() { return this.placement_ } getOffsetX() { return this.offsetX_ } getOffsetY() { return this.offsetY_ } getFill() { return this.fill_ } getRotateWithView() { return this.rotateWithView_ } getRotation() { return this.rotation_ } getScale() { return this.scale_ } getScaleArray() { return this.scaleArray_ } getStroke() { return this.stroke_ } getText() { return this.text_ } getTextAlign() { return this.textAlign_ } getJustify() { return this.justify_ } getTextBaseline() { return this.textBaseline_ } getBackgroundFill() { return this.backgroundFill_ } getBackgroundStroke() { return this.backgroundStroke_ } getPadding() { return this.padding_ } setOverflow(t) { this.overflow_ = t } setFont(t) { this.font_ = t } setMaxAngle(t) { this.maxAngle_ = t } setOffsetX(t) { this.offsetX_ = t } setOffsetY(t) { this.offsetY_ = t } setPlacement(t) { this.placement_ = t } setRotateWithView(t) { this.rotateWithView_ = t } setFill(t) { this.fill_ = t } setRotation(t) { this.rotation_ = t } setScale(t) { this.scale_ = t, this.scaleArray_ = Va(void 0 !== t ? t : 1) } setStroke(t) { this.stroke_ = t } setText(t) { this.text_ = t } setTextAlign(t) { this.textAlign_ = t } setJustify(t) { this.justify_ = t } setTextBaseline(t) { this.textBaseline_ = t } setBackgroundFill(t) { this.backgroundFill_ = t } setBackgroundStroke(t) { this.backgroundStroke_ = t } setPadding(t) { this.padding_ = t } } function _g(t) { return new cg({ fill: yg(t, ""), stroke: xg(t, ""), text: vg(t), image: Sg(t) }) } function yg(t, e) { const i = t[e + "fill-color"]; if (i) return new rg({ color: i }) } function xg(t, e) { const i = t[e + "stroke-width"], n = t[e + "stroke-color"]; if (i || n) return new hg({ width: i, color: n, lineCap: t[e + "stroke-line-cap"], lineJoin: t[e + "stroke-line-join"], lineDash: t[e + "stroke-line-dash"], lineDashOffset: t[e + "stroke-line-dash-offset"], miterLimit: t[e + "stroke-miter-limit"] }) } function vg(t) { const e = t["text-value"]; if (!e) return; return new mg({ text: e, font: t["text-font"], maxAngle: t["text-max-angle"], offsetX: t["text-offset-x"], offsetY: t["text-offset-y"], overflow: t["text-overflow"], placement: t["text-placement"], scale: t["text-scale"], rotateWithView: t["text-rotate-with-view"], rotation: t["text-rotation"], textAlign: t["text-align"], justify: t["text-justify"], textBaseline: t["text-baseline"], padding: t["text-padding"], fill: yg(t, "text-"), backgroundFill: yg(t, "text-background-"), stroke: xg(t, "text-"), backgroundStroke: xg(t, "text-background-") }) } function Sg(t) { const e = t["icon-src"], i = t["icon-img"]; if (e || i) { return new lg({ src: e, img: i, imgSize: t["icon-img-size"], anchor: t["icon-anchor"], anchorOrigin: t["icon-anchor-origin"], anchorXUnits: t["icon-anchor-x-units"], anchorYUnits: t["icon-anchor-y-units"], color: t["icon-color"], crossOrigin: t["icon-cross-origin"], offset: t["icon-offset"], displacement: t["icon-displacement"], opacity: t["icon-opacity"], scale: t["icon-scale"], rotation: t["icon-rotation"], rotateWithView: t["icon-rotate-with-view"], size: t["icon-size"], declutterMode: t["icon-declutter-mode"] }) } const n = t["shape-points"]; if (n) { const e = "shape-"; return new ig({ points: n, fill: yg(t, e), stroke: xg(t, e), radius: t["shape-radius"], radius1: t["shape-radius1"], radius2: t["shape-radius2"], angle: t["shape-angle"], displacement: t["shape-displacement"], rotation: t["shape-rotation"], rotateWithView: t["shape-rotate-with-view"], scale: t["shape-scale"], declutterMode: t["shape-declutter-mode"] }) } const r = t["circle-radius"]; if (r) { const e = "circle-"; return new ng({ radius: r, fill: yg(t, e), stroke: xg(t, e), displacement: t["circle-displacement"], scale: t["circle-scale"], rotation: t["circle-rotation"], rotateWithView: t["circle-rotate-with-view"], declutterMode: t["circle-declutter-mode"] }) } } const wg = { "image/png": !0, "image/jpeg": !0, "image/gif": !0, "image/webp": !0 }, Eg = { "application/vnd.mapbox-vector-tile": !0, "application/geo+json": !0 }; function Tg(t, e) { let i, n; for (let r = 0; r < t.length; ++r) { const s = t[r]; if ("item" === s.rel) { if (s.type === e) { i = s.href; break } (wg[s.type] || !n && s.type.startsWith("image/")) && (n = s.href) } } if (!i) { if (!n) throw new Error('Could not find "item" link'); i = n } return i } function Cg(t, e, i) { let n, r; const s = {}; for (let i = 0; i < t.length; ++i) { const o = t[i]; if (s[o.type] = o.href, "item" === o.rel) { if (o.type === e) { n = o.href; break } Eg[o.type] && (r = o.href) } } if (!n && i) for (let t = 0; t < i.length; ++t) { const e = i[t]; if (s[e]) { n = s[e]; break } } if (!n) { if (!r) throw new Error('Could not find "item" link'); n = r } return n } function bg(t, e, i, n) { let r = t.projection; if (!r && (r = Ui(e.crs), !r)) throw new Error(`Unsupported CRS: ${e.crs}`); const s = "en" !== r.getAxisOrientation().substr(0, 2), o = e.tileMatrices, a = {}; for (let t = 0; t < o.length; ++t) { const e = o[t]; a[e.id] = e } const l = {}, h = []; if (n) for (let t = 0; t < n.length; ++t) { const e = n[t], i = e.tileMatrix; h.push(i), l[i] = e } else for (let t = 0; t < o.length; ++t) { const e = o[t].id; h.push(e) } const c = h.length, u = new Array(c), d = new Array(c), g = new Array(c), f = new Array(c), p = [-1 / 0, -1 / 0, 1 / 0, 1 / 0]; for (let t = 0; t < c; ++t) { const e = h[t], i = a[e], n = i.pointOfOrigin; u[t] = s ? [n[1], n[0]] : n, d[t] = i.cellSize, g[t] = [i.matrixWidth, i.matrixHeight], f[t] = [i.tileWidth, i.tileHeight]; const r = l[e]; if (r) { const e = i.cellSize * i.tileWidth, n = u[t][0] + r.minTileCol * e, s = u[t][0] + (r.maxTileCol + 1) * e, o = i.cellSize * i.tileHeight; let a, l; "bottomLeft" === i.cornerOfOrigin ? (a = u[t][1] + r.minTileRow * o, l = u[t][1] + (r.maxTileRow + 1) * o) : (a = u[t][1] - (r.maxTileRow + 1) * o, l = u[t][1] - r.minTileRow * o), ye(p, [n, a, s, l], p) } } const m = new ql({ origins: u, resolutions: d, sizes: g, tileSizes: f, extent: n ? p : void 0 }), _ = t.context, y = t.url; return { grid: m, urlTemplate: i, urlFunction: function (t, e, r) { if (!t) return; const s = h[t[0]], o = a[s], c = "bottomLeft" === o.cornerOfOrigin, u = { tileMatrix: s, tileCol: t[1], tileRow: c ? -t[2] - 1 : t[2] }; if (n) { const t = l[o.id]; if (u.tileCol < t.minTileCol || u.tileCol > t.maxTileCol || u.tileRow < t.minTileRow || u.tileRow > t.maxTileRow) return } Object.assign(u, _); const d = i.replace(/\{(\w+?)\}/g, (function (t, e) { return u[e] })); return Tl(y, d) } } } function Rg(t) { return El(t.url).then((function (e) { return function (t, e) { const i = e.tileMatrixSetLimits; let n; if ("map" === e.dataType) n = Tg(e.links, t.mediaType); else { if ("vector" !== e.dataType) throw new Error('Expected tileset data type to be "map" or "vector"'); n = Cg(e.links, t.mediaType, t.supportedMediaTypes) } if (e.tileMatrixSet) return bg(t, e.tileMatrixSet, n, i); const r = e.links.find((t => "http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme" === t.rel)); if (!r) throw new Error("Expected http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme link or tileMatrixSet"); const s = r.href; return El(Tl(t.url, s)).then((function (e) { return bg(t, e, n, i) })) }(t, e) })) } const Pg = "renderOrder"; class Ig extends vs { constructor(t) { t = t || {}; const e = Object.assign({}, t); delete e.style, delete e.renderBuffer, delete e.updateWhileAnimating, delete e.updateWhileInteracting, super(e), this.declutter_ = void 0 !== t.declutter && t.declutter, this.renderBuffer_ = void 0 !== t.renderBuffer ? t.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(t.style), this.updateWhileAnimating_ = void 0 !== t.updateWhileAnimating && t.updateWhileAnimating, this.updateWhileInteracting_ = void 0 !== t.updateWhileInteracting && t.updateWhileInteracting } getDeclutter() { return this.declutter_ } getFeatures(t) { return super.getFeatures(t) } getRenderBuffer() { return this.renderBuffer_ } getRenderOrder() { return this.get(Pg) } getStyle() { return this.style_ } getStyleFunction() { return this.styleFunction_ } getUpdateWhileAnimating() { return this.updateWhileAnimating_ } getUpdateWhileInteracting() { return this.updateWhileInteracting_ } renderDeclutter(t) { t.declutterTree || (t.declutterTree = new xh(9)), this.getRenderer().renderDeclutter(t) } setRenderOrder(t) { this.set(Pg, t) } setStyle(t) { let e; if (void 0 === t) e = gg; else if (null === t) e = null; else if ("function" == typeof t) e = t; else if (t instanceof cg) e = t; else if (Array.isArray(t)) { const i = t.length, n = new Array(i); for (let e = 0; e < i; ++e) { const i = t[e]; n[e] = i instanceof cg ? i : _g(i) } e = n } else e = _g(t); this.style_ = e, this.styleFunction_ = null === t ? void 0 : ug(this.style_), this.changed() } } const Lg = "GENERATE_POLYGON_BUFFERS", Mg = "GENERATE_POINT_BUFFERS", Fg = "GENERATE_LINE_STRING_BUFFERS"; var Ag = { exports: {} }; function Og(t, e, i) { i = i || 2; var n, r, s, o, a, l, h, c = e && e.length, u = c ? e[0] * i : t.length, d = Ng(t, 0, u, i, !0), g = []; if (!d || d.next === d.prev) return g; if (c && (d = function (t, e, i, n) { var r, s, o, a = []; for (r = 0, s = e.length; r < s; r++)(o = Ng(t, e[r] * n, r < s - 1 ? e[r + 1] * n : t.length, n, !1)) === o.next && (o.steiner = !0), a.push(Zg(o)); for (a.sort(zg), r = 0; r < a.length; r++)i = Dg(i = Xg(a[r], i), i.next); return i }(t, e, d, i)), t.length > 80 * i) { n = s = t[0], r = o = t[1]; for (var f = i; f < u; f += i)(a = t[f]) < n && (n = a), (l = t[f + 1]) < r && (r = l), a > s && (s = a), l > o && (o = l); h = 0 !== (h = Math.max(s - n, o - r)) ? 1 / h : 0 } return kg(d, g, i, n, r, h), g } function Ng(t, e, i, n, r) { var s, o; if (r === of(t, e, i, n) > 0) for (s = e; s < i; s += n)o = nf(s, t[s], t[s + 1], o); else for (s = i - n; s >= e; s -= n)o = nf(s, t[s], t[s + 1], o); return o && Hg(o, o.next) && (rf(o), o = o.next), o } function Dg(t, e) { if (!t) return t; e || (e = t); var i, n = t; do { if (i = !1, n.steiner || !Hg(n, n.next) && 0 !== qg(n.prev, n, n.next)) n = n.next; else { if (rf(n), (n = e = n.prev) === n.next) break; i = !0 } } while (i || n !== e); return e } function kg(t, e, i, n, r, s, o) { if (t) { !o && s && function (t, e, i, n) { var r = t; do { null === r.z && (r.z = Wg(r.x, r.y, e, i, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next } while (r !== t); r.prevZ.nextZ = null, r.prevZ = null, function (t) { var e, i, n, r, s, o, a, l, h = 1; do { for (i = t, t = null, s = null, o = 0; i;) { for (o++, n = i, a = 0, e = 0; e < h && (a++, n = n.nextZ); e++); for (l = h; a > 0 || l > 0 && n;)0 !== a && (0 === l || !n || i.z <= n.z) ? (r = i, i = i.nextZ, a--) : (r = n, n = n.nextZ, l--), s ? s.nextZ = r : t = r, r.prevZ = s, s = r; i = n } s.nextZ = null, h *= 2 } while (o > 1) }(r) }(t, n, r, s); for (var a, l, h = t; t.prev !== t.next;)if (a = t.prev, l = t.next, s ? jg(t, n, r, s) : Gg(t)) e.push(a.i / i), e.push(t.i / i), e.push(l.i / i), rf(t), t = l.next, h = l.next; else if ((t = l) === h) { o ? 1 === o ? kg(t = Bg(Dg(t), e, i), e, i, n, r, s, 2) : 2 === o && Ug(t, e, i, n, r, s) : kg(Dg(t), e, i, n, r, s, 1); break } } } function Gg(t) { var e = t.prev, i = t, n = t.next; if (qg(e, i, n) >= 0) return !1; for (var r = t.next.next; r !== t.prev;) { if (Yg(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) && qg(r.prev, r, r.next) >= 0) return !1; r = r.next } return !0 } function jg(t, e, i, n) { var r = t.prev, s = t, o = t.next; if (qg(r, s, o) >= 0) return !1; for (var a = r.x < s.x ? r.x < o.x ? r.x : o.x : s.x < o.x ? s.x : o.x, l = r.y < s.y ? r.y < o.y ? r.y : o.y : s.y < o.y ? s.y : o.y, h = r.x > s.x ? r.x > o.x ? r.x : o.x : s.x > o.x ? s.x : o.x, c = r.y > s.y ? r.y > o.y ? r.y : o.y : s.y > o.y ? s.y : o.y, u = Wg(a, l, e, i, n), d = Wg(h, c, e, i, n), g = t.prevZ, f = t.nextZ; g && g.z >= u && f && f.z <= d;) { if (g !== t.prev && g !== t.next && Yg(r.x, r.y, s.x, s.y, o.x, o.y, g.x, g.y) && qg(g.prev, g, g.next) >= 0) return !1; if (g = g.prevZ, f !== t.prev && f !== t.next && Yg(r.x, r.y, s.x, s.y, o.x, o.y, f.x, f.y) && qg(f.prev, f, f.next) >= 0) return !1; f = f.nextZ } for (; g && g.z >= u;) { if (g !== t.prev && g !== t.next && Yg(r.x, r.y, s.x, s.y, o.x, o.y, g.x, g.y) && qg(g.prev, g, g.next) >= 0) return !1; g = g.prevZ } for (; f && f.z <= d;) { if (f !== t.prev && f !== t.next && Yg(r.x, r.y, s.x, s.y, o.x, o.y, f.x, f.y) && qg(f.prev, f, f.next) >= 0) return !1; f = f.nextZ } return !0 } function Bg(t, e, i) { var n = t; do { var r = n.prev, s = n.next.next; !Hg(r, s) && $g(r, n, n.next, s) && tf(r, s) && tf(s, r) && (e.push(r.i / i), e.push(n.i / i), e.push(s.i / i), rf(n), rf(n.next), n = t = s), n = n.next } while (n !== t); return Dg(n) } function Ug(t, e, i, n, r, s) { var o = t; do { for (var a = o.next.next; a !== o.prev;) { if (o.i !== a.i && Kg(o, a)) { var l = ef(o, a); return o = Dg(o, o.next), l = Dg(l, l.next), kg(o, e, i, n, r, s), void kg(l, e, i, n, r, s) } a = a.next } o = o.next } while (o !== t) } function zg(t, e) { return t.x - e.x } function Xg(t, e) { var i = function (t, e) { var i, n = e, r = t.x, s = t.y, o = -1 / 0; do { if (s <= n.y && s >= n.next.y && n.next.y !== n.y) { var a = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (a <= r && a > o) { if (o = a, a === r) { if (s === n.y) return n; if (s === n.next.y) return n.next } i = n.x < n.next.x ? n : n.next } } n = n.next } while (n !== e); if (!i) return null; if (r === o) return i; var l, h = i, c = i.x, u = i.y, d = 1 / 0; n = i; do { r >= n.x && n.x >= c && r !== n.x && Yg(s < u ? r : o, s, c, u, s < u ? o : r, s, n.x, n.y) && (l = Math.abs(s - n.y) / (r - n.x), tf(n, t) && (l < d || l === d && (n.x > i.x || n.x === i.x && Vg(i, n))) && (i = n, d = l)), n = n.next } while (n !== h); return i }(t, e); if (!i) return e; var n = ef(i, t), r = Dg(i, i.next); return Dg(n, n.next), e === i ? r : e } function Vg(t, e) { return qg(t.prev, t, e.prev) < 0 && qg(e.next, t, t.next) < 0 } function Wg(t, e, i, n, r) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 } function Zg(t) { var e = t, i = t; do { (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next } while (e !== t); return i } function Yg(t, e, i, n, r, s, o, a) { return (r - o) * (e - a) - (t - o) * (s - a) >= 0 && (t - o) * (n - a) - (i - o) * (e - a) >= 0 && (i - o) * (s - a) - (r - o) * (n - a) >= 0 } function Kg(t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) { var i = t; do { if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && $g(i, i.next, t, e)) return !0; i = i.next } while (i !== t); return !1 }(t, e) && (tf(t, e) && tf(e, t) && function (t, e) { var i = t, n = !1, r = (t.x + e.x) / 2, s = (t.y + e.y) / 2; do { i.y > s != i.next.y > s && i.next.y !== i.y && r < (i.next.x - i.x) * (s - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next } while (i !== t); return n }(t, e) && (qg(t.prev, t, e.prev) || qg(t, e.prev, e)) || Hg(t, e) && qg(t.prev, t, t.next) > 0 && qg(e.prev, e, e.next) > 0) } function qg(t, e, i) { return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y) } function Hg(t, e) { return t.x === e.x && t.y === e.y } function $g(t, e, i, n) { var r = Qg(qg(t, e, i)), s = Qg(qg(t, e, n)), o = Qg(qg(i, n, t)), a = Qg(qg(i, n, e)); return r !== s && o !== a || (!(0 !== r || !Jg(t, i, e)) || (!(0 !== s || !Jg(t, n, e)) || (!(0 !== o || !Jg(i, t, n)) || !(0 !== a || !Jg(i, e, n))))) } function Jg(t, e, i) { return e.x <= Math.max(t.x, i.x) && e.x >= Math.min(t.x, i.x) && e.y <= Math.max(t.y, i.y) && e.y >= Math.min(t.y, i.y) } function Qg(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 } function tf(t, e) { return qg(t.prev, t, t.next) < 0 ? qg(t, e, t.next) >= 0 && qg(t, t.prev, e) >= 0 : qg(t, e, t.prev) < 0 || qg(t, t.next, e) < 0 } function ef(t, e) { var i = new sf(t.i, t.x, t.y), n = new sf(e.i, e.x, e.y), r = t.next, s = e.prev; return t.next = e, e.prev = t, i.next = r, r.prev = i, n.next = i, i.prev = n, s.next = n, n.prev = s, n } function nf(t, e, i, n) { var r = new sf(t, e, i); return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r } function rf(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function sf(t, e, i) { this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function of(t, e, i, n) { for (var r = 0, s = e, o = i - n; s < i; s += n)r += (t[o] - t[s]) * (t[s + 1] + t[o + 1]), o = s; return r } Ag.exports = Og, Ag.exports.default = Og, Og.deviation = function (t, e, i, n) { var r = e && e.length, s = r ? e[0] * i : t.length, o = Math.abs(of(t, 0, s, i)); if (r) for (var a = 0, l = e.length; a < l; a++) { var h = e[a] * i, c = a < l - 1 ? e[a + 1] * i : t.length; o -= Math.abs(of(t, h, c, i)) } var u = 0; for (a = 0; a < n.length; a += 3) { var d = n[a] * i, g = n[a + 1] * i, f = n[a + 2] * i; u += Math.abs((t[d] - t[f]) * (t[g + 1] - t[d + 1]) - (t[d] - t[g]) * (t[f + 1] - t[d + 1])) } return 0 === o && 0 === u ? 0 : Math.abs((u - o) / o) }, Og.flatten = function (t) { for (var e = t[0][0].length, i = { vertices: [], holes: [], dimensions: e }, n = 0, r = 0; r < t.length; r++) { for (var s = 0; s < t[r].length; s++)for (var o = 0; o < e; o++)i.vertices.push(t[r][s][o]); r > 0 && (n += t[r - 1].length, i.holes.push(n)) } return i }; const af = [], lf = { vertexPosition: 0, indexPosition: 0 }; function hf(t, e, i, n, r) { t[e + 0] = i, t[e + 1] = n, t[e + 2] = r } function cf(t, e) { const i = 256, n = 255; return (e = e || [])[0] = Math.floor(t / i / i / i) / n, e[1] = Math.floor(t / i / i) % i / n, e[2] = Math.floor(t / i) % i / n, e[3] = t % i / n, e } function uf(t) { let e = 0; const i = 256, n = 255; return e += Math.round(t[0] * i * i * i * n), e += Math.round(t[1] * i * i * n), e += Math.round(t[2] * i * n), e += Math.round(t[3] * n), e } function df() { const t = 'const e="GENERATE_POLYGON_BUFFERS",t="GENERATE_POINT_BUFFERS",n="GENERATE_LINE_STRING_BUFFERS",r="undefined"!=typeof navigator&&void 0!==navigator.userAgent?navigator.userAgent.toLowerCase():"";r.includes("firefox");r.includes("safari")&&!r.includes("chrom")&&(r.includes("version/15.4")||/cpu (os|iphone os) 15_4 like mac os x/.test(r)),r.includes("webkit")&&r.includes("edge"),r.includes("macintosh"),"undefined"!=typeof WorkerGlobalScope&&"undefined"!=typeof OffscreenCanvas&&(self,WorkerGlobalScope),function(){let e=!1;try{const t=Object.defineProperty({},"passive",{get:function(){e=!0}});window.addEventListener("_",null,t),window.removeEventListener("_",null,t)}catch(e){}}();const o={1:"The view center is not defined",2:"The view resolution is not defined",3:"The view rotation is not defined",4:"`image` and `src` cannot be provided at the same time",5:"`imgSize` must be set when `image` is provided",7:"`format` must be set when `url` is set",8:"Unknown `serverType` configured",9:"`url` must be configured or set using `#setUrl()`",10:"The default `geometryFunction` can only handle `Point` geometries",11:"`options.featureTypes` must be an Array",12:"`options.geometryName` must also be provided when `options.bbox` is set",13:"Invalid corner",14:"Invalid color",15:"Tried to get a value for a key that does not exist in the cache",16:"Tried to set a value for a key that is used already",17:"`resolutions` must be sorted in descending order",18:"Either `origin` or `origins` must be configured, never both",19:"Number of `tileSizes` and `resolutions` must be equal",20:"Number of `origins` and `resolutions` must be equal",22:"Either `tileSize` or `tileSizes` must be configured, never both",24:"Invalid extent or geometry provided as `geometry`",25:"Cannot fit empty extent provided as `geometry`",26:"Features must have an id set",27:"Features must have an id set",28:\'`renderMode` must be `"hybrid"` or `"vector"`\',30:"The passed `feature` was already added to the source",31:"Tried to enqueue an `element` that was already added to the queue",32:"Transformation matrix cannot be inverted",33:"Invalid units",34:"Invalid geometry layout",36:"Unknown SRS type",37:"Unknown geometry type found",38:"`styleMapValue` has an unknown type",39:"Unknown geometry type",40:"Expected `feature` to have a geometry",41:"Expected an `ol/style/Style` or an array of `ol/style/Style.js`",42:"Question unknown, the answer is 42",43:"Expected `layers` to be an array or a `Collection`",47:"Expected `controls` to be an array or an `ol/Collection`",48:"Expected `interactions` to be an array or an `ol/Collection`",49:"Expected `overlays` to be an array or an `ol/Collection`",50:"`options.featureTypes` should be an Array",51:"Either `url` or `tileJSON` options must be provided",52:"Unknown `serverType` configured",53:"Unknown `tierSizeCalculation` configured",55:"The {-y} placeholder requires a tile grid with extent",56:"mapBrowserEvent must originate from a pointer event",57:"At least 2 conditions are required",59:"Invalid command found in the PBF",60:"Missing or invalid `size`",61:"Cannot determine IIIF Image API version from provided image information JSON",62:"A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`",64:"Layer opacity must be a number",66:"`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`",67:"A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both",68:"A VectorTile source can only be rendered if it has a projection compatible with the view projection"};class i extends Error{constructor(e){const t=o[e];super(t),this.code=e,this.name="AssertionError",this.message=t}}function s(e,t){const n=t[0],r=t[1];return t[0]=e[0]*n+e[2]*r+e[4],t[1]=e[1]*n+e[3]*r+e[5],t}function a(e,t){const n=(r=t)[0]*r[3]-r[1]*r[2];var r;!function(e,t){if(!e)throw new i(t)}(0!==n,32);const o=t[0],s=t[1],a=t[2],u=t[3],x=t[4],f=t[5];return e[0]=u/n,e[1]=-s/n,e[2]=-a/n,e[3]=o/n,e[4]=(a*f-u*x)/n,e[5]=-(o*f-s*x)/n,e}new Array(6);var u={exports:{}};function x(e,t,n){n=n||2;var r,o,i,s,a,u,x,y=t&&t.length,d=y?t[0]*n:e.length,h=f(e,0,d,n,!0),v=[];if(!h||h.next===h.prev)return v;if(y&&(h=function(e,t,n,r){var o,i,s,a=[];for(o=0,i=t.length;o<i;o++)(s=f(e,t[o]*r,o<i-1?t[o+1]*r:e.length,r,!1))===s.next&&(s.steiner=!0),a.push(w(s));for(a.sort(p),o=0;o<a.length;o++)n=l(n=g(a[o],n),n.next);return n}(e,t,h,n)),e.length>80*n){r=i=e[0],o=s=e[1];for(var b=n;b<d;b+=n)(a=e[b])<r&&(r=a),(u=e[b+1])<o&&(o=u),a>i&&(i=a),u>s&&(s=u);x=0!==(x=Math.max(i-r,s-o))?1/x:0}return c(h,v,n,r,o,x),v}function f(e,t,n,r,o){var i,s;if(o===B(e,t,n,r)>0)for(i=t;i<n;i+=r)s=U(i,e[i],e[i+1],s);else for(i=n-r;i>=t;i-=r)s=U(i,e[i],e[i+1],s);return s&&M(s,s.next)&&(z(s),s=s.next),s}function l(e,t){if(!e)return e;t||(t=e);var n,r=e;do{if(n=!1,r.steiner||!M(r,r.next)&&0!==Z(r.prev,r,r.next))r=r.next;else{if(z(r),(r=t=r.prev)===r.next)break;n=!0}}while(n||r!==t);return t}function c(e,t,n,r,o,i,s){if(e){!s&&i&&function(e,t,n,r){var o=e;do{null===o.z&&(o.z=m(o.x,o.y,t,n,r)),o.prevZ=o.prev,o.nextZ=o.next,o=o.next}while(o!==e);o.prevZ.nextZ=null,o.prevZ=null,function(e){var t,n,r,o,i,s,a,u,x=1;do{for(n=e,e=null,i=null,s=0;n;){for(s++,r=n,a=0,t=0;t<x&&(a++,r=r.nextZ);t++);for(u=x;a>0||u>0&&r;)0!==a&&(0===u||!r||n.z<=r.z)?(o=n,n=n.nextZ,a--):(o=r,r=r.nextZ,u--),i?i.nextZ=o:e=o,o.prevZ=i,i=o;n=r}i.nextZ=null,x*=2}while(s>1)}(o)}(e,r,o,i);for(var a,u,x=e;e.prev!==e.next;)if(a=e.prev,u=e.next,i?d(e,r,o,i):y(e))t.push(a.i/n),t.push(e.i/n),t.push(u.i/n),z(e),e=u.next,x=u.next;else if((e=u)===x){s?1===s?c(e=h(l(e),t,n),t,n,r,o,i,2):2===s&&v(e,t,n,r,o,i):c(l(e),t,n,r,o,i,1);break}}}function y(e){var t=e.prev,n=e,r=e.next;if(Z(t,n,r)>=0)return!1;for(var o=e.next.next;o!==e.prev;){if(A(t.x,t.y,n.x,n.y,r.x,r.y,o.x,o.y)&&Z(o.prev,o,o.next)>=0)return!1;o=o.next}return!0}function d(e,t,n,r){var o=e.prev,i=e,s=e.next;if(Z(o,i,s)>=0)return!1;for(var a=o.x<i.x?o.x<s.x?o.x:s.x:i.x<s.x?i.x:s.x,u=o.y<i.y?o.y<s.y?o.y:s.y:i.y<s.y?i.y:s.y,x=o.x>i.x?o.x>s.x?o.x:s.x:i.x>s.x?i.x:s.x,f=o.y>i.y?o.y>s.y?o.y:s.y:i.y>s.y?i.y:s.y,l=m(a,u,t,n,r),c=m(x,f,t,n,r),y=e.prevZ,d=e.nextZ;y&&y.z>=l&&d&&d.z<=c;){if(y!==e.prev&&y!==e.next&&A(o.x,o.y,i.x,i.y,s.x,s.y,y.x,y.y)&&Z(y.prev,y,y.next)>=0)return!1;if(y=y.prevZ,d!==e.prev&&d!==e.next&&A(o.x,o.y,i.x,i.y,s.x,s.y,d.x,d.y)&&Z(d.prev,d,d.next)>=0)return!1;d=d.nextZ}for(;y&&y.z>=l;){if(y!==e.prev&&y!==e.next&&A(o.x,o.y,i.x,i.y,s.x,s.y,y.x,y.y)&&Z(y.prev,y,y.next)>=0)return!1;y=y.prevZ}for(;d&&d.z<=c;){if(d!==e.prev&&d!==e.next&&A(o.x,o.y,i.x,i.y,s.x,s.y,d.x,d.y)&&Z(d.prev,d,d.next)>=0)return!1;d=d.nextZ}return!0}function h(e,t,n){var r=e;do{var o=r.prev,i=r.next.next;!M(o,i)&&F(o,r,r.next,i)&&k(o,i)&&k(i,o)&&(t.push(o.i/n),t.push(r.i/n),t.push(i.i/n),z(r),z(r.next),r=e=i),r=r.next}while(r!==e);return l(r)}function v(e,t,n,r,o,i){var s=e;do{for(var a=s.next.next;a!==s.prev;){if(s.i!==a.i&&E(s,a)){var u=S(s,a);return s=l(s,s.next),u=l(u,u.next),c(s,t,n,r,o,i),void c(u,t,n,r,o,i)}a=a.next}s=s.next}while(s!==e)}function p(e,t){return e.x-t.x}function g(e,t){var n=function(e,t){var n,r=t,o=e.x,i=e.y,s=-1/0;do{if(i<=r.y&&i>=r.next.y&&r.next.y!==r.y){var a=r.x+(i-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(a<=o&&a>s){if(s=a,a===o){if(i===r.y)return r;if(i===r.next.y)return r.next}n=r.x<r.next.x?r:r.next}}r=r.next}while(r!==t);if(!n)return null;if(o===s)return n;var u,x=n,f=n.x,l=n.y,c=1/0;r=n;do{o>=r.x&&r.x>=f&&o!==r.x&&A(i<l?o:s,i,f,l,i<l?s:o,i,r.x,r.y)&&(u=Math.abs(i-r.y)/(o-r.x),k(r,e)&&(u<c||u===c&&(r.x>n.x||r.x===n.x&&b(n,r)))&&(n=r,c=u)),r=r.next}while(r!==x);return n}(e,t);if(!n)return t;var r=S(n,e),o=l(n,n.next);return l(r,r.next),t===n?o:t}function b(e,t){return Z(e.prev,e,t.prev)<0&&Z(t.next,e,e.next)<0}function m(e,t,n,r,o){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-n)*o)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-r)*o)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function w(e){var t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function A(e,t,n,r,o,i,s,a){return(o-s)*(t-a)-(e-s)*(i-a)>=0&&(e-s)*(r-a)-(n-s)*(t-a)>=0&&(n-s)*(i-a)-(o-s)*(r-a)>=0}function E(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function(e,t){var n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&F(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}(e,t)&&(k(e,t)&&k(t,e)&&function(e,t){var n=e,r=!1,o=(e.x+t.x)/2,i=(e.y+t.y)/2;do{n.y>i!=n.next.y>i&&n.next.y!==n.y&&o<(n.next.x-n.x)*(i-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==e);return r}(e,t)&&(Z(e.prev,e,t.prev)||Z(e,t.prev,t))||M(e,t)&&Z(e.prev,e,e.next)>0&&Z(t.prev,t,t.next)>0)}function Z(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function M(e,t){return e.x===t.x&&e.y===t.y}function F(e,t,n,r){var o=I(Z(e,t,n)),i=I(Z(e,t,r)),s=I(Z(n,r,e)),a=I(Z(n,r,t));return o!==i&&s!==a||(!(0!==o||!T(e,n,t))||(!(0!==i||!T(e,r,t))||(!(0!==s||!T(n,e,r))||!(0!==a||!T(n,t,r)))))}function T(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function I(e){return e>0?1:e<0?-1:0}function k(e,t){return Z(e.prev,e,e.next)<0?Z(e,t,e.next)>=0&&Z(e,e.prev,t)>=0:Z(e,t,e.prev)<0||Z(e,e.next,t)<0}function S(e,t){var n=new R(e.i,e.x,e.y),r=new R(t.i,t.x,t.y),o=e.next,i=t.prev;return e.next=t,t.prev=e,n.next=o,o.prev=n,r.next=n,n.prev=r,i.next=r,r.prev=i,r}function U(e,t,n,r){var o=new R(e,t,n);return r?(o.next=r.next,o.prev=r,r.next.prev=o,r.next=o):(o.prev=o,o.next=o),o}function z(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function R(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function B(e,t,n,r){for(var o=0,i=t,s=n-r;i<n;i+=r)o+=(e[s]-e[i])*(e[i+1]+e[s+1]),s=i;return o}u.exports=x,u.exports.default=x,x.deviation=function(e,t,n,r){var o=t&&t.length,i=o?t[0]*n:e.length,s=Math.abs(B(e,0,i,n));if(o)for(var a=0,u=t.length;a<u;a++){var x=t[a]*n,f=a<u-1?t[a+1]*n:e.length;s-=Math.abs(B(e,x,f,n))}var l=0;for(a=0;a<r.length;a+=3){var c=r[a]*n,y=r[a+1]*n,d=r[a+2]*n;l+=Math.abs((e[c]-e[d])*(e[y+1]-e[c+1])-(e[c]-e[y])*(e[d+1]-e[c+1]))}return 0===s&&0===l?0:Math.abs((l-s)/s)},x.flatten=function(e){for(var t=e[0][0].length,n={vertices:[],holes:[],dimensions:t},r=0,o=0;o<e.length;o++){for(var i=0;i<e[o].length;i++)for(var s=0;s<t;s++)n.vertices.push(e[o][i][s]);o>0&&(r+=e[o-1].length,n.holes.push(r))}return n};const P=[],C={vertexPosition:0,indexPosition:0};function N(e,t,n,r,o){e[t+0]=n,e[t+1]=r,e[t+2]=o}function _(e,t,n,r,o,i){const s=3+o,a=e[t+0],u=e[t+1],x=P;x.length=o;for(let n=0;n<x.length;n++)x[n]=e[t+2+n];let f=i?i.vertexPosition:0,l=i?i.indexPosition:0;const c=f/s;return N(n,f,a,u,0),x.length&&n.set(x,f+3),f+=s,N(n,f,a,u,1),x.length&&n.set(x,f+3),f+=s,N(n,f,a,u,2),x.length&&n.set(x,f+3),f+=s,N(n,f,a,u,3),x.length&&n.set(x,f+3),f+=s,r[l++]=c,r[l++]=c+1,r[l++]=c+3,r[l++]=c+1,r[l++]=c+2,r[l++]=c+3,C.vertexPosition=f,C.indexPosition=l,C}function L(e,t,n,r,o,i,a,u,x,f){const l=5+u.length,c=i.length/l,y=[e[t+0],e[t+1]],d=[e[n],e[n+1]],h=s(f,[...y]),v=s(f,[...d]);function p(e,t,n){const r=1e4;return Math.round(1500*t)+Math.round(1500*n)*r+e*r*r}function g(e,t,n){const r=Math.sqrt((t[0]-e[0])*(t[0]-e[0])+(t[1]-e[1])*(t[1]-e[1])),o=[(t[0]-e[0])/r,(t[1]-e[1])/r],i=[-o[1],o[0]],s=Math.sqrt((n[0]-e[0])*(n[0]-e[0])+(n[1]-e[1])*(n[1]-e[1])),a=[(n[0]-e[0])/s,(n[1]-e[1])/s],u=0===r||0===s?0:Math.acos((x=a[0]*o[0]+a[1]*o[1],f=-1,l=1,Math.min(Math.max(x,f),l)));var x,f,l;return a[0]*i[0]+a[1]*i[1]>0?u:2*Math.PI-u}const b=null!==o;let m=0,w=0;if(null!==r){m=g(h,v,s(f,[...[e[r],e[r+1]]]))}if(b){w=g(v,h,s(f,[...[e[o],e[o+1]]]))}i.push(y[0],y[1],d[0],d[1],p(0,m,w)),i.push(...u),i.push(y[0],y[1],d[0],d[1],p(1,m,w)),i.push(...u),i.push(y[0],y[1],d[0],d[1],p(2,m,w)),i.push(...u),i.push(y[0],y[1],d[0],d[1],p(3,m,w)),i.push(...u),a.push(c,c+1,c+2,c+1,c+3,c+2)}function G(e,t,n,r,o){const i=2+o;let s=t;const a=e.slice(s,s+o);s+=o;const x=e[s++];let f=0;const l=new Array(x-1);for(let t=0;t<x;t++)f+=e[s++],t<x-1&&(l[t]=f);const c=e.slice(s,s+2*f),y=u.exports(c,l,2);for(let e=0;e<y.length;e++)r.push(y[e]+n.length/i);for(let e=0;e<c.length;e+=2)n.push(c[e],c[e+1],...a);return s+2*f}const O=self;O.onmessage=r=>{const o=r.data;switch(o.type){case t:{const e=3,t=2,n=o.customAttributesCount,r=t+n,i=new Float32Array(o.renderInstructions),s=i.length/r,a=4*s*(n+e),u=new Uint32Array(6*s),x=new Float32Array(a);let f;for(let e=0;e<i.length;e+=r)f=_(i,e,x,u,n,f);const l=Object.assign({vertexBuffer:x.buffer,indexBuffer:u.buffer,renderInstructions:i.buffer},o);O.postMessage(l,[x.buffer,u.buffer,i.buffer]);break}case n:{const e=[],t=[],n=o.customAttributesCount,r=2,i=new Float32Array(o.renderInstructions);let s=0;const u=o.renderInstructionsTransform,x=[1,0,0,1,0,0];let f,l;for(a(x,u);s<i.length;){l=Array.from(i.slice(s,s+n)),s+=n,f=i[s++];for(let n=0;n<f-1;n++)L(i,s+n*r,s+(n+1)*r,n>0?s+(n-1)*r:null,n<f-2?s+(n+2)*r:null,e,t,l,0,x);s+=f*r}const c=Uint32Array.from(t),y=Float32Array.from(e),d=Object.assign({vertexBuffer:y.buffer,indexBuffer:c.buffer,renderInstructions:i.buffer},o);O.postMessage(d,[y.buffer,c.buffer,i.buffer]);break}case e:{const e=[],t=[],n=o.customAttributesCount,r=new Float32Array(o.renderInstructions);let i=0;for(;i<r.length;)i=G(r,i,e,t,n);const s=Uint32Array.from(t),a=Float32Array.from(e),u=Object.assign({vertexBuffer:a.buffer,indexBuffer:s.buffer,renderInstructions:r.buffer},o);O.postMessage(u,[a.buffer,s.buffer,r.buffer]);break}}};'; return new Worker("undefined" == typeof Blob ? "data:application/javascript;base64," + Buffer.from(t, "binary").toString("base64") : URL.createObjectURL(new Blob([t], { type: "application/javascript" }))) } class gf extends gd { constructor(t, e) { const i = e.uniforms || {}, n = [1, 0, 0, 1, 0, 0]; i[Wu] = n, super(t, { uniforms: i, postProcesses: e.postProcesses }), this.ready = !1, this.sourceRevision_ = -1, this.verticesBuffer_ = new Gu(nu, ou), this.hitVerticesBuffer_ = new Gu(nu, ou), this.indicesBuffer_ = new Gu(ru, ou), this.vertexShader_ = e.vertexShader, this.fragmentShader_ = e.fragmentShader, this.program_, this.hitDetectionEnabled_ = !(!e.hitFragmentShader || !e.hitVertexShader), this.hitVertexShader_ = e.hitVertexShader, this.hitFragmentShader_ = e.hitFragmentShader, this.hitProgram_; const r = e.attributes ? e.attributes.map((function (t) { return { name: "a_" + t.name, size: 1, type: Qu.FLOAT } })) : []; this.attributes = [{ name: "a_position", size: 2, type: Qu.FLOAT }, { name: "a_index", size: 1, type: Qu.FLOAT }].concat(r), this.hitDetectionAttributes = [{ name: "a_position", size: 2, type: Qu.FLOAT }, { name: "a_index", size: 1, type: Qu.FLOAT }, { name: "a_hitColor", size: 4, type: Qu.FLOAT }, { name: "a_featureUid", size: 1, type: Qu.FLOAT }].concat(r), this.customAttributes = e.attributes ? e.attributes : [], this.previousExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], this.currentTransform_ = n, this.renderTransform_ = [1, 0, 0, 1, 0, 0], this.invertRenderTransform_ = [1, 0, 0, 1, 0, 0], this.renderInstructions_ = new Float32Array(0), this.hitRenderInstructions_ = new Float32Array(0), this.hitRenderTarget_, this.generateBuffersRun_ = 0, this.worker_ = df(), this.worker_.addEventListener("message", function (t) { const e = t.data; if (e.type === Mg) { const i = e.projectionTransform; e.hitDetection ? (this.hitVerticesBuffer_.fromArrayBuffer(e.vertexBuffer), this.helper.flushBufferData(this.hitVerticesBuffer_)) : (this.verticesBuffer_.fromArrayBuffer(e.vertexBuffer), this.helper.flushBufferData(this.verticesBuffer_)), this.indicesBuffer_.fromArrayBuffer(e.indexBuffer), this.helper.flushBufferData(this.indicesBuffer_), this.renderTransform_ = i, Ft(this.invertRenderTransform_, this.renderTransform_), e.hitDetection ? this.hitRenderInstructions_ = new Float32Array(t.data.renderInstructions) : (this.renderInstructions_ = new Float32Array(t.data.renderInstructions), e.generateBuffersRun === this.generateBuffersRun_ && (this.ready = !0)), this.getLayer().changed() } }.bind(this)), this.featureCache_ = {}, this.featureCount_ = 0; const s = this.getLayer().getSource(); this.sourceListenKeys_ = [N(s, Oh, this.handleSourceFeatureAdded_, this), N(s, Nh, this.handleSourceFeatureChanged_, this), N(s, kh, this.handleSourceFeatureDelete_, this), N(s, Dh, this.handleSourceFeatureClear_, this)], s.forEachFeature(function (t) { this.featureCache_[z(t)] = { feature: t, properties: t.getProperties(), geometry: t.getGeometry() }, this.featureCount_++ }.bind(this)) } afterHelperCreated() { this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_), this.hitDetectionEnabled_ && (this.hitProgram_ = this.helper.getProgram(this.hitFragmentShader_, this.hitVertexShader_), this.hitRenderTarget_ = new ld(this.helper)) } handleSourceFeatureAdded_(t) { const e = t.feature; this.featureCache_[z(e)] = { feature: e, properties: e.getProperties(), geometry: e.getGeometry() }, this.featureCount_++ } handleSourceFeatureChanged_(t) { const e = t.feature; this.featureCache_[z(e)] = { feature: e, properties: e.getProperties(), geometry: e.getGeometry() } } handleSourceFeatureDelete_(t) { const e = t.feature; delete this.featureCache_[z(e)], this.featureCount_-- } handleSourceFeatureClear_() { this.featureCache_ = {}, this.featureCount_ = 0 } renderFrame(t) { const e = this.helper.getGL(); this.preRender(e, t); const i = t.viewState.projection, n = this.getLayer().getSource().getWrapX() && i.canWrapX(), r = i.getExtent(), s = t.extent, o = n ? Se(r) : null, a = n ? Math.ceil((s[2] - r[2]) / o) + 1 : 1, l = n ? Math.floor((s[0] - r[0]) / o) : 0; let h = l; const c = this.indicesBuffer_.getSize(); do { this.helper.makeProjectionTransform(t, this.currentTransform_), Lt(this.currentTransform_, h * o, 0), Et(this.currentTransform_, this.invertRenderTransform_), this.helper.applyUniforms(t), this.helper.drawElements(0, c) } while (++h < a); this.helper.finalizeDraw(t, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent); const u = this.helper.getCanvas(); return this.hitDetectionEnabled_ && (this.renderHitDetection(t, l, a, o), this.hitRenderTarget_.clearCachedData()), this.postRender(e, t), u } prepareFrameInternal(t) { const e = this.getLayer(), i = e.getSource(), n = t.viewState, r = !t.viewHints[Ro] && !t.viewHints[Po], s = !ee(this.previousExtent_, t.extent), o = this.sourceRevision_ < i.getRevision(); if (o && (this.sourceRevision_ = i.getRevision()), r && (s || o)) { const r = n.projection, s = n.resolution, o = e instanceof Ig ? e.getRenderBuffer() : 0, a = Xt(t.extent, o * s); i.loadFeatures(a, s, r), this.rebuildBuffers_(t), this.previousExtent_ = t.extent.slice() } return this.helper.useProgram(this.program_, t), this.helper.prepareDraw(t), this.helper.bindBuffer(this.verticesBuffer_), this.helper.bindBuffer(this.indicesBuffer_), this.helper.enableAttributes(this.attributes), !0 } rebuildBuffers_(t) { const e = [1, 0, 0, 1, 0, 0]; this.helper.makeProjectionTransform(t, e); const i = (2 + this.customAttributes.length) * this.featureCount_; if (this.renderInstructions_ && this.renderInstructions_.length === i || (this.renderInstructions_ = new Float32Array(i)), this.hitDetectionEnabled_) { const t = (7 + this.customAttributes.length) * this.featureCount_; this.hitRenderInstructions_ && this.hitRenderInstructions_.length === t || (this.hitRenderInstructions_ = new Float32Array(t)) } let n, r; const s = [], o = []; let a, l = 0, h = 0; for (const t in this.featureCache_) { if (n = this.featureCache_[t], r = n.geometry, !r || "Point" !== r.getType()) continue; let i; s[0] = r.getFlatCoordinates()[0], s[1] = r.getFlatCoordinates()[1], bt(e, s), a = cf(h + 6, o), this.renderInstructions_[l++] = s[0], this.renderInstructions_[l++] = s[1], this.hitDetectionEnabled_ && (this.hitRenderInstructions_[h++] = s[0], this.hitRenderInstructions_[h++] = s[1], this.hitRenderInstructions_[h++] = a[0], this.hitRenderInstructions_[h++] = a[1], this.hitRenderInstructions_[h++] = a[2], this.hitRenderInstructions_[h++] = a[3], this.hitRenderInstructions_[h++] = Number(t)); for (let t = 0; t < this.customAttributes.length; t++)i = this.customAttributes[t].callback(n.feature, n.properties), this.renderInstructions_[l++] = i, this.hitDetectionEnabled_ && (this.hitRenderInstructions_[h++] = i) } const c = { id: 0, type: Mg, renderInstructions: this.renderInstructions_.buffer, customAttributesCount: this.customAttributes.length }; if (c.projectionTransform = e, c.generateBuffersRun = ++this.generateBuffersRun_, this.ready = !1, this.worker_.postMessage(c, [this.renderInstructions_.buffer]), this.renderInstructions_ = null, this.hitDetectionEnabled_) { const t = { id: 0, type: Mg, renderInstructions: this.hitRenderInstructions_.buffer, customAttributesCount: 5 + this.customAttributes.length }; t.projectionTransform = e, t.hitDetection = !0, this.worker_.postMessage(t, [this.hitRenderInstructions_.buffer]), this.hitRenderInstructions_ = null } } forEachFeatureAtCoordinate(t, e, i, n, r) { if (at(this.hitDetectionEnabled_, 66), !this.hitRenderInstructions_) return; const s = bt(e.coordinateToPixelTransform, t.slice()), o = this.hitRenderTarget_.readPixel(s[0] / 2, s[1] / 2), a = uf([o[0] / 255, o[1] / 255, o[2] / 255, o[3] / 255]), l = this.hitRenderInstructions_[a], h = Math.floor(l).toString(), c = this.getLayer().getSource().getFeatureByUid(h); return c ? n(c, this.getLayer(), null) : void 0 } renderHitDetection(t, e, i, n) { if (!this.hitVerticesBuffer_.getSize()) return; let r = e; this.hitRenderTarget_.setSize([Math.floor(t.size[0] / 2), Math.floor(t.size[1] / 2)]), this.helper.useProgram(this.hitProgram_, t), this.helper.prepareDrawToRenderTarget(t, this.hitRenderTarget_, !0), this.helper.bindBuffer(this.hitVerticesBuffer_), this.helper.bindBuffer(this.indicesBuffer_), this.helper.enableAttributes(this.hitDetectionAttributes); do { this.helper.makeProjectionTransform(t, this.currentTransform_), Lt(this.currentTransform_, r * n, 0), Et(this.currentTransform_, this.invertRenderTransform_), this.helper.applyUniforms(t); const e = this.indicesBuffer_.getSize(); this.helper.drawElements(0, e) } while (++r < i) } disposeInternal() { this.worker_.terminate(), this.layer_ = null, this.sourceListenKeys_.forEach((function (t) { k(t) })), this.sourceListenKeys_ = null, super.disposeInternal() } } let ff = 0; class pf { constructor(t, e, i, n, r) { this.helper_ = t, this.worker_ = e, this.program_ = this.helper_.getProgram(n, i), this.attributes = [], this.customAttributes = r } rebuild(t, e, i, n) { t.renderInstructionsTransform = this.helper_.makeProjectionTransform(e, [1, 0, 0, 1, 0, 0]), this.generateRenderInstructions(t), this.generateBuffers_(t, i, n) } render(t, e, i, n) { this.helper_.makeProjectionTransform(i, e), Lt(e, n, 0), Et(e, t.invertVerticesBufferTransform), this.helper_.useProgram(this.program_, i), this.helper_.bindBuffer(t.verticesBuffer), this.helper_.bindBuffer(t.indicesBuffer), this.helper_.enableAttributes(this.attributes); const r = t.indicesBuffer.getSize(); this.helper_.drawElements(0, r) } generateRenderInstructions(t) { B() } generateBuffers_(t, e, i) { const n = ff++; let r; switch (e) { case "Polygon": r = Lg; break; case "Point": r = Mg; break; case "LineString": r = Fg }const s = { id: n, type: r, renderInstructions: t.renderInstructions.buffer, renderInstructionsTransform: t.renderInstructionsTransform, customAttributesCount: this.customAttributes.length }; this.worker_.postMessage(s, [t.renderInstructions.buffer]), t.renderInstructions = null; const o = function (e) { const r = e.data; r.id === n && (this.worker_.removeEventListener("message", o), t.verticesBufferTransform = r.renderInstructionsTransform, Ft(t.invertVerticesBufferTransform, t.verticesBufferTransform), t.verticesBuffer.fromArrayBuffer(r.vertexBuffer), this.helper_.flushBufferData(t.verticesBuffer), t.indicesBuffer.fromArrayBuffer(r.indexBuffer), this.helper_.flushBufferData(t.indicesBuffer), t.renderInstructions = new Float32Array(r.renderInstructions), i()) }.bind(this); this.worker_.addEventListener("message", o) } } const mf = { SEGMENT_START: "a_segmentStart", SEGMENT_END: "a_segmentEnd", PARAMETERS: "a_parameters" }; class _f extends pf { constructor(t, e, i, n, r) { super(t, e, i, n, r), this.attributes = [{ name: mf.SEGMENT_START, size: 2, type: Qu.FLOAT }, { name: mf.SEGMENT_END, size: 2, type: Qu.FLOAT }, { name: mf.PARAMETERS, size: 1, type: Qu.FLOAT }].concat(r.map((function (t) { return { name: "a_" + t.name, size: 1, type: Qu.FLOAT } }))) } generateRenderInstructions(t) { const e = 2 * t.verticesCount + (1 + this.customAttributes.length) * t.geometriesCount; let i; t.renderInstructions && t.renderInstructions.length === e || (t.renderInstructions = new Float32Array(e)); const n = []; let r, s = 0; for (const e in t.entries) { i = t.entries[e]; for (let e = 0, o = i.flatCoordss.length; e < o; e++) { n.length = i.flatCoordss[e].length, un(i.flatCoordss[e], 0, n.length, 2, t.renderInstructionsTransform, n); for (let e = 0, n = this.customAttributes.length; e < n; e++)r = this.customAttributes[e].callback(i.feature), t.renderInstructions[s++] = r; t.renderInstructions[s++] = n.length / 2; for (let e = 0, i = n.length; e < i; e += 2)t.renderInstructions[s++] = n[e], t.renderInstructions[s++] = n[e + 1] } } } } class yf { constructor() { this.polygonBatch = { entries: {}, geometriesCount: 0, verticesCount: 0, ringsCount: 0, renderInstructions: new Float32Array(0), verticesBuffer: new Gu(nu, ou), indicesBuffer: new Gu(ru, ou), renderInstructionsTransform: [1, 0, 0, 1, 0, 0], verticesBufferTransform: [1, 0, 0, 1, 0, 0], invertVerticesBufferTransform: [1, 0, 0, 1, 0, 0] }, this.pointBatch = { entries: {}, geometriesCount: 0, renderInstructions: new Float32Array(0), verticesBuffer: new Gu(nu, ou), indicesBuffer: new Gu(ru, ou), renderInstructionsTransform: [1, 0, 0, 1, 0, 0], verticesBufferTransform: [1, 0, 0, 1, 0, 0], invertVerticesBufferTransform: [1, 0, 0, 1, 0, 0] }, this.lineStringBatch = { entries: {}, geometriesCount: 0, verticesCount: 0, renderInstructions: new Float32Array(0), verticesBuffer: new Gu(nu, ou), indicesBuffer: new Gu(ru, ou), renderInstructionsTransform: [1, 0, 0, 1, 0, 0], verticesBufferTransform: [1, 0, 0, 1, 0, 0], invertVerticesBufferTransform: [1, 0, 0, 1, 0, 0] } } addFeatures(t) { for (let e = 0; e < t.length; e++)this.addFeature(t[e]) } addFeature(t) { const e = t.getGeometry(); e && this.addGeometry_(e, t) } addFeatureEntryInPointBatch_(t) { const e = z(t); return e in this.pointBatch.entries || (this.pointBatch.entries[e] = { feature: t, flatCoordss: [] }), this.pointBatch.entries[e] } addFeatureEntryInLineStringBatch_(t) { const e = z(t); return e in this.lineStringBatch.entries || (this.lineStringBatch.entries[e] = { feature: t, flatCoordss: [], verticesCount: 0 }), this.lineStringBatch.entries[e] } addFeatureEntryInPolygonBatch_(t) { const e = z(t); return e in this.polygonBatch.entries || (this.polygonBatch.entries[e] = { feature: t, flatCoordss: [], verticesCount: 0, ringsCount: 0, ringsVerticesCounts: [] }), this.polygonBatch.entries[e] } clearFeatureEntryInPointBatch_(t) { const e = this.pointBatch.entries[z(t)]; e && (this.pointBatch.geometriesCount -= e.flatCoordss.length, delete this.pointBatch.entries[z(t)]) } clearFeatureEntryInLineStringBatch_(t) { const e = this.lineStringBatch.entries[z(t)]; e && (this.lineStringBatch.verticesCount -= e.verticesCount, this.lineStringBatch.geometriesCount -= e.flatCoordss.length, delete this.lineStringBatch.entries[z(t)]) } clearFeatureEntryInPolygonBatch_(t) { const e = this.polygonBatch.entries[z(t)]; e && (this.polygonBatch.verticesCount -= e.verticesCount, this.polygonBatch.ringsCount -= e.ringsCount, this.polygonBatch.geometriesCount -= e.flatCoordss.length, delete this.polygonBatch.entries[z(t)]) } addGeometry_(t, e) { let i, n, r; switch (t.getType()) { case "GeometryCollection": t.getGeometries().map((t => this.addGeometry_(t, e))); break; case "MultiPolygon": t.getPolygons().map((t => this.addGeometry_(t, e))); break; case "MultiLineString": t.getLineStrings().map((t => this.addGeometry_(t, e))); break; case "MultiPoint": t.getPoints().map((t => this.addGeometry_(t, e))); break; case "Polygon": const s = t; r = this.addFeatureEntryInPolygonBatch_(e), i = s.getFlatCoordinates(), n = i.length / 2; const o = s.getLinearRingCount(), a = s.getEnds().map(((t, e, i) => e > 0 ? (t - i[e - 1]) / 2 : t / 2)); this.polygonBatch.verticesCount += n, this.polygonBatch.ringsCount += o, this.polygonBatch.geometriesCount++, r.flatCoordss.push(i), r.ringsVerticesCounts.push(a), r.verticesCount += n, r.ringsCount += o, s.getLinearRings().map((t => this.addGeometry_(t, e))); break; case "Point": const l = t; r = this.addFeatureEntryInPointBatch_(e), i = l.getFlatCoordinates(), this.pointBatch.geometriesCount++, r.flatCoordss.push(i); break; case "LineString": case "LinearRing": const h = t; r = this.addFeatureEntryInLineStringBatch_(e), i = h.getFlatCoordinates(), n = i.length / 2, this.lineStringBatch.verticesCount += n, this.lineStringBatch.geometriesCount++, r.flatCoordss.push(i), r.verticesCount += n } } changeFeature(t) { this.clearFeatureEntryInPointBatch_(t), this.clearFeatureEntryInPolygonBatch_(t), this.clearFeatureEntryInLineStringBatch_(t); const e = t.getGeometry(); e && this.addGeometry_(e, t) } removeFeature(t) { this.clearFeatureEntryInPointBatch_(t), this.clearFeatureEntryInPolygonBatch_(t), this.clearFeatureEntryInLineStringBatch_(t) } clear() { this.polygonBatch.entries = {}, this.polygonBatch.geometriesCount = 0, this.polygonBatch.verticesCount = 0, this.polygonBatch.ringsCount = 0, this.lineStringBatch.entries = {}, this.lineStringBatch.geometriesCount = 0, this.lineStringBatch.verticesCount = 0, this.pointBatch.entries = {}, this.pointBatch.geometriesCount = 0 } } const xf = { POSITION: "a_position", INDEX: "a_index" }; class vf extends pf { constructor(t, e, i, n, r) { super(t, e, i, n, r), this.attributes = [{ name: xf.POSITION, size: 2, type: Qu.FLOAT }, { name: xf.INDEX, size: 1, type: Qu.FLOAT }].concat(r.map((function (t) { return { name: "a_" + t.name, size: 1, type: Qu.FLOAT } }))) } generateRenderInstructions(t) { const e = (2 + this.customAttributes.length) * t.geometriesCount; let i; t.renderInstructions && t.renderInstructions.length === e || (t.renderInstructions = new Float32Array(e)); const n = []; let r, s = 0; for (const e in t.entries) { i = t.entries[e]; for (let e = 0, o = i.flatCoordss.length; e < o; e++) { n[0] = i.flatCoordss[e][0], n[1] = i.flatCoordss[e][1], bt(t.renderInstructionsTransform, n), t.renderInstructions[s++] = n[0], t.renderInstructions[s++] = n[1]; for (let e = 0, n = this.customAttributes.length; e < n; e++)r = this.customAttributes[e].callback(i.feature), t.renderInstructions[s++] = r } } } } const Sf = { POSITION: "a_position" }; class wf extends pf { constructor(t, e, i, n, r) { super(t, e, i, n, r), this.attributes = [{ name: Sf.POSITION, size: 2, type: Qu.FLOAT }].concat(r.map((function (t) { return { name: "a_" + t.name, size: 1, type: Qu.FLOAT } }))) } generateRenderInstructions(t) { const e = 2 * t.verticesCount + (1 + this.customAttributes.length) * t.geometriesCount + t.ringsCount; let i; t.renderInstructions && t.renderInstructions.length === e || (t.renderInstructions = new Float32Array(e)); const n = []; let r, s = 0; for (const e in t.entries) { i = t.entries[e]; for (let e = 0, o = i.flatCoordss.length; e < o; e++) { n.length = i.flatCoordss[e].length, un(i.flatCoordss[e], 0, n.length, 2, t.renderInstructionsTransform, n); for (let e = 0, n = this.customAttributes.length; e < n; e++)r = this.customAttributes[e].callback(i.feature), t.renderInstructions[s++] = r; t.renderInstructions[s++] = i.ringsVerticesCounts[e].length; for (let n = 0, r = i.ringsVerticesCounts[e].length; n < r; n++)t.renderInstructions[s++] = i.ringsVerticesCounts[e][n]; for (let e = 0, i = n.length; e < i; e += 2)t.renderInstructions[s++] = n[e], t.renderInstructions[s++] = n[e + 1] } } } } function Ef(t) { const e = $r(t); return 256 * e[0] * 256 + 256 * e[1] + e[2] } const Tf = "vec3(\n  fract(floor(a_color / 256.0 / 256.0) / 256.0),\n  fract(floor(a_color / 256.0) / 256.0),\n  fract(a_color / 256.0)\n);", Cf = `\n  precision mediump float;\n  uniform mat4 u_projectionMatrix;\n  attribute vec2 a_position;\n  attribute float a_color;\n  attribute float a_opacity;\n  varying vec3 v_color;\n  varying float v_opacity;\n\n  void main(void) {\n    gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n    v_color = ${Tf}\n    v_opacity = a_opacity;\n  }`, bf = "\n  precision mediump float;\n  varying vec3 v_color;\n  varying float v_opacity;\n\n  void main(void) {\n    gl_FragColor = vec4(v_color, 1.0) * v_opacity;\n  }", Rf = `\n  precision mediump float;\n  uniform mat4 u_projectionMatrix;\n  uniform vec2 u_sizePx;\n  attribute vec2 a_segmentStart;\n  attribute vec2 a_segmentEnd;\n  attribute float a_parameters;\n  attribute float a_color;\n  attribute float a_opacity;\n  attribute float a_width;\n  varying vec2 v_segmentStart;\n  varying vec2 v_segmentEnd;\n  varying float v_angleStart;\n  varying float v_angleEnd;\n  varying vec3 v_color;\n  varying float v_opacity;\n  varying float v_width;\n\n  vec2 worldToPx(vec2 worldPos) {\n    vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);\n    return (0.5 * screenPos.xy + 0.5) * u_sizePx;\n  }\n\n  vec4 pxToScreen(vec2 pxPos) {\n    vec2 screenPos = pxPos * 4.0 / u_sizePx;\n    return vec4(screenPos.xy, 0.0, 0.0);\n  }\n\n  vec2 getOffsetDirection(vec2 normalPx, vec2 tangentPx, float joinAngle) {\n    if (cos(joinAngle) > 0.93) return normalPx - tangentPx;\n    float halfAngle = joinAngle / 2.0;\n    vec2 angleBisectorNormal = vec2(\n      sin(halfAngle) * normalPx.x + cos(halfAngle) * normalPx.y,\n      -cos(halfAngle) * normalPx.x + sin(halfAngle) * normalPx.y\n    );\n    float length = 1.0 / sin(halfAngle);\n    return angleBisectorNormal * length;\n  }\n\n  void main(void) {\n    float anglePrecision = 1500.0;\n    float paramShift = 10000.0;\n    v_angleStart = fract(a_parameters / paramShift) * paramShift / anglePrecision;\n    v_angleEnd = fract(floor(a_parameters / paramShift + 0.5) / paramShift) * paramShift / anglePrecision;\n    float vertexNumber = floor(a_parameters / paramShift / paramShift + 0.0001);\n    vec2 tangentPx = worldToPx(a_segmentEnd) - worldToPx(a_segmentStart);\n    tangentPx = normalize(tangentPx);\n    vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);\n    float normalDir = vertexNumber < 0.5 || (vertexNumber > 1.5 && vertexNumber < 2.5) ? 1.0 : -1.0;\n    float tangentDir = vertexNumber < 1.5 ? 1.0 : -1.0;\n    float angle = vertexNumber < 1.5 ? v_angleStart : v_angleEnd;\n    vec2 offsetPx = getOffsetDirection(normalPx * normalDir, tangentDir * tangentPx, angle) * a_width * 0.5;\n    vec2 position =  vertexNumber < 1.5 ? a_segmentStart : a_segmentEnd;\n    gl_Position = u_projectionMatrix * vec4(position, 0.0, 1.0) + pxToScreen(offsetPx);\n    v_segmentStart = worldToPx(a_segmentStart);\n    v_segmentEnd = worldToPx(a_segmentEnd);\n    v_color = ${Tf}\n    v_opacity = a_opacity;\n    v_width = a_width;\n  }`, Pf = "\n  precision mediump float;\n  uniform float u_pixelRatio;\n  varying vec2 v_segmentStart;\n  varying vec2 v_segmentEnd;\n  varying float v_angleStart;\n  varying float v_angleEnd;\n  varying vec3 v_color;\n  varying float v_opacity;\n  varying float v_width;\n\n  float segmentDistanceField(vec2 point, vec2 start, vec2 end, float radius) {\n    vec2 startToPoint = point - start;\n    vec2 startToEnd = end - start;\n    float ratio = clamp(dot(startToPoint, startToEnd) / dot(startToEnd, startToEnd), 0.0, 1.0);\n    float dist = length(startToPoint - ratio * startToEnd);\n    return 1.0 - smoothstep(radius - 1.0, radius, dist);\n  }\n\n  void main(void) {\n    vec2 v_currentPoint = gl_FragCoord.xy / u_pixelRatio;\n    gl_FragColor = vec4(v_color, 1.0) * v_opacity;\n    gl_FragColor *= segmentDistanceField(v_currentPoint, v_segmentStart, v_segmentEnd, v_width);\n  }", If = `\n  precision mediump float;\n  uniform mat4 u_projectionMatrix;\n  uniform mat4 u_offsetScaleMatrix;\n  attribute vec2 a_position;\n  attribute float a_index;\n  attribute float a_color;\n  attribute float a_opacity;\n  varying vec2 v_texCoord;\n  varying vec3 v_color;\n  varying float v_opacity;\n\n  void main(void) {\n    mat4 offsetMatrix = u_offsetScaleMatrix;\n    float size = 6.0;\n    float offsetX = a_index == 0.0 || a_index == 3.0 ? -size / 2.0 : size / 2.0;\n    float offsetY = a_index == 0.0 || a_index == 1.0 ? -size / 2.0 : size / 2.0;\n    vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n    gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n    float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n    float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n    v_texCoord = vec2(u, v);\n    v_color = ${Tf}\n    v_opacity = a_opacity;\n  }`, Lf = "\n  precision mediump float;\n  varying vec3 v_color;\n  varying float v_opacity;\n\n  void main(void) {\n      gl_FragColor = vec4(v_color, 1.0) * v_opacity;\n  }"; function Mf(t) { return Object.keys(t).map((e => ({ name: e, callback: t[e] }))) } const Ff = 0, Af = 1, Of = 2, Nf = 3, Df = 4, kf = 5, Gf = 6, jf = 7, Bf = 8, Uf = 9, zf = 10, Xf = 11, Vf = 12, Wf = [Bf], Zf = [Vf], Yf = [Af], Kf = [Nf]; class qf extends Cl { constructor(t, e, i, n) { super(), this.tolerance = t, this.maxExtent = e, this.pixelRatio = n, this.maxLineWidth = 0, this.resolution = i, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = {} } applyPixelRatio(t) { const e = this.pixelRatio; return 1 == e ? t : t.map((function (t) { return t * e })) } appendFlatPointCoordinates(t, e) { const i = this.getBufferedMaxExtent(), n = this.tmpCoordinate_, r = this.coordinates; let s = r.length; for (let o = 0, a = t.length; o < a; o += e)n[0] = t[o], n[1] = t[o + 1], Zt(i, n) && (r[s++] = n[0], r[s++] = n[1]); return s } appendFlatLineCoordinates(t, e, i, n, r, s) { const o = this.coordinates; let a = o.length; const l = this.getBufferedMaxExtent(); s && (e += n); let h = t[e], c = t[e + 1]; const u = this.tmpCoordinate_; let d, g, f, p = !0; for (d = e + n; d < i; d += n)u[0] = t[d], u[1] = t[d + 1], f = qt(l, u), f !== g ? (p && (o[a++] = h, o[a++] = c, p = !1), o[a++] = u[0], o[a++] = u[1]) : f === kt ? (o[a++] = u[0], o[a++] = u[1], p = !1) : p = !0, h = u[0], c = u[1], g = f; return (r && p || d === e + n) && (o[a++] = h, o[a++] = c), a } drawCustomCoordinates_(t, e, i, n, r) { for (let s = 0, o = i.length; s < o; ++s) { const o = i[s], a = this.appendFlatLineCoordinates(t, e, o, n, !1, !1); r.push(a), e = o } return e } drawCustom(t, e, i, n) { this.beginGeometry(t, e); const r = t.getType(), s = t.getStride(), o = this.coordinates.length; let a, l, h, c, u; switch (r) { case "MultiPolygon": a = t.getOrientedFlatCoordinates(), c = []; const e = t.getEndss(); u = 0; for (let t = 0, i = e.length; t < i; ++t) { const i = []; u = this.drawCustomCoordinates_(a, u, e[t], s, i), c.push(i) } this.instructions.push([Df, o, c, t, i, Bn]), this.hitDetectionInstructions.push([Df, o, c, t, n || i, Bn]); break; case "Polygon": case "MultiLineString": h = [], a = "Polygon" == r ? t.getOrientedFlatCoordinates() : t.getFlatCoordinates(), u = this.drawCustomCoordinates_(a, 0, t.getEnds(), s, h), this.instructions.push([Df, o, h, t, i, jn]), this.hitDetectionInstructions.push([Df, o, h, t, n || i, jn]); break; case "LineString": case "Circle": a = t.getFlatCoordinates(), l = this.appendFlatLineCoordinates(a, 0, a.length, s, !1, !1), this.instructions.push([Df, o, l, t, i, Gn]), this.hitDetectionInstructions.push([Df, o, l, t, n || i, Gn]); break; case "MultiPoint": a = t.getFlatCoordinates(), l = this.appendFlatPointCoordinates(a, s), l > o && (this.instructions.push([Df, o, l, t, i, Gn]), this.hitDetectionInstructions.push([Df, o, l, t, n || i, Gn])); break; case "Point": a = t.getFlatCoordinates(), this.coordinates.push(a[0], a[1]), l = this.coordinates.length, this.instructions.push([Df, o, l, t, i]), this.hitDetectionInstructions.push([Df, o, l, t, n || i]) }this.endGeometry(e) } beginGeometry(t, e) { this.beginGeometryInstruction1_ = [Ff, e, 0, t], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [Ff, e, 0, t], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_) } finish() { return { instructions: this.instructions, hitDetectionInstructions: this.hitDetectionInstructions, coordinates: this.coordinates } } reverseHitDetectionInstructions() { const t = this.hitDetectionInstructions; let e; t.reverse(); const i = t.length; let n, r, s = -1; for (e = 0; e < i; ++e)n = t[e], r = n[0], r == jf ? s = e : r == Ff && (n[2] = e, h(this.hitDetectionInstructions, s, e), s = -1) } setFillStrokeStyle(t, e) { const i = this.state; if (t) { const e = t.getColor(); i.fillStyle = fl(e || Ns) } else i.fillStyle = void 0; if (e) { const t = e.getColor(); i.strokeStyle = fl(t || Bs); const n = e.getLineCap(); i.lineCap = void 0 !== n ? n : Ds; const r = e.getLineDash(); i.lineDash = r ? r.slice() : ks; const s = e.getLineDashOffset(); i.lineDashOffset = s || 0; const o = e.getLineJoin(); i.lineJoin = void 0 !== o ? o : Gs; const a = e.getWidth(); i.lineWidth = void 0 !== a ? a : 1; const l = e.getMiterLimit(); i.miterLimit = void 0 !== l ? l : js, i.lineWidth > this.maxLineWidth && (this.maxLineWidth = i.lineWidth, this.bufferedMaxExtent_ = null) } else i.strokeStyle = void 0, i.lineCap = void 0, i.lineDash = null, i.lineDashOffset = void 0, i.lineJoin = void 0, i.lineWidth = void 0, i.miterLimit = void 0 } createFill(t) { const e = t.fillStyle, i = [zf, e]; return "string" != typeof e && i.push(!0), i } applyStroke(t) { this.instructions.push(this.createStroke(t)) } createStroke(t) { return [Xf, t.strokeStyle, t.lineWidth * this.pixelRatio, t.lineCap, t.lineJoin, t.miterLimit, this.applyPixelRatio(t.lineDash), t.lineDashOffset * this.pixelRatio] } updateFillStyle(t, e) { const i = t.fillStyle; "string" == typeof i && t.currentFillStyle == i || (void 0 !== i && this.instructions.push(e.call(this, t)), t.currentFillStyle = i) } updateStrokeStyle(t, e) { const i = t.strokeStyle, n = t.lineCap, r = t.lineDash, s = t.lineDashOffset, o = t.lineJoin, a = t.lineWidth, l = t.miterLimit; (t.currentStrokeStyle != i || t.currentLineCap != n || r != t.currentLineDash && !u(t.currentLineDash, r) || t.currentLineDashOffset != s || t.currentLineJoin != o || t.currentLineWidth != a || t.currentMiterLimit != l) && (void 0 !== i && e.call(this, t), t.currentStrokeStyle = i, t.currentLineCap = n, t.currentLineDash = r, t.currentLineDashOffset = s, t.currentLineJoin = o, t.currentLineWidth = a, t.currentMiterLimit = l) } endGeometry(t) { this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null; const e = [jf, t]; this.instructions.push(e), this.hitDetectionInstructions.push(e) } getBufferedMaxExtent() { if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = Vt(this.maxExtent), this.maxLineWidth > 0)) { const t = this.resolution * (this.maxLineWidth + 1) / 2; Xt(this.bufferedMaxExtent_, t, this.bufferedMaxExtent_) } return this.bufferedMaxExtent_ } } class Hf extends qf { constructor(t, e, i, n) { super(t, e, i, n), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0 } drawPoint(t, e) { if (!this.image_) return; this.beginGeometry(t, e); const i = t.getFlatCoordinates(), n = t.getStride(), r = this.coordinates.length, s = this.appendFlatPointCoordinates(i, n); this.instructions.push([Gf, r, s, this.image_, this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]), this.hitDetectionInstructions.push([Gf, r, s, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]), this.endGeometry(e) } drawMultiPoint(t, e) { if (!this.image_) return; this.beginGeometry(t, e); const i = t.getFlatCoordinates(), n = t.getStride(), r = this.coordinates.length, s = this.appendFlatPointCoordinates(i, n); this.instructions.push([Gf, r, s, this.image_, this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]), this.hitDetectionInstructions.push([Gf, r, s, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]), this.endGeometry(e) } finish() { return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish() } setImageStyle(t, e) { const i = t.getAnchor(), n = t.getSize(), r = t.getOrigin(); this.imagePixelRatio_ = t.getPixelRatio(this.pixelRatio), this.anchorX_ = i[0], this.anchorY_ = i[1], this.hitDetectionImage_ = t.getHitDetectionImage(), this.image_ = t.getImage(this.pixelRatio), this.height_ = n[1], this.opacity_ = t.getOpacity(), this.originX_ = r[0], this.originY_ = r[1], this.rotateWithView_ = t.getRotateWithView(), this.rotation_ = t.getRotation(), this.scale_ = t.getScaleArray(), this.width_ = n[0], this.declutterMode_ = t.getDeclutterMode(), this.declutterImageWithText_ = e } } class $f extends qf { constructor(t, e, i, n) { super(t, e, i, n) } drawFlatCoordinates_(t, e, i, n) { const r = this.coordinates.length, s = this.appendFlatLineCoordinates(t, e, i, n, !1, !1), o = [Uf, r, s]; return this.instructions.push(o), this.hitDetectionInstructions.push(o), i } drawLineString(t, e) { const i = this.state, n = i.strokeStyle, r = i.lineWidth; if (void 0 === n || void 0 === r) return; this.updateStrokeStyle(i, this.applyStroke), this.beginGeometry(t, e), this.hitDetectionInstructions.push([Xf, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, ks, 0], Yf); const s = t.getFlatCoordinates(), o = t.getStride(); this.drawFlatCoordinates_(s, 0, s.length, o), this.hitDetectionInstructions.push(Zf), this.endGeometry(e) } drawMultiLineString(t, e) { const i = this.state, n = i.strokeStyle, r = i.lineWidth; if (void 0 === n || void 0 === r) return; this.updateStrokeStyle(i, this.applyStroke), this.beginGeometry(t, e), this.hitDetectionInstructions.push([Xf, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, i.lineDash, i.lineDashOffset], Yf); const s = t.getEnds(), o = t.getFlatCoordinates(), a = t.getStride(); let l = 0; for (let t = 0, e = s.length; t < e; ++t)l = this.drawFlatCoordinates_(o, l, s[t], a); this.hitDetectionInstructions.push(Zf), this.endGeometry(e) } finish() { const t = this.state; return null != t.lastStroke && t.lastStroke != this.coordinates.length && this.instructions.push(Zf), this.reverseHitDetectionInstructions(), this.state = null, super.finish() } applyStroke(t) { null != t.lastStroke && t.lastStroke != this.coordinates.length && (this.instructions.push(Zf), t.lastStroke = this.coordinates.length), t.lastStroke = 0, super.applyStroke(t), this.instructions.push(Yf) } } class Jf extends qf { constructor(t, e, i, n) { super(t, e, i, n) } drawFlatCoordinatess_(t, e, i, n) { const r = this.state, s = void 0 !== r.fillStyle, o = void 0 !== r.strokeStyle, a = i.length; this.instructions.push(Yf), this.hitDetectionInstructions.push(Yf); for (let r = 0; r < a; ++r) { const s = i[r], a = this.coordinates.length, l = this.appendFlatLineCoordinates(t, e, s, n, !0, !o), h = [Uf, a, l]; this.instructions.push(h), this.hitDetectionInstructions.push(h), o && (this.instructions.push(Kf), this.hitDetectionInstructions.push(Kf)), e = s } return s && (this.instructions.push(Wf), this.hitDetectionInstructions.push(Wf)), o && (this.instructions.push(Zf), this.hitDetectionInstructions.push(Zf)), e } drawCircle(t, e) { const i = this.state, n = i.fillStyle, r = i.strokeStyle; if (void 0 === n && void 0 === r) return; this.setFillStrokeStyles_(), this.beginGeometry(t, e), void 0 !== i.fillStyle && this.hitDetectionInstructions.push([zf, Ns]), void 0 !== i.strokeStyle && this.hitDetectionInstructions.push([Xf, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, i.lineDash, i.lineDashOffset]); const s = t.getFlatCoordinates(), o = t.getStride(), a = this.coordinates.length; this.appendFlatLineCoordinates(s, 0, s.length, o, !1, !1); const l = [Of, a]; this.instructions.push(Yf, l), this.hitDetectionInstructions.push(Yf, l), void 0 !== i.fillStyle && (this.instructions.push(Wf), this.hitDetectionInstructions.push(Wf)), void 0 !== i.strokeStyle && (this.instructions.push(Zf), this.hitDetectionInstructions.push(Zf)), this.endGeometry(e) } drawPolygon(t, e) { const i = this.state, n = i.fillStyle, r = i.strokeStyle; if (void 0 === n && void 0 === r) return; this.setFillStrokeStyles_(), this.beginGeometry(t, e), void 0 !== i.fillStyle && this.hitDetectionInstructions.push([zf, Ns]), void 0 !== i.strokeStyle && this.hitDetectionInstructions.push([Xf, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, i.lineDash, i.lineDashOffset]); const s = t.getEnds(), o = t.getOrientedFlatCoordinates(), a = t.getStride(); this.drawFlatCoordinatess_(o, 0, s, a), this.endGeometry(e) } drawMultiPolygon(t, e) { const i = this.state, n = i.fillStyle, r = i.strokeStyle; if (void 0 === n && void 0 === r) return; this.setFillStrokeStyles_(), this.beginGeometry(t, e), void 0 !== i.fillStyle && this.hitDetectionInstructions.push([zf, Ns]), void 0 !== i.strokeStyle && this.hitDetectionInstructions.push([Xf, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, i.lineDash, i.lineDashOffset]); const s = t.getEndss(), o = t.getOrientedFlatCoordinates(), a = t.getStride(); let l = 0; for (let t = 0, e = s.length; t < e; ++t)l = this.drawFlatCoordinatess_(o, l, s[t], a); this.endGeometry(e) } finish() { this.reverseHitDetectionInstructions(), this.state = null; const t = this.tolerance; if (0 !== t) { const e = this.coordinates; for (let i = 0, n = e.length; i < n; ++i)e[i] = On(e[i], t) } return super.finish() } setFillStrokeStyles_() { const t = this.state; void 0 !== t.fillStyle && this.updateFillStyle(t, this.createFill), void 0 !== t.strokeStyle && this.updateStrokeStyle(t, this.applyStroke) } } function Qf(t, e, i, n, r) { let s, o, a, l, h, c, u, d, g, f, p = i, m = i, _ = 0, y = 0, x = i; for (o = i; o < n; o += r) { const i = e[o], n = e[o + 1]; void 0 !== h && (g = i - h, f = n - c, l = Math.sqrt(g * g + f * f), void 0 !== u && (y += a, s = Math.acos((u * g + d * f) / (a * l)), s > t && (y > _ && (_ = y, p = x, m = o), y = 0, x = o - r)), a = l, u = g, d = f), h = i, c = n } return y += l, y > _ ? [x, o] : [p, m] } const tp = { left: 0, end: 0, center: .5, right: 1, start: 1, top: 0, middle: .5, hanging: .2, alphabetic: .8, ideographic: .8, bottom: 1 }; class ep extends qf { constructor(t, e, i, n) { super(t, e, i, n), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterImageWithText_ = void 0 } finish() { const t = super.finish(); return t.textStates = this.textStates, t.fillStates = this.fillStates, t.strokeStates = this.strokeStates, t } drawText(t, e) { const i = this.textFillState_, n = this.textStrokeState_, r = this.textState_; if ("" === this.text_ || !r || !i && !n) return; const s = this.coordinates; let o = s.length; const a = t.getType(); let l = null, h = t.getStride(); if ("line" !== r.placement || "LineString" != a && "MultiLineString" != a && "Polygon" != a && "MultiPolygon" != a) { let i = r.overflow ? null : []; switch (a) { case "Point": case "MultiPoint": l = t.getFlatCoordinates(); break; case "LineString": l = t.getFlatMidpoint(); break; case "Circle": l = t.getCenter(); break; case "MultiLineString": l = t.getFlatMidpoints(), h = 2; break; case "Polygon": l = t.getFlatInteriorPoint(), r.overflow || i.push(l[2] / this.resolution), h = 3; break; case "MultiPolygon": const e = t.getFlatInteriorPoints(); l = []; for (let t = 0, n = e.length; t < n; t += 3)r.overflow || i.push(e[t + 2] / this.resolution), l.push(e[t], e[t + 1]); if (0 === l.length) return; h = 2 }const n = this.appendFlatPointCoordinates(l, h); if (n === o) return; if (i && (n - o) / 2 != l.length / h) { let t = o / 2; i = i.filter(((e, i) => { const n = s[2 * (t + i)] === l[i * h] && s[2 * (t + i) + 1] === l[i * h + 1]; return n || --t, n })) } this.saveTextStates_(), (r.backgroundFill || r.backgroundStroke) && (this.setFillStrokeStyle(r.backgroundFill, r.backgroundStroke), r.backgroundFill && (this.updateFillStyle(this.state, this.createFill), this.hitDetectionInstructions.push(this.createFill(this.state))), r.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke), this.hitDetectionInstructions.push(this.createStroke(this.state)))), this.beginGeometry(t, e); let c = r.padding; if (c != Xs && (r.scale[0] < 0 || r.scale[1] < 0)) { let t = r.padding[0], e = r.padding[1], i = r.padding[2], n = r.padding[3]; r.scale[0] < 0 && (e = -e, n = -n), r.scale[1] < 0 && (t = -t, i = -i), c = [t, e, i, n] } const u = this.pixelRatio; this.instructions.push([Gf, o, n, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [1, 1], NaN, void 0, this.declutterImageWithText_, c == Xs ? Xs : c.map((function (t) { return t * u })), !!r.backgroundFill, !!r.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, i]); const d = 1 / u; this.hitDetectionInstructions.push([Gf, o, n, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [d, d], NaN, void 0, this.declutterImageWithText_, c, !!r.backgroundFill, !!r.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, i]), this.endGeometry(e) } else { if (!we(this.getBufferedMaxExtent(), t.getExtent())) return; let i; if (l = t.getFlatCoordinates(), "LineString" == a) i = [l.length]; else if ("MultiLineString" == a) i = t.getEnds(); else if ("Polygon" == a) i = t.getEnds().slice(0, 1); else if ("MultiPolygon" == a) { const e = t.getEndss(); i = []; for (let t = 0, n = e.length; t < n; ++t)i.push(e[t][0]) } this.beginGeometry(t, e); const n = r.textAlign; let c, u = 0; for (let t = 0, e = i.length; t < e; ++t) { if (null == n) { const e = Qf(r.maxAngle, l, u, i[t], h); u = e[0], c = e[1] } else c = i[t]; for (let t = u; t < c; t += h)s.push(l[t], l[t + 1]); const e = s.length; u = i[t], this.drawChars_(o, e), o = e } this.endGeometry(e) } } saveTextStates_() { const t = this.textStrokeState_, e = this.textState_, i = this.textFillState_, n = this.strokeKey_; t && (n in this.strokeStates || (this.strokeStates[n] = { strokeStyle: t.strokeStyle, lineCap: t.lineCap, lineDashOffset: t.lineDashOffset, lineWidth: t.lineWidth, lineJoin: t.lineJoin, miterLimit: t.miterLimit, lineDash: t.lineDash })); const r = this.textKey_; r in this.textStates || (this.textStates[r] = { font: e.font, textAlign: e.textAlign || Us, justify: e.justify, textBaseline: e.textBaseline || zs, scale: e.scale }); const s = this.fillKey_; i && (s in this.fillStates || (this.fillStates[s] = { fillStyle: i.fillStyle })) } drawChars_(t, e) { const i = this.textStrokeState_, n = this.textState_, r = this.strokeKey_, s = this.textKey_, o = this.fillKey_; this.saveTextStates_(); const a = this.pixelRatio, l = tp[n.textBaseline], h = this.textOffsetY_ * a, c = this.text_, u = i ? i.lineWidth * Math.abs(n.scale[0]) / 2 : 0; this.instructions.push([kf, t, e, l, n.overflow, o, n.maxAngle, a, h, r, u * a, c, s, 1]), this.hitDetectionInstructions.push([kf, t, e, l, n.overflow, o, n.maxAngle, 1, h, r, u, c, s, 1 / a]) } setTextStyle(t, e) { let i, n, r; if (t) { const e = t.getFill(); e ? (n = this.textFillState_, n || (n = {}, this.textFillState_ = n), n.fillStyle = fl(e.getColor() || Ns)) : (n = null, this.textFillState_ = n); const s = t.getStroke(); if (s) { r = this.textStrokeState_, r || (r = {}, this.textStrokeState_ = r); const t = s.getLineDash(), e = s.getLineDashOffset(), i = s.getWidth(), n = s.getMiterLimit(); r.lineCap = s.getLineCap() || Ds, r.lineDash = t ? t.slice() : ks, r.lineDashOffset = void 0 === e ? 0 : e, r.lineJoin = s.getLineJoin() || Gs, r.lineWidth = void 0 === i ? 1 : i, r.miterLimit = void 0 === n ? js : n, r.strokeStyle = fl(s.getColor() || Bs) } else r = null, this.textStrokeState_ = r; i = this.textState_; const o = t.getFont() || Os; Ks(o); const a = t.getScaleArray(); i.overflow = t.getOverflow(), i.font = o, i.maxAngle = t.getMaxAngle(), i.placement = t.getPlacement(), i.textAlign = t.getTextAlign(), i.justify = t.getJustify(), i.textBaseline = t.getTextBaseline() || zs, i.backgroundFill = t.getBackgroundFill(), i.backgroundStroke = t.getBackgroundStroke(), i.padding = t.getPadding() || Xs, i.scale = void 0 === a ? [1, 1] : a; const l = t.getOffsetX(), h = t.getOffsetY(), c = t.getRotateWithView(), u = t.getRotation(); this.text_ = t.getText() || "", this.textOffsetX_ = void 0 === l ? 0 : l, this.textOffsetY_ = void 0 === h ? 0 : h, this.textRotateWithView_ = void 0 !== c && c, this.textRotation_ = void 0 === u ? 0 : u, this.strokeKey_ = r ? ("string" == typeof r.strokeStyle ? r.strokeStyle : z(r.strokeStyle)) + r.lineCap + r.lineDashOffset + "|" + r.lineWidth + r.lineJoin + r.miterLimit + "[" + r.lineDash.join() + "]" : "", this.textKey_ = i.font + i.scale + (i.textAlign || "?") + (i.justify || "?") + (i.textBaseline || "?"), this.fillKey_ = n ? "string" == typeof n.fillStyle ? n.fillStyle : "|" + z(n.fillStyle) : "" } else this.text_ = ""; this.declutterImageWithText_ = e } } const ip = { Circle: Jf, Default: qf, Image: Hf, LineString: $f, Polygon: Jf, Text: ep }; class np { constructor(t, e, i, n) { this.tolerance_ = t, this.maxExtent_ = e, this.pixelRatio_ = n, this.resolution_ = i, this.buildersByZIndex_ = {} } finish() { const t = {}; for (const e in this.buildersByZIndex_) { t[e] = t[e] || {}; const i = this.buildersByZIndex_[e]; for (const n in i) { const r = i[n].finish(); t[e][n] = r } } return t } getBuilder(t, e) { const i = void 0 !== t ? t.toString() : "0"; let n = this.buildersByZIndex_[i]; void 0 === n && (n = {}, this.buildersByZIndex_[i] = n); let r = n[e]; if (void 0 === r) { r = new (0, ip[e])(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_), n[e] = r } return r } } function rp(t, e, i, n, r, s, o, a, l, h, c, u) { let d = t[e], g = t[e + 1], f = 0, p = 0, m = 0, _ = 0; function y() { f = d, p = g, d = t[e += n], g = t[e + 1], _ += m, m = Math.sqrt((d - f) * (d - f) + (g - p) * (g - p)) } do { y() } while (e < i - n && _ + m < s); let x = 0 === m ? 0 : (s - _) / m; const v = hi(f, d, x), S = hi(p, g, x), w = e - n, E = _, T = s + a * l(h, r, c); for (; e < i - n && _ + m < T;)y(); x = 0 === m ? 0 : (T - _) / m; const C = hi(f, d, x), b = hi(p, g, x); let R; if (u) { const t = [v, S, C, b]; dn(t, 0, 4, 2, u, t, t), R = t[0] > t[2] } else R = v > C; const P = Math.PI, I = [], L = w + n === e; let M; if (m = 0, _ = E, d = t[e = w], g = t[e + 1], L) { y(), M = Math.atan2(g - p, d - f), R && (M += M > 0 ? -P : P); const t = (C + v) / 2, e = (b + S) / 2; return I[0] = [t, e, (T - s) / 2, M, r], I } for (let t = 0, u = (r = r.replace(/\n/g, " ")).length; t < u;) { y(); let v = Math.atan2(g - p, d - f); if (R && (v += v > 0 ? -P : P), void 0 !== M) { let t = v - M; if (t += t > P ? -2 * P : t < -P ? 2 * P : 0, Math.abs(t) > o) return null } M = v; const S = t; let w = 0; for (; t < u; ++t) { const o = a * l(h, r[R ? u - t - 1 : t], c); if (e + n < i && _ + m < s + w + o / 2) break; w += o } if (t === S) continue; const E = R ? r.substring(u - S, u - t) : r.substring(S, t); x = 0 === m ? 0 : (s + w / 2 - _) / m; const T = hi(f, d, x), C = hi(p, g, x); I.push([T, C, w / 2, v, E]), s += w } return I } function sp(t, e, i, n) { let r = t[e], s = t[e + 1], o = 0; for (let a = e + n; a < i; a += n) { const e = t[a], i = t[a + 1]; o += Math.sqrt((e - r) * (e - r) + (i - s) * (i - s)), r = e, s = i } return o } const op = [1 / 0, 1 / 0, -1 / 0, -1 / 0], ap = [], lp = [], hp = [], cp = []; function up(t) { return t[3].declutterBox } const dp = new RegExp("[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]"); function gp(t, e) { return "start" !== e && "end" !== e || dp.test(t) || (e = "start" === e ? "left" : "right"), tp[e] } function fp(t, e, i) { return i > 0 && t.push("\n", ""), t.push(e, ""), t } class pp { constructor(t, e, i, n) { this.overlaps = i, this.pixelRatio = e, this.resolution = t, this.alignFill_, this.instructions = n.instructions, this.coordinates = n.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = [1, 0, 0, 1, 0, 0], this.hitDetectionInstructions = n.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = n.fillStates || {}, this.strokeStates = n.strokeStates || {}, this.textStates = n.textStates || {}, this.widths_ = {}, this.labels_ = {} } createLabel(t, e, i, n) { const r = t + e + i + n; if (this.labels_[r]) return this.labels_[r]; const s = n ? this.strokeStates[n] : null, o = i ? this.fillStates[i] : null, a = this.textStates[e], l = this.pixelRatio, h = [a.scale[0] * l, a.scale[1] * l], c = Array.isArray(t), u = a.justify ? tp[a.justify] : gp(Array.isArray(t) ? t[0] : t, a.textAlign || Us), d = n && s.lineWidth ? s.lineWidth : 0, g = c ? t : t.split("\n").reduce(fp, []), { width: f, height: p, widths: m, heights: _, lineWidths: y } = Qs(a, g), x = f + d, v = [], S = (x + 2) * h[0], w = (p + d) * h[1], E = { width: S < 0 ? Math.floor(S) : Math.ceil(S), height: w < 0 ? Math.floor(w) : Math.ceil(w), contextInstructions: v }; 1 == h[0] && 1 == h[1] || v.push("scale", h), n && (v.push("strokeStyle", s.strokeStyle), v.push("lineWidth", d), v.push("lineCap", s.lineCap), v.push("lineJoin", s.lineJoin), v.push("miterLimit", s.miterLimit), v.push("setLineDash", [s.lineDash]), v.push("lineDashOffset", s.lineDashOffset)), i && v.push("fillStyle", o.fillStyle), v.push("textBaseline", "middle"), v.push("textAlign", "center"); const T = .5 - u; let C = u * x + T * d; const b = [], R = []; let P, I = 0, L = 0, M = 0, F = 0; for (let t = 0, e = g.length; t < e; t += 2) { const e = g[t]; if ("\n" === e) { L += I, I = 0, C = u * x + T * d, ++F; continue } const r = g[t + 1] || a.font; r !== P && (n && b.push("font", r), i && R.push("font", r), P = r), I = Math.max(I, _[M]); const s = [e, C + T * m[M] + u * (m[M] - y[F]), .5 * (d + I) + L]; C += m[M], n && b.push("strokeText", s), i && R.push("fillText", s), ++M } return Array.prototype.push.apply(v, b), Array.prototype.push.apply(v, R), this.labels_[r] = E, E } replayTextBackground_(t, e, i, n, r, s, o) { t.beginPath(), t.moveTo.apply(t, e), t.lineTo.apply(t, i), t.lineTo.apply(t, n), t.lineTo.apply(t, r), t.lineTo.apply(t, e), s && (this.alignFill_ = s[2], this.fill_(t)), o && (this.setStrokeStyle_(t, o), t.stroke()) } calculateImageOrLabelDimensions_(t, e, i, n, r, s, o, a, l, h, c, u, d, g, f, p) { let m = i - (o *= u[0]), _ = n - (a *= u[1]); const y = r + l > t ? t - l : r, x = s + h > e ? e - h : s, v = g[3] + y * u[0] + g[1], S = g[0] + x * u[1] + g[2], w = m - g[3], E = _ - g[0]; let T; return (f || 0 !== c) && (ap[0] = w, cp[0] = w, ap[1] = E, lp[1] = E, lp[0] = w + v, hp[0] = lp[0], hp[1] = E + S, cp[1] = hp[1]), 0 !== c ? (T = Mt([1, 0, 0, 1, 0, 0], i, n, 1, 1, c, -i, -n), bt(T, ap), bt(T, lp), bt(T, hp), bt(T, cp), $t(Math.min(ap[0], lp[0], hp[0], cp[0]), Math.min(ap[1], lp[1], hp[1], cp[1]), Math.max(ap[0], lp[0], hp[0], cp[0]), Math.max(ap[1], lp[1], hp[1], cp[1]), op)) : $t(Math.min(w, w + v), Math.min(E, E + S), Math.max(w, w + v), Math.max(E, E + S), op), d && (m = Math.round(m), _ = Math.round(_)), { drawImageX: m, drawImageY: _, drawImageW: y, drawImageH: x, originX: l, originY: h, declutterBox: { minX: op[0], minY: op[1], maxX: op[2], maxY: op[3], value: p }, canvasTransform: T, scale: u } } replayImageOrLabel_(t, e, i, n, r, s, o) { const a = !(!s && !o), l = n.declutterBox, h = t.canvas, c = o ? o[2] * n.scale[0] / 2 : 0; return l.minX - c <= h.width / e && l.maxX + c >= 0 && l.minY - c <= h.height / e && l.maxY + c >= 0 && (a && this.replayTextBackground_(t, ap, lp, hp, cp, s, o), to(t, n.canvasTransform, r, i, n.originX, n.originY, n.drawImageW, n.drawImageH, n.drawImageX, n.drawImageY, n.scale)), !0 } fill_(t) { if (this.alignFill_) { const e = bt(this.renderedTransform_, [0, 0]), i = 512 * this.pixelRatio; t.save(), t.translate(e[0] % i, e[1] % i), t.rotate(this.viewRotation_) } t.fill(), this.alignFill_ && t.restore() } setStrokeStyle_(t, e) { t.strokeStyle = e[1], t.lineWidth = e[2], t.lineCap = e[3], t.lineJoin = e[4], t.miterLimit = e[5], t.lineDashOffset = e[7], t.setLineDash(e[6]) } drawLabelWithPointPlacement_(t, e, i, n) { const r = this.textStates[e], s = this.createLabel(t, e, n, i), o = this.strokeStates[i], a = this.pixelRatio, l = gp(Array.isArray(t) ? t[0] : t, r.textAlign || Us), h = tp[r.textBaseline || zs], c = o && o.lineWidth ? o.lineWidth : 0; return { label: s, anchorX: l * (s.width / a - 2 * r.scale[0]) + 2 * (.5 - l) * c, anchorY: h * s.height / a + 2 * (.5 - h) * c } } execute_(t, e, i, n, r, s, o, a) { let l; this.pixelCoordinates_ && u(i, this.renderedTransform_) ? l = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), l = un(this.coordinates, 0, this.coordinates.length, 2, i, this.pixelCoordinates_), Ct(this.renderedTransform_, i)); let h = 0; const c = n.length; let d, g, f, p, m, _, y, x, v, S, w, E, T = 0, C = 0, b = 0, R = null, P = null; const I = this.coordinateCache_, L = this.viewRotation_, M = Math.round(1e12 * Math.atan2(-i[1], i[0])) / 1e12, F = { context: t, pixelRatio: this.pixelRatio, resolution: this.resolution, rotation: L }, A = this.instructions != n || this.overlaps ? 0 : 200; let O, N, D, k; for (; h < c;) { const i = n[h]; switch (i[0]) { case Ff: O = i[1], k = i[3], O.getGeometry() ? void 0 === o || we(o, k.getExtent()) ? ++h : h = i[2] + 1 : h = i[2]; break; case Af: C > A && (this.fill_(t), C = 0), b > A && (t.stroke(), b = 0), C || b || (t.beginPath(), p = NaN, m = NaN), ++h; break; case Of: T = i[1]; const n = l[T], c = l[T + 1], u = l[T + 2] - n, G = l[T + 3] - c, j = Math.sqrt(u * u + G * G); t.moveTo(n + j, c), t.arc(n, c, j, 0, 2 * Math.PI, !0), ++h; break; case Nf: t.closePath(), ++h; break; case Df: T = i[1], d = i[2]; const B = i[3], U = i[4], z = 6 == i.length ? i[5] : void 0; F.geometry = B, F.feature = O, h in I || (I[h] = []); const X = I[h]; z ? z(l, T, d, 2, X) : (X[0] = l[T], X[1] = l[T + 1], X.length = 2), U(X, F), ++h; break; case Gf: T = i[1], d = i[2], x = i[3], g = i[4], f = i[5]; let V = i[6]; const W = i[7], Z = i[8], Y = i[9], K = i[10]; let q = i[11]; const H = i[12]; let $ = i[13]; const J = i[14], Q = i[15]; if (!x && i.length >= 20) { v = i[19], S = i[20], w = i[21], E = i[22]; const t = this.drawLabelWithPointPlacement_(v, S, w, E); x = t.label, i[3] = x; const e = i[23]; g = (t.anchorX - e) * this.pixelRatio, i[4] = g; const n = i[24]; f = (t.anchorY - n) * this.pixelRatio, i[5] = f, V = x.height, i[6] = V, $ = x.width, i[13] = $ } let tt, et, it, nt; i.length > 25 && (tt = i[25]), i.length > 17 ? (et = i[16], it = i[17], nt = i[18]) : (et = Xs, it = !1, nt = !1), K && M ? q += L : K || M || (q -= L); let rt = 0; for (; T < d; T += 2) { if (tt && tt[rt++] < $ / this.pixelRatio) continue; const i = this.calculateImageOrLabelDimensions_(x.width, x.height, l[T], l[T + 1], $, V, g, f, Z, Y, q, H, r, et, it || nt, O), n = [t, e, x, i, W, it ? R : null, nt ? P : null]; if (a) { if ("none" === J) continue; if ("obstacle" === J) { a.insert(i.declutterBox); continue } { let t, e; if (Q) { const i = d - T; if (!Q[i]) { Q[i] = n; continue } if (t = Q[i], delete Q[i], e = up(t), a.collides(e)) continue } if (a.collides(i.declutterBox)) continue; t && (a.insert(e), this.replayImageOrLabel_.apply(this, t)), a.insert(i.declutterBox) } } this.replayImageOrLabel_.apply(this, n) } ++h; break; case kf: const st = i[1], ot = i[2], at = i[3], lt = i[4]; E = i[5]; const ht = i[6], ct = i[7], ut = i[8]; w = i[9]; const dt = i[10]; v = i[11], S = i[12]; const gt = [i[13], i[13]], ft = this.textStates[S], pt = ft.font, mt = [ft.scale[0] * ct, ft.scale[1] * ct]; let _t; pt in this.widths_ ? _t = this.widths_[pt] : (_t = {}, this.widths_[pt] = _t); const yt = sp(l, st, ot, 2), xt = Math.abs(mt[0]) * Js(pt, v, _t); if (lt || xt <= yt) { const i = this.textStates[S].textAlign, n = rp(l, st, ot, 2, v, (yt - xt) * tp[i], ht, Math.abs(mt[0]), Js, pt, _t, M ? 0 : this.viewRotation_); t: if (n) { const i = []; let r, s, o, l, h; if (w) for (r = 0, s = n.length; r < s; ++r) { h = n[r], o = h[4], l = this.createLabel(o, S, "", w), g = h[2] + (mt[0] < 0 ? -dt : dt), f = at * l.height + 2 * (.5 - at) * dt * mt[1] / mt[0] - ut; const s = this.calculateImageOrLabelDimensions_(l.width, l.height, h[0], h[1], l.width, l.height, g, f, 0, 0, h[3], gt, !1, Xs, !1, O); if (a && a.collides(s.declutterBox)) break t; i.push([t, e, l, s, 1, null, null]) } if (E) for (r = 0, s = n.length; r < s; ++r) { h = n[r], o = h[4], l = this.createLabel(o, S, E, ""), g = h[2], f = at * l.height - ut; const s = this.calculateImageOrLabelDimensions_(l.width, l.height, h[0], h[1], l.width, l.height, g, f, 0, 0, h[3], gt, !1, Xs, !1, O); if (a && a.collides(s.declutterBox)) break t; i.push([t, e, l, s, 1, null, null]) } a && a.load(i.map(up)); for (let t = 0, e = i.length; t < e; ++t)this.replayImageOrLabel_.apply(this, i[t]) } } ++h; break; case jf: if (void 0 !== s) { O = i[1]; const t = s(O, k); if (t) return t } ++h; break; case Bf: A ? C++ : this.fill_(t), ++h; break; case Uf: for (T = i[1], d = i[2], N = l[T], D = l[T + 1], _ = N + .5 | 0, y = D + .5 | 0, _ === p && y === m || (t.moveTo(N, D), p = _, m = y), T += 2; T < d; T += 2)N = l[T], D = l[T + 1], _ = N + .5 | 0, y = D + .5 | 0, T != d - 2 && _ === p && y === m || (t.lineTo(N, D), p = _, m = y); ++h; break; case zf: R = i, this.alignFill_ = i[2], C && (this.fill_(t), C = 0, b && (t.stroke(), b = 0)), t.fillStyle = i[1], ++h; break; case Xf: P = i, b && (t.stroke(), b = 0), this.setStrokeStyle_(t, i), ++h; break; case Vf: A ? b++ : t.stroke(), ++h; break; default: ++h } } C && this.fill_(t), b && t.stroke() } execute(t, e, i, n, r, s) { this.viewRotation_ = n, this.execute_(t, e, i, this.instructions, r, void 0, void 0, s) } executeHitDetection(t, e, i, n, r) { return this.viewRotation_ = i, this.execute_(t, 1, e, this.hitDetectionInstructions, !0, n, r) } } const mp = ["Polygon", "Circle", "LineString", "Image", "Text", "Default"]; class _p { constructor(t, e, i, n, r, s) { this.maxExtent_ = t, this.overlaps_ = n, this.pixelRatio_ = i, this.resolution_ = e, this.renderBuffer_ = s, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = [1, 0, 0, 1, 0, 0], this.createExecutors_(r) } clip(t, e) { const i = this.getClipCoords(e); t.beginPath(), t.moveTo(i[0], i[1]), t.lineTo(i[2], i[3]), t.lineTo(i[4], i[5]), t.lineTo(i[6], i[7]), t.clip() } createExecutors_(t) { for (const e in t) { let i = this.executorsByZIndex_[e]; void 0 === i && (i = {}, this.executorsByZIndex_[e] = i); const n = t[e]; for (const t in n) { const e = n[t]; i[t] = new pp(this.resolution_, this.pixelRatio_, this.overlaps_, e) } } } hasExecutors(t) { for (const e in this.executorsByZIndex_) { const i = this.executorsByZIndex_[e]; for (let e = 0, n = t.length; e < n; ++e)if (t[e] in i) return !0 } return !1 } forEachFeatureAtCoordinate(t, e, i, n, r, s) { const o = 2 * (n = Math.round(n)) + 1, l = Mt(this.hitDetectionTransform_, n + .5, n + .5, 1 / e, -1 / e, -i, -t[0], -t[1]), h = !this.hitDetectionContext_; h && (this.hitDetectionContext_ = Dr(o, o)); const c = this.hitDetectionContext_; let u; c.canvas.width !== o || c.canvas.height !== o ? (c.canvas.width = o, c.canvas.height = o) : h || c.clearRect(0, 0, o, o), void 0 !== this.renderBuffer_ && (u = [1 / 0, 1 / 0, -1 / 0, -1 / 0], re(u, t), Xt(u, e * (this.renderBuffer_ + n), u)); const d = xp(n); let g; function f(t, e) { const i = c.getImageData(0, 0, o, o).data; for (let a = 0, l = d.length; a < l; a++)if (i[d[a]] > 0) { if (!s || "Image" !== g && "Text" !== g || s.includes(t)) { const i = (d[a] - 3) / 4, s = n - i % o, l = n - (i / o | 0), h = r(t, e, s * s + l * l); if (h) return h } c.clearRect(0, 0, o, o); break } } const p = Object.keys(this.executorsByZIndex_).map(Number); let m, _, y, x, v; for (p.sort(a), m = p.length - 1; m >= 0; --m) { const t = p[m].toString(); for (y = this.executorsByZIndex_[t], _ = mp.length - 1; _ >= 0; --_)if (g = mp[_], x = y[g], void 0 !== x && (v = x.executeHitDetection(c, l, i, f, u), v)) return v } } getClipCoords(t) { const e = this.maxExtent_; if (!e) return null; const i = e[0], n = e[1], r = e[2], s = e[3], o = [i, n, i, s, r, s, r, n]; return un(o, 0, 8, 2, t, o), o } isEmpty() { return x(this.executorsByZIndex_) } execute(t, e, i, n, r, s, o) { const l = Object.keys(this.executorsByZIndex_).map(Number); let h, c, u, d, g, f; for (l.sort(a), this.maxExtent_ && (t.save(), this.clip(t, i)), s = s || mp, o && l.reverse(), h = 0, c = l.length; h < c; ++h) { const a = l[h].toString(); for (g = this.executorsByZIndex_[a], u = 0, d = s.length; u < d; ++u) { f = g[s[u]], void 0 !== f && f.execute(t, e, i, n, r, o) } } this.maxExtent_ && t.restore() } } const yp = {}; function xp(t) { if (void 0 !== yp[t]) return yp[t]; const e = 2 * t + 1, i = t * t, n = new Array(i + 1); for (let r = 0; r <= t; ++r)for (let s = 0; s <= t; ++s) { const o = r * r + s * s; if (o > i) break; let a = n[o]; a || (a = [], n[o] = a), a.push(4 * ((t + r) * e + (t + s)) + 3), r > 0 && a.push(4 * ((t - r) * e + (t + s)) + 3), s > 0 && (a.push(4 * ((t + r) * e + (t - s)) + 3), r > 0 && a.push(4 * ((t - r) * e + (t - s)) + 3)) } const r = []; for (let t = 0, e = n.length; t < e; ++t)n[t] && r.push(...n[t]); return yp[t] = r, r } const vp = .5; function Sp(t, e, i, n, r, s, o) { const l = Dr(t[0] * vp, t[1] * vp); l.imageSmoothingEnabled = !1; const h = l.canvas, c = new bl(l, vp, r, null, o), u = i.length, d = Math.floor(16777215 / u), g = {}; for (let t = 1; t <= u; ++t) { const e = i[t - 1], o = e.getStyleFunction() || n; if (!n) continue; let a = o(e, s); if (!a) continue; Array.isArray(a) || (a = [a]); const l = "#" + ("000000" + (t * d).toString(16)).slice(-6); for (let t = 0, i = a.length; t < i; ++t) { const i = a[t], n = i.getGeometryFunction()(e); if (!n || !we(r, n.getExtent())) continue; const s = i.clone(), o = s.getFill(); o && o.setColor(l); const h = s.getStroke(); h && (h.setColor(l), h.setLineDash(null)), s.setText(void 0); const c = i.getImage(); if (c && 0 !== c.getOpacity()) { const t = c.getImageSize(); if (!t) continue; const e = Dr(t[0], t[1], void 0, { alpha: !1 }), i = e.canvas; e.fillStyle = l, e.fillRect(0, 0, i.width, i.height), s.setImage(new lg({ img: i, imgSize: t, anchor: c.getAnchor(), anchorXUnits: "pixels", anchorYUnits: "pixels", offset: c.getOrigin(), opacity: 1, size: c.getSize(), scale: c.getScale(), rotation: c.getRotation(), rotateWithView: c.getRotateWithView() })) } const u = s.getZIndex() || 0; let d = g[u]; d || (d = {}, g[u] = d, d.Polygon = [], d.Circle = [], d.LineString = [], d.Point = []), d[n.getType().replace("Multi", "")].push(n, s) } } const f = Object.keys(g).map(Number).sort(a); for (let t = 0, i = f.length; t < i; ++t) { const i = g[f[t]]; for (const t in i) { const n = i[t]; for (let t = 0, i = n.length; t < i; t += 2) { c.setStyle(n[t + 1]); for (let i = 0, r = e.length; i < r; ++i)c.setTransform(e[i]), c.drawGeometry(n[t]) } } } return l.getImageData(0, 0, h.width, h.height) } function wp(t, e, i) { const n = []; if (i) { const r = Math.floor(Math.round(t[0]) * vp), s = Math.floor(Math.round(t[1]) * vp), o = 4 * (ii(r, 0, i.width - 1) + ii(s, 0, i.height - 1) * i.width), a = i.data[o], l = i.data[o + 1], h = i.data[o + 2] + 256 * (l + 256 * a), c = Math.floor(16777215 / e.length); h && h % c == 0 && n.push(e[h / c - 1]) } return n } class Ep extends Pc { constructor(t) { super(t), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], this.wrappedRenderedExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedRenderOrder_ = null, this.replayGroup_ = null, this.replayGroupChanged = !0, this.declutterExecutorGroup = null, this.clipping = !0, this.compositionContext_ = null, this.opacity_ = 1 } renderWorlds(t, e, i) { const n = e.extent, r = e.viewState, s = r.center, o = r.resolution, a = r.projection, l = r.rotation, h = a.getExtent(), c = this.getLayer().getSource(), u = e.pixelRatio, d = e.viewHints, g = !(d[Ro] || d[Po]), f = this.compositionContext_, p = Math.round(e.size[0] * u), m = Math.round(e.size[1] * u), _ = c.getWrapX() && a.canWrapX(), y = _ ? Se(h) : null, x = _ ? Math.ceil((n[2] - h[2]) / y) + 1 : 1; let v = _ ? Math.floor((n[0] - h[0]) / y) : 0; do { const e = this.getRenderTransform(s, o, l, u, p, m, v * y); t.execute(f, 1, e, l, g, void 0, i) } while (++v < x) } setupCompositionContext_() { if (1 !== this.opacity_) { const t = Dr(this.context.canvas.width, this.context.canvas.height, bc); this.compositionContext_ = t } else this.compositionContext_ = this.context } releaseCompositionContext_() { if (1 !== this.opacity_) { const t = this.context.globalAlpha; this.context.globalAlpha = this.opacity_, this.context.drawImage(this.compositionContext_.canvas, 0, 0), this.context.globalAlpha = t, kr(this.compositionContext_), bc.push(this.compositionContext_.canvas), this.compositionContext_ = null } } renderDeclutter(t) { this.declutterExecutorGroup && (this.setupCompositionContext_(), this.renderWorlds(this.declutterExecutorGroup, t, t.declutterTree), this.releaseCompositionContext_()) } renderFrame(t, e) { const i = t.pixelRatio, n = t.layerStatesArray[t.layerIndex]; It(this.pixelTransform, 1 / i, 1 / i), Ft(this.inversePixelTransform, this.pixelTransform); const r = Nt(this.pixelTransform); this.useContainer(e, r, this.getBackground(t)); const s = this.context, o = s.canvas, a = this.replayGroup_, l = this.declutterExecutorGroup; if ((!a || a.isEmpty()) && (!l || l.isEmpty())) return null; const h = Math.round(t.size[0] * i), c = Math.round(t.size[1] * i); o.width != h || o.height != c ? (o.width = h, o.height = c, o.style.transform !== r && (o.style.transform = r)) : this.containerReused || s.clearRect(0, 0, h, c), this.preRender(s, t); const u = t.viewState, d = u.projection; this.opacity_ = n.opacity, this.setupCompositionContext_(); let g = !1, f = !0; if (n.extent && this.clipping) { const e = on(n.extent, d); f = we(e, t.extent), g = f && !Yt(e, t.extent), g && this.clipUnrotated(this.compositionContext_, t, e) } return f && this.renderWorlds(a, t), g && this.compositionContext_.restore(), this.releaseCompositionContext_(), this.postRender(s, t), this.renderedRotation_ !== u.rotation && (this.renderedRotation_ = u.rotation, this.hitDetectionImageData_ = null), this.container } getFeatures(t) { return new Promise(function (e) { if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) { const t = [this.context.canvas.width, this.context.canvas.height]; bt(this.pixelTransform, t); const e = this.renderedCenter_, i = this.renderedResolution_, n = this.renderedRotation_, r = this.renderedProjection_, s = this.wrappedRenderedExtent_, o = this.getLayer(), a = [], l = t[0] * vp, h = t[1] * vp; a.push(this.getRenderTransform(e, i, n, vp, l, h, 0).slice()); const c = o.getSource(), u = r.getExtent(); if (c.getWrapX() && r.canWrapX() && !Yt(u, s)) { let t = s[0]; const r = Se(u); let o, c = 0; for (; t < u[0];)--c, o = r * c, a.push(this.getRenderTransform(e, i, n, vp, l, h, o).slice()), t += r; for (c = 0, t = s[2]; t > u[2];)++c, o = r * c, a.push(this.getRenderTransform(e, i, n, vp, l, h, o).slice()), t -= r } this.hitDetectionImageData_ = Sp(t, a, this.renderedFeatures_, o.getStyleFunction(), s, i, n) } e(wp(t, this.renderedFeatures_, this.hitDetectionImageData_)) }.bind(this)) } forEachFeatureAtCoordinate(t, e, i, n, r) { if (!this.replayGroup_) return; const s = e.viewState.resolution, o = e.viewState.rotation, a = this.getLayer(), l = {}, h = function (t, e, i) { const s = z(t), o = l[s]; if (o) { if (!0 !== o && i < o.distanceSq) { if (0 === i) return l[s] = !0, r.splice(r.lastIndexOf(o), 1), n(t, a, e); o.geometry = e, o.distanceSq = i } } else { if (0 === i) return l[s] = !0, n(t, a, e); r.push(l[s] = { feature: t, layer: a, geometry: e, distanceSq: i, callback: n }) } }; let c; const u = [this.replayGroup_]; return this.declutterExecutorGroup && u.push(this.declutterExecutorGroup), u.some((n => c = n.forEachFeatureAtCoordinate(t, s, o, i, h, n === this.declutterExecutorGroup && e.declutterTree ? e.declutterTree.all().map((t => t.value)) : null))), c } handleFontsChanged() { const t = this.getLayer(); t.getVisible() && this.replayGroup_ && t.changed() } handleStyleImageChange_(t) { this.renderIfReadyAndVisible() } prepareFrame(t) { const e = this.getLayer(), i = e.getSource(); if (!i) return !1; const n = t.viewHints[Ro], r = t.viewHints[Po], s = e.getUpdateWhileAnimating(), o = e.getUpdateWhileInteracting(); if (this.ready && !s && n || !o && r) return this.animatingOrInteracting_ = !0, !0; this.animatingOrInteracting_ = !1; const a = t.extent, l = t.viewState, h = l.projection, c = l.resolution, d = t.pixelRatio, g = e.getRevision(), f = e.getRenderBuffer(); let p = e.getRenderOrder(); void 0 === p && (p = Pl); const m = l.center.slice(), _ = Xt(a, f * c), y = _.slice(), x = [_.slice()], v = h.getExtent(); if (i.getWrapX() && h.canWrapX() && !Yt(v, t.extent)) { const t = Se(v), e = Math.max(Se(_) / 2, t); _[0] = v[0] - e, _[2] = v[2] + e, Pi(m, h); const i = Pe(x[0], h); i[0] < v[0] && i[2] < v[2] ? x.push([i[0] + t, i[1], i[2] + t, i[3]]) : i[0] > v[0] && i[2] > v[2] && x.push([i[0] - t, i[1], i[2] - t, i[3]]) } if (this.ready && this.renderedResolution_ == c && this.renderedRevision_ == g && this.renderedRenderOrder_ == p && Yt(this.wrappedRenderedExtent_, _)) return u(this.renderedExtent_, y) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = y), this.renderedCenter_ = m, this.replayGroupChanged = !1, !0; this.replayGroup_ = null; const S = new np(Ll(c, d), _, c, d); let w; this.getLayer().getDeclutter() && (w = new np(Ll(c, d), _, c, d)); const E = en(); let T; if (E) { for (let t = 0, e = x.length; t < e; ++t) { const e = sn(x[t], h); i.loadFeatures(e, an(c, h), E) } T = qi(E, h) } else for (let t = 0, e = x.length; t < e; ++t)i.loadFeatures(x[t], c, h); const C = Il(c, d); let b = !0; const R = function (t) { let i; const n = t.getStyleFunction() || e.getStyleFunction(); if (n && (i = n(t, c)), i) { const e = this.renderFeature(t, C, i, S, T, w); b = b && !e } }.bind(this), P = sn(_, h), I = i.getFeaturesInExtent(P); p && I.sort(p); for (let t = 0, e = I.length; t < e; ++t)R(I[t]); this.renderedFeatures_ = I, this.ready = b; const L = S.finish(), M = new _p(_, c, d, i.getOverlaps(), L, e.getRenderBuffer()); return w && (this.declutterExecutorGroup = new _p(_, c, d, i.getOverlaps(), w.finish(), e.getRenderBuffer())), this.renderedResolution_ = c, this.renderedRevision_ = g, this.renderedRenderOrder_ = p, this.renderedExtent_ = y, this.wrappedRenderedExtent_ = _, this.renderedCenter_ = m, this.renderedProjection_ = h, this.replayGroup_ = M, this.hitDetectionImageData_ = null, this.replayGroupChanged = !0, !0 } renderFeature(t, e, i, n, r, s) { if (!i) return !1; let o = !1; if (Array.isArray(i)) for (let a = 0, l = i.length; a < l; ++a)o = Ml(n, t, i[a], e, this.boundHandleStyleImageChange_, r, s) || o; else o = Ml(n, t, i, e, this.boundHandleStyleImageChange_, r, s); return o } } class Tp extends Ic { constructor(t) { super(t), this.vectorRenderer_ = new Ep(t), this.layerImageRatio_ = t.getImageRatio(), this.coordinateToVectorPixelTransform_ = [1, 0, 0, 1, 0, 0], this.renderedPixelToCoordinateTransform_ = null } disposeInternal() { this.vectorRenderer_.dispose(), super.disposeInternal() } getFeatures(t) { if (!this.vectorRenderer_) return new Promise((t => t([]))); const e = bt(this.coordinateToVectorPixelTransform_, bt(this.renderedPixelToCoordinateTransform_, t.slice())); return this.vectorRenderer_.getFeatures(e) } handleFontsChanged() { this.vectorRenderer_.handleFontsChanged() } prepareFrame(t) { const e = t.pixelRatio, i = t.viewState, n = i.resolution, r = t.viewHints, s = this.vectorRenderer_; let o = t.extent; 1 !== this.layerImageRatio_ && (o = o.slice(0), Ce(o, this.layerImageRatio_)); const a = Se(o) / n, l = _e(o) / n; if (!r[Ro] && !r[Po] && !Ee(o)) { s.useContainer(null, null); const r = s.context, h = t.layerStatesArray[t.layerIndex]; r.globalAlpha = h.opacity; const c = Object.assign({}, h, { opacity: 1 }), u = Object.assign({}, t, { declutterTree: new xh(9), extent: o, size: [a, l], viewState: Object.assign({}, t.viewState, { rotation: 0 }), layerStatesArray: [c], layerIndex: 0 }); let d = !0; const g = new Nr(o, n, e, r.canvas, (function (t) { s.prepareFrame(u) && s.replayGroupChanged && (s.clipping = !1, s.renderFrame(u, null) && (s.renderDeclutter(u), d = !1), t()) })); g.addEventListener(S, function () { if (g.getState() !== Lr) return; this.image_ = d ? null : g; const t = g.getResolution(), n = g.getPixelRatio(), r = t * e / n; this.renderedResolution = r, this.coordinateToVectorPixelTransform_ = Mt(this.coordinateToVectorPixelTransform_, a / 2, l / 2, 1 / r, -1 / r, 0, -i.center[0], -i.center[1]) }.bind(this)), g.load() } return this.image_ && (this.renderedPixelToCoordinateTransform_ = t.pixelToCoordinateTransform.slice()), !!this.image_ } preRender() { } postRender() { } renderDeclutter() { } forEachFeatureAtCoordinate(t, e, i, n, r) { return this.vectorRenderer_ ? this.vectorRenderer_.forEachFeatureAtCoordinate(t, e, i, n, r) : super.forEachFeatureAtCoordinate(t, e, i, n, r) } } const Cp = { image: ["Polygon", "Circle", "LineString", "Image", "Text"], hybrid: ["Polygon", "LineString"], vector: [] }, bp = { hybrid: ["Image", "Text", "Default"], vector: ["Polygon", "Circle", "LineString", "Image", "Text", "Default"] }; class Rp extends Oc { constructor(t) { super(t), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.renderedLayerRevision_, this.renderedPixelToCoordinateTransform_ = null, this.renderedRotation_, this.tmpTransform_ = [1, 0, 0, 1, 0, 0] } prepareTile(t, e, i) { let n; const r = t.getState(); return r !== J && r !== Q || (this.updateExecutorGroup_(t, e, i), this.tileImageNeedsRender_(t) && (n = !0)), n } getTile(t, e, i, n) { const r = n.pixelRatio, s = n.viewState, o = s.resolution, a = s.projection, l = this.getLayer(), h = l.getSource().getTile(t, e, i, r, a), c = n.viewHints, u = !(c[Ro] || c[Po]); !u && h.wantedResolution || (h.wantedResolution = o); return this.prepareTile(h, r, a) && (u || Date.now() - n.time < 8) && "vector" !== l.getRenderMode() && this.renderTileImage_(h, n), super.getTile(t, e, i, n) } isDrawableTile(t) { const e = this.getLayer(); return super.isDrawableTile(t) && ("vector" === e.getRenderMode() ? z(e) in t.executorGroups : t.hasContext(e)) } getTileImage(t) { return t.getImage(this.getLayer()) } prepareFrame(t) { const e = this.getLayer().getRevision(); return this.renderedLayerRevision_ !== e && (this.renderedLayerRevision_ = e, this.renderedTiles.length = 0), super.prepareFrame(t) } updateExecutorGroup_(t, e, i) { const n = this.getLayer(), r = n.getRevision(), s = n.getRenderOrder() || null, o = t.wantedResolution, a = t.getReplayState(n); if (!a.dirty && a.renderedResolution === o && a.renderedRevision == r && a.renderedRenderOrder == s) return; const l = n.getSource(), h = n.getDeclutter(), c = l.getTileGrid(), u = l.getTileGridForProjection(i).getTileCoordExtent(t.wrappedTileCoord), d = l.getSourceTiles(e, i, t), g = z(n); delete t.hitDetectionImageData[g], t.executorGroups[g] = [], h && (t.declutterExecutorGroups[g] = []), a.dirty = !1; for (let i = 0, r = d.length; i < r; ++i) { const r = d[i]; if (r.getState() != J) continue; const f = r.tileCoord, p = c.getTileCoordExtent(f), m = ye(u, p), _ = Xt(m, n.getRenderBuffer() * o, this.tmpExtent), y = ee(p, m) ? null : _, x = new np(0, _, o, e), v = h ? new np(0, m, o, e) : void 0, S = Il(o, e), w = function (t) { let e; const i = t.getStyleFunction() || n.getStyleFunction(); if (i && (e = i(t, o)), e) { const i = this.renderFeature(t, S, e, x, v); a.dirty = a.dirty || i } }, E = r.getFeatures(); s && s !== a.renderedRenderOrder && E.sort(s); for (let t = 0, e = E.length; t < e; ++t) { const e = E[t]; y && !we(y, e.getGeometry().getExtent()) || w.call(this, e) } const T = x.finish(), C = "vector" !== n.getRenderMode() && h && 1 === d.length ? null : m, b = new _p(C, o, e, l.getOverlaps(), T, n.getRenderBuffer()); if (t.executorGroups[g].push(b), v) { const i = new _p(null, o, e, l.getOverlaps(), v.finish(), n.getRenderBuffer()); t.declutterExecutorGroups[g].push(i) } } a.renderedRevision = r, a.renderedRenderOrder = s, a.renderedResolution = o } forEachFeatureAtCoordinate(t, e, i, n, r) { const s = e.viewState.resolution, o = e.viewState.rotation; i = null == i ? 0 : i; const a = this.getLayer(), l = a.getSource().getTileGridForProjection(e.viewState.projection), h = zt([t]); Xt(h, s * i, h); const c = {}, u = function (t, e, i) { let s = t.getId(); void 0 === s && (s = z(t)); const o = c[s]; if (o) { if (!0 !== o && i < o.distanceSq) { if (0 === i) return c[s] = !0, r.splice(r.lastIndexOf(o), 1), n(t, a, e); o.geometry = e, o.distanceSq = i } } else { if (0 === i) return c[s] = !0, n(t, a, e); r.push(c[s] = { feature: t, layer: a, geometry: e, distanceSq: i, callback: n }) } }, d = this.renderedTiles; let g; for (let n = 0, r = d.length; !g && n < r; ++n) { const r = d[n]; if (!we(l.getTileCoordExtent(r.wrappedTileCoord), h)) continue; const c = z(a), f = [r.executorGroups[c]], p = r.declutterExecutorGroups[c]; p && f.push(p), f.some((n => { const r = n === p ? e.declutterTree.all().map((t => t.value)) : null; for (let e = 0, a = n.length; e < a; ++e) { const a = n[e]; if (g = a.forEachFeatureAtCoordinate(t, s, o, i, u, r), g) return !0 } })) } return g } getFeatures(t) { return new Promise(function (e, i) { const n = this.getLayer(), r = z(n), s = n.getSource(), o = this.renderedProjection, a = o.getExtent(), l = this.renderedResolution, h = s.getTileGridForProjection(o), c = bt(this.renderedPixelToCoordinateTransform_, t.slice()), u = h.getTileCoordForCoordAndResolution(c, l); let d; for (let t = 0, e = this.renderedTiles.length; t < e; ++t)if (u.toString() === this.renderedTiles[t].tileCoord.toString()) { if (d = this.renderedTiles[t], d.getState() === J) { const t = h.getTileCoordExtent(d.tileCoord); s.getWrapX() && o.canWrapX() && !Yt(a, t) && Pi(c, o); break } d = void 0 } if (!d || d.loadingSourceTiles > 0) return void e([]); const g = xe(h.getTileCoordExtent(d.wrappedTileCoord)), f = [(c[0] - g[0]) / l, (g[1] - c[1]) / l], p = d.getSourceTiles().reduce((function (t, e) { return t.concat(e.getFeatures()) }), []); let m = d.hitDetectionImageData[r]; if (!m && !this.animatingOrInteracting_) { const t = Va(h.getTileSize(h.getZForResolution(l, s.zDirection))), e = this.renderedRotation_; m = Sp(t, [this.getRenderTransform(h.getTileCoordCenter(d.wrappedTileCoord), l, 0, vp, t[0] * vp, t[1] * vp, 0)], p, n.getStyleFunction(), h.getTileCoordExtent(d.wrappedTileCoord), d.getReplayState(n).renderedResolution, e), d.hitDetectionImageData[r] = m } e(wp(f, p, m)) }.bind(this)) } handleFontsChanged() { const t = this.getLayer(); t.getVisible() && void 0 !== this.renderedLayerRevision_ && t.changed() } handleStyleImageChange_(t) { this.renderIfReadyAndVisible() } renderDeclutter(t) { const e = this.context, i = e.globalAlpha; e.globalAlpha = this.getLayer().getOpacity(); const n = t.viewHints, r = !(n[Ro] || n[Po]), s = this.renderedTiles; for (let e = 0, i = s.length; e < i; ++e) { const i = s[e], n = i.declutterExecutorGroups[z(this.getLayer())]; if (n) for (let e = n.length - 1; e >= 0; --e)n[e].execute(this.context, 1, this.getTileRenderTransform(i, t), t.viewState.rotation, r, void 0, t.declutterTree) } e.globalAlpha = i } getTileRenderTransform(t, e) { const i = e.pixelRatio, n = e.viewState, r = n.center, s = n.resolution, o = n.rotation, a = e.size, l = Math.round(a[0] * i), h = Math.round(a[1] * i), c = this.getLayer().getSource().getTileGridForProjection(e.viewState.projection), u = t.tileCoord, d = c.getTileCoordExtent(t.wrappedTileCoord), g = c.getTileCoordExtent(u, this.tmpExtent)[0] - d[0]; return Et(Pt(this.inversePixelTransform.slice(), 1 / i, 1 / i), this.getRenderTransform(r, s, o, i, l, h, g)) } postRender(t, e) { const i = e.viewHints, n = !(i[Ro] || i[Po]); this.renderedPixelToCoordinateTransform_ = e.pixelToCoordinateTransform.slice(), this.renderedRotation_ = e.viewState.rotation; const r = this.getLayer(), s = r.getRenderMode(), o = t.globalAlpha; t.globalAlpha = r.getOpacity(); const a = bp[s], l = e.viewState, h = l.rotation, c = r.getSource(), u = c.getTileGridForProjection(l.projection).getZForResolution(l.resolution, c.zDirection), d = this.renderedTiles, g = [], f = []; let p = !0; for (let i = d.length - 1; i >= 0; --i) { const s = d[i]; p = p && !s.getReplayState(r).dirty; const o = s.executorGroups[z(r)].filter((t => t.hasExecutors(a))); if (0 === o.length) continue; const l = this.getTileRenderTransform(s, e), c = s.tileCoord[0]; let m = !1; const _ = o[0].getClipCoords(l); if (_) { for (let e = 0, i = g.length; e < i; ++e)if (u !== c && c < f[e]) { const i = g[e]; we([_[0], _[3], _[4], _[7]], [i[0], i[3], i[4], i[7]]) && (m || (t.save(), m = !0), t.beginPath(), t.moveTo(_[0], _[1]), t.lineTo(_[2], _[3]), t.lineTo(_[4], _[5]), t.lineTo(_[6], _[7]), t.moveTo(i[6], i[7]), t.lineTo(i[4], i[5]), t.lineTo(i[2], i[3]), t.lineTo(i[0], i[1]), t.clip()) } g.push(_), f.push(c) } for (let e = 0, i = o.length; e < i; ++e) { o[e].execute(t, 1, l, h, n, a) } m && t.restore() } t.globalAlpha = o, this.ready = p, super.postRender(t, e) } renderFeature(t, e, i, n, r) { if (!i) return !1; let s = !1; if (Array.isArray(i)) for (let o = 0, a = i.length; o < a; ++o)s = Ml(n, t, i[o], e, this.boundHandleStyleImageChange_, void 0, r) || s; else s = Ml(n, t, i, e, this.boundHandleStyleImageChange_, void 0, r); return s } tileImageNeedsRender_(t) { const e = this.getLayer(); if ("vector" === e.getRenderMode()) return !1; const i = t.getReplayState(e), n = e.getRevision(), r = t.wantedResolution; return i.renderedTileResolution !== r || i.renderedTileRevision !== n } renderTileImage_(t, e) { const i = this.getLayer(), n = t.getReplayState(i), r = i.getRevision(), s = t.executorGroups[z(i)]; n.renderedTileRevision = r; const o = t.wrappedTileCoord, a = o[0], l = i.getSource(); let h = e.pixelRatio; const c = e.viewState.projection, u = l.getTileGridForProjection(c), d = u.getResolution(t.tileCoord[0]), g = e.pixelRatio / t.wantedResolution * d, f = u.getResolution(a), p = t.getContext(i); h = Math.round(Math.max(h, g / h)); const m = l.getTilePixelSize(a, h, c); p.canvas.width = m[0], p.canvas.height = m[1]; const _ = h / g; if (1 !== _) { const t = wt(this.tmpTransform_); Pt(t, _, _), p.setTransform.apply(p, t) } const y = u.getTileCoordExtent(o, this.tmpExtent), x = g / f, v = wt(this.tmpTransform_); Pt(v, x, -x), Lt(v, -y[0], -y[3]); for (let t = 0, e = s.length; t < e; ++t) { s[t].execute(p, _, v, 0, !0, Cp[i.getRenderMode()]) } n.renderedTileResolution = t.wantedResolution } } class Pp extends _n { constructor(t, e, i) { super(), void 0 !== i && void 0 === e ? this.setFlatCoordinates(i, t) : (e = e || 0, this.setCenterAndRadius(t, e, i)) } clone() { const t = new Pp(this.flatCoordinates.slice(), void 0, this.layout); return t.applyProperties(this), t } closestPointXY(t, e, i, n) { const r = this.flatCoordinates, s = t - r[0], o = e - r[1], a = s * s + o * o; if (a < n) { if (0 === a) for (let t = 0; t < this.stride; ++t)i[t] = r[t]; else { const t = this.getRadius() / Math.sqrt(a); i[0] = r[0] + t * s, i[1] = r[1] + t * o; for (let t = 2; t < this.stride; ++t)i[t] = r[t] } return i.length = this.stride, a } return n } containsXY(t, e) { const i = this.flatCoordinates, n = t - i[0], r = e - i[1]; return n * n + r * r <= this.getRadiusSquared_() } getCenter() { return this.flatCoordinates.slice(0, this.stride) } computeExtent(t) { const e = this.flatCoordinates, i = e[this.stride] - e[0]; return $t(e[0] - i, e[1] - i, e[0] + i, e[1] + i, t) } getRadius() { return Math.sqrt(this.getRadiusSquared_()) } getRadiusSquared_() { const t = this.flatCoordinates[this.stride] - this.flatCoordinates[0], e = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1]; return t * t + e * e } getType() { return "Circle" } intersectsExtent(t) { if (we(t, this.getExtent())) { const e = this.getCenter(); return t[0] <= e[0] && t[2] >= e[0] || (t[1] <= e[1] && t[3] >= e[1] || he(t, this.intersectsCoordinate.bind(this))) } return !1 } setCenter(t) { const e = this.stride, i = this.flatCoordinates[e] - this.flatCoordinates[0], n = t.slice(); n[e] = n[0] + i; for (let i = 1; i < e; ++i)n[e + i] = t[i]; this.setFlatCoordinates(this.layout, n), this.changed() } setCenterAndRadius(t, e, i) { this.setLayout(i, t, 0), this.flatCoordinates || (this.flatCoordinates = []); const n = this.flatCoordinates; let r = Rn(n, 0, t, this.stride); n[r++] = n[0] + e; for (let t = 1, e = this.stride; t < e; ++t)n[r++] = n[t]; n.length = r, this.changed() } getCoordinates() { return null } setCoordinates(t, e) { } setRadius(t) { this.flatCoordinates[this.stride] = this.flatCoordinates[0] + t, this.changed() } rotate(t, e) { const i = this.getCenter(), n = this.getStride(); this.setCenter(dn(i, 0, i.length, n, t, e, i)), this.changed() } translate(t, e) { const i = this.getCenter(), n = this.getStride(); this.setCenter(fn(i, 0, i.length, n, t, e, i)), this.changed() } } Pp.prototype.transform; class Ip extends mn { constructor(t) { super(), this.geometries_ = t || null, this.changeEventsKeys_ = [], this.listenGeometriesChange_() } unlistenGeometriesChange_() { this.changeEventsKeys_.forEach(k), this.changeEventsKeys_.length = 0 } listenGeometriesChange_() { if (this.geometries_) for (let t = 0, e = this.geometries_.length; t < e; ++t)this.changeEventsKeys_.push(N(this.geometries_[t], S, this.changed, this)) } clone() { const t = new Ip(null); return t.setGeometries(this.geometries_), t.applyProperties(this), t } closestPointXY(t, e, i, n) { if (n < Wt(this.getExtent(), t, e)) return n; const r = this.geometries_; for (let s = 0, o = r.length; s < o; ++s)n = r[s].closestPointXY(t, e, i, n); return n } containsXY(t, e) { const i = this.geometries_; for (let n = 0, r = i.length; n < r; ++n)if (i[n].containsXY(t, e)) return !0; return !1 } computeExtent(t) { Jt(t); const e = this.geometries_; for (let i = 0, n = e.length; i < n; ++i)ne(t, e[i].getExtent()); return t } getGeometries() { return Lp(this.geometries_) } getGeometriesArray() { return this.geometries_ } getGeometriesArrayRecursive() { let t = []; const e = this.geometries_; for (let i = 0, n = e.length; i < n; ++i)e[i].getType() === this.getType() ? t = t.concat(e[i].getGeometriesArrayRecursive()) : t.push(e[i]); return t } getSimplifiedGeometry(t) { if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || 0 !== this.simplifiedGeometryMaxMinSquaredTolerance && t < this.simplifiedGeometryMaxMinSquaredTolerance) return this; const e = [], i = this.geometries_; let n = !1; for (let r = 0, s = i.length; r < s; ++r) { const s = i[r], o = s.getSimplifiedGeometry(t); e.push(o), o !== s && (n = !0) } if (n) { const t = new Ip(null); return t.setGeometriesArray(e), t } return this.simplifiedGeometryMaxMinSquaredTolerance = t, this } getType() { return "GeometryCollection" } intersectsExtent(t) { const e = this.geometries_; for (let i = 0, n = e.length; i < n; ++i)if (e[i].intersectsExtent(t)) return !0; return !1 } isEmpty() { return 0 === this.geometries_.length } rotate(t, e) { const i = this.geometries_; for (let n = 0, r = i.length; n < r; ++n)i[n].rotate(t, e); this.changed() } scale(t, e, i) { i || (i = ge(this.getExtent())); const n = this.geometries_; for (let r = 0, s = n.length; r < s; ++r)n[r].scale(t, e, i); this.changed() } setGeometries(t) { this.setGeometriesArray(Lp(t)) } setGeometriesArray(t) { this.unlistenGeometriesChange_(), this.geometries_ = t, this.listenGeometriesChange_(), this.changed() } applyTransform(t) { const e = this.geometries_; for (let i = 0, n = e.length; i < n; ++i)e[i].applyTransform(t); this.changed() } translate(t, e) { const i = this.geometries_; for (let n = 0, r = i.length; n < r; ++n)i[n].translate(t, e); this.changed() } disposeInternal() { this.unlistenGeometriesChange_(), super.disposeInternal() } } function Lp(t) { const e = []; for (let i = 0, n = t.length; i < n; ++i)e.push(t[i].clone()); return e } function Mp(t, e, i, n, r, s, a) { let l, h; const c = (i - e) / n; if (1 === c) l = e; else if (2 === c) l = e, h = r; else if (0 !== c) { let s = t[e], a = t[e + 1], c = 0; const u = [0]; for (let r = e + n; r < i; r += n) { const e = t[r], i = t[r + 1]; c += Math.sqrt((e - s) * (e - s) + (i - a) * (i - a)), u.push(c), s = e, a = i } const d = r * c, g = o(u, d); g < 0 ? (h = (d - u[-g - 2]) / (u[-g - 1] - u[-g - 2]), l = e + (-g - 2) * n) : l = e + g * n } a = a > 1 ? a : 2, s = s || new Array(a); for (let e = 0; e < a; ++e)s[e] = void 0 === l ? NaN : void 0 === h ? t[l + e] : hi(t[l + e], t[l + n + e], h); return s } function Fp(t, e, i, n, r, s) { if (i == e) return null; let o; if (r < t[e + n - 1]) return s ? (o = t.slice(e, e + n), o[n - 1] = r, o) : null; if (t[i - 1] < r) return s ? (o = t.slice(i - n, i), o[n - 1] = r, o) : null; if (r == t[e + n - 1]) return t.slice(e, e + n); let a = e / n, l = i / n; for (; a < l;) { const e = a + l >> 1; r < t[(e + 1) * n - 1] ? l = e : a = e + 1 } const h = t[a * n - 1]; if (r == h) return t.slice((a - 1) * n, (a - 1) * n + n); const c = (r - h) / (t[(a + 1) * n - 1] - h); o = []; for (let e = 0; e < n - 1; ++e)o.push(hi(t[(a - 1) * n + e], t[a * n + e], c)); return o.push(r), o } function Ap(t, e, i, n, r, s, o) { if (o) return Fp(t, e, i[i.length - 1], n, r, s); let a; if (r < t[n - 1]) return s ? (a = t.slice(0, n), a[n - 1] = r, a) : null; if (t[t.length - 1] < r) return s ? (a = t.slice(t.length - n), a[n - 1] = r, a) : null; for (let s = 0, o = i.length; s < o; ++s) { const o = i[s]; if (e != o) { if (r < t[e + n - 1]) return null; if (r <= t[o - 1]) return Fp(t, e, o, n, r, !1); e = o } } return null } class Op extends _n { constructor(t, e) { super(), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, void 0 === e || Array.isArray(t[0]) ? this.setCoordinates(t, e) : this.setFlatCoordinates(e, t) } appendCoordinate(t) { this.flatCoordinates ? c(this.flatCoordinates, t) : this.flatCoordinates = t.slice(), this.changed() } clone() { const t = new Op(this.flatCoordinates.slice(), this.layout); return t.applyProperties(this), t } closestPointXY(t, e, i, n) { return n < Wt(this.getExtent(), t, e) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(Sn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Tn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, !1, t, e, i, n)) } forEachSegment(t) { return Jn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t) } getCoordinateAtM(t, e) { return "XYM" != this.layout && "XYZM" != this.layout ? null : (e = void 0 !== e && e, Fp(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e)) } getCoordinates() { return Gn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride) } getCoordinateAt(t, e) { return Mp(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e, this.stride) } getLength() { return sp(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride) } getFlatMidpoint() { return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(.5, this.flatMidpoint_), this.flatMidpointRevision_ = this.getRevision()), this.flatMidpoint_ } getSimplifiedGeometryInternal(t) { const e = []; return e.length = Mn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e, 0), new Op(e, "XY") } getType() { return "LineString" } intersectsExtent(t) { return Qn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t) } setCoordinates(t, e) { this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Pn(this.flatCoordinates, 0, t, this.stride), this.changed() } } class Np extends _n { constructor(t, e, i) { if (super(), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(t[0])) this.setCoordinates(t, e); else if (void 0 !== e && i) this.setFlatCoordinates(e, t), this.ends_ = i; else { let e = this.getLayout(); const i = t, n = [], r = []; for (let t = 0, s = i.length; t < s; ++t) { const s = i[t]; 0 === t && (e = s.getLayout()), c(n, s.getFlatCoordinates()), r.push(n.length) } this.setFlatCoordinates(e, n), this.ends_ = r } } appendLineString(t) { this.flatCoordinates ? c(this.flatCoordinates, t.getFlatCoordinates().slice()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed() } clone() { const t = new Np(this.flatCoordinates.slice(), this.layout, this.ends_.slice()); return t.applyProperties(this), t } closestPointXY(t, e, i, n) { return n < Wt(this.getExtent(), t, e) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(wn(this.flatCoordinates, 0, this.ends_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Cn(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, !1, t, e, i, n)) } getCoordinateAtM(t, e, i) { return "XYM" != this.layout && "XYZM" != this.layout || 0 === this.flatCoordinates.length ? null : (e = void 0 !== e && e, i = void 0 !== i && i, Ap(this.flatCoordinates, 0, this.ends_, this.stride, t, e, i)) } getCoordinates() { return jn(this.flatCoordinates, 0, this.ends_, this.stride) } getEnds() { return this.ends_ } getLineString(t) { return t < 0 || this.ends_.length <= t ? null : new Op(this.flatCoordinates.slice(0 === t ? 0 : this.ends_[t - 1], this.ends_[t]), this.layout) } getLineStrings() { const t = this.flatCoordinates, e = this.ends_, i = this.layout, n = []; let r = 0; for (let s = 0, o = e.length; s < o; ++s) { const o = e[s], a = new Op(t.slice(r, o), i); n.push(a), r = o } return n } getFlatMidpoints() { const t = [], e = this.flatCoordinates; let i = 0; const n = this.ends_, r = this.stride; for (let s = 0, o = n.length; s < o; ++s) { const o = n[s]; c(t, Mp(e, i, o, r, .5)), i = o } return t } getSimplifiedGeometryInternal(t) { const e = [], i = []; return e.length = Fn(this.flatCoordinates, 0, this.ends_, this.stride, t, e, 0, i), new Np(e, "XY", i) } getType() { return "MultiLineString" } intersectsExtent(t) { return tr(this.flatCoordinates, 0, this.ends_, this.stride, t) } setCoordinates(t, e) { this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []); const i = In(this.flatCoordinates, 0, t, this.stride, this.ends_); this.flatCoordinates.length = 0 === i.length ? 0 : i[i.length - 1], this.changed() } } class Dp extends _n { constructor(t, e) { super(), e && !Array.isArray(t[0]) ? this.setFlatCoordinates(e, t) : this.setCoordinates(t, e) } appendPoint(t) { this.flatCoordinates ? c(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.changed() } clone() { const t = new Dp(this.flatCoordinates.slice(), this.layout); return t.applyProperties(this), t } closestPointXY(t, e, i, n) { if (n < Wt(this.getExtent(), t, e)) return n; const r = this.flatCoordinates, s = this.stride; for (let o = 0, a = r.length; o < a; o += s) { const a = ri(t, e, r[o], r[o + 1]); if (a < n) { n = a; for (let t = 0; t < s; ++t)i[t] = r[o + t]; i.length = s } } return n } getCoordinates() { return Gn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride) } getPoint(t) { const e = this.flatCoordinates ? this.flatCoordinates.length / this.stride : 0; return t < 0 || e <= t ? null : new Wn(this.flatCoordinates.slice(t * this.stride, (t + 1) * this.stride), this.layout) } getPoints() { const t = this.flatCoordinates, e = this.layout, i = this.stride, n = []; for (let r = 0, s = t.length; r < s; r += i) { const s = new Wn(t.slice(r, r + i), e); n.push(s) } return n } getType() { return "MultiPoint" } intersectsExtent(t) { const e = this.flatCoordinates, i = this.stride; for (let n = 0, r = e.length; n < r; n += i) { if (Kt(t, e[n], e[n + 1])) return !0 } return !1 } setCoordinates(t, e) { this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Pn(this.flatCoordinates, 0, t, this.stride), this.changed() } } function kp(t, e, i, n) { const r = []; let s = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; for (let o = 0, a = i.length; o < a; ++o) { const a = i[o]; s = te(t, e, a[0], n), r.push((s[0] + s[2]) / 2, (s[1] + s[3]) / 2), e = a[a.length - 1] } return r } class Gp extends _n { constructor(t, e, i) { if (super(), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !i && !Array.isArray(t[0])) { let n = this.getLayout(); const r = t, s = [], o = []; for (let t = 0, e = r.length; t < e; ++t) { const e = r[t]; 0 === t && (n = e.getLayout()); const i = s.length, a = e.getEnds(); for (let t = 0, e = a.length; t < e; ++t)a[t] += i; c(s, e.getFlatCoordinates()), o.push(a) } e = n, t = s, i = o } void 0 !== e && i ? (this.setFlatCoordinates(e, t), this.endss_ = i) : this.setCoordinates(t, e) } appendPolygon(t) { let e; if (this.flatCoordinates) { const i = this.flatCoordinates.length; c(this.flatCoordinates, t.getFlatCoordinates()), e = t.getEnds().slice(); for (let t = 0, n = e.length; t < n; ++t)e[t] += i } else this.flatCoordinates = t.getFlatCoordinates().slice(), e = t.getEnds().slice(), this.endss_.push(); this.endss_.push(e), this.changed() } clone() { const t = this.endss_.length, e = new Array(t); for (let i = 0; i < t; ++i)e[i] = this.endss_[i].slice(); const i = new Gp(this.flatCoordinates.slice(), this.layout, e); return i.applyProperties(this), i } closestPointXY(t, e, i, n) { return n < Wt(this.getExtent(), t, e) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(En(this.flatCoordinates, 0, this.endss_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), bn(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, !0, t, e, i, n)) } containsXY(t, e) { return qn(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t, e) } getArea() { return Xn(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride) } getCoordinates(t) { let e; return void 0 !== t ? (e = this.getOrientedFlatCoordinates().slice(), hr(e, 0, this.endss_, this.stride, t)) : e = this.flatCoordinates, Bn(e, 0, this.endss_, this.stride) } getEndss() { return this.endss_ } getFlatInteriorPoints() { if (this.flatInteriorPointsRevision_ != this.getRevision()) { const t = kp(this.flatCoordinates, 0, this.endss_, this.stride); this.flatInteriorPoints_ = $n(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t), this.flatInteriorPointsRevision_ = this.getRevision() } return this.flatInteriorPoints_ } getInteriorPoints() { return new Dp(this.getFlatInteriorPoints().slice(), "XYM") } getOrientedFlatCoordinates() { if (this.orientedRevision_ != this.getRevision()) { const t = this.flatCoordinates; ar(t, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = hr(this.orientedFlatCoordinates_, 0, this.endss_, this.stride)), this.orientedRevision_ = this.getRevision() } return this.orientedFlatCoordinates_ } getSimplifiedGeometryInternal(t) { const e = [], i = []; return e.length = kn(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(t), e, 0, i), new Gp(e, "XY", i) } getPolygon(t) { if (t < 0 || this.endss_.length <= t) return null; let e; if (0 === t) e = 0; else { const i = this.endss_[t - 1]; e = i[i.length - 1] } const i = this.endss_[t].slice(), n = i[i.length - 1]; if (0 !== e) for (let t = 0, n = i.length; t < n; ++t)i[t] -= e; return new ur(this.flatCoordinates.slice(e, n), this.layout, i) } getPolygons() { const t = this.layout, e = this.flatCoordinates, i = this.endss_, n = []; let r = 0; for (let s = 0, o = i.length; s < o; ++s) { const o = i[s].slice(), a = o[o.length - 1]; if (0 !== r) for (let t = 0, e = o.length; t < e; ++t)o[t] -= r; const l = new ur(e.slice(r, a), t, o); n.push(l), r = a } return n } getType() { return "MultiPolygon" } intersectsExtent(t) { return nr(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t) } setCoordinates(t, e) { this.setLayout(e, t, 3), this.flatCoordinates || (this.flatCoordinates = []); const i = Ln(this.flatCoordinates, 0, t, this.stride, this.endss_); if (0 === i.length) this.flatCoordinates.length = 0; else { const t = i[i.length - 1]; this.flatCoordinates.length = 0 === t.length ? 0 : t[t.length - 1] } this.changed() } } const jp = [1, 0, 0, 1, 0, 0]; class Bp { constructor(t, e, i, n, r) { this.styleFunction, this.extent_, this.id_ = r, this.type_ = t, this.flatCoordinates_ = e, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = i, this.properties_ = n } get(t) { return this.properties_[t] } getExtent() { return this.extent_ || (this.extent_ = "Point" === this.type_ ? Qt(this.flatCoordinates_) : te(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2)), this.extent_ } getFlatInteriorPoint() { if (!this.flatInteriorPoints_) { const t = ge(this.getExtent()); this.flatInteriorPoints_ = Hn(this.flatCoordinates_, 0, this.ends_, 2, t, 0) } return this.flatInteriorPoints_ } getFlatInteriorPoints() { if (!this.flatInteriorPoints_) { const t = kp(this.flatCoordinates_, 0, this.ends_, 2); this.flatInteriorPoints_ = $n(this.flatCoordinates_, 0, this.ends_, 2, t) } return this.flatInteriorPoints_ } getFlatMidpoint() { return this.flatMidpoints_ || (this.flatMidpoints_ = Mp(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, .5)), this.flatMidpoints_ } getFlatMidpoints() { if (!this.flatMidpoints_) { this.flatMidpoints_ = []; const t = this.flatCoordinates_; let e = 0; const i = this.ends_; for (let n = 0, r = i.length; n < r; ++n) { const r = i[n], s = Mp(t, e, r, 2, .5); c(this.flatMidpoints_, s), e = r } } return this.flatMidpoints_ } getId() { return this.id_ } getOrientedFlatCoordinates() { return this.flatCoordinates_ } getGeometry() { return this } getSimplifiedGeometry(t) { return this } simplifyTransformed(t, e) { return this } getProperties() { return this.properties_ } getStride() { return 2 } getStyleFunction() { return this.styleFunction } getType() { return this.type_ } transform(t) { const e = (t = Ui(t)).getExtent(), i = t.getWorldExtent(); if (e && i) { const t = _e(i) / _e(e); Mt(jp, i[0], i[3], t, -t, 0, 0, 0), un(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, jp, this.flatCoordinates_) } } getEnds() { return this.ends_ } } function Up(t) { const e = t.getType(); switch (e) { case "Point": return new Wn(t.getFlatCoordinates()); case "MultiPoint": return new Dp(t.getFlatCoordinates(), "XY"); case "LineString": return new Op(t.getFlatCoordinates(), "XY"); case "MultiLineString": return new Np(t.getFlatCoordinates(), "XY", t.getEnds()); case "Polygon": const i = t.getFlatCoordinates(), n = t.getEnds(), r = cr(i, n); return r.length > 1 ? new Gp(i, "XY", r) : new ur(i, "XY", n); default: throw new Error("Invalid geometry type:" + e) } } Bp.prototype.getEndss = Bp.prototype.getEnds, Bp.prototype.getFlatCoordinates = Bp.prototype.getOrientedFlatCoordinates; class zp extends Ig { constructor(t) { super(t) } createRenderer() { return new Ep(this) } } function Xp(t, e, i) { const n = []; let r = t(0), s = t(1), o = e(r), a = e(s); const l = [s, r], h = [a, o], c = [1, 0], u = {}; let d, g, f, p, m, _, y = 1e5; for (; --y > 0 && c.length > 0;)f = c.pop(), r = l.pop(), o = h.pop(), _ = f.toString(), _ in u || (n.push(o[0], o[1]), u[_] = !0), p = c.pop(), s = l.pop(), a = h.pop(), m = (f + p) / 2, d = t(m), g = e(d), ni(g[0], g[1], o[0], o[1], a[0], a[1]) < i ? (n.push(a[0], a[1]), _ = p.toString(), u[_] = !0) : (c.push(p, m, m, f), h.push(a, g, g, o), l.push(s, d, d, r)); return n } function Vp(t, e, i, n, r) { return Xp((function (n) { return [t, e + (i - e) * n] }), Hi(Ui("EPSG:4326"), n), r) } function Wp(t, e, i, n, r) { return Xp((function (n) { return [e + (i - e) * n, t] }), Hi(Ui("EPSG:4326"), n), r) } const Zp = new hg({ color: "rgba(0,0,0,0.2)" }), Yp = [90, 45, 30, 20, 10, 5, 2, 1, .5, 20 / 60, 10 / 60, 5 / 60, 2 / 60, 1 / 60, 30 / 3600, 20 / 3600, 10 / 3600, 5 / 3600, 2 / 3600, 1 / 3600]; const Kp = "blur", qp = "gradient", Hp = "radius", $p = ["#00f", "#0ff", "#0f0", "#ff0", "#f00"]; class Jp { constructor() { this.dataProjection = void 0, this.defaultFeatureProjection = void 0, this.supportedMediaTypes = null } getReadOptions(t, e) { if (e) { let i = e.dataProjection ? Ui(e.dataProjection) : this.readProjection(t); e.extent && i && "tile-pixels" === i.getUnits() && (i = Ui(i), i.setWorldExtent(e.extent)), e = { dataProjection: i, featureProjection: e.featureProjection } } return this.adaptOptions(e) } adaptOptions(t) { return Object.assign({ dataProjection: this.dataProjection, featureProjection: this.defaultFeatureProjection }, t) } getType() { return B() } readFeature(t, e) { return B() } readFeatures(t, e) { return B() } readGeometry(t, e) { return B() } readProjection(t) { return B() } writeFeature(t, e) { return B() } writeFeatures(t, e) { return B() } writeGeometry(t, e) { return B() } } function Qp(t, e, i) { const n = i ? Ui(i.featureProjection) : null, r = i ? Ui(i.dataProjection) : null; let s; if (s = n && r && !Ki(n, r) ? (e ? t.clone() : t).transform(e ? n : r, e ? r : n) : t, e && i && void 0 !== i.decimals) { const e = Math.pow(10, i.decimals), n = function (t) { for (let i = 0, n = t.length; i < n; ++i)t[i] = Math.round(t[i] * e) / e; return t }; s === t && (s = t.clone()), s.applyTransform(n) } return s } function tm(t, e) { const i = e ? Ui(e.featureProjection) : null, n = e ? Ui(e.dataProjection) : null; return i && n && !Ki(i, n) ? Ji(t, n, i) : t } var em = {
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
        read: function (t, e, i, n, r) { var s, o, a = 8 * r - n - 1, l = (1 << a) - 1, h = l >> 1, c = -7, u = i ? r - 1 : 0, d = i ? -1 : 1, g = t[e + u]; for (u += d, s = g & (1 << -c) - 1, g >>= -c, c += a; c > 0; s = 256 * s + t[e + u], u += d, c -= 8); for (o = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; o = 256 * o + t[e + u], u += d, c -= 8); if (0 === s) s = 1 - h; else { if (s === l) return o ? NaN : 1 / 0 * (g ? -1 : 1); o += Math.pow(2, n), s -= h } return (g ? -1 : 1) * o * Math.pow(2, s - n) }, write: function (t, e, i, n, r, s) { var o, a, l, h = 8 * s - r - 1, c = (1 << h) - 1, u = c >> 1, d = 23 === r ? Math.pow(2, -24) - Math.pow(2, -77) : 0, g = n ? 0 : s - 1, f = n ? 1 : -1, p = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0; for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, o = c) : (o = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), (e += o + u >= 1 ? d / l : d * Math.pow(2, 1 - u)) * l >= 2 && (o++, l /= 2), o + u >= c ? (a = 0, o = c) : o + u >= 1 ? (a = (e * l - 1) * Math.pow(2, r), o += u) : (a = e * Math.pow(2, u - 1) * Math.pow(2, r), o = 0)); r >= 8; t[i + g] = 255 & a, g += f, a /= 256, r -= 8); for (o = o << r | a, h += r; h > 0; t[i + g] = 255 & o, g += f, o /= 256, h -= 8); t[i + g - f] |= 128 * p }
    }, im = rm, nm = em; function rm(t) { this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length } rm.Varint = 0, rm.Fixed64 = 1, rm.Bytes = 2, rm.Fixed32 = 5; var sm = 4294967296, om = 1 / sm, am = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8"); function lm(t) { return t.type === rm.Bytes ? t.readVarint() + t.pos : t.pos + 1 } function hm(t, e, i) { return i ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0) } function cm(t, e, i) { var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2)); i.realloc(n); for (var r = i.pos - 1; r >= t; r--)i.buf[r + n] = i.buf[r] } function um(t, e) { for (var i = 0; i < t.length; i++)e.writeVarint(t[i]) } function dm(t, e) { for (var i = 0; i < t.length; i++)e.writeSVarint(t[i]) } function gm(t, e) { for (var i = 0; i < t.length; i++)e.writeFloat(t[i]) } function fm(t, e) { for (var i = 0; i < t.length; i++)e.writeDouble(t[i]) } function pm(t, e) { for (var i = 0; i < t.length; i++)e.writeBoolean(t[i]) } function mm(t, e) { for (var i = 0; i < t.length; i++)e.writeFixed32(t[i]) } function _m(t, e) { for (var i = 0; i < t.length; i++)e.writeSFixed32(t[i]) } function ym(t, e) { for (var i = 0; i < t.length; i++)e.writeFixed64(t[i]) } function xm(t, e) { for (var i = 0; i < t.length; i++)e.writeSFixed64(t[i]) } function vm(t, e) { return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3] } function Sm(t, e, i) { t[i] = e, t[i + 1] = e >>> 8, t[i + 2] = e >>> 16, t[i + 3] = e >>> 24 } function wm(t, e) { return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24) } rm.prototype = { destroy: function () { this.buf = null }, readFields: function (t, e, i) { for (i = i || this.length; this.pos < i;) { var n = this.readVarint(), r = n >> 3, s = this.pos; this.type = 7 & n, t(r, e, this), this.pos === s && this.skip(n) } return e }, readMessage: function (t, e) { return this.readFields(t, e, this.readVarint() + this.pos) }, readFixed32: function () { var t = vm(this.buf, this.pos); return this.pos += 4, t }, readSFixed32: function () { var t = wm(this.buf, this.pos); return this.pos += 4, t }, readFixed64: function () { var t = vm(this.buf, this.pos) + vm(this.buf, this.pos + 4) * sm; return this.pos += 8, t }, readSFixed64: function () { var t = vm(this.buf, this.pos) + wm(this.buf, this.pos + 4) * sm; return this.pos += 8, t }, readFloat: function () { var t = nm.read(this.buf, this.pos, !0, 23, 4); return this.pos += 4, t }, readDouble: function () { var t = nm.read(this.buf, this.pos, !0, 52, 8); return this.pos += 8, t }, readVarint: function (t) { var e, i, n = this.buf; return e = 127 & (i = n[this.pos++]), i < 128 ? e : (e |= (127 & (i = n[this.pos++])) << 7, i < 128 ? e : (e |= (127 & (i = n[this.pos++])) << 14, i < 128 ? e : (e |= (127 & (i = n[this.pos++])) << 21, i < 128 ? e : function (t, e, i) { var n, r, s = i.buf; if (r = s[i.pos++], n = (112 & r) >> 4, r < 128) return hm(t, n, e); if (r = s[i.pos++], n |= (127 & r) << 3, r < 128) return hm(t, n, e); if (r = s[i.pos++], n |= (127 & r) << 10, r < 128) return hm(t, n, e); if (r = s[i.pos++], n |= (127 & r) << 17, r < 128) return hm(t, n, e); if (r = s[i.pos++], n |= (127 & r) << 24, r < 128) return hm(t, n, e); if (r = s[i.pos++], n |= (1 & r) << 31, r < 128) return hm(t, n, e); throw new Error("Expected varint not more than 10 bytes") }(e |= (15 & (i = n[this.pos])) << 28, t, this)))) }, readVarint64: function () { return this.readVarint(!0) }, readSVarint: function () { var t = this.readVarint(); return t % 2 == 1 ? (t + 1) / -2 : t / 2 }, readBoolean: function () { return Boolean(this.readVarint()) }, readString: function () { var t = this.readVarint() + this.pos, e = this.pos; return this.pos = t, t - e >= 12 && am ? function (t, e, i) { return am.decode(t.subarray(e, i)) }(this.buf, e, t) : function (t, e, i) { var n = "", r = e; for (; r < i;) { var s, o, a, l = t[r], h = null, c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1; if (r + c > i) break; 1 === c ? l < 128 && (h = l) : 2 === c ? 128 == (192 & (s = t[r + 1])) && (h = (31 & l) << 6 | 63 & s) <= 127 && (h = null) : 3 === c ? (s = t[r + 1], o = t[r + 2], 128 == (192 & s) && 128 == (192 & o) && ((h = (15 & l) << 12 | (63 & s) << 6 | 63 & o) <= 2047 || h >= 55296 && h <= 57343) && (h = null)) : 4 === c && (s = t[r + 1], o = t[r + 2], a = t[r + 3], 128 == (192 & s) && 128 == (192 & o) && 128 == (192 & a) && ((h = (15 & l) << 18 | (63 & s) << 12 | (63 & o) << 6 | 63 & a) <= 65535 || h >= 1114112) && (h = null)), null === h ? (h = 65533, c = 1) : h > 65535 && (h -= 65536, n += String.fromCharCode(h >>> 10 & 1023 | 55296), h = 56320 | 1023 & h), n += String.fromCharCode(h), r += c } return n }(this.buf, e, t) }, readBytes: function () { var t = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, t); return this.pos = t, e }, readPackedVarint: function (t, e) { if (this.type !== rm.Bytes) return t.push(this.readVarint(e)); var i = lm(this); for (t = t || []; this.pos < i;)t.push(this.readVarint(e)); return t }, readPackedSVarint: function (t) { if (this.type !== rm.Bytes) return t.push(this.readSVarint()); var e = lm(this); for (t = t || []; this.pos < e;)t.push(this.readSVarint()); return t }, readPackedBoolean: function (t) { if (this.type !== rm.Bytes) return t.push(this.readBoolean()); var e = lm(this); for (t = t || []; this.pos < e;)t.push(this.readBoolean()); return t }, readPackedFloat: function (t) { if (this.type !== rm.Bytes) return t.push(this.readFloat()); var e = lm(this); for (t = t || []; this.pos < e;)t.push(this.readFloat()); return t }, readPackedDouble: function (t) { if (this.type !== rm.Bytes) return t.push(this.readDouble()); var e = lm(this); for (t = t || []; this.pos < e;)t.push(this.readDouble()); return t }, readPackedFixed32: function (t) { if (this.type !== rm.Bytes) return t.push(this.readFixed32()); var e = lm(this); for (t = t || []; this.pos < e;)t.push(this.readFixed32()); return t }, readPackedSFixed32: function (t) { if (this.type !== rm.Bytes) return t.push(this.readSFixed32()); var e = lm(this); for (t = t || []; this.pos < e;)t.push(this.readSFixed32()); return t }, readPackedFixed64: function (t) { if (this.type !== rm.Bytes) return t.push(this.readFixed64()); var e = lm(this); for (t = t || []; this.pos < e;)t.push(this.readFixed64()); return t }, readPackedSFixed64: function (t) { if (this.type !== rm.Bytes) return t.push(this.readSFixed64()); var e = lm(this); for (t = t || []; this.pos < e;)t.push(this.readSFixed64()); return t }, skip: function (t) { var e = 7 & t; if (e === rm.Varint) for (; this.buf[this.pos++] > 127;); else if (e === rm.Bytes) this.pos = this.readVarint() + this.pos; else if (e === rm.Fixed32) this.pos += 4; else { if (e !== rm.Fixed64) throw new Error("Unimplemented type: " + e); this.pos += 8 } }, writeTag: function (t, e) { this.writeVarint(t << 3 | e) }, realloc: function (t) { for (var e = this.length || 16; e < this.pos + t;)e *= 2; if (e !== this.length) { var i = new Uint8Array(e); i.set(this.buf), this.buf = i, this.length = e } }, finish: function () { return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length) }, writeFixed32: function (t) { this.realloc(4), Sm(this.buf, t, this.pos), this.pos += 4 }, writeSFixed32: function (t) { this.realloc(4), Sm(this.buf, t, this.pos), this.pos += 4 }, writeFixed64: function (t) { this.realloc(8), Sm(this.buf, -1 & t, this.pos), Sm(this.buf, Math.floor(t * om), this.pos + 4), this.pos += 8 }, writeSFixed64: function (t) { this.realloc(8), Sm(this.buf, -1 & t, this.pos), Sm(this.buf, Math.floor(t * om), this.pos + 4), this.pos += 8 }, writeVarint: function (t) { (t = +t || 0) > 268435455 || t < 0 ? function (t, e) { var i, n; t >= 0 ? (i = t % 4294967296 | 0, n = t / 4294967296 | 0) : (n = ~(-t / 4294967296), 4294967295 ^ (i = ~(-t % 4294967296)) ? i = i + 1 | 0 : (i = 0, n = n + 1 | 0)); if (t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes"); e.realloc(10), function (t, e, i) { i.buf[i.pos++] = 127 & t | 128, t >>>= 7, i.buf[i.pos++] = 127 & t | 128, t >>>= 7, i.buf[i.pos++] = 127 & t | 128, t >>>= 7, i.buf[i.pos++] = 127 & t | 128, t >>>= 7, i.buf[i.pos] = 127 & t }(i, 0, e), function (t, e) { var i = (7 & t) << 4; if (e.buf[e.pos++] |= i | ((t >>>= 3) ? 128 : 0), !t) return; if (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), !t) return; if (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), !t) return; if (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), !t) return; if (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), !t) return; e.buf[e.pos++] = 127 & t }(n, e) }(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127)))) }, writeSVarint: function (t) { this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t) }, writeBoolean: function (t) { this.writeVarint(Boolean(t)) }, writeString: function (t) { t = String(t), this.realloc(4 * t.length), this.pos++; var e = this.pos; this.pos = function (t, e, i) { for (var n, r, s = 0; s < e.length; s++) { if ((n = e.charCodeAt(s)) > 55295 && n < 57344) { if (!r) { n > 56319 || s + 1 === e.length ? (t[i++] = 239, t[i++] = 191, t[i++] = 189) : r = n; continue } if (n < 56320) { t[i++] = 239, t[i++] = 191, t[i++] = 189, r = n; continue } n = r - 55296 << 10 | n - 56320 | 65536, r = null } else r && (t[i++] = 239, t[i++] = 191, t[i++] = 189, r = null); n < 128 ? t[i++] = n : (n < 2048 ? t[i++] = n >> 6 | 192 : (n < 65536 ? t[i++] = n >> 12 | 224 : (t[i++] = n >> 18 | 240, t[i++] = n >> 12 & 63 | 128), t[i++] = n >> 6 & 63 | 128), t[i++] = 63 & n | 128) } return i }(this.buf, t, this.pos); var i = this.pos - e; i >= 128 && cm(e, i, this), this.pos = e - 1, this.writeVarint(i), this.pos += i }, writeFloat: function (t) { this.realloc(4), nm.write(this.buf, t, this.pos, !0, 23, 4), this.pos += 4 }, writeDouble: function (t) { this.realloc(8), nm.write(this.buf, t, this.pos, !0, 52, 8), this.pos += 8 }, writeBytes: function (t) { var e = t.length; this.writeVarint(e), this.realloc(e); for (var i = 0; i < e; i++)this.buf[this.pos++] = t[i] }, writeRawMessage: function (t, e) { this.pos++; var i = this.pos; t(e, this); var n = this.pos - i; n >= 128 && cm(i, n, this), this.pos = i - 1, this.writeVarint(n), this.pos += n }, writeMessage: function (t, e, i) { this.writeTag(t, rm.Bytes), this.writeRawMessage(e, i) }, writePackedVarint: function (t, e) { e.length && this.writeMessage(t, um, e) }, writePackedSVarint: function (t, e) { e.length && this.writeMessage(t, dm, e) }, writePackedBoolean: function (t, e) { e.length && this.writeMessage(t, pm, e) }, writePackedFloat: function (t, e) { e.length && this.writeMessage(t, gm, e) }, writePackedDouble: function (t, e) { e.length && this.writeMessage(t, fm, e) }, writePackedFixed32: function (t, e) { e.length && this.writeMessage(t, mm, e) }, writePackedSFixed32: function (t, e) { e.length && this.writeMessage(t, _m, e) }, writePackedFixed64: function (t, e) { e.length && this.writeMessage(t, ym, e) }, writePackedSFixed64: function (t, e) { e.length && this.writeMessage(t, xm, e) }, writeBytesField: function (t, e) { this.writeTag(t, rm.Bytes), this.writeBytes(e) }, writeFixed32Field: function (t, e) { this.writeTag(t, rm.Fixed32), this.writeFixed32(e) }, writeSFixed32Field: function (t, e) { this.writeTag(t, rm.Fixed32), this.writeSFixed32(e) }, writeFixed64Field: function (t, e) { this.writeTag(t, rm.Fixed64), this.writeFixed64(e) }, writeSFixed64Field: function (t, e) { this.writeTag(t, rm.Fixed64), this.writeSFixed64(e) }, writeVarintField: function (t, e) { this.writeTag(t, rm.Varint), this.writeVarint(e) }, writeSVarintField: function (t, e) { this.writeTag(t, rm.Varint), this.writeSVarint(e) }, writeStringField: function (t, e) { this.writeTag(t, rm.Bytes), this.writeString(e) }, writeFloatField: function (t, e) { this.writeTag(t, rm.Fixed32), this.writeFloat(e) }, writeDoubleField: function (t, e) { this.writeTag(t, rm.Fixed64), this.writeDouble(e) }, writeBooleanField: function (t, e) { this.writeVarintField(t, Boolean(e)) } }; class Em extends Jp { constructor(t) { super(), t = t || {}, this.dataProjection = new Ae({ code: "", units: "tile-pixels" }), this.featureClass_ = t.featureClass ? t.featureClass : Bp, this.geometryName_ = t.geometryName, this.layerName_ = t.layerName ? t.layerName : "layer", this.layers_ = t.layers ? t.layers : null, this.idProperty_ = t.idProperty, this.supportedMediaTypes = ["application/vnd.mapbox-vector-tile", "application/x-protobuf"] } readRawGeometry_(t, e, i, n) { t.pos = e.geometry; const r = t.readVarint() + t.pos; let s = 1, o = 0, a = 0, l = 0, h = 0, c = 0; for (; t.pos < r;) { if (!o) { const e = t.readVarint(); s = 7 & e, o = e >> 3 } o--, 1 === s || 2 === s ? (a += t.readSVarint(), l += t.readSVarint(), 1 === s && h > c && (n.push(h), c = h), i.push(a, l), h += 2) : 7 === s ? h > c && (i.push(i[c], i[c + 1]), h += 2) : at(!1, 59) } h > c && (n.push(h), c = h) } createFeature_(t, e, i) { const n = e.type; if (0 === n) return null; let r; const s = e.properties; let o; this.idProperty_ ? (o = s[this.idProperty_], delete s[this.idProperty_]) : o = e.id, s[this.layerName_] = e.layer.name; const a = [], l = []; this.readRawGeometry_(t, e, a, l); const h = function (t, e) { let i; 1 === t ? i = 1 === e ? "Point" : "MultiPoint" : 2 === t ? i = 1 === e ? "LineString" : "MultiLineString" : 3 === t && (i = "Polygon"); return i }(n, l.length); if (this.featureClass_ === Bp) r = new this.featureClass_(h, a, l, s, o), r.transform(i.dataProjection); else { let t; if ("Polygon" == h) { const e = cr(a, l); t = e.length > 1 ? new Gp(a, "XY", e) : new ur(a, "XY", l) } else t = "Point" === h ? new Wn(a, "XY") : "LineString" === h ? new Op(a, "XY") : "MultiPoint" === h ? new Dp(a, "XY") : "MultiLineString" === h ? new Np(a, "XY", l) : null; r = new (0, this.featureClass_), this.geometryName_ && r.setGeometryName(this.geometryName_); const e = Qp(t, !1, i); r.setGeometry(e), void 0 !== o && r.setId(o), r.setProperties(s, !0) } return r } getType() { return "arraybuffer" } readFeatures(t, e) { const i = this.layers_, n = Ui((e = this.adaptOptions(e)).dataProjection); n.setWorldExtent(e.extent), e.dataProjection = n; const r = new im(t), s = r.readFields(Tm, {}), o = []; for (const t in s) { if (i && !i.includes(t)) continue; const a = s[t], l = a ? [0, 0, a.extent, a.extent] : null; n.setExtent(l); for (let t = 0, i = a.length; t < i; ++t) { const i = Rm(r, a, t), n = this.createFeature_(r, i, e); null !== n && o.push(n) } } return o } readProjection(t) { return this.dataProjection } setLayers(t) { this.layers_ = t } } function Tm(t, e, i) { if (3 === t) { const t = { keys: [], values: [], features: [] }, n = i.readVarint() + i.pos; i.readFields(Cm, t, n), t.length = t.features.length, t.length && (e[t.name] = t) } } function Cm(t, e, i) { if (15 === t) e.version = i.readVarint(); else if (1 === t) e.name = i.readString(); else if (5 === t) e.extent = i.readVarint(); else if (2 === t) e.features.push(i.pos); else if (3 === t) e.keys.push(i.readString()); else if (4 === t) { let n = null; const r = i.readVarint() + i.pos; for (; i.pos < r;)n = 1 === (t = i.readVarint() >> 3) ? i.readString() : 2 === t ? i.readFloat() : 3 === t ? i.readDouble() : 4 === t ? i.readVarint64() : 5 === t ? i.readVarint() : 6 === t ? i.readSVarint() : 7 === t ? i.readBoolean() : null; e.values.push(n) } } function bm(t, e, i) { if (1 == t) e.id = i.readVarint(); else if (2 == t) { const t = i.readVarint() + i.pos; for (; i.pos < t;) { const t = e.layer.keys[i.readVarint()], n = e.layer.values[i.readVarint()]; e.properties[t] = n } } else 3 == t ? e.type = i.readVarint() : 4 == t && (e.geometry = i.pos) } function Rm(t, e, i) { t.pos = e.features[i]; const n = t.readVarint() + t.pos, r = { layer: e, type: 0, properties: {} }; return t.readFields(bm, r, n), r } class Pm extends Ig { constructor(t) { t = t || {}; const e = Object.assign({}, t); delete e.preload, delete e.useInterimTilesOnError, super(e), this.on, this.once, this.un; const i = t.renderMode || "hybrid"; at("hybrid" == i || "vector" == i, 28), this.renderMode_ = i, this.setPreload(t.preload ? t.preload : 0), this.setUseInterimTilesOnError(void 0 === t.useInterimTilesOnError || t.useInterimTilesOnError), this.getBackground, this.setBackground } createRenderer() { return new Rp(this) } getFeatures(t) { return super.getFeatures(t) } getRenderMode() { return this.renderMode_ } getPreload() { return this.get(Mc) } getUseInterimTilesOnError() { return this.get(Fc) } setPreload(t) { this.set(Mc, t) } setUseInterimTilesOnError(t) { this.set(Fc, t) } } class Im extends i { constructor(t) { super(w), this.error = t } } function Lm(t, e) { const i = `\n    attribute vec2 ${pd.TEXTURE_COORD};\n    uniform mat4 ${fd.TILE_TRANSFORM};\n    uniform float ${fd.TEXTURE_PIXEL_WIDTH};\n    uniform float ${fd.TEXTURE_PIXEL_HEIGHT};\n    uniform float ${fd.TEXTURE_RESOLUTION};\n    uniform float ${fd.TEXTURE_ORIGIN_X};\n    uniform float ${fd.TEXTURE_ORIGIN_Y};\n    uniform float ${fd.DEPTH};\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n\n    void main() {\n      v_textureCoord = ${pd.TEXTURE_COORD};\n      v_mapCoord = vec2(\n        ${fd.TEXTURE_ORIGIN_X} + ${fd.TEXTURE_RESOLUTION} * ${fd.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],\n        ${fd.TEXTURE_ORIGIN_Y} - ${fd.TEXTURE_RESOLUTION} * ${fd.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]\n      );\n      gl_Position = ${fd.TILE_TRANSFORM} * vec4(${pd.TEXTURE_COORD}, ${fd.DEPTH}, 1.0);\n    }\n  `, n = { inFragmentShader: !0, variables: [], attributes: [], stringLiteralsMap: {}, functions: {}, bandCount: e }, r = []; if (void 0 !== t.color) { const e = Gd(n, t.color, Cd); r.push(`color = ${e};`) } if (void 0 !== t.contrast) { const e = Gd(n, t.contrast, Ed); r.push(`color.rgb = clamp((${e} + 1.0) * color.rgb - (${e} / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`) } if (void 0 !== t.exposure) { const e = Gd(n, t.exposure, Ed); r.push(`color.rgb = clamp((${e} + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`) } if (void 0 !== t.saturation) { const e = Gd(n, t.saturation, Ed); r.push(`\n      float saturation = ${e} + 1.0;\n      float sr = (1.0 - saturation) * 0.2126;\n      float sg = (1.0 - saturation) * 0.7152;\n      float sb = (1.0 - saturation) * 0.0722;\n      mat3 saturationMatrix = mat3(\n        sr + saturation, sr, sr,\n        sg, sg + saturation, sg,\n        sb, sb, sb + saturation\n      );\n      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    `) } if (void 0 !== t.gamma) { const e = Gd(n, t.gamma, Ed); r.push(`color.rgb = pow(color.rgb, vec3(1.0 / ${e}));`) } if (void 0 !== t.brightness) { const e = Gd(n, t.brightness, Ed); r.push(`color.rgb = clamp(color.rgb + ${e}, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`) } const s = {}, o = n.variables.length; if (o > 1 && !t.variables) throw new Error(`Missing variables in style (expected ${n.variables})`); for (let e = 0; e < o; ++e) { const i = n.variables[e]; if (!(i in t.variables)) throw new Error(`Missing '${i}' in style variables`); s[Kd(i)] = function () { let e = t.variables[i]; return "string" == typeof e && (e = Dd(n, e)), void 0 !== e ? e : -9999999 } } const a = Object.keys(s).map((function (t) { return `uniform float ${t};` })), l = Math.ceil(e / 4); a.push(`uniform sampler2D ${fd.TILE_TEXTURE_ARRAY}[${l}];`), n.paletteTextures && a.push(`uniform sampler2D u_paletteTextures[${n.paletteTextures.length}];`); const h = Object.keys(n.functions).map((function (t) { return n.functions[t] })); return { vertexShader: i, fragmentShader: `\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    #else\n    precision mediump float;\n    #endif\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n    uniform vec4 ${fd.RENDER_EXTENT};\n    uniform float ${fd.TRANSITION_ALPHA};\n    uniform float ${fd.TEXTURE_PIXEL_WIDTH};\n    uniform float ${fd.TEXTURE_PIXEL_HEIGHT};\n    uniform float ${fd.RESOLUTION};\n    uniform float ${fd.ZOOM};\n\n    ${a.join("\n")}\n\n    ${h.join("\n")}\n\n    void main() {\n      if (\n        v_mapCoord[0] < ${fd.RENDER_EXTENT}[0] ||\n        v_mapCoord[1] < ${fd.RENDER_EXTENT}[1] ||\n        v_mapCoord[0] > ${fd.RENDER_EXTENT}[2] ||\n        v_mapCoord[1] > ${fd.RENDER_EXTENT}[3]\n      ) {\n        discard;\n      }\n\n      vec4 color = texture2D(${fd.TILE_TEXTURE_ARRAY}[0],  v_textureCoord);\n\n      ${r.join("\n")}\n\n      if (color.a == 0.0) {\n        discard;\n      }\n\n      gl_FragColor = color;\n      gl_FragColor.rgb *= gl_FragColor.a;\n      gl_FragColor *= ${fd.TRANSITION_ALPHA};\n    }`, uniforms: s, paletteTextures: n.paletteTextures } } class Mm extends Ac { constructor(t) { const e = (t = t ? Object.assign({}, t) : {}).style || {}; delete t.style; const i = t.cacheSize; delete t.cacheSize, super(t), this.sources_ = t.sources, this.renderedSource_ = null, this.renderedResolution_ = NaN, this.style_ = e, this.cacheSize_ = i, this.styleVariables_ = this.style_.variables || {}, this.addChangeListener(ds, this.handleSourceUpdate_) } getSources(t, e) { const i = this.getSource(); return this.sources_ ? "function" == typeof this.sources_ ? this.sources_(t, e) : this.sources_ : i ? [i] : [] } getRenderSource() { return this.renderedSource_ || this.getSource() } getSourceState() { const t = this.getRenderSource(); return t ? t.getState() : "undefined" } handleSourceUpdate_() { this.hasRenderer() && this.getRenderer().clearCache(), this.getSource() && this.setStyle(this.style_) } getSourceBandCount_() { const t = Number.MAX_SAFE_INTEGER, e = this.getSources([-t, -t, t, t], t); return e && e.length && "bandCount" in e[0] ? e[0].bandCount : 4 } createRenderer() { const t = Lm(this.style_, this.getSourceBandCount_()); return new wd(this, { vertexShader: t.vertexShader, fragmentShader: t.fragmentShader, uniforms: t.uniforms, cacheSize: this.cacheSize_, paletteTextures: t.paletteTextures }) } renderSources(t, e) { const i = this.getRenderer(); let n; for (let r = 0, s = e.length; r < s; ++r)this.renderedSource_ = e[r], i.prepareFrame(t) && (n = i.renderFrame(t)); return n } render(t, e) { this.rendered = !0; const i = t.viewState, n = this.getSources(t.extent, i.resolution); let r = !0; for (let t = 0, e = n.length; t < e; ++t) { const e = n[t], i = e.getState(); if ("loading" == i) { const t = () => { "ready" == e.getState() && (e.removeEventListener("change", t), this.changed()) }; e.addEventListener("change", t) } r = r && "ready" == i } const s = this.renderSources(t, n); if (this.getRenderer().renderComplete && r) return this.renderedResolution_ = i.resolution, s; if (this.renderedResolution_ > .5 * i.resolution) { const e = this.getSources(t.extent, this.renderedResolution_).filter((t => !n.includes(t))); if (e.length > 0) return this.renderSources(t, e) } return s } setStyle(t) { this.styleVariables_ = t.variables || {}, this.style_ = t; const e = Lm(this.style_, this.getSourceBandCount_()); this.getRenderer().reset({ vertexShader: e.vertexShader, fragmentShader: e.fragmentShader, uniforms: e.uniforms, paletteTextures: e.paletteTextures }), this.changed() } updateStyleVariables(t) { Object.assign(this.styleVariables_, t), this.changed() } } Mm.prototype.dispose; const Fm = "addfeatures"; class Am extends i { constructor(t, e, i, n) { super(t), this.features = i, this.file = e, this.projection = n } } const Om = "drawstart", Nm = "drawend", Dm = "drawabort"; class km extends i { constructor(t, e) { super(t), this.feature = e } } function Gm(t, e) { return ri(t[0], t[1], e[0], e[1]) } function jm(t, e) { const i = t.length; return e < 0 ? t[e + i] : e >= i ? t[e - i] : t[e] } function Bm(t, e, i) { let n, r; e < i ? (n = e, r = i) : (n = i, r = e); const s = Math.ceil(n), o = Math.floor(r); if (s > o) { return Gm(Zm(t, n), Zm(t, r)) } let a = 0; if (n < s) { a += Gm(Zm(t, n), jm(t, s)) } if (o < r) { a += Gm(jm(t, o), Zm(t, r)) } for (let e = s; e < o - 1; ++e) { a += Gm(jm(t, e), jm(t, e + 1)) } return a } function Um(t, e, i) { if (e instanceof Op) Xm(t, e.getCoordinates(), !1, i); else if (e instanceof Np) { const n = e.getCoordinates(); for (let e = 0, r = n.length; e < r; ++e)Xm(t, n[e], !1, i) } else if (e instanceof ur) { const n = e.getCoordinates(); for (let e = 0, r = n.length; e < r; ++e)Xm(t, n[e], !0, i) } else if (e instanceof Gp) { const n = e.getCoordinates(); for (let e = 0, r = n.length; e < r; ++e) { const r = n[e]; for (let e = 0, n = r.length; e < n; ++e)Xm(t, r[e], !0, i) } } else if (e instanceof Ip) { const n = e.getGeometries(); for (let e = 0; e < n.length; ++e)Um(t, n[e], i) } else; } const zm = { index: -1, endIndex: NaN }; function Xm(t, e, i, n) { const r = t[0], s = t[1]; for (let t = 0, o = e.length - 1; t < o; ++t) { const o = Wm(r, s, e[t], e[t + 1]); if (0 === o.squaredDistance) { const r = t + o.along; return void n.push({ coordinates: e, ring: i, startIndex: r, endIndex: r }) } } } const Vm = { along: 0, squaredDistance: 0 }; function Wm(t, e, i, n) { const r = i[0], s = i[1], o = n[0] - r, a = n[1] - s; let l = 0, h = r, c = s; return 0 === o && 0 === a || (l = ii(((t - r) * o + (e - s) * a) / (o * o + a * a), 0, 1), h += o * l, c += a * l), Vm.along = l, Vm.squaredDistance = ci(ri(t, e, h, c), 10), Vm } function Zm(t, e) { const i = t.length; let n = Math.floor(e); const r = e - n; n >= i ? n -= i : n < 0 && (n += i); let s = n + 1; s >= i && (s -= i); const o = t[n], a = o[0], l = o[1], h = t[s]; return [a + (h[0] - a) * r, l + (h[1] - l) * r] } function Ym() { const t = fg(); return function (e, i) { return t[e.getGeometry().getType()] } } const Km = "extentchanged"; class qm extends i { constructor(t) { super(Km), this.extent = t } } function Hm() { const t = fg(); return function (e, i) { return t.Polygon } } function $m() { const t = fg(); return function (e, i) { return t.Point } } function Jm(t) { return function (e) { return zt([t, e]) } } function Qm(t, e) { return t[0] == e[0] ? function (i) { return zt([t, [i[0], e[1]]]) } : t[1] == e[1] ? function (i) { return zt([t, [e[0], i[1]]]) } : null } function t_(t) { return parseFloat(t) } function e_(t) { return function (t) { return ci(t, 5) }(t).toString() } function i_(t, e) { return !isNaN(t) && t !== t_(e_(e)) } const n_ = [0, 0, 0, 0], r_ = [], s_ = "modifystart", o_ = "modifyend"; class a_ extends i { constructor(t, e, i) { super(t), this.features = e, this.mapBrowserEvent = i } } function l_(t, e) { return t.index - e.index } function h_(t, e, i) { const n = e.geometry; if ("Circle" === n.getType()) { let r = n; if (1 === e.index) { const e = en(); e && (r = r.clone().transform(e, i)); const n = Ti(r.getCenter(), rn(t, i)), s = Math.sqrt(n) - r.getRadius(); return s * s } } const r = rn(t, i); return r_[0] = rn(e.segment[0], i), r_[1] = rn(e.segment[1], i), bi(r, r_) } function c_(t, e, i) { const n = e.geometry; if ("Circle" === n.getType() && 1 === e.index) { let e = n; const r = en(); return r && (e = e.clone().transform(r, i)), nn(e.getClosestPoint(rn(t, i)), i) } const r = rn(t, i); return r_[0] = rn(e.segment[0], i), r_[1] = rn(e.segment[1], i), nn(yi(r, r_), i) } function u_() { const t = fg(); return function (e, i) { return t.Point } } const d_ = "select"; class g_ extends i { constructor(t, e, i, n) { super(t), this.selected = e, this.deselected = i, this.mapBrowserEvent = n } } const f_ = {}; class p_ extends ea { constructor(t) { let e; if (super(), this.on, this.once, this.un, t = t || {}, this.boundAddFeature_ = this.addFeature_.bind(this), this.boundRemoveFeature_ = this.removeFeature_.bind(this), this.condition_ = t.condition ? t.condition : pa, this.addCondition_ = t.addCondition ? t.addCondition : fa, this.removeCondition_ = t.removeCondition ? t.removeCondition : fa, this.toggleCondition_ = t.toggleCondition ? t.toggleCondition : _a, this.multi_ = !!t.multi && t.multi, this.filter_ = t.filter ? t.filter : g, this.hitTolerance_ = t.hitTolerance ? t.hitTolerance : 0, this.style_ = void 0 !== t.style ? t.style : function () { const t = fg(); return c(t.Polygon, t.LineString), c(t.GeometryCollection, t.LineString), function (e) { return e.getGeometry() ? t[e.getGeometry().getType()] : null } }(), this.features_ = t.features || new q, t.layers) if ("function" == typeof t.layers) e = t.layers; else { const i = t.layers; e = function (t) { return i.includes(t) } } else e = g; this.layerFilter_ = e, this.featureLayerAssociation_ = {} } addFeatureLayerAssociation_(t, e) { this.featureLayerAssociation_[z(t)] = e } getFeatures() { return this.features_ } getHitTolerance() { return this.hitTolerance_ } getLayer(t) { return this.featureLayerAssociation_[z(t)] } setHitTolerance(t) { this.hitTolerance_ = t } setMap(t) { this.getMap() && this.style_ && this.features_.forEach(this.restorePreviousStyle_.bind(this)), super.setMap(t), t ? (this.features_.addEventListener(W, this.boundAddFeature_), this.features_.addEventListener(Z, this.boundRemoveFeature_), this.style_ && this.features_.forEach(this.applySelectedStyle_.bind(this))) : (this.features_.removeEventListener(W, this.boundAddFeature_), this.features_.removeEventListener(Z, this.boundRemoveFeature_)) } addFeature_(t) { const e = t.element; if (this.style_ && this.applySelectedStyle_(e), !this.getLayer(e)) { const t = this.getMap().getAllLayers().find((function (t) { if (t instanceof zp && t.getSource() && t.getSource().hasFeature(e)) return t })); t && this.addFeatureLayerAssociation_(e, t) } } removeFeature_(t) { this.style_ && this.restorePreviousStyle_(t.element) } getStyle() { return this.style_ } applySelectedStyle_(t) { const e = z(t); e in f_ || (f_[e] = t.getStyle()), t.setStyle(this.style_) } restorePreviousStyle_(t) { const e = this.getMap().getInteractions().getArray(); for (let i = e.length - 1; i >= 0; --i) { const n = e[i]; if (n !== this && n instanceof p_ && n.getStyle() && -1 !== n.getFeatures().getArray().lastIndexOf(t)) return void t.setStyle(n.getStyle()) } const i = z(t); t.setStyle(f_[i]), delete f_[i] } removeFeatureLayerAssociation_(t) { delete this.featureLayerAssociation_[z(t)] } handleEvent(t) { if (!this.condition_(t)) return !0; const e = this.addCondition_(t), i = this.removeCondition_(t), n = this.toggleCondition_(t), r = !e && !i && !n, s = t.map, o = this.getFeatures(), a = [], l = []; if (r) { y(this.featureLayerAssociation_), s.forEachFeatureAtPixel(t.pixel, function (t, e) { if (t instanceof lt && this.filter_(t, e)) return this.addFeatureLayerAssociation_(t, e), l.push(t), !this.multi_ }.bind(this), { layerFilter: this.layerFilter_, hitTolerance: this.hitTolerance_ }); for (let t = o.getLength() - 1; t >= 0; --t) { const e = o.item(t), i = l.indexOf(e); i > -1 ? l.splice(i, 1) : (o.remove(e), a.push(e)) } 0 !== l.length && o.extend(l) } else { s.forEachFeatureAtPixel(t.pixel, function (t, r) { if (t instanceof lt && this.filter_(t, r)) return !e && !n || o.getArray().includes(t) ? (i || n) && o.getArray().includes(t) && (a.push(t), this.removeFeatureLayerAssociation_(t)) : (this.addFeatureLayerAssociation_(t, r), l.push(t)), !this.multi_ }.bind(this), { layerFilter: this.layerFilter_, hitTolerance: this.hitTolerance_ }); for (let t = a.length - 1; t >= 0; --t)o.remove(a[t]); o.extend(l) } return (l.length > 0 || a.length > 0) && this.dispatchEvent(new g_(d_, l, a, t)), !0 } } function m_(t) { return t.feature ? t.feature : t.element ? t.element : void 0 } const __ = []; const y_ = "translatestart", x_ = "translating", v_ = "translateend"; class S_ extends i { constructor(t, e, i, n, r) { super(t), this.features = e, this.coordinate = i, this.startCoordinate = n, this.mapBrowserEvent = r } } function w_(t, e, i, n, r, s) { void 0 !== r ? s = void 0 !== s ? s : 0 : (r = [], s = 0); let o = e; for (; o < i;) { const e = t[o++]; r[s++] = t[o++], r[s++] = e; for (let e = 2; e < n; ++e)r[s++] = t[o++] } return r.length = s, r } class E_ extends Jp { constructor() { super() } getType() { return "json" } readFeature(t, e) { return this.readFeatureFromObject(T_(t), this.getReadOptions(t, e)) } readFeatures(t, e) { return this.readFeaturesFromObject(T_(t), this.getReadOptions(t, e)) } readFeatureFromObject(t, e) { return B() } readFeaturesFromObject(t, e) { return B() } readGeometry(t, e) { return this.readGeometryFromObject(T_(t), this.getReadOptions(t, e)) } readGeometryFromObject(t, e) { return B() } readProjection(t) { return this.readProjectionFromObject(T_(t)) } readProjectionFromObject(t) { return B() } writeFeature(t, e) { return JSON.stringify(this.writeFeatureObject(t, e)) } writeFeatureObject(t, e) { return B() } writeFeatures(t, e) { return JSON.stringify(this.writeFeaturesObject(t, e)) } writeFeaturesObject(t, e) { return B() } writeGeometry(t, e) { return JSON.stringify(this.writeGeometryObject(t, e)) } writeGeometryObject(t, e) { return B() } } function T_(t) { if ("string" == typeof t) { const e = JSON.parse(t); return e || null } return null !== t ? t : null } const C_ = { Point: function (t) { let e; e = void 0 !== t.m && void 0 !== t.z ? new Wn([t.x, t.y, t.z, t.m], "XYZM") : void 0 !== t.z ? new Wn([t.x, t.y, t.z], "XYZ") : void 0 !== t.m ? new Wn([t.x, t.y, t.m], "XYM") : new Wn([t.x, t.y]); return e }, LineString: function (t) { const e = P_(t); return new Op(t.paths[0], e) }, Polygon: function (t) { const e = P_(t); return new ur(t.rings, e) }, MultiPoint: function (t) { const e = P_(t); return new Dp(t.points, e) }, MultiLineString: function (t) { const e = P_(t); return new Np(t.paths, e) }, MultiPolygon: function (t) { const e = P_(t); return new Gp(t.rings, e) } }, b_ = { Point: function (t, e) { const i = t.getCoordinates(); let n; const r = t.getLayout(); "XYZ" === r ? n = { x: i[0], y: i[1], z: i[2] } : "XYM" === r ? n = { x: i[0], y: i[1], m: i[2] } : "XYZM" === r ? n = { x: i[0], y: i[1], z: i[2], m: i[3] } : "XY" === r ? n = { x: i[0], y: i[1] } : at(!1, 34); return n }, LineString: function (t, e) { const i = I_(t); return { hasZ: i.hasZ, hasM: i.hasM, paths: [t.getCoordinates()] } }, Polygon: function (t, e) { const i = I_(t); return { hasZ: i.hasZ, hasM: i.hasM, rings: t.getCoordinates(!1) } }, MultiPoint: function (t, e) { const i = I_(t); return { hasZ: i.hasZ, hasM: i.hasM, points: t.getCoordinates() } }, MultiLineString: function (t, e) { const i = I_(t); return { hasZ: i.hasZ, hasM: i.hasM, paths: t.getCoordinates() } }, MultiPolygon: function (t, e) { const i = I_(t), n = t.getCoordinates(!1), r = []; for (let t = 0; t < n.length; t++)for (let e = n[t].length - 1; e >= 0; e--)r.push(n[t][e]); return { hasZ: i.hasZ, hasM: i.hasM, rings: r } } }; function R_(t, e) { if (!t) return null; let i; if ("number" == typeof t.x && "number" == typeof t.y) i = "Point"; else if (t.points) i = "MultiPoint"; else if (t.paths) { i = 1 === t.paths.length ? "LineString" : "MultiLineString" } else if (t.rings) { const e = t, n = P_(e), r = function (t, e) { const i = [], n = [], r = []; let s, o; for (s = 0, o = t.length; s < o; ++s) { i.length = 0, Pn(i, 0, t[s], e.length); sr(i, 0, i.length, e.length) ? n.push([t[s]]) : r.push(t[s]) } for (; r.length;) { const t = r.shift(); let e = !1; for (s = n.length - 1; s >= 0; s--) { const i = n[s][0]; if (Yt(new Vn(i).getExtent(), new Vn(t).getExtent())) { n[s].push(t), e = !0; break } } e || n.push([t.reverse()]) } return n }(e.rings, n); 1 === r.length ? (i = "Polygon", t = Object.assign({}, t, { rings: r[0] })) : (i = "MultiPolygon", t = Object.assign({}, t, { rings: r })) } return Qp((0, C_[i])(t), !1, e) } function P_(t) { let e = "XY"; return !0 === t.hasZ && !0 === t.hasM ? e = "XYZM" : !0 === t.hasZ ? e = "XYZ" : !0 === t.hasM && (e = "XYM"), e } function I_(t) { const e = t.getLayout(); return { hasZ: "XYZ" === e || "XYZM" === e, hasM: "XYM" === e || "XYZM" === e } } function L_(t, e) { return (0, b_[t.getType()])(Qp(t, !0, e), e) } class M_ extends Jp { constructor() { super(), this.xmlSerializer_ = Nu() } getType() { return "xml" } readFeature(t, e) { if (t) { if ("string" == typeof t) { const i = _u(t); return this.readFeatureFromDocument(i, e) } return pu(t) ? this.readFeatureFromDocument(t, e) : this.readFeatureFromNode(t, e) } return null } readFeatureFromDocument(t, e) { const i = this.readFeaturesFromDocument(t, e); return i.length > 0 ? i[0] : null } readFeatureFromNode(t, e) { return null } readFeatures(t, e) { if (t) { if ("string" == typeof t) { const i = _u(t); return this.readFeaturesFromDocument(i, e) } return pu(t) ? this.readFeaturesFromDocument(t, e) : this.readFeaturesFromNode(t, e) } return [] } readFeaturesFromDocument(t, e) { const i = []; for (let n = t.firstChild; n; n = n.nextSibling)n.nodeType == Node.ELEMENT_NODE && c(i, this.readFeaturesFromNode(n, e)); return i } readFeaturesFromNode(t, e) { return B() } readGeometry(t, e) { if (t) { if ("string" == typeof t) { const i = _u(t); return this.readGeometryFromDocument(i, e) } return pu(t) ? this.readGeometryFromDocument(t, e) : this.readGeometryFromNode(t, e) } return null } readGeometryFromDocument(t, e) { return null } readGeometryFromNode(t, e) { return null } readProjection(t) { if (t) { if ("string" == typeof t) { const e = _u(t); return this.readProjectionFromDocument(e) } return pu(t) ? this.readProjectionFromDocument(t) : this.readProjectionFromNode(t) } return null } readProjectionFromDocument(t) { return this.dataProjection } readProjectionFromNode(t) { return this.dataProjection } writeFeature(t, e) { const i = this.writeFeatureNode(t, e); return this.xmlSerializer_.serializeToString(i) } writeFeatureNode(t, e) { return null } writeFeatures(t, e) { const i = this.writeFeaturesNode(t, e); return this.xmlSerializer_.serializeToString(i) } writeFeaturesNode(t, e) { return null } writeGeometry(t, e) { const i = this.writeGeometryNode(t, e); return this.xmlSerializer_.serializeToString(i) } writeGeometryNode(t, e) { return null } } const F_ = "http://www.opengis.net/gml", A_ = /^\s*$/; class O_ extends M_ { constructor(t) { super(), t = t || {}, this.featureType = t.featureType, this.featureNS = t.featureNS, this.srsName = t.srsName, this.schemaLocation = "", this.FEATURE_COLLECTION_PARSERS = {}, this.FEATURE_COLLECTION_PARSERS[this.namespace] = { featureMember: xu(this.readFeaturesInternal), featureMembers: vu(this.readFeaturesInternal) }, this.supportedMediaTypes = ["application/gml+xml"] } readFeaturesInternal(t, e) { const i = t.localName; let n = null; if ("FeatureCollection" == i) n = Lu([], this.FEATURE_COLLECTION_PARSERS, t, e, this); else if ("featureMembers" == i || "featureMember" == i || "member" == i) { const r = e[0]; let s = r.featureType, o = r.featureNS; const a = "p", l = "p0"; if (!s && t.childNodes) { s = [], o = {}; for (let e = 0, i = t.childNodes.length; e < i; ++e) { const i = t.childNodes[e]; if (1 === i.nodeType) { const t = i.nodeName.split(":").pop(); if (!s.includes(t)) { let e = "", n = 0; const r = i.namespaceURI; for (const t in o) { if (o[t] === r) { e = t; break } ++n } e || (e = a + n, o[e] = r), s.push(e + ":" + t) } } } "featureMember" != i && (r.featureType = s, r.featureNS = o) } if ("string" == typeof o) { const t = o; o = {}, o[l] = t } const h = {}, c = Array.isArray(s) ? s : [s]; for (const t in o) { const e = {}; for (let n = 0, r = c.length; n < r; ++n) { (c[n].includes(":") ? c[n].split(":")[0] : l) === t && (e[c[n].split(":").pop()] = "featureMembers" == i ? xu(this.readFeatureElement, this) : vu(this.readFeatureElement, this)) } h[o[t]] = e } n = Lu("featureMember" == i || "member" == i ? void 0 : [], h, t, e) } return null === n && (n = []), n } readGeometryOrExtent(t, e) { const i = e[0]; return i.srsName = t.firstElementChild.getAttribute("srsName"), i.srsDimension = t.firstElementChild.getAttribute("srsDimension"), Lu(null, this.GEOMETRY_PARSERS, t, e, this) } readExtentElement(t, e) { const i = e[0], n = this.readGeometryOrExtent(t, e); return n ? tm(n, i) : void 0 } readGeometryElement(t, e) { const i = e[0], n = this.readGeometryOrExtent(t, e); return n ? Qp(n, !1, i) : void 0 } readFeatureElementInternal(t, e, i) { let n; const r = {}; for (let s = t.firstElementChild; s; s = s.nextElementSibling) { let t; const o = s.localName; 0 === s.childNodes.length || 1 === s.childNodes.length && (3 === s.firstChild.nodeType || 4 === s.firstChild.nodeType) ? (t = gu(s, !1), A_.test(t) && (t = void 0)) : (i && (t = "boundedBy" === o ? this.readExtentElement(s, e) : this.readGeometryElement(s, e)), t ? "boundedBy" !== o && (n = o) : t = this.readFeatureElementInternal(s, e, !1)); const a = s.attributes.length; if (a > 0) { t = { _content_: t }; for (let e = 0; e < a; e++) { t[s.attributes[e].name] = s.attributes[e].value } } r[o] ? (r[o] instanceof Array || (r[o] = [r[o]]), r[o].push(t)) : r[o] = t } if (i) { const e = new lt(r); n && e.setGeometryName(n); const i = t.getAttribute("fid") || mu(t, this.namespace, "id"); return i && e.setId(i), e } return r } readFeatureElement(t, e) { return this.readFeatureElementInternal(t, e, !0) } readPoint(t, e) { const i = this.readFlatCoordinatesFromNode(t, e); if (i) return new Wn(i, "XYZ") } readMultiPoint(t, e) { const i = Lu([], this.MULTIPOINT_PARSERS, t, e, this); return i ? new Dp(i) : void 0 } readMultiLineString(t, e) { const i = Lu([], this.MULTILINESTRING_PARSERS, t, e, this); if (i) return new Np(i) } readMultiPolygon(t, e) { const i = Lu([], this.MULTIPOLYGON_PARSERS, t, e, this); if (i) return new Gp(i) } pointMemberParser(t, e) { Iu(this.POINTMEMBER_PARSERS, t, e, this) } lineStringMemberParser(t, e) { Iu(this.LINESTRINGMEMBER_PARSERS, t, e, this) } polygonMemberParser(t, e) { Iu(this.POLYGONMEMBER_PARSERS, t, e, this) } readLineString(t, e) { const i = this.readFlatCoordinatesFromNode(t, e); if (i) { return new Op(i, "XYZ") } } readFlatLinearRing(t, e) { const i = Lu(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, t, e, this); return i || void 0 } readLinearRing(t, e) { const i = this.readFlatCoordinatesFromNode(t, e); if (i) return new Vn(i, "XYZ") } readPolygon(t, e) { const i = Lu([null], this.FLAT_LINEAR_RINGS_PARSERS, t, e, this); if (i && i[0]) { const t = i[0], e = [t.length]; let n, r; for (n = 1, r = i.length; n < r; ++n)c(t, i[n]), e.push(t.length); return new ur(t, "XYZ", e) } } readFlatCoordinatesFromNode(t, e) { return Lu(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, t, e, this) } readGeometryFromNode(t, e) { const i = this.readGeometryElement(t, [this.getReadOptions(t, e || {})]); return i || null } readFeaturesFromNode(t, e) { const i = { featureType: this.featureType, featureNS: this.featureNS }; i && Object.assign(i, this.getReadOptions(t, e)); return this.readFeaturesInternal(t, [i]) || [] } readProjectionFromNode(t) { return Ui(this.srsName ? this.srsName : t.firstElementChild.getAttribute("srsName")) } } function N_(t) { return D_(gu(t, !1)) } function D_(t) { const e = /^\s*(true|1)|(false|0)\s*$/.exec(t); return e ? void 0 !== e[1] || !1 : void 0 } function k_(t) { const e = gu(t, !1), i = Date.parse(e); return isNaN(i) ? void 0 : i / 1e3 } function G_(t) { return j_(gu(t, !1)) } function j_(t) { const e = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(t); return e ? parseFloat(e[1]) : void 0 } function B_(t) { return U_(gu(t, !1)) } function U_(t) { const e = /^\s*(\d+)\s*$/.exec(t); return e ? parseInt(e[1], 10) : void 0 } function z_(t) { return gu(t, !1).trim() } function X_(t, e) { K_(t, e ? "1" : "0") } function V_(t, e) { t.appendChild(Du().createCDATASection(e)) } function W_(t, e) { const i = new Date(1e3 * e), n = i.getUTCFullYear() + "-" + fi(i.getUTCMonth() + 1, 2) + "-" + fi(i.getUTCDate(), 2) + "T" + fi(i.getUTCHours(), 2) + ":" + fi(i.getUTCMinutes(), 2) + ":" + fi(i.getUTCSeconds(), 2) + "Z"; t.appendChild(Du().createTextNode(n)) } function Z_(t, e) { const i = e.toPrecision(); t.appendChild(Du().createTextNode(i)) } function Y_(t, e) { const i = e.toString(); t.appendChild(Du().createTextNode(i)) } function K_(t, e) { t.appendChild(Du().createTextNode(e)) } O_.prototype.namespace = F_, O_.prototype.FLAT_LINEAR_RINGS_PARSERS = { "http://www.opengis.net/gml": {} }, O_.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = { "http://www.opengis.net/gml": {} }, O_.prototype.GEOMETRY_PARSERS = { "http://www.opengis.net/gml": {} }, O_.prototype.MULTIPOINT_PARSERS = { "http://www.opengis.net/gml": { pointMember: xu(O_.prototype.pointMemberParser), pointMembers: xu(O_.prototype.pointMemberParser) } }, O_.prototype.MULTILINESTRING_PARSERS = { "http://www.opengis.net/gml": { lineStringMember: xu(O_.prototype.lineStringMemberParser), lineStringMembers: xu(O_.prototype.lineStringMemberParser) } }, O_.prototype.MULTIPOLYGON_PARSERS = { "http://www.opengis.net/gml": { polygonMember: xu(O_.prototype.polygonMemberParser), polygonMembers: xu(O_.prototype.polygonMemberParser) } }, O_.prototype.POINTMEMBER_PARSERS = { "http://www.opengis.net/gml": { Point: xu(O_.prototype.readFlatCoordinatesFromNode) } }, O_.prototype.LINESTRINGMEMBER_PARSERS = { "http://www.opengis.net/gml": { LineString: xu(O_.prototype.readLineString) } }, O_.prototype.POLYGONMEMBER_PARSERS = { "http://www.opengis.net/gml": { Polygon: xu(O_.prototype.readPolygon) } }, O_.prototype.RING_PARSERS = { "http://www.opengis.net/gml": { LinearRing: vu(O_.prototype.readFlatLinearRing) } }; const q_ = { MultiLineString: "lineStringMember", MultiCurve: "curveMember", MultiPolygon: "polygonMember", MultiSurface: "surfaceMember" }; class H_ extends O_ { constructor(t) { super(t = t || {}), this.FEATURE_COLLECTION_PARSERS[F_].featureMember = xu(this.readFeaturesInternal), this.schemaLocation = t.schemaLocation ? t.schemaLocation : "http://www.opengis.net/gml http://schemas.opengis.net/gml/2.1.2/feature.xsd" } readFlatCoordinates(t, e) { const i = gu(t, !1).replace(/^\s*|\s*$/g, ""), n = e[0].srsName; let r = "enu"; if (n) { const t = Ui(n); t && (r = t.getAxisOrientation()) } const s = i.trim().split(/\s+/), o = []; for (let t = 0, e = s.length; t < e; t++) { const e = s[t].split(/,+/), i = parseFloat(e[0]), n = parseFloat(e[1]), a = 3 === e.length ? parseFloat(e[2]) : 0; "en" === r.substr(0, 2) ? o.push(i, n, a) : o.push(n, i, a) } return o } readBox(t, e) { const i = Lu([null], this.BOX_PARSERS_, t, e, this); return $t(i[1][0], i[1][1], i[1][3], i[1][4]) } innerBoundaryIsParser(t, e) { const i = Lu(void 0, this.RING_PARSERS, t, e, this); if (i) { e[e.length - 1].push(i) } } outerBoundaryIsParser(t, e) { const i = Lu(void 0, this.RING_PARSERS, t, e, this); if (i) { e[e.length - 1][0] = i } } GEOMETRY_NODE_FACTORY_(t, e, i) { const n = e[e.length - 1], r = n.multiSurface, s = n.surface, o = n.multiCurve; return Array.isArray(t) ? i = "Envelope" : "MultiPolygon" === (i = t.getType()) && !0 === r ? i = "MultiSurface" : "Polygon" === i && !0 === s ? i = "Surface" : "MultiLineString" === i && !0 === o && (i = "MultiCurve"), du("http://www.opengis.net/gml", i) } writeFeatureElement(t, e, i) { const n = e.getId(); n && t.setAttribute("fid", n); const r = i[i.length - 1], s = r.featureNS, o = e.getGeometryName(); r.serializers || (r.serializers = {}, r.serializers[s] = {}); const a = [], l = []; if (e.hasProperties()) { const t = e.getProperties(); for (const e in t) { const i = t[e]; null !== i && (a.push(e), l.push(i), e == o || "function" == typeof i.getSimplifiedGeometry ? e in r.serializers[s] || (r.serializers[s][e] = Eu(this.writeGeometryElement, this)) : e in r.serializers[s] || (r.serializers[s][e] = Eu(K_))) } } const h = Object.assign({}, r); h.node = t, Fu(h, r.serializers, Cu(void 0, s), l, i, a) } writeCurveOrLineString(t, e, i) { const n = i[i.length - 1].srsName; if ("LineStringSegment" !== t.nodeName && n && t.setAttribute("srsName", n), "LineString" === t.nodeName || "LineStringSegment" === t.nodeName) { const n = this.createCoordinatesNode_(t.namespaceURI); t.appendChild(n), this.writeCoordinates_(n, e, i) } else if ("Curve" === t.nodeName) { const n = du(t.namespaceURI, "segments"); t.appendChild(n), this.writeCurveSegments_(n, e, i) } } writeLineStringOrCurveMember(t, e, i) { const n = this.GEOMETRY_NODE_FACTORY_(e, i); n && (t.appendChild(n), this.writeCurveOrLineString(n, e, i)) } writeMultiCurveOrLineString(t, e, i) { const n = i[i.length - 1], r = n.hasZ, s = n.srsName, o = n.curve; s && t.setAttribute("srsName", s); const a = e.getLineStrings(); Fu({ node: t, hasZ: r, srsName: s, curve: o }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, a, i, void 0, this) } writeGeometryElement(t, e, i) { const n = i[i.length - 1], r = Object.assign({}, n); let s; r.node = t, s = Array.isArray(e) ? tm(e, n) : Qp(e, !0, n), Fu(r, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [s], i, void 0, this) } createCoordinatesNode_(t) { const e = du(t, "coordinates"); return e.setAttribute("decimal", "."), e.setAttribute("cs", ","), e.setAttribute("ts", " "), e } writeCoordinates_(t, e, i) { const n = i[i.length - 1], r = n.hasZ, s = n.srsName, o = e.getCoordinates(), a = o.length, l = new Array(a); for (let t = 0; t < a; ++t) { const e = o[t]; l[t] = this.getCoords_(e, s, r) } K_(t, l.join(" ")) } writeCurveSegments_(t, e, i) { const n = du(t.namespaceURI, "LineStringSegment"); t.appendChild(n), this.writeCurveOrLineString(n, e, i) } writeSurfaceOrPolygon(t, e, i) { const n = i[i.length - 1], r = n.hasZ, s = n.srsName; if ("PolygonPatch" !== t.nodeName && s && t.setAttribute("srsName", s), "Polygon" === t.nodeName || "PolygonPatch" === t.nodeName) { const n = e.getLinearRings(); Fu({ node: t, hasZ: r, srsName: s }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, n, i, void 0, this) } else if ("Surface" === t.nodeName) { const n = du(t.namespaceURI, "patches"); t.appendChild(n), this.writeSurfacePatches_(n, e, i) } } RING_NODE_FACTORY_(t, e, i) { const n = e[e.length - 1], r = n.node, s = n.exteriorWritten; return void 0 === s && (n.exteriorWritten = !0), du(r.namespaceURI, void 0 !== s ? "innerBoundaryIs" : "outerBoundaryIs") } writeSurfacePatches_(t, e, i) { const n = du(t.namespaceURI, "PolygonPatch"); t.appendChild(n), this.writeSurfaceOrPolygon(n, e, i) } writeRing(t, e, i) { const n = du(t.namespaceURI, "LinearRing"); t.appendChild(n), this.writeLinearRing(n, e, i) } getCoords_(t, e, i) { let n = "enu"; e && (n = Ui(e).getAxisOrientation()); let r = "en" === n.substr(0, 2) ? t[0] + "," + t[1] : t[1] + "," + t[0]; if (i) { r += "," + (t[2] || 0) } return r } writePoint(t, e, i) { const n = i[i.length - 1], r = n.hasZ, s = n.srsName; s && t.setAttribute("srsName", s); const o = this.createCoordinatesNode_(t.namespaceURI); t.appendChild(o); const a = e.getCoordinates(); K_(o, this.getCoords_(a, s, r)) } writeMultiPoint(t, e, i) { const n = i[i.length - 1], r = n.hasZ, s = n.srsName; s && t.setAttribute("srsName", s); const o = e.getPoints(); Fu({ node: t, hasZ: r, srsName: s }, this.POINTMEMBER_SERIALIZERS, Cu("pointMember"), o, i, void 0, this) } writePointMember(t, e, i) { const n = du(t.namespaceURI, "Point"); t.appendChild(n), this.writePoint(n, e, i) } writeLinearRing(t, e, i) { const n = i[i.length - 1].srsName; n && t.setAttribute("srsName", n); const r = this.createCoordinatesNode_(t.namespaceURI); t.appendChild(r), this.writeCoordinates_(r, e, i) } writeMultiSurfaceOrPolygon(t, e, i) { const n = i[i.length - 1], r = n.hasZ, s = n.srsName, o = n.surface; s && t.setAttribute("srsName", s); const a = e.getPolygons(); Fu({ node: t, hasZ: r, srsName: s, surface: o }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, a, i, void 0, this) } writeSurfaceOrPolygonMember(t, e, i) { const n = this.GEOMETRY_NODE_FACTORY_(e, i); n && (t.appendChild(n), this.writeSurfaceOrPolygon(n, e, i)) } writeEnvelope(t, e, i) { const n = i[i.length - 1].srsName; n && t.setAttribute("srsName", n); const r = [e[0] + " " + e[1], e[2] + " " + e[3]]; Fu({ node: t }, this.ENVELOPE_SERIALIZERS, bu, r, i, ["lowerCorner", "upperCorner"], this) } MULTIGEOMETRY_MEMBER_NODE_FACTORY_(t, e, i) { const n = e[e.length - 1].node; return du("http://www.opengis.net/gml", q_[n.nodeName]) } } H_.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = { "http://www.opengis.net/gml": { coordinates: vu(H_.prototype.readFlatCoordinates) } }, H_.prototype.FLAT_LINEAR_RINGS_PARSERS = { "http://www.opengis.net/gml": { innerBoundaryIs: H_.prototype.innerBoundaryIsParser, outerBoundaryIs: H_.prototype.outerBoundaryIsParser } }, H_.prototype.BOX_PARSERS_ = { "http://www.opengis.net/gml": { coordinates: xu(H_.prototype.readFlatCoordinates) } }, H_.prototype.GEOMETRY_PARSERS = { "http://www.opengis.net/gml": { Point: vu(O_.prototype.readPoint), MultiPoint: vu(O_.prototype.readMultiPoint), LineString: vu(O_.prototype.readLineString), MultiLineString: vu(O_.prototype.readMultiLineString), LinearRing: vu(O_.prototype.readLinearRing), Polygon: vu(O_.prototype.readPolygon), MultiPolygon: vu(O_.prototype.readMultiPolygon), Box: vu(H_.prototype.readBox) } }, H_.prototype.GEOMETRY_SERIALIZERS = { "http://www.opengis.net/gml": { Curve: Eu(H_.prototype.writeCurveOrLineString), MultiCurve: Eu(H_.prototype.writeMultiCurveOrLineString), Point: Eu(H_.prototype.writePoint), MultiPoint: Eu(H_.prototype.writeMultiPoint), LineString: Eu(H_.prototype.writeCurveOrLineString), MultiLineString: Eu(H_.prototype.writeMultiCurveOrLineString), LinearRing: Eu(H_.prototype.writeLinearRing), Polygon: Eu(H_.prototype.writeSurfaceOrPolygon), MultiPolygon: Eu(H_.prototype.writeMultiSurfaceOrPolygon), Surface: Eu(H_.prototype.writeSurfaceOrPolygon), MultiSurface: Eu(H_.prototype.writeMultiSurfaceOrPolygon), Envelope: Eu(H_.prototype.writeEnvelope) } }, H_.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { lineStringMember: Eu(H_.prototype.writeLineStringOrCurveMember), curveMember: Eu(H_.prototype.writeLineStringOrCurveMember) } }, H_.prototype.RING_SERIALIZERS = { "http://www.opengis.net/gml": { outerBoundaryIs: Eu(H_.prototype.writeRing), innerBoundaryIs: Eu(H_.prototype.writeRing) } }, H_.prototype.POINTMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { pointMember: Eu(H_.prototype.writePointMember) } }, H_.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { surfaceMember: Eu(H_.prototype.writeSurfaceOrPolygonMember), polygonMember: Eu(H_.prototype.writeSurfaceOrPolygonMember) } }, H_.prototype.ENVELOPE_SERIALIZERS = { "http://www.opengis.net/gml": { lowerCorner: Eu(K_), upperCorner: Eu(K_) } }; const $_ = { MultiLineString: "lineStringMember", MultiCurve: "curveMember", MultiPolygon: "polygonMember", MultiSurface: "surfaceMember" }; class J_ extends O_ { constructor(t) { super(t = t || {}), this.surface_ = void 0 !== t.surface && t.surface, this.curve_ = void 0 !== t.curve && t.curve, this.multiCurve_ = void 0 === t.multiCurve || t.multiCurve, this.multiSurface_ = void 0 === t.multiSurface || t.multiSurface, this.schemaLocation = t.schemaLocation ? t.schemaLocation : "http://www.opengis.net/gml http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd", this.hasZ = void 0 !== t.hasZ && t.hasZ } readMultiCurve(t, e) { const i = Lu([], this.MULTICURVE_PARSERS, t, e, this); if (i) { return new Np(i) } } readFlatCurveRing(t, e) { const i = Lu([], this.MULTICURVE_PARSERS, t, e, this), n = []; for (let t = 0, e = i.length; t < e; ++t)c(n, i[t].getFlatCoordinates()); return n } readMultiSurface(t, e) { const i = Lu([], this.MULTISURFACE_PARSERS, t, e, this); if (i) return new Gp(i) } curveMemberParser(t, e) { Iu(this.CURVEMEMBER_PARSERS, t, e, this) } surfaceMemberParser(t, e) { Iu(this.SURFACEMEMBER_PARSERS, t, e, this) } readPatch(t, e) { return Lu([null], this.PATCHES_PARSERS, t, e, this) } readSegment(t, e) { return Lu([], this.SEGMENTS_PARSERS, t, e, this) } readPolygonPatch(t, e) { return Lu([null], this.FLAT_LINEAR_RINGS_PARSERS, t, e, this) } readLineStringSegment(t, e) { return Lu([null], this.GEOMETRY_FLAT_COORDINATES_PARSERS, t, e, this) } interiorParser(t, e) { const i = Lu(void 0, this.RING_PARSERS, t, e, this); if (i) { e[e.length - 1].push(i) } } exteriorParser(t, e) { const i = Lu(void 0, this.RING_PARSERS, t, e, this); if (i) { e[e.length - 1][0] = i } } readSurface(t, e) { const i = Lu([null], this.SURFACE_PARSERS, t, e, this); if (i && i[0]) { const t = i[0], e = [t.length]; let n, r; for (n = 1, r = i.length; n < r; ++n)c(t, i[n]), e.push(t.length); return new ur(t, "XYZ", e) } } readCurve(t, e) { const i = Lu([null], this.CURVE_PARSERS, t, e, this); if (i) { return new Op(i, "XYZ") } } readEnvelope(t, e) { const i = Lu([null], this.ENVELOPE_PARSERS, t, e, this); return $t(i[1][0], i[1][1], i[2][0], i[2][1]) } readFlatPos(t, e) { let i = gu(t, !1); const n = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/, r = []; let s; for (; s = n.exec(i);)r.push(parseFloat(s[1])), i = i.substr(s[0].length); if ("" !== i) return; const o = e[0].srsName; let a = "enu"; if (o) { a = Ui(o).getAxisOrientation() } if ("neu" === a) { let t, e; for (t = 0, e = r.length; t < e; t += 3) { const e = r[t], i = r[t + 1]; r[t] = i, r[t + 1] = e } } const l = r.length; return 2 == l && r.push(0), 0 !== l ? r : void 0 } readFlatPosList(t, e) { const i = gu(t, !1).replace(/^\s*|\s*$/g, ""), n = e[0], r = n.srsName, s = n.srsDimension; let o = "enu"; if (r) { o = Ui(r).getAxisOrientation() } const a = i.split(/\s+/); let l, h, c, u = 2; t.getAttribute("srsDimension") ? u = U_(t.getAttribute("srsDimension")) : t.getAttribute("dimension") ? u = U_(t.getAttribute("dimension")) : t.parentNode.getAttribute("srsDimension") ? u = U_(t.parentNode.getAttribute("srsDimension")) : s && (u = U_(s)); const d = []; for (let t = 0, e = a.length; t < e; t += u)l = parseFloat(a[t]), h = parseFloat(a[t + 1]), c = 3 === u ? parseFloat(a[t + 2]) : 0, "en" === o.substr(0, 2) ? d.push(l, h, c) : d.push(h, l, c); return d } writePos_(t, e, i) { const n = i[i.length - 1], r = n.hasZ, s = r ? "3" : "2"; t.setAttribute("srsDimension", s); const o = n.srsName; let a = "enu"; o && (a = Ui(o).getAxisOrientation()); const l = e.getCoordinates(); let h; if (h = "en" === a.substr(0, 2) ? l[0] + " " + l[1] : l[1] + " " + l[0], r) { h += " " + (l[2] || 0) } K_(t, h) } getCoords_(t, e, i) { let n = "enu"; e && (n = Ui(e).getAxisOrientation()); let r = "en" === n.substr(0, 2) ? t[0] + " " + t[1] : t[1] + " " + t[0]; if (i) { r += " " + (t[2] || 0) } return r } writePosList_(t, e, i) { const n = i[i.length - 1], r = n.hasZ, s = r ? "3" : "2"; t.setAttribute("srsDimension", s); const o = n.srsName, a = e.getCoordinates(), l = a.length, h = new Array(l); let c; for (let t = 0; t < l; ++t)c = a[t], h[t] = this.getCoords_(c, o, r); K_(t, h.join(" ")) } writePoint(t, e, i) { const n = i[i.length - 1].srsName; n && t.setAttribute("srsName", n); const r = du(t.namespaceURI, "pos"); t.appendChild(r), this.writePos_(r, e, i) } writeEnvelope(t, e, i) { const n = i[i.length - 1].srsName; n && t.setAttribute("srsName", n); const r = [e[0] + " " + e[1], e[2] + " " + e[3]]; Fu({ node: t }, this.ENVELOPE_SERIALIZERS, bu, r, i, ["lowerCorner", "upperCorner"], this) } writeLinearRing(t, e, i) { const n = i[i.length - 1].srsName; n && t.setAttribute("srsName", n); const r = du(t.namespaceURI, "posList"); t.appendChild(r), this.writePosList_(r, e, i) } RING_NODE_FACTORY_(t, e, i) { const n = e[e.length - 1], r = n.node, s = n.exteriorWritten; return void 0 === s && (n.exteriorWritten = !0), du(r.namespaceURI, void 0 !== s ? "interior" : "exterior") } writeSurfaceOrPolygon(t, e, i) { const n = i[i.length - 1], r = n.hasZ, s = n.srsName; if ("PolygonPatch" !== t.nodeName && s && t.setAttribute("srsName", s), "Polygon" === t.nodeName || "PolygonPatch" === t.nodeName) { const n = e.getLinearRings(); Fu({ node: t, hasZ: r, srsName: s }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, n, i, void 0, this) } else if ("Surface" === t.nodeName) { const n = du(t.namespaceURI, "patches"); t.appendChild(n), this.writeSurfacePatches_(n, e, i) } } writeCurveOrLineString(t, e, i) { const n = i[i.length - 1].srsName; if ("LineStringSegment" !== t.nodeName && n && t.setAttribute("srsName", n), "LineString" === t.nodeName || "LineStringSegment" === t.nodeName) { const n = du(t.namespaceURI, "posList"); t.appendChild(n), this.writePosList_(n, e, i) } else if ("Curve" === t.nodeName) { const n = du(t.namespaceURI, "segments"); t.appendChild(n), this.writeCurveSegments_(n, e, i) } } writeMultiSurfaceOrPolygon(t, e, i) { const n = i[i.length - 1], r = n.hasZ, s = n.srsName, o = n.surface; s && t.setAttribute("srsName", s); const a = e.getPolygons(); Fu({ node: t, hasZ: r, srsName: s, surface: o }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, a, i, void 0, this) } writeMultiPoint(t, e, i) { const n = i[i.length - 1], r = n.srsName, s = n.hasZ; r && t.setAttribute("srsName", r); const o = e.getPoints(); Fu({ node: t, hasZ: s, srsName: r }, this.POINTMEMBER_SERIALIZERS, Cu("pointMember"), o, i, void 0, this) } writeMultiCurveOrLineString(t, e, i) { const n = i[i.length - 1], r = n.hasZ, s = n.srsName, o = n.curve; s && t.setAttribute("srsName", s); const a = e.getLineStrings(); Fu({ node: t, hasZ: r, srsName: s, curve: o }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, a, i, void 0, this) } writeRing(t, e, i) { const n = du(t.namespaceURI, "LinearRing"); t.appendChild(n), this.writeLinearRing(n, e, i) } writeSurfaceOrPolygonMember(t, e, i) { const n = this.GEOMETRY_NODE_FACTORY_(e, i); n && (t.appendChild(n), this.writeSurfaceOrPolygon(n, e, i)) } writePointMember(t, e, i) { const n = du(t.namespaceURI, "Point"); t.appendChild(n), this.writePoint(n, e, i) } writeLineStringOrCurveMember(t, e, i) { const n = this.GEOMETRY_NODE_FACTORY_(e, i); n && (t.appendChild(n), this.writeCurveOrLineString(n, e, i)) } writeSurfacePatches_(t, e, i) { const n = du(t.namespaceURI, "PolygonPatch"); t.appendChild(n), this.writeSurfaceOrPolygon(n, e, i) } writeCurveSegments_(t, e, i) { const n = du(t.namespaceURI, "LineStringSegment"); t.appendChild(n), this.writeCurveOrLineString(n, e, i) } writeGeometryElement(t, e, i) { const n = i[i.length - 1], r = Object.assign({}, n); let s; r.node = t, s = Array.isArray(e) ? tm(e, n) : Qp(e, !0, n), Fu(r, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [s], i, void 0, this) } writeFeatureElement(t, e, i) { const n = e.getId(); n && t.setAttribute("fid", n); const r = i[i.length - 1], s = r.featureNS, o = e.getGeometryName(); r.serializers || (r.serializers = {}, r.serializers[s] = {}); const a = [], l = []; if (e.hasProperties()) { const t = e.getProperties(); for (const e in t) { const i = t[e]; null !== i && (a.push(e), l.push(i), e == o || "function" == typeof i.getSimplifiedGeometry ? e in r.serializers[s] || (r.serializers[s][e] = Eu(this.writeGeometryElement, this)) : e in r.serializers[s] || (r.serializers[s][e] = Eu(K_))) } } const h = Object.assign({}, r); h.node = t, Fu(h, r.serializers, Cu(void 0, s), l, i, a) } writeFeatureMembers_(t, e, i) { const n = i[i.length - 1], r = n.featureType, s = n.featureNS, o = {}; o[s] = {}, o[s][r] = Eu(this.writeFeatureElement, this); const a = Object.assign({}, n); a.node = t, Fu(a, o, Cu(r, s), e, i) } MULTIGEOMETRY_MEMBER_NODE_FACTORY_(t, e, i) { const n = e[e.length - 1].node; return du(this.namespace, $_[n.nodeName]) } GEOMETRY_NODE_FACTORY_(t, e, i) { const n = e[e.length - 1], r = n.multiSurface, s = n.surface, o = n.curve, a = n.multiCurve; return Array.isArray(t) ? i = "Envelope" : "MultiPolygon" === (i = t.getType()) && !0 === r ? i = "MultiSurface" : "Polygon" === i && !0 === s ? i = "Surface" : "LineString" === i && !0 === o ? i = "Curve" : "MultiLineString" === i && !0 === a && (i = "MultiCurve"), du(this.namespace, i) } writeGeometryNode(t, e) { e = this.adaptOptions(e); const i = du(this.namespace, "geom"), n = { node: i, hasZ: this.hasZ, srsName: this.srsName, curve: this.curve_, surface: this.surface_, multiSurface: this.multiSurface_, multiCurve: this.multiCurve_ }; return e && Object.assign(n, e), this.writeGeometryElement(i, t, [n]), i } writeFeaturesNode(t, e) { e = this.adaptOptions(e); const i = du(this.namespace, "featureMembers"); i.setAttributeNS(uu, "xsi:schemaLocation", this.schemaLocation); const n = { srsName: this.srsName, hasZ: this.hasZ, curve: this.curve_, surface: this.surface_, multiSurface: this.multiSurface_, multiCurve: this.multiCurve_, featureNS: this.featureNS, featureType: this.featureType }; return e && Object.assign(n, e), this.writeFeatureMembers_(i, t, [n]), i } } J_.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = { "http://www.opengis.net/gml": { pos: vu(J_.prototype.readFlatPos), posList: vu(J_.prototype.readFlatPosList), coordinates: vu(H_.prototype.readFlatCoordinates) } }, J_.prototype.FLAT_LINEAR_RINGS_PARSERS = { "http://www.opengis.net/gml": { interior: J_.prototype.interiorParser, exterior: J_.prototype.exteriorParser } }, J_.prototype.GEOMETRY_PARSERS = { "http://www.opengis.net/gml": { Point: vu(O_.prototype.readPoint), MultiPoint: vu(O_.prototype.readMultiPoint), LineString: vu(O_.prototype.readLineString), MultiLineString: vu(O_.prototype.readMultiLineString), LinearRing: vu(O_.prototype.readLinearRing), Polygon: vu(O_.prototype.readPolygon), MultiPolygon: vu(O_.prototype.readMultiPolygon), Surface: vu(J_.prototype.readSurface), MultiSurface: vu(J_.prototype.readMultiSurface), Curve: vu(J_.prototype.readCurve), MultiCurve: vu(J_.prototype.readMultiCurve), Envelope: vu(J_.prototype.readEnvelope) } }, J_.prototype.MULTICURVE_PARSERS = { "http://www.opengis.net/gml": { curveMember: xu(J_.prototype.curveMemberParser), curveMembers: xu(J_.prototype.curveMemberParser) } }, J_.prototype.MULTISURFACE_PARSERS = { "http://www.opengis.net/gml": { surfaceMember: xu(J_.prototype.surfaceMemberParser), surfaceMembers: xu(J_.prototype.surfaceMemberParser) } }, J_.prototype.CURVEMEMBER_PARSERS = { "http://www.opengis.net/gml": { LineString: xu(O_.prototype.readLineString), Curve: xu(J_.prototype.readCurve) } }, J_.prototype.SURFACEMEMBER_PARSERS = { "http://www.opengis.net/gml": { Polygon: xu(O_.prototype.readPolygon), Surface: xu(J_.prototype.readSurface) } }, J_.prototype.SURFACE_PARSERS = { "http://www.opengis.net/gml": { patches: vu(J_.prototype.readPatch) } }, J_.prototype.CURVE_PARSERS = { "http://www.opengis.net/gml": { segments: vu(J_.prototype.readSegment) } }, J_.prototype.ENVELOPE_PARSERS = { "http://www.opengis.net/gml": { lowerCorner: xu(J_.prototype.readFlatPosList), upperCorner: xu(J_.prototype.readFlatPosList) } }, J_.prototype.PATCHES_PARSERS = { "http://www.opengis.net/gml": { PolygonPatch: vu(J_.prototype.readPolygonPatch) } }, J_.prototype.SEGMENTS_PARSERS = { "http://www.opengis.net/gml": { LineStringSegment: yu(J_.prototype.readLineStringSegment) } }, O_.prototype.RING_PARSERS = { "http://www.opengis.net/gml": { LinearRing: vu(O_.prototype.readFlatLinearRing), Ring: vu(J_.prototype.readFlatCurveRing) } }, J_.prototype.writeFeatures, J_.prototype.RING_SERIALIZERS = { "http://www.opengis.net/gml": { exterior: Eu(J_.prototype.writeRing), interior: Eu(J_.prototype.writeRing) } }, J_.prototype.ENVELOPE_SERIALIZERS = { "http://www.opengis.net/gml": { lowerCorner: Eu(K_), upperCorner: Eu(K_) } }, J_.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { surfaceMember: Eu(J_.prototype.writeSurfaceOrPolygonMember), polygonMember: Eu(J_.prototype.writeSurfaceOrPolygonMember) } }, J_.prototype.POINTMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { pointMember: Eu(J_.prototype.writePointMember) } }, J_.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { lineStringMember: Eu(J_.prototype.writeLineStringOrCurveMember), curveMember: Eu(J_.prototype.writeLineStringOrCurveMember) } }, J_.prototype.GEOMETRY_SERIALIZERS = { "http://www.opengis.net/gml": { Curve: Eu(J_.prototype.writeCurveOrLineString), MultiCurve: Eu(J_.prototype.writeMultiCurveOrLineString), Point: Eu(J_.prototype.writePoint), MultiPoint: Eu(J_.prototype.writeMultiPoint), LineString: Eu(J_.prototype.writeCurveOrLineString), MultiLineString: Eu(J_.prototype.writeMultiCurveOrLineString), LinearRing: Eu(J_.prototype.writeLinearRing), Polygon: Eu(J_.prototype.writeSurfaceOrPolygon), MultiPolygon: Eu(J_.prototype.writeMultiSurfaceOrPolygon), Surface: Eu(J_.prototype.writeSurfaceOrPolygon), MultiSurface: Eu(J_.prototype.writeMultiSurfaceOrPolygon), Envelope: Eu(J_.prototype.writeEnvelope) } }; const Q_ = J_; Q_.prototype.writeFeatures, Q_.prototype.writeFeaturesNode; class ty extends J_ { constructor(t) { super(t = t || {}), this.schemaLocation = t.schemaLocation ? t.schemaLocation : this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd" } } ty.prototype.namespace = "http://www.opengis.net/gml/3.2", ty.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = { "http://www.opengis.net/gml/3.2": { pos: vu(J_.prototype.readFlatPos), posList: vu(J_.prototype.readFlatPosList), coordinates: vu(H_.prototype.readFlatCoordinates) } }, ty.prototype.FLAT_LINEAR_RINGS_PARSERS = { "http://www.opengis.net/gml/3.2": { interior: J_.prototype.interiorParser, exterior: J_.prototype.exteriorParser } }, ty.prototype.GEOMETRY_PARSERS = { "http://www.opengis.net/gml/3.2": { Point: vu(O_.prototype.readPoint), MultiPoint: vu(O_.prototype.readMultiPoint), LineString: vu(O_.prototype.readLineString), MultiLineString: vu(O_.prototype.readMultiLineString), LinearRing: vu(O_.prototype.readLinearRing), Polygon: vu(O_.prototype.readPolygon), MultiPolygon: vu(O_.prototype.readMultiPolygon), Surface: vu(ty.prototype.readSurface), MultiSurface: vu(J_.prototype.readMultiSurface), Curve: vu(ty.prototype.readCurve), MultiCurve: vu(J_.prototype.readMultiCurve), Envelope: vu(ty.prototype.readEnvelope) } }, ty.prototype.MULTICURVE_PARSERS = { "http://www.opengis.net/gml/3.2": { curveMember: xu(J_.prototype.curveMemberParser), curveMembers: xu(J_.prototype.curveMemberParser) } }, ty.prototype.MULTISURFACE_PARSERS = { "http://www.opengis.net/gml/3.2": { surfaceMember: xu(J_.prototype.surfaceMemberParser), surfaceMembers: xu(J_.prototype.surfaceMemberParser) } }, ty.prototype.CURVEMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { LineString: xu(O_.prototype.readLineString), Curve: xu(J_.prototype.readCurve) } }, ty.prototype.SURFACEMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { Polygon: xu(O_.prototype.readPolygon), Surface: xu(J_.prototype.readSurface) } }, ty.prototype.SURFACE_PARSERS = { "http://www.opengis.net/gml/3.2": { patches: vu(J_.prototype.readPatch) } }, ty.prototype.CURVE_PARSERS = { "http://www.opengis.net/gml/3.2": { segments: vu(J_.prototype.readSegment) } }, ty.prototype.ENVELOPE_PARSERS = { "http://www.opengis.net/gml/3.2": { lowerCorner: xu(J_.prototype.readFlatPosList), upperCorner: xu(J_.prototype.readFlatPosList) } }, ty.prototype.PATCHES_PARSERS = { "http://www.opengis.net/gml/3.2": { PolygonPatch: vu(J_.prototype.readPolygonPatch) } }, ty.prototype.SEGMENTS_PARSERS = { "http://www.opengis.net/gml/3.2": { LineStringSegment: yu(J_.prototype.readLineStringSegment) } }, ty.prototype.MULTIPOINT_PARSERS = { "http://www.opengis.net/gml/3.2": { pointMember: xu(O_.prototype.pointMemberParser), pointMembers: xu(O_.prototype.pointMemberParser) } }, ty.prototype.MULTILINESTRING_PARSERS = { "http://www.opengis.net/gml/3.2": { lineStringMember: xu(O_.prototype.lineStringMemberParser), lineStringMembers: xu(O_.prototype.lineStringMemberParser) } }, ty.prototype.MULTIPOLYGON_PARSERS = { "http://www.opengis.net/gml/3.2": { polygonMember: xu(O_.prototype.polygonMemberParser), polygonMembers: xu(O_.prototype.polygonMemberParser) } }, ty.prototype.POINTMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { Point: xu(O_.prototype.readFlatCoordinatesFromNode) } }, ty.prototype.LINESTRINGMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { LineString: xu(O_.prototype.readLineString) } }, ty.prototype.POLYGONMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { Polygon: xu(O_.prototype.readPolygon) } }, ty.prototype.RING_PARSERS = { "http://www.opengis.net/gml/3.2": { LinearRing: vu(O_.prototype.readFlatLinearRing), Ring: vu(ty.prototype.readFlatCurveRing) } }, ty.prototype.RING_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { exterior: Eu(J_.prototype.writeRing), interior: Eu(J_.prototype.writeRing) } }, ty.prototype.ENVELOPE_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { lowerCorner: Eu(K_), upperCorner: Eu(K_) } }, ty.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { surfaceMember: Eu(J_.prototype.writeSurfaceOrPolygonMember), polygonMember: Eu(J_.prototype.writeSurfaceOrPolygonMember) } }, ty.prototype.POINTMEMBER_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { pointMember: Eu(J_.prototype.writePointMember) } }, ty.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { lineStringMember: Eu(J_.prototype.writeLineStringOrCurveMember), curveMember: Eu(J_.prototype.writeLineStringOrCurveMember) } }, ty.prototype.GEOMETRY_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { Curve: Eu(J_.prototype.writeCurveOrLineString), MultiCurve: Eu(J_.prototype.writeMultiCurveOrLineString), Point: Eu(ty.prototype.writePoint), MultiPoint: Eu(J_.prototype.writeMultiPoint), LineString: Eu(J_.prototype.writeCurveOrLineString), MultiLineString: Eu(J_.prototype.writeMultiCurveOrLineString), LinearRing: Eu(J_.prototype.writeLinearRing), Polygon: Eu(J_.prototype.writeSurfaceOrPolygon), MultiPolygon: Eu(J_.prototype.writeMultiSurfaceOrPolygon), Surface: Eu(J_.prototype.writeSurfaceOrPolygon), MultiSurface: Eu(J_.prototype.writeMultiSurfaceOrPolygon), Envelope: Eu(J_.prototype.writeEnvelope) } }; const ey = [null, "http://www.topografix.com/GPX/1/0", "http://www.topografix.com/GPX/1/1"], iy = { rte: Iy, trk: Ly, wpt: My }, ny = Pu(ey, { rte: xu(Iy), trk: xu(Ly), wpt: xu(My) }), ry = Pu(ey, { text: wu(z_, "linkText"), type: wu(z_, "linkType") }), sy = Pu(ey, { rte: Eu((function (t, e, i) { const n = i[0], r = e.getProperties(), s = { node: t }; s.properties = r; const o = e.getGeometry(); if ("LineString" == o.getType()) { const t = Qp(o, !0, n); s.geometryLayout = t.getLayout(), r.rtept = t.getCoordinates() } const a = i[i.length - 1].node, l = fy[a.namespaceURI], h = Ru(r, l); Fu(s, py, bu, h, i, l) })), trk: Eu((function (t, e, i) { const n = i[0], r = e.getProperties(), s = { node: t }; s.properties = r; const o = e.getGeometry(); if ("MultiLineString" == o.getType()) { const t = Qp(o, !0, n); r.trkseg = t.getLineStrings() } const a = i[i.length - 1].node, l = _y[a.namespaceURI], h = Ru(r, l); Fu(s, yy, bu, h, i, l) })), wpt: Eu((function (t, e, i) { const n = i[0], r = i[i.length - 1]; r.properties = e.getProperties(); const s = e.getGeometry(); if ("Point" == s.getType()) { const e = Qp(s, !0, n); r.geometryLayout = e.getLayout(), Ay(t, e.getCoordinates(), i) } })) }); const oy = Pu(ey, { name: wu(z_), cmt: wu(z_), desc: wu(z_), src: wu(z_), link: Ry, number: wu(B_), extensions: Py, type: wu(z_), rtept: function (t, e) { const i = Lu({}, ay, t, e); if (i) { const n = e[e.length - 1], r = n.flatCoordinates, s = n.layoutOptions; Cy(r, s, t, i) } } }), ay = Pu(ey, { ele: wu(G_), time: wu(k_) }), ly = Pu(ey, { name: wu(z_), cmt: wu(z_), desc: wu(z_), src: wu(z_), link: Ry, number: wu(B_), type: wu(z_), extensions: Py, trkseg: function (t, e) { const i = e[e.length - 1]; Iu(hy, t, e); const n = i.flatCoordinates; i.ends.push(n.length) } }), hy = Pu(ey, { trkpt: function (t, e) { const i = Lu({}, cy, t, e); if (i) { const n = e[e.length - 1], r = n.flatCoordinates, s = n.layoutOptions; Cy(r, s, t, i) } } }), cy = Pu(ey, { ele: wu(G_), time: wu(k_) }), uy = Pu(ey, { ele: wu(G_), time: wu(k_), magvar: wu(G_), geoidheight: wu(G_), name: wu(z_), cmt: wu(z_), desc: wu(z_), src: wu(z_), link: Ry, sym: wu(z_), type: wu(z_), fix: wu(z_), sat: wu(B_), hdop: wu(G_), vdop: wu(G_), pdop: wu(G_), ageofdgpsdata: wu(G_), dgpsid: wu(B_), extensions: Py }), dy = ["text", "type"], gy = Pu(ey, { text: Eu(K_), type: Eu(K_) }), fy = Pu(ey, ["name", "cmt", "desc", "src", "link", "number", "type", "rtept"]), py = Pu(ey, { name: Eu(K_), cmt: Eu(K_), desc: Eu(K_), src: Eu(K_), link: Eu(Fy), number: Eu(Y_), type: Eu(K_), rtept: Tu(Eu(Ay)) }), my = Pu(ey, ["ele", "time"]), _y = Pu(ey, ["name", "cmt", "desc", "src", "link", "number", "type", "trkseg"]), yy = Pu(ey, { name: Eu(K_), cmt: Eu(K_), desc: Eu(K_), src: Eu(K_), link: Eu(Fy), number: Eu(Y_), type: Eu(K_), trkseg: Tu(Eu((function (t, e, i) { const n = { node: t }; n.geometryLayout = e.getLayout(), n.properties = {}, Fu(n, vy, xy, e.getCoordinates(), i) }))) }), xy = Cu("trkpt"), vy = Pu(ey, { trkpt: Eu(Ay) }), Sy = Pu(ey, ["ele", "time", "magvar", "geoidheight", "name", "cmt", "desc", "src", "link", "sym", "type", "fix", "sat", "hdop", "vdop", "pdop", "ageofdgpsdata", "dgpsid"]), wy = Pu(ey, { ele: Eu(Z_), time: Eu(W_), magvar: Eu(Z_), geoidheight: Eu(Z_), name: Eu(K_), cmt: Eu(K_), desc: Eu(K_), src: Eu(K_), link: Eu(Fy), sym: Eu(K_), type: Eu(K_), fix: Eu(K_), sat: Eu(Y_), hdop: Eu(Z_), vdop: Eu(Z_), pdop: Eu(Z_), ageofdgpsdata: Eu(Z_), dgpsid: Eu(Y_) }), Ey = { Point: "wpt", LineString: "rte", MultiLineString: "trk" }; function Ty(t, e, i) { const n = t.getGeometry(); if (n) { const t = Ey[n.getType()]; if (t) { return du(e[e.length - 1].node.namespaceURI, t) } } } function Cy(t, e, i, n) { return t.push(parseFloat(i.getAttribute("lon")), parseFloat(i.getAttribute("lat"))), "ele" in n ? (t.push(n.ele), delete n.ele, e.hasZ = !0) : t.push(0), "time" in n ? (t.push(n.time), delete n.time, e.hasM = !0) : t.push(0), t } function by(t, e, i) { let n = "XY", r = 2; if (t.hasZ && t.hasM ? (n = "XYZM", r = 4) : t.hasZ ? (n = "XYZ", r = 3) : t.hasM && (n = "XYM", r = 3), 4 !== r) { for (let i = 0, n = e.length / 4; i < n; i++)e[i * r] = e[4 * i], e[i * r + 1] = e[4 * i + 1], t.hasZ && (e[i * r + 2] = e[4 * i + 2]), t.hasM && (e[i * r + 2] = e[4 * i + 3]); if (e.length = e.length / 4 * r, i) for (let t = 0, e = i.length; t < e; t++)i[t] = i[t] / 4 * r } return n } function Ry(t, e) { const i = e[e.length - 1], n = t.getAttribute("href"); null !== n && (i.link = n), Iu(ry, t, e) } function Py(t, e) { e[e.length - 1].extensionsNode_ = t } function Iy(t, e) { const i = e[0], n = Lu({ flatCoordinates: [], layoutOptions: {} }, oy, t, e); if (!n) return; const r = n.flatCoordinates; delete n.flatCoordinates; const s = n.layoutOptions; delete n.layoutOptions; const o = by(s, r), a = new Op(r, o); Qp(a, !1, i); const l = new lt(a); return l.setProperties(n, !0), l } function Ly(t, e) { const i = e[0], n = Lu({ flatCoordinates: [], ends: [], layoutOptions: {} }, ly, t, e); if (!n) return; const r = n.flatCoordinates; delete n.flatCoordinates; const s = n.ends; delete n.ends; const o = n.layoutOptions; delete n.layoutOptions; const a = by(o, r, s), l = new Np(r, a, s); Qp(l, !1, i); const h = new lt(l); return h.setProperties(n, !0), h } function My(t, e) { const i = e[0], n = Lu({}, uy, t, e); if (!n) return; const r = {}, s = Cy([], r, t, n), o = by(r, s), a = new Wn(s, o); Qp(a, !1, i); const l = new lt(a); return l.setProperties(n, !0), l } function Fy(t, e, i) { t.setAttribute("href", e); const n = i[i.length - 1].properties, r = [n.linkText, n.linkType]; Fu({ node: t }, gy, bu, r, i, dy) } function Ay(t, e, i) { const n = i[i.length - 1], r = n.node.namespaceURI, s = n.properties; t.setAttributeNS(null, "lat", String(e[1])), t.setAttributeNS(null, "lon", String(e[0])); switch (n.geometryLayout) { case "XYZM": 0 !== e[3] && (s.time = e[3]); case "XYZ": 0 !== e[2] && (s.ele = e[2]); break; case "XYM": 0 !== e[2] && (s.time = e[2]) }const o = "rtept" == t.nodeName ? my[r] : Sy[r], a = Ru(s, o); Fu({ node: t, properties: s }, wy, bu, a, i, o) } function Oy(t, e) { if (!t) return null; let i; switch (t.type) { case "Point": i = function (t) { return new Wn(t.coordinates) }(t); break; case "LineString": i = function (t) { return new Op(t.coordinates) }(t); break; case "Polygon": i = function (t) { return new ur(t.coordinates) }(t); break; case "MultiPoint": i = function (t) { return new Dp(t.coordinates) }(t); break; case "MultiLineString": i = function (t) { return new Np(t.coordinates) }(t); break; case "MultiPolygon": i = function (t) { return new Gp(t.coordinates) }(t); break; case "GeometryCollection": i = function (t, e) { const i = t.geometries.map((function (t) { return Oy(t, e) })); return new Ip(i) }(t); break; default: throw new Error("Unsupported GeoJSON type: " + t.type) }return Qp(i, !1, e) } function Ny(t, e) { const i = (t = Qp(t, !0, e)).getType(); let n; switch (i) { case "Point": n = function (t, e) { return { type: "Point", coordinates: t.getCoordinates() } }(t); break; case "LineString": n = function (t, e) { return { type: "LineString", coordinates: t.getCoordinates() } }(t); break; case "Polygon": n = function (t, e) { let i; e && (i = e.rightHanded); return { type: "Polygon", coordinates: t.getCoordinates(i) } }(t, e); break; case "MultiPoint": n = function (t, e) { return { type: "MultiPoint", coordinates: t.getCoordinates() } }(t); break; case "MultiLineString": n = function (t, e) { return { type: "MultiLineString", coordinates: t.getCoordinates() } }(t); break; case "MultiPolygon": n = function (t, e) { let i; e && (i = e.rightHanded); return { type: "MultiPolygon", coordinates: t.getCoordinates(i) } }(t, e); break; case "GeometryCollection": n = function (t, e) { delete (e = Object.assign({}, e)).featureProjection; return { type: "GeometryCollection", geometries: t.getGeometriesArray().map((function (t) { return Ny(t, e) })) } }(t, e); break; case "Circle": n = { type: "GeometryCollection", geometries: [] }; break; default: throw new Error("Unsupported geometry type: " + i) }return n } class Dy extends Jp { constructor() { super() } getType() { return "text" } readFeature(t, e) { return this.readFeatureFromText(ky(t), this.adaptOptions(e)) } readFeatureFromText(t, e) { return B() } readFeatures(t, e) { return this.readFeaturesFromText(ky(t), this.adaptOptions(e)) } readFeaturesFromText(t, e) { return B() } readGeometry(t, e) { return this.readGeometryFromText(ky(t), this.adaptOptions(e)) } readGeometryFromText(t, e) { return B() } readProjection(t) { return this.readProjectionFromText(ky(t)) } readProjectionFromText(t) { return this.dataProjection } writeFeature(t, e) { return this.writeFeatureText(t, this.adaptOptions(e)) } writeFeatureText(t, e) { return B() } writeFeatures(t, e) { return this.writeFeaturesText(t, this.adaptOptions(e)) } writeFeaturesText(t, e) { return B() } writeGeometry(t, e) { return this.writeGeometryText(t, this.adaptOptions(e)) } writeGeometryText(t, e) { return B() } } function ky(t) { return "string" == typeof t ? t : "" } const Gy = /^B(\d{2})(\d{2})(\d{2})(\d{2})(\d{5})([NS])(\d{3})(\d{5})([EW])([AV])(\d{5})(\d{5})/, jy = /^H.([A-Z]{3}).*?:(.*)/, By = /^HFDTE(\d{2})(\d{2})(\d{2})/, Uy = /\r\n|\r|\n/; const zy = ["http://www.google.com/kml/ext/2.2"], Xy = [null, "http://earth.google.com/kml/2.0", "http://earth.google.com/kml/2.1", "http://earth.google.com/kml/2.2", "http://www.opengis.net/kml/2.2"], Vy = { fraction: "fraction", pixels: "pixels", insetPixels: "pixels" }, Wy = Pu(Xy, { ExtendedData: Yx, Region: Kx, MultiGeometry: wu(Gx, "geometry"), LineString: wu(Nx, "geometry"), LinearRing: wu(Dx, "geometry"), Point: wu(jx, "geometry"), Polygon: wu(Ux, "geometry"), Style: wu(Xx), StyleMap: function (t, e) { const i = Sx.call(this, t, e); if (!i) return; const n = e[e.length - 1]; Array.isArray(i) ? n.Style = i : "string" == typeof i ? n.styleUrl = i : at(!1, 38) }, address: wu(z_), description: wu(z_), name: wu(z_), open: wu(N_), phoneNumber: wu(z_), styleUrl: wu(yx), visibility: wu(N_) }, Pu(zy, { MultiTrack: wu((function (t, e) { const i = Lu([], Px, t, e); if (!i) return; return new Np(i) }), "geometry"), Track: wu(Lx, "geometry") })), Zy = Pu(Xy, { ExtendedData: Yx, Region: Kx, Link: function (t, e) { Iu(Yy, t, e) }, address: wu(z_), description: wu(z_), name: wu(z_), open: wu(N_), phoneNumber: wu(z_), visibility: wu(N_) }), Yy = Pu(Xy, { href: wu(_x) }), Ky = Pu(Xy, { LatLonAltBox: function (t, e) { const i = Lu({}, $x, t, e); if (!i) return; const n = e[e.length - 1], r = [parseFloat(i.west), parseFloat(i.south), parseFloat(i.east), parseFloat(i.north)]; n.extent = r, n.altitudeMode = i.altitudeMode, n.minAltitude = parseFloat(i.minAltitude), n.maxAltitude = parseFloat(i.maxAltitude) }, Lod: function (t, e) { const i = Lu({}, Jx, t, e); if (!i) return; const n = e[e.length - 1]; n.minLodPixels = parseFloat(i.minLodPixels), n.maxLodPixels = parseFloat(i.maxLodPixels), n.minFadeExtent = parseFloat(i.minFadeExtent), n.maxFadeExtent = parseFloat(i.maxFadeExtent) } }), qy = Pu(Xy, ["Document", "Placemark"]), Hy = Pu(Xy, { Document: Eu((function (t, e, i) { Fu({ node: t }, nv, rv, e, i, void 0, this) })), Placemark: Eu(Pv) }); let $y, Jy, Qy, tx, ex, ix, nx = null; let rx, sx = null; let ox, ax = null; let lx = null; let hx = null; let cx, ux = null; function dx(t) { return 32 / Math.min(t[0], t[1]) } function gx(t) { return t } function fx(t, e, i) { return Array.isArray(t) ? t : "string" == typeof t ? fx(i[t], e, i) : e } function px(t) { const e = gu(t, !1), i = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(e); if (i) { const t = i[1]; return [parseInt(t.substr(6, 2), 16), parseInt(t.substr(4, 2), 16), parseInt(t.substr(2, 2), 16), parseInt(t.substr(0, 2), 16) / 255] } } function mx(t) { let e = gu(t, !1); const i = []; e = e.replace(/\s*,\s*/g, ","); const n = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?),([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|,|$)(?:([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|$))?\s*/i; let r; for (; r = n.exec(e);) { const t = parseFloat(r[1]), n = parseFloat(r[2]), s = r[3] ? parseFloat(r[3]) : 0; i.push(t, n, s), e = e.substr(r[0].length) } if ("" === e) return i } function _x(t) { const e = gu(t, !1).trim(); let i = t.baseURI; if (i && "about:blank" != i || (i = window.location.href), i) { return new URL(e, i).href } return e } function yx(t) { const e = gu(t, !1).trim().replace(/^(?!.*#)/, "#"); let i = t.baseURI; if (i && "about:blank" != i || (i = window.location.href), i) { return new URL(e, i).href } return e } function xx(t) { return G_(t) } const vx = Pu(Xy, { Pair: function (t, e) { const i = Lu({}, qx, t, e, this); if (!i) return; const n = i.key; if (n && "normal" == n) { const t = i.styleUrl; t && (e[e.length - 1] = t); const n = i.Style; n && (e[e.length - 1] = n) } } }); function Sx(t, e) { return Lu(void 0, vx, t, e, this) } const wx = Pu(Xy, { Icon: wu((function (t, e) { const i = Lu({}, Mx, t, e); return i || null })), color: wu(px), heading: wu(G_), hotSpot: wu((function (t) { const e = t.getAttribute("xunits"), i = t.getAttribute("yunits"); let n; return n = "insetPixels" !== e ? "insetPixels" !== i ? "bottom-left" : "top-left" : "insetPixels" !== i ? "bottom-right" : "top-right", { x: parseFloat(t.getAttribute("x")), xunits: Vy[e], y: parseFloat(t.getAttribute("y")), yunits: Vy[i], origin: n } })), scale: wu(xx) }); const Ex = Pu(Xy, { color: wu(px), scale: wu(xx) }); const Tx = Pu(Xy, { color: wu(px), width: wu(G_) }); const Cx = Pu(Xy, { color: wu(px), fill: wu(N_), outline: wu(N_) }); const bx = Pu(Xy, { coordinates: vu(mx) }); function Rx(t, e) { return Lu(null, bx, t, e) } const Px = Pu(zy, { Track: xu(Lx) }); const Ix = Pu(Xy, { when: function (t, e) { const i = e[e.length - 1].whens, n = gu(t, !1), r = Date.parse(n); i.push(isNaN(r) ? 0 : r) } }, Pu(zy, { coord: function (t, e) { const i = e[e.length - 1].coordinates, n = gu(t, !1), r = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i.exec(n); if (r) { const t = parseFloat(r[1]), e = parseFloat(r[2]), n = parseFloat(r[3]); i.push([t, e, n]) } else i.push([]) } })); function Lx(t, e) { const i = Lu({ coordinates: [], whens: [] }, Ix, t, e); if (!i) return; const n = [], r = i.coordinates, s = i.whens; for (let t = 0, e = Math.min(r.length, s.length); t < e; ++t)3 == r[t].length && n.push(r[t][0], r[t][1], r[t][2], s[t]); return new Op(n, "XYZM") } const Mx = Pu(Xy, { href: wu(_x) }, Pu(zy, { x: wu(G_), y: wu(G_), w: wu(G_), h: wu(G_) })); const Fx = Pu(Xy, { coordinates: vu(mx) }); function Ax(t, e) { return Lu(null, Fx, t, e) } const Ox = Pu(Xy, { extrude: wu(N_), tessellate: wu(N_), altitudeMode: wu(z_) }); function Nx(t, e) { const i = Lu({}, Ox, t, e), n = Ax(t, e); if (n) { const t = new Op(n, "XYZ"); return t.setProperties(i, !0), t } } function Dx(t, e) { const i = Lu({}, Ox, t, e), n = Ax(t, e); if (n) { const t = new ur(n, "XYZ", [n.length]); return t.setProperties(i, !0), t } } const kx = Pu(Xy, { LineString: xu(Nx), LinearRing: xu(Dx), MultiGeometry: xu(Gx), Point: xu(jx), Polygon: xu(Ux) }); function Gx(t, e) { const i = Lu([], kx, t, e); if (!i) return null; if (0 === i.length) return new Ip(i); let n, r = !0; const s = i[0].getType(); let o; for (let t = 1, e = i.length; t < e; ++t)if (o = i[t], o.getType() != s) { r = !1; break } if (r) { let t, e; if ("Point" == s) { const r = i[0]; t = r.getLayout(), e = r.getFlatCoordinates(); for (let t = 1, n = i.length; t < n; ++t)o = i[t], c(e, o.getFlatCoordinates()); n = new Dp(e, t), Vx(n, i) } else "LineString" == s ? (n = new Np(i), Vx(n, i)) : "Polygon" == s ? (n = new Gp(i), Vx(n, i)) : "GeometryCollection" == s ? n = new Ip(i) : at(!1, 37) } else n = new Ip(i); return n } function jx(t, e) { const i = Lu({}, Ox, t, e), n = Ax(t, e); if (n) { const t = new Wn(n, "XYZ"); return t.setProperties(i, !0), t } } const Bx = Pu(Xy, { innerBoundaryIs: function (t, e) { const i = Lu([], Qx, t, e); if (i.length > 0) { e[e.length - 1].push(...i) } }, outerBoundaryIs: function (t, e) { const i = Lu(void 0, tv, t, e); if (i) { e[e.length - 1][0] = i } } }); function Ux(t, e) { const i = Lu({}, Ox, t, e), n = Lu([null], Bx, t, e); if (n && n[0]) { const t = n[0], e = [t.length]; for (let i = 1, r = n.length; i < r; ++i)c(t, n[i]), e.push(t.length); const r = new ur(t, "XYZ", e); return r.setProperties(i, !0), r } } const zx = Pu(Xy, { IconStyle: function (t, e) { const i = Lu({}, wx, t, e); if (!i) return; const n = e[e.length - 1], r = "Icon" in i ? i.Icon : {}, s = !("Icon" in i) || Object.keys(r).length > 0; let o; const a = r.href; let l, h, c; a ? o = a : s && (o = ix); let u = "bottom-left"; const d = i.hotSpot; let g; d ? (l = [d.x, d.y], h = d.xunits, c = d.yunits, u = d.origin) : /^https?:\/\/maps\.(?:google|gstatic)\.com\//.test(o) && (o.includes("pushpin") ? (l = Jy, h = Qy, c = tx) : o.includes("arrow-reverse") ? (l = [54, 42], h = Qy, c = tx) : o.includes("paddle") && (l = [32, 1], h = Qy, c = tx)); const f = r.x, p = r.y; let m; void 0 !== f && void 0 !== p && (g = [f, p]); const _ = r.w, y = r.h; let x; void 0 !== _ && void 0 !== y && (m = [_, y]); const v = i.heading; void 0 !== v && (x = ai(v)); const S = i.scale, w = i.color; if (s) { o == ix && (m = ex); const t = new lg({ anchor: l, anchorOrigin: u, anchorXUnits: h, anchorYUnits: c, crossOrigin: this.crossOrigin_, offset: g, offsetOrigin: "bottom-left", rotation: x, scale: S, size: m, src: this.iconUrlFunction_(o), color: w }), e = t.getScaleArray()[0], i = t.getSize(); if (null === i) { const i = t.getImageState(); if (i === Pr || i === Ir) { const n = function () { const i = t.getImageState(); if (i !== Pr && i !== Ir) { const i = t.getSize(); if (i && 2 == i.length) { const n = dx(i); t.setScale(e * n) } t.unlistenImageChange(n) } }; t.listenImageChange(n), i === Pr && t.load() } } else if (2 == i.length) { const n = dx(i); t.setScale(e * n) } n.imageStyle = t } else n.imageStyle = rx }, LabelStyle: function (t, e) { const i = Lu({}, Ex, t, e); if (!i) return; const n = e[e.length - 1], r = new mg({ fill: new rg({ color: "color" in i ? i.color : $y }), scale: i.scale }); n.textStyle = r }, LineStyle: function (t, e) { const i = Lu({}, Tx, t, e); if (!i) return; const n = e[e.length - 1], r = new hg({ color: "color" in i ? i.color : $y, width: "width" in i ? i.width : 1 }); n.strokeStyle = r }, PolyStyle: function (t, e) { const i = Lu({}, Cx, t, e); if (!i) return; const n = e[e.length - 1], r = new rg({ color: "color" in i ? i.color : $y }); n.fillStyle = r; const s = i.fill; void 0 !== s && (n.fill = s); const o = i.outline; void 0 !== o && (n.outline = o) } }); function Xx(t, e) { const i = Lu({}, zx, t, e, this); if (!i) return null; let n = "fillStyle" in i ? i.fillStyle : nx; const r = i.fill; let s; void 0 === r || r || (n = null), "imageStyle" in i ? i.imageStyle != rx && (s = i.imageStyle) : s = sx; const o = "textStyle" in i ? i.textStyle : lx, a = "strokeStyle" in i ? i.strokeStyle : ax, l = i.outline; return void 0 === l || l ? [new cg({ fill: n, image: s, stroke: a, text: o, zIndex: void 0 })] : [new cg({ geometry: function (t) { const e = t.getGeometry(), i = e.getType(); if ("GeometryCollection" === i) { return new Ip(e.getGeometriesArrayRecursive().filter((function (t) { const e = t.getType(); return "Polygon" !== e && "MultiPolygon" !== e }))) } if ("Polygon" !== i && "MultiPolygon" !== i) return e }, fill: n, image: s, stroke: a, text: o, zIndex: void 0 }), new cg({ geometry: function (t) { const e = t.getGeometry(), i = e.getType(); if ("GeometryCollection" === i) { return new Ip(e.getGeometriesArrayRecursive().filter((function (t) { const e = t.getType(); return "Polygon" === e || "MultiPolygon" === e }))) } if ("Polygon" === i || "MultiPolygon" === i) return e }, fill: n, stroke: null, zIndex: void 0 })] } function Vx(t, e) { const i = e.length, n = new Array(e.length), r = new Array(e.length), s = new Array(e.length); let o, a, l; o = !1, a = !1, l = !1; for (let t = 0; t < i; ++t) { const i = e[t]; n[t] = i.get("extrude"), r[t] = i.get("tessellate"), s[t] = i.get("altitudeMode"), o = o || void 0 !== n[t], a = a || void 0 !== r[t], l = l || s[t] } o && t.set("extrude", n), a && t.set("tessellate", r), l && t.set("altitudeMode", s) } const Wx = Pu(Xy, { displayName: wu(z_), value: wu(z_) }); const Zx = Pu(Xy, { Data: function (t, e) { const i = t.getAttribute("name"); Iu(Wx, t, e); const n = e[e.length - 1]; i && n.displayName ? n[i] = { value: n.value, displayName: n.displayName, toString: function () { return n.value } } : null !== i ? n[i] = n.value : null !== n.displayName && (n[n.displayName] = n.value), delete n.value }, SchemaData: function (t, e) { Iu(Hx, t, e) } }); function Yx(t, e) { Iu(Zx, t, e) } function Kx(t, e) { Iu(Ky, t, e) } const qx = Pu(Xy, { Style: wu(Xx), key: wu(z_), styleUrl: wu(yx) }); const Hx = Pu(Xy, { SimpleData: function (t, e) { const i = t.getAttribute("name"); if (null !== i) { const n = z_(t); e[e.length - 1][i] = n } } }); const $x = Pu(Xy, { altitudeMode: wu(z_), minAltitude: wu(G_), maxAltitude: wu(G_), north: wu(G_), south: wu(G_), east: wu(G_), west: wu(G_) }); const Jx = Pu(Xy, { minLodPixels: wu(G_), maxLodPixels: wu(G_), minFadeExtent: wu(G_), maxFadeExtent: wu(G_) }); const Qx = Pu(Xy, { LinearRing: xu(Rx) }); const tv = Pu(Xy, { LinearRing: vu(Rx) }); function ev(t, e) { const i = $r(e), n = [255 * (4 == i.length ? i[3] : 1), i[2], i[1], i[0]]; for (let t = 0; t < 4; ++t) { const e = Math.floor(n[t]).toString(16); n[t] = 1 == e.length ? "0" + e : e } K_(t, n.join("")) } const iv = Pu(Xy, { Data: Eu((function (t, e, i) { t.setAttribute("name", e.name); const n = { node: t }, r = e.value; "object" == typeof r ? (null !== r && r.displayName && Fu(n, iv, bu, [r.displayName], i, ["displayName"]), null !== r && r.value && Fu(n, iv, bu, [r.value], i, ["value"])) : Fu(n, iv, bu, [r], i, ["value"]) })), value: Eu((function (t, e) { K_(t, e) })), displayName: Eu((function (t, e) { V_(t, e) })) }); const nv = Pu(Xy, { Placemark: Eu(Pv) }), rv = function (t, e, i) { return du(e[e.length - 1].node.namespaceURI, "Placemark") }; const sv = Cu("Data"); const ov = Pu(Xy, ["href"], Pu(zy, ["x", "y", "w", "h"])), av = Pu(Xy, { href: Eu(K_) }, Pu(zy, { x: Eu(Z_), y: Eu(Z_), w: Eu(Z_), h: Eu(Z_) })), lv = function (t, e, i) { return du(zy[0], "gx:" + i) }; const hv = Pu(Xy, ["scale", "heading", "Icon", "color", "hotSpot"]), cv = Pu(Xy, { Icon: Eu((function (t, e, i) { const n = { node: t }, r = i[i.length - 1].node; let s = ov[r.namespaceURI], o = Ru(e, s); Fu(n, av, bu, o, i, s), s = ov[zy[0]], o = Ru(e, s), Fu(n, av, lv, o, i, s) })), color: Eu(ev), heading: Eu(Z_), hotSpot: Eu((function (t, e) { t.setAttribute("x", String(e.x)), t.setAttribute("y", String(e.y)), t.setAttribute("xunits", e.xunits), t.setAttribute("yunits", e.yunits) })), scale: Eu(Gv) }); const uv = Pu(Xy, ["color", "scale"]), dv = Pu(Xy, { color: Eu(ev), scale: Eu(Gv) }); const gv = Pu(Xy, ["color", "width"]), fv = Pu(Xy, { color: Eu(ev), width: Eu(Z_) }); const pv = { Point: "Point", LineString: "LineString", LinearRing: "LinearRing", Polygon: "Polygon", MultiPoint: "MultiGeometry", MultiLineString: "MultiGeometry", MultiPolygon: "MultiGeometry", GeometryCollection: "MultiGeometry" }, mv = function (t, e, i) { if (t) { return du(e[e.length - 1].node.namespaceURI, pv[t.getType()]) } }, _v = Cu("Point"), yv = Cu("LineString"), xv = Cu("LinearRing"), vv = Cu("Polygon"), Sv = Pu(Xy, { LineString: Eu(Mv), Point: Eu(Mv), Polygon: Eu(Dv), GeometryCollection: Eu(wv) }); function wv(t, e, i) { const n = { node: t }, r = e.getType(); let s, o = []; "GeometryCollection" === r ? (e.getGeometriesArrayRecursive().forEach((function (t) { const e = t.getType(); "MultiPoint" === e ? o = o.concat(t.getPoints()) : "MultiLineString" === e ? o = o.concat(t.getLineStrings()) : "MultiPolygon" === e ? o = o.concat(t.getPolygons()) : "Point" === e || "LineString" === e || "Polygon" === e ? o.push(t) : at(!1, 39) })), s = mv) : "MultiPoint" === r ? (o = e.getPoints(), s = _v) : "MultiLineString" === r ? (o = e.getLineStrings(), s = yv) : "MultiPolygon" === r ? (o = e.getPolygons(), s = vv) : at(!1, 39), Fu(n, Sv, s, o, i) } const Ev = Pu(Xy, { LinearRing: Eu(Mv) }); function Tv(t, e, i) { Fu({ node: t }, Ev, xv, [e], i) } const Cv = Pu(Xy, { ExtendedData: Eu((function (t, e, i) { const n = { node: t }, r = e.names, s = e.values, o = r.length; for (let t = 0; t < o; t++)Fu(n, iv, sv, [{ name: r[t], value: s[t] }], i) })), MultiGeometry: Eu(wv), LineString: Eu(Mv), LinearRing: Eu(Mv), Point: Eu(Mv), Polygon: Eu(Dv), Style: Eu((function (t, e, i) { const n = { node: t }, r = {}; if (e.pointStyles.length) { const t = e.pointStyles[0].getText(); t && (r.LabelStyle = t); const i = e.pointStyles[0].getImage(); i && "function" == typeof i.getSrc && (r.IconStyle = i) } if (e.lineStyles.length) { const t = e.lineStyles[0].getStroke(); t && (r.LineStyle = t) } if (e.polyStyles.length) { const t = e.polyStyles[0].getStroke(); t && !r.LineStyle && (r.LineStyle = t), r.PolyStyle = e.polyStyles[0] } const s = i[i.length - 1].node, o = jv[s.namespaceURI], a = Ru(r, o); Fu(n, Bv, bu, a, i, o) })), address: Eu(K_), description: Eu(K_), name: Eu(K_), open: Eu(X_), phoneNumber: Eu(K_), styleUrl: Eu(K_), visibility: Eu(X_) }), bv = Pu(Xy, ["name", "open", "visibility", "address", "phoneNumber", "description", "styleUrl", "Style"]), Rv = Cu("ExtendedData"); function Pv(t, e, i) { const n = { node: t }; e.getId() && t.setAttribute("id", e.getId()); const r = e.getProperties(), s = { address: 1, description: 1, name: 1, open: 1, phoneNumber: 1, styleUrl: 1, visibility: 1 }; s[e.getGeometryName()] = 1; const o = Object.keys(r || {}).sort().filter((function (t) { return !s[t] })), a = e.getStyleFunction(); if (a) { const t = a(e, 0); if (t) { const i = Array.isArray(t) ? t : [t]; let n = i; if (e.getGeometry() && (n = i.filter((function (t) { const i = t.getGeometryFunction()(e); if (i) { const t = i.getType(); return "GeometryCollection" === t ? i.getGeometriesArrayRecursive().filter((function (t) { const e = t.getType(); return "Point" === e || "MultiPoint" === e })).length : "Point" === t || "MultiPoint" === t } }))), this.writeStyles_) { let t = i, s = i; e.getGeometry() && (t = i.filter((function (t) { const i = t.getGeometryFunction()(e); if (i) { const t = i.getType(); return "GeometryCollection" === t ? i.getGeometriesArrayRecursive().filter((function (t) { const e = t.getType(); return "LineString" === e || "MultiLineString" === e })).length : "LineString" === t || "MultiLineString" === t } })), s = i.filter((function (t) { const i = t.getGeometryFunction()(e); if (i) { const t = i.getType(); return "GeometryCollection" === t ? i.getGeometriesArrayRecursive().filter((function (t) { const e = t.getType(); return "Polygon" === e || "MultiPolygon" === e })).length : "Polygon" === t || "MultiPolygon" === t } }))), r.Style = { pointStyles: n, lineStyles: t, polyStyles: s } } if (n.length && void 0 === r.name) { const t = n[0].getText(); t && (r.name = t.getText()) } } } const l = i[i.length - 1].node, h = bv[l.namespaceURI], c = Ru(r, h); if (Fu(n, Cv, bu, c, i, h), o.length > 0) { const t = Ru(r, o); Fu(n, Cv, Rv, [{ names: o, values: t }], i) } const u = i[0]; let d = e.getGeometry(); d && (d = Qp(d, !0, u)), Fu(n, Cv, mv, [d], i) } const Iv = Pu(Xy, ["extrude", "tessellate", "altitudeMode", "coordinates"]), Lv = Pu(Xy, { extrude: Eu(X_), tessellate: Eu(X_), altitudeMode: Eu(K_), coordinates: Eu((function (t, e, i) { const n = i[i.length - 1], r = n.layout, s = n.stride; let o; "XY" == r || "XYM" == r ? o = 2 : "XYZ" == r || "XYZM" == r ? o = 3 : at(!1, 34); const a = e.length; let l = ""; if (a > 0) { l += e[0]; for (let t = 1; t < o; ++t)l += "," + e[t]; for (let t = s; t < a; t += s) { l += " " + e[t]; for (let i = 1; i < o; ++i)l += "," + e[t + i] } } K_(t, l) })) }); function Mv(t, e, i) { const n = e.getFlatCoordinates(), r = { node: t }; r.layout = e.getLayout(), r.stride = e.getStride(); const s = e.getProperties(); s.coordinates = n; const o = i[i.length - 1].node, a = Iv[o.namespaceURI], l = Ru(s, a); Fu(r, Lv, bu, l, i, a) } const Fv = Pu(Xy, ["color", "fill", "outline"]), Av = Pu(Xy, { outerBoundaryIs: Eu(Tv), innerBoundaryIs: Eu(Tv) }), Ov = Cu("innerBoundaryIs"), Nv = Cu("outerBoundaryIs"); function Dv(t, e, i) { const n = e.getLinearRings(), r = n.shift(), s = { node: t }; Fu(s, Av, Ov, n, i), Fu(s, Av, Nv, [r], i) } const kv = Pu(Xy, { color: Eu(ev), fill: Eu(X_), outline: Eu(X_) }); function Gv(t, e) { Z_(t, Math.round(1e6 * e) / 1e6) } const jv = Pu(Xy, ["IconStyle", "LabelStyle", "LineStyle", "PolyStyle"]), Bv = Pu(Xy, { IconStyle: Eu((function (t, e, i) { const n = { node: t }, r = {}, s = e.getSrc(), o = e.getSize(), a = e.getImageSize(), l = { href: s }; if (o) { l.w = o[0], l.h = o[1]; const t = e.getAnchor(), i = e.getOrigin(); if (i && a && 0 !== i[0] && i[1] !== o[1] && (l.x = i[0], l.y = a[1] - (i[1] + o[1])), t && (t[0] !== o[0] / 2 || t[1] !== o[1] / 2)) { const e = { x: t[0], xunits: "pixels", y: o[1] - t[1], yunits: "pixels" }; r.hotSpot = e } } r.Icon = l; let h = e.getScaleArray()[0], c = o; if (null === c && (c = ex), 2 == c.length) { h /= dx(c) } 1 !== h && (r.scale = h); const u = e.getRotation(); 0 !== u && (r.heading = u); const d = e.getColor(); d && (r.color = d); const g = i[i.length - 1].node, f = hv[g.namespaceURI], p = Ru(r, f); Fu(n, cv, bu, p, i, f) })), LabelStyle: Eu((function (t, e, i) { const n = { node: t }, r = {}, s = e.getFill(); s && (r.color = s.getColor()); const o = e.getScale(); o && 1 !== o && (r.scale = o); const a = i[i.length - 1].node, l = uv[a.namespaceURI], h = Ru(r, l); Fu(n, dv, bu, h, i, l) })), LineStyle: Eu((function (t, e, i) { const n = { node: t }, r = { color: e.getColor(), width: Number(e.getWidth()) || 1 }, s = i[i.length - 1].node, o = gv[s.namespaceURI], a = Ru(r, o); Fu(n, fv, bu, a, i, o) })), PolyStyle: Eu((function (t, e, i) { const n = { node: t }, r = e.getFill(), s = e.getStroke(), o = { color: r ? r.getColor() : void 0, fill: !!r && void 0, outline: !!s && void 0 }, a = i[i.length - 1].node, l = Fv[a.namespaceURI], h = Ru(o, l); Fu(n, kv, bu, h, i, l) })) }); const Uv = [null], zv = Pu(Uv, { nd: function (t, e) { e[e.length - 1].ndrefs.push(t.getAttribute("ref")) }, tag: Wv }), Xv = Pu(Uv, { node: function (t, e) { const i = e[0], n = e[e.length - 1], r = t.getAttribute("id"), s = [parseFloat(t.getAttribute("lon")), parseFloat(t.getAttribute("lat"))]; n.nodes[r] = s; const o = Lu({ tags: {} }, Vv, t, e); if (!x(o.tags)) { const t = new Wn(s); Qp(t, !1, i); const e = new lt(t); void 0 !== r && e.setId(r), e.setProperties(o.tags, !0), n.features.push(e) } }, way: function (t, e) { const i = Lu({ id: t.getAttribute("id"), ndrefs: [], tags: {} }, zv, t, e); e[e.length - 1].ways.push(i) } }); const Vv = Pu(Uv, { tag: Wv }); function Wv(t, e) { e[e.length - 1].tags[t.getAttribute("k")] = t.getAttribute("v") } class Zv { read(t) { if (t) { if ("string" == typeof t) { const e = _u(t); return this.readFromDocument(e) } return pu(t) ? this.readFromDocument(t) : this.readFromNode(t) } return null } readFromDocument(t) { for (let e = t.firstChild; e; e = e.nextSibling)if (e.nodeType == Node.ELEMENT_NODE) return this.readFromNode(e); return null } readFromNode(t) { } } function Yv(t) { return t.getAttributeNS("http://www.w3.org/1999/xlink", "href") } const Kv = [null, "http://www.opengis.net/ows/1.1"], qv = Pu(Kv, { ServiceIdentification: wu((function (t, e) { return Lu({}, lS, t, e) })), ServiceProvider: wu((function (t, e) { return Lu({}, hS, t, e) })), OperationsMetadata: wu((function (t, e) { return Lu({}, rS, t, e) })) }); class Hv extends Zv { constructor() { super() } readFromNode(t) { const e = Lu({}, qv, t, []); return e || null } } const $v = Pu(Kv, { DeliveryPoint: wu(z_), City: wu(z_), AdministrativeArea: wu(z_), PostalCode: wu(z_), Country: wu(z_), ElectronicMailAddress: wu(z_) }), Jv = Pu(Kv, { Value: Su((function (t, e) { return z_(t) })) }), Qv = Pu(Kv, { AllowedValues: wu((function (t, e) { return Lu({}, Jv, t, e) })) }), tS = Pu(Kv, { Phone: wu((function (t, e) { return Lu({}, sS, t, e) })), Address: wu((function (t, e) { return Lu({}, $v, t, e) })) }), eS = Pu(Kv, { HTTP: wu((function (t, e) { return Lu({}, iS, t, e) })) }), iS = Pu(Kv, { Get: Su((function (t, e) { const i = Yv(t); if (!i) return; return Lu({ href: i }, oS, t, e) })), Post: void 0 }), nS = Pu(Kv, { DCP: wu((function (t, e) { return Lu({}, eS, t, e) })) }), rS = Pu(Kv, { Operation: function (t, e) { const i = t.getAttribute("name"), n = Lu({}, nS, t, e); if (!n) return; e[e.length - 1][i] = n } }), sS = Pu(Kv, { Voice: wu(z_), Facsimile: wu(z_) }), oS = Pu(Kv, { Constraint: Su((function (t, e) { const i = t.getAttribute("name"); if (!i) return; return Lu({ name: i }, Qv, t, e) })) }), aS = Pu(Kv, { IndividualName: wu(z_), PositionName: wu(z_), ContactInfo: wu((function (t, e) { return Lu({}, tS, t, e) })) }), lS = Pu(Kv, { Abstract: wu(z_), AccessConstraints: wu(z_), Fees: wu(z_), Title: wu(z_), ServiceTypeVersion: wu(z_), ServiceType: wu(z_) }), hS = Pu(Kv, { ProviderName: wu(z_), ProviderSite: wu(Yv), ServiceContact: wu((function (t, e) { return Lu({}, aS, t, e) })) }); function cS(t, e, i) { let n; i = i || 1e5; const r = new Array(e); for (n = 0; n < e; ++n)r[n] = 0; for (let i = 0, s = t.length; i < s;)for (n = 0; n < e; ++n, ++i) { const e = t[i], s = e - r[n]; r[n] = e, t[i] = s } return dS(t, i) } function uS(t, e, i) { let n; i = i || 1e5; const r = new Array(e); for (n = 0; n < e; ++n)r[n] = 0; const s = gS(t, i); for (let t = 0, i = s.length; t < i;)for (n = 0; n < e; ++n, ++t)r[n] += s[t], s[t] = r[n]; return s } function dS(t, e) { e = e || 1e5; for (let i = 0, n = t.length; i < n; ++i)t[i] = Math.round(t[i] * e); return fS(t) } function gS(t, e) { e = e || 1e5; const i = pS(t); for (let t = 0, n = i.length; t < n; ++t)i[t] /= e; return i } function fS(t) { for (let e = 0, i = t.length; e < i; ++e) { const i = t[e]; t[e] = i < 0 ? ~(i << 1) : i << 1 } return mS(t) } function pS(t) { const e = _S(t); for (let t = 0, i = e.length; t < i; ++t) { const i = e[t]; e[t] = 1 & i ? ~(i >> 1) : i >> 1 } return e } function mS(t) { let e = ""; for (let i = 0, n = t.length; i < n; ++i)e += yS(t[i]); return e } function _S(t) { const e = []; let i = 0, n = 0; for (let r = 0, s = t.length; r < s; ++r) { const s = t.charCodeAt(r) - 63; i |= (31 & s) << n, s < 32 ? (e.push(i), i = 0, n = 0) : n += 5 } return e } function yS(t) { let e, i = ""; for (; t >= 32;)e = 63 + (32 | 31 & t), i += String.fromCharCode(e), t >>= 5; return e = t + 63, i += String.fromCharCode(e), i } const xS = { Point: function (t, e, i) { const n = t.coordinates; e && i && TS(n, e, i); return new Wn(n) }, LineString: function (t, e) { const i = vS(t.arcs, e); return new Op(i) }, Polygon: function (t, e) { const i = []; for (let n = 0, r = t.arcs.length; n < r; ++n)i[n] = vS(t.arcs[n], e); return new ur(i) }, MultiPoint: function (t, e, i) { const n = t.coordinates; if (e && i) for (let t = 0, r = n.length; t < r; ++t)TS(n[t], e, i); return new Dp(n) }, MultiLineString: function (t, e) { const i = []; for (let n = 0, r = t.arcs.length; n < r; ++n)i[n] = vS(t.arcs[n], e); return new Np(i) }, MultiPolygon: function (t, e) { const i = []; for (let n = 0, r = t.arcs.length; n < r; ++n) { const r = t.arcs[n], s = []; for (let t = 0, i = r.length; t < i; ++t)s[t] = vS(r[t], e); i[n] = s } return new Gp(i) } }; function vS(t, e) { const i = []; let n; for (let r = 0, s = t.length; r < s; ++r)if (n = t[r], r > 0 && i.pop(), n >= 0) { const t = e[n]; for (let e = 0, n = t.length; e < n; ++e)i.push(t[e].slice(0)) } else { const t = e[~n]; for (let e = t.length - 1; e >= 0; --e)i.push(t[e].slice(0)) } return i } function SS(t, e, i, n, r, s, o) { const a = t.geometries, l = []; for (let t = 0, h = a.length; t < h; ++t)l[t] = wS(a[t], e, i, n, r, s, o); return l } function wS(t, e, i, n, r, s, o) { let a = null; const l = t.type; if (l) { const r = xS[l]; a = "Point" === l || "MultiPoint" === l ? r(t, i, n) : r(t, e), a = Qp(a, !1, o) } const h = new lt({ geometry: a }); void 0 !== t.id && h.setId(t.id); let c = t.properties; return r && (c || (c = {}), c[r] = s), c && h.setProperties(c, !0), h } function ES(t, e, i) { let n = 0, r = 0; for (let s = 0, o = t.length; s < o; ++s) { const o = t[s]; n += o[0], r += o[1], o[0] = n, o[1] = r, TS(o, e, i) } } function TS(t, e, i) { t[0] = t[0] * e[0] + i[0], t[1] = t[1] * e[1] + i[1] } class CS { constructor(t) { this.tagName_ = t } getTagName() { return this.tagName_ } } class bS extends CS { constructor(t, e) { super(t), this.conditions = e, at(this.conditions.length >= 2, 57) } } class RS extends bS { constructor(t) { super("And", Array.prototype.slice.call(arguments)) } } class PS extends CS { constructor(t, e, i) { if (super("BBOX"), this.geometryName = t, this.extent = e, 4 !== e.length) throw new Error("Expected an extent with four values ([minX, minY, maxX, maxY])"); this.srsName = i } } class IS extends CS { constructor(t, e, i, n) { super(t), this.geometryName = e || "the_geom", this.geometry = i, this.srsName = n } } class LS extends IS { constructor(t, e, i) { super("Contains", t, e, i) } } class MS extends IS { constructor(t, e, i, n, r) { super("DWithin", t, e, r), this.distance = i, this.unit = n } } class FS extends IS { constructor(t, e, i) { super("Disjoint", t, e, i) } } class AS extends CS { constructor(t, e) { super(t), this.propertyName = e } } class OS extends AS { constructor(t, e, i) { super("During", t), this.begin = e, this.end = i } } class NS extends AS { constructor(t, e, i, n) { super(t, e), this.expression = i, this.matchCase = n } } class DS extends NS { constructor(t, e, i) { super("PropertyIsEqualTo", t, e, i) } } class kS extends NS { constructor(t, e) { super("PropertyIsGreaterThan", t, e) } } class GS extends NS { constructor(t, e) { super("PropertyIsGreaterThanOrEqualTo", t, e) } } class jS extends IS { constructor(t, e, i) { super("Intersects", t, e, i) } } class BS extends AS { constructor(t, e, i) { super("PropertyIsBetween", t), this.lowerBoundary = e, this.upperBoundary = i } } class US extends AS { constructor(t, e, i, n, r, s) { super("PropertyIsLike", t), this.pattern = e, this.wildCard = void 0 !== i ? i : "*", this.singleChar = void 0 !== n ? n : ".", this.escapeChar = void 0 !== r ? r : "!", this.matchCase = s } } class zS extends AS { constructor(t) { super("PropertyIsNull", t) } } class XS extends NS { constructor(t, e) { super("PropertyIsLessThan", t, e) } } class VS extends NS { constructor(t, e) { super("PropertyIsLessThanOrEqualTo", t, e) } } class WS extends CS { constructor(t) { super("Not"), this.condition = t } } class ZS extends NS { constructor(t, e, i) { super("PropertyIsNotEqualTo", t, e, i) } } class YS extends bS { constructor(t) { super("Or", Array.prototype.slice.call(arguments)) } } class KS extends CS { constructor(t) { super("ResourceId"), this.rid = t } } class qS extends IS { constructor(t, e, i) { super("Within", t, e, i) } } function HS(t) { const e = [null].concat(Array.prototype.slice.call(arguments)); return new (Function.prototype.bind.apply(RS, e)) } function $S(t, e, i) { return new PS(t, e, i) } const JS = { "http://www.opengis.net/gml": { boundedBy: wu(O_.prototype.readExtentElement, "bounds") }, "http://www.opengis.net/wfs/2.0": { member: xu(O_.prototype.readFeaturesInternal) } }, QS = { "http://www.opengis.net/wfs": { totalInserted: wu(B_), totalUpdated: wu(B_), totalDeleted: wu(B_) }, "http://www.opengis.net/wfs/2.0": { totalInserted: wu(B_), totalUpdated: wu(B_), totalDeleted: wu(B_) } }, tw = { "http://www.opengis.net/wfs": { TransactionSummary: wu(uw, "transactionSummary"), InsertResults: wu(pw, "insertIds") }, "http://www.opengis.net/wfs/2.0": { TransactionSummary: wu(uw, "transactionSummary"), InsertResults: wu(pw, "insertIds") } }, ew = { "http://www.opengis.net/wfs": { PropertyName: Eu(K_) }, "http://www.opengis.net/wfs/2.0": { PropertyName: Eu(K_) } }, iw = { "http://www.opengis.net/wfs": { Insert: Eu(mw), Update: Eu(vw), Delete: Eu(xw), Property: Eu(Sw), Native: Eu(ww) }, "http://www.opengis.net/wfs/2.0": { Insert: Eu(mw), Update: Eu(vw), Delete: Eu(xw), Property: Eu(Sw), Native: Eu(ww) } }, nw = "feature", rw = "http://www.w3.org/2000/xmlns/", sw = { "2.0.0": "http://www.opengis.net/ogc/1.1", "1.1.0": "http://www.opengis.net/ogc", "1.0.0": "http://www.opengis.net/ogc" }, ow = { "2.0.0": "http://www.opengis.net/wfs/2.0", "1.1.0": "http://www.opengis.net/wfs", "1.0.0": "http://www.opengis.net/wfs" }, aw = { "2.0.0": "http://www.opengis.net/fes/2.0", "1.1.0": "http://www.opengis.net/fes", "1.0.0": "http://www.opengis.net/fes" }, lw = { "2.0.0": "http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd", "1.1.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd", "1.0.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd" }, hw = { "2.0.0": ty, "1.1.0": J_, "1.0.0": H_ }; function cw(t, e, i, n) { Fu(n, iw, Cu(t), e, i) } function uw(t, e) { return Lu({}, QS, t, e) } const dw = { "http://www.opengis.net/ogc": { FeatureId: xu((function (t, e) { return t.getAttribute("fid") })) }, "http://www.opengis.net/ogc/1.1": { FeatureId: xu((function (t, e) { return t.getAttribute("fid") })) } }; function gw(t, e) { Iu(dw, t, e) } const fw = { "http://www.opengis.net/wfs": { Feature: gw }, "http://www.opengis.net/wfs/2.0": { Feature: gw } }; function pw(t, e) { return Lu([], fw, t, e) } function mw(t, e, i) { const n = i[i.length - 1], r = n.featureType, s = n.featureNS, o = n.gmlVersion, a = du(s, r); t.appendChild(a), 2 === o ? H_.prototype.writeFeatureElement(a, e, i) : 3 === o ? J_.prototype.writeFeatureElement(a, e, i) : ty.prototype.writeFeatureElement(a, e, i) } function _w(t, e, i) { const n = i[i.length - 1].version, r = sw[n], s = du(r, "Filter"), o = du(r, "FeatureId"); s.appendChild(o), o.setAttribute("fid", e), t.appendChild(s) } function yw(t, e) { const i = (t = t || nw) + ":"; return e.startsWith(i) ? e : i + e } function xw(t, e, i) { const n = i[i.length - 1]; at(void 0 !== e.getId(), 26); const r = n.featureType, s = n.featurePrefix, o = n.featureNS, a = yw(s, r); t.setAttribute("typeName", a), t.setAttributeNS(rw, "xmlns:" + s, o); const l = e.getId(); void 0 !== l && _w(t, l, i) } function vw(t, e, i) { const n = i[i.length - 1]; at(void 0 !== e.getId(), 27); const r = n.version, s = n.featureType, o = n.featurePrefix, a = n.featureNS, l = yw(o, s), h = e.getGeometryName(); t.setAttribute("typeName", l), t.setAttributeNS(rw, "xmlns:" + o, a); const c = e.getId(); if (void 0 !== c) { const s = e.getKeys(), o = []; for (let t = 0, i = s.length; t < i; t++) { const i = e.get(s[t]); if (void 0 !== i) { let e = s[t]; i && "function" == typeof i.getSimplifiedGeometry && (e = h), o.push({ name: e, value: i }) } } Fu({ version: r, gmlVersion: n.gmlVersion, node: t, hasZ: n.hasZ, srsName: n.srsName }, iw, Cu("Property"), o, i), _w(t, c, i) } } function Sw(t, e, i) { const n = i[i.length - 1], r = n.version, s = ow[r], o = du(s, "Name"), a = n.gmlVersion; if (t.appendChild(o), K_(o, e.name), void 0 !== e.value && null !== e.value) { const n = du(s, "Value"); t.appendChild(n), e.value && "function" == typeof e.value.getSimplifiedGeometry ? 2 === a ? H_.prototype.writeGeometryElement(n, e.value, i) : 3 === a ? J_.prototype.writeGeometryElement(n, e.value, i) : ty.prototype.writeGeometryElement(n, e.value, i) : K_(n, e.value) } } function ww(t, e, i) { e.vendorId && t.setAttribute("vendorId", e.vendorId), void 0 !== e.safeToIgnore && t.setAttribute("safeToIgnore", String(e.safeToIgnore)), void 0 !== e.value && K_(t, e.value) } const Ew = { "http://www.opengis.net/wfs": { Query: Eu(Tw) }, "http://www.opengis.net/wfs/2.0": { Query: Eu(Tw) }, "http://www.opengis.net/ogc": { During: Eu(Iw), And: Eu(Lw), Or: Eu(Lw), Not: Eu(Mw), BBOX: Eu(bw), Contains: Eu(Rw), Intersects: Eu(Rw), Within: Eu(Rw), DWithin: Eu(Pw), PropertyIsEqualTo: Eu(Fw), PropertyIsNotEqualTo: Eu(Fw), PropertyIsLessThan: Eu(Fw), PropertyIsLessThanOrEqualTo: Eu(Fw), PropertyIsGreaterThan: Eu(Fw), PropertyIsGreaterThanOrEqualTo: Eu(Fw), PropertyIsNull: Eu(Aw), PropertyIsBetween: Eu(Ow), PropertyIsLike: Eu(Nw) }, "http://www.opengis.net/fes/2.0": { During: Eu(Iw), And: Eu(Lw), Or: Eu(Lw), Not: Eu(Mw), BBOX: Eu(bw), Contains: Eu(Rw), Disjoint: Eu(Rw), Intersects: Eu(Rw), ResourceId: Eu((function (t, e, i) { t.setAttribute("rid", e.rid) })), Within: Eu(Rw), DWithin: Eu(Pw), PropertyIsEqualTo: Eu(Fw), PropertyIsNotEqualTo: Eu(Fw), PropertyIsLessThan: Eu(Fw), PropertyIsLessThanOrEqualTo: Eu(Fw), PropertyIsGreaterThan: Eu(Fw), PropertyIsGreaterThanOrEqualTo: Eu(Fw), PropertyIsNull: Eu(Aw), PropertyIsBetween: Eu(Ow), PropertyIsLike: Eu(Nw) } }; function Tw(t, e, i) { const n = i[i.length - 1], r = n.version, s = n.featurePrefix, o = n.featureNS, a = n.propertyNames, l = n.srsName; let h, c; h = s ? yw(s, e) : e, c = "2.0.0" === r ? "typeNames" : "typeName", t.setAttribute(c, h), l && t.setAttribute("srsName", l), o && t.setAttributeNS(rw, "xmlns:" + s, o); const u = Object.assign({}, n); u.node = t, Fu(u, ew, Cu("PropertyName"), a, i); const d = n.filter; if (d) { const e = du(Uw(r), "Filter"); t.appendChild(e), Cw(e, d, i) } } function Cw(t, e, i) { const n = i[i.length - 1], r = { node: t }; Object.assign(r, { context: n }), Fu(r, Ew, Cu(e.getTagName()), [e], i) } function bw(t, e, i) { const n = i[i.length - 1], r = n.context.version; n.srsName = e.srsName; const s = hw[r]; Gw(r, t, e.geometryName), s.prototype.writeGeometryElement(t, e.extent, i) } function Rw(t, e, i) { const n = i[i.length - 1], r = n.context.version; n.srsName = e.srsName; const s = hw[r]; Gw(r, t, e.geometryName), s.prototype.writeGeometryElement(t, e.geometry, i) } function Pw(t, e, i) { const n = i[i.length - 1].context.version; Rw(t, e, i); const r = du(Uw(n), "Distance"); K_(r, e.distance.toString()), "2.0.0" === n ? r.setAttribute("uom", e.unit) : r.setAttribute("units", e.unit), t.appendChild(r) } function Iw(t, e, i) { const n = i[i.length - 1].context.version; Dw(aw[n], "ValueReference", t, e.propertyName); const r = du(F_, "TimePeriod"); t.appendChild(r); const s = du(F_, "begin"); r.appendChild(s), jw(s, e.begin); const o = du(F_, "end"); r.appendChild(o), jw(o, e.end) } function Lw(t, e, i) { const n = i[i.length - 1].context, r = { node: t }; Object.assign(r, { context: n }); const s = e.conditions; for (let t = 0, e = s.length; t < e; ++t) { const e = s[t]; Fu(r, Ew, Cu(e.getTagName()), [e], i) } } function Mw(t, e, i) { const n = i[i.length - 1].context, r = { node: t }; Object.assign(r, { context: n }); const s = e.condition; Fu(r, Ew, Cu(s.getTagName()), [s], i) } function Fw(t, e, i) { const n = i[i.length - 1].context.version; void 0 !== e.matchCase && t.setAttribute("matchCase", e.matchCase.toString()), Gw(n, t, e.propertyName), kw(n, t, "" + e.expression) } function Aw(t, e, i) { Gw(i[i.length - 1].context.version, t, e.propertyName) } function Ow(t, e, i) { const n = i[i.length - 1].context.version, r = Uw(n); Gw(n, t, e.propertyName); const s = du(r, "LowerBoundary"); t.appendChild(s), kw(n, s, "" + e.lowerBoundary); const o = du(r, "UpperBoundary"); t.appendChild(o), kw(n, o, "" + e.upperBoundary) } function Nw(t, e, i) { const n = i[i.length - 1].context.version; t.setAttribute("wildCard", e.wildCard), t.setAttribute("singleChar", e.singleChar), t.setAttribute("escapeChar", e.escapeChar), void 0 !== e.matchCase && t.setAttribute("matchCase", e.matchCase.toString()), Gw(n, t, e.propertyName), kw(n, t, "" + e.pattern) } function Dw(t, e, i, n) { const r = du(t, e); K_(r, n), i.appendChild(r) } function kw(t, e, i) { Dw(Uw(t), "Literal", e, i) } function Gw(t, e, i) { "2.0.0" === t ? Dw(aw[t], "ValueReference", e, i) : Dw(sw[t], "PropertyName", e, i) } function jw(t, e) { const i = du(F_, "TimeInstant"); t.appendChild(i); const n = du(F_, "timePosition"); i.appendChild(n), K_(n, e) } function Bw(t, e, i) { const n = i[i.length - 1], r = Object.assign({}, n); r.node = t, Fu(r, Ew, Cu("Query"), e, i) } function Uw(t) { let e; return e = "2.0.0" === t ? aw[t] : sw[t], e } const zw = 1, Xw = 2, Vw = 3, Ww = 4, Zw = 5, Yw = 6, Kw = 7, qw = 15, Hw = 16, $w = 17; class Jw { constructor(t) { this.view_ = t, this.pos_ = 0, this.initialized_ = !1, this.isLittleEndian_ = !1, this.hasZ_ = !1, this.hasM_ = !1, this.srid_ = null, this.layout_ = "XY" } readUint8() { return this.view_.getUint8(this.pos_++) } readUint32(t) { return this.view_.getUint32((this.pos_ += 4) - 4, void 0 !== t ? t : this.isLittleEndian_) } readDouble(t) { return this.view_.getFloat64((this.pos_ += 8) - 8, void 0 !== t ? t : this.isLittleEndian_) } readPoint() { const t = []; return t.push(this.readDouble()), t.push(this.readDouble()), this.hasZ_ && t.push(this.readDouble()), this.hasM_ && t.push(this.readDouble()), t } readLineString() { const t = this.readUint32(), e = []; for (let i = 0; i < t; i++)e.push(this.readPoint()); return e } readPolygon() { const t = this.readUint32(), e = []; for (let i = 0; i < t; i++)e.push(this.readLineString()); return e } readWkbHeader(t) { const e = this.readUint8() > 0, i = this.readUint32(e), n = Math.floor((268435455 & i) / 1e3), r = Boolean(2147483648 & i) || 1 === n || 3 === n, s = Boolean(1073741824 & i) || 2 === n || 3 === n, o = Boolean(536870912 & i), a = (268435455 & i) % 1e3, l = ["XY", r ? "Z" : "", s ? "M" : ""].join(""), h = o ? this.readUint32(e) : null; if (void 0 !== t && t !== a) throw new Error("Unexpected WKB geometry type " + a); if (this.initialized_) { if (this.isLittleEndian_ !== e) throw new Error("Inconsistent endian"); if (this.layout_ !== l) throw new Error("Inconsistent geometry layout"); if (h && this.srid_ !== h) throw new Error("Inconsistent coordinate system (SRID)") } else this.isLittleEndian_ = e, this.hasZ_ = r, this.hasM_ = s, this.layout_ = l, this.srid_ = h, this.initialized_ = !0; return a } readWkbPayload(t) { switch (t) { case zw: return this.readPoint(); case Xw: return this.readLineString(); case Vw: case $w: return this.readPolygon(); case Ww: return this.readMultiPoint(); case Zw: return this.readMultiLineString(); case Yw: case qw: case Hw: return this.readMultiPolygon(); case Kw: return this.readGeometryCollection(); default: throw new Error("Unsupported WKB geometry type " + t + " is found") } } readWkbBlock(t) { return this.readWkbPayload(this.readWkbHeader(t)) } readWkbCollection(t, e) { const i = this.readUint32(), n = []; for (let r = 0; r < i; r++) { const i = t.call(this, e); i && n.push(i) } return n } readMultiPoint() { return this.readWkbCollection(this.readWkbBlock, zw) } readMultiLineString() { return this.readWkbCollection(this.readWkbBlock, Xw) } readMultiPolygon() { return this.readWkbCollection(this.readWkbBlock, Vw) } readGeometryCollection() { return this.readWkbCollection(this.readGeometry) } readGeometry() { const t = this.readWkbHeader(), e = this.readWkbPayload(t); switch (t) { case zw: return new Wn(e, this.layout_); case Xw: return new Op(e, this.layout_); case Vw: case $w: return new ur(e, this.layout_); case Ww: return new Dp(e, this.layout_); case Zw: return new Np(e, this.layout_); case Yw: case qw: case Hw: return new Gp(e, this.layout_); case Kw: return new Ip(e); default: return null } } getSrid() { return this.srid_ } } class Qw { constructor(t) { t = t || {}, this.layout_ = t.layout, this.isLittleEndian_ = !1 !== t.littleEndian, this.isEWKB_ = !1 !== t.ewkb, this.writeQueue_ = [], this.nodata_ = Object.assign({ X: 0, Y: 0, Z: 0, M: 0 }, t.nodata) } writeUint8(t) { this.writeQueue_.push([1, t]) } writeUint32(t) { this.writeQueue_.push([4, t]) } writeDouble(t) { this.writeQueue_.push([8, t]) } writePoint(t, e) { const i = Object.assign.apply(null, e.split("").map(((e, i) => ({ [e]: t[i] })))); for (const t of this.layout_) this.writeDouble(t in i ? i[t] : this.nodata_[t]) } writeLineString(t, e) { this.writeUint32(t.length); for (let i = 0; i < t.length; i++)this.writePoint(t[i], e) } writePolygon(t, e) { this.writeUint32(t.length); for (let i = 0; i < t.length; i++)this.writeLineString(t[i], e) } writeWkbHeader(t, e) { t %= 1e3, this.layout_.includes("Z") && (t += this.isEWKB_ ? 2147483648 : 1e3), this.layout_.includes("M") && (t += this.isEWKB_ ? 1073741824 : 2e3), this.isEWKB_ && Number.isInteger(e) && (t |= 536870912), this.writeUint8(this.isLittleEndian_ ? 1 : 0), this.writeUint32(t), this.isEWKB_ && Number.isInteger(e) && this.writeUint32(e) } writeMultiPoint(t, e) { this.writeUint32(t.length); for (let i = 0; i < t.length; i++)this.writeWkbHeader(1), this.writePoint(t[i], e) } writeMultiLineString(t, e) { this.writeUint32(t.length); for (let i = 0; i < t.length; i++)this.writeWkbHeader(2), this.writeLineString(t[i], e) } writeMultiPolygon(t, e) { this.writeUint32(t.length); for (let i = 0; i < t.length; i++)this.writeWkbHeader(3), this.writePolygon(t[i], e) } writeGeometryCollection(t) { this.writeUint32(t.length); for (let e = 0; e < t.length; e++)this.writeGeometry(t[e]) } findMinimumLayout(t, e = "XYZM") { if (t instanceof _n) return (i = t.getLayout()) === (n = e) ? i : "XYZM" === i ? n : "XYZM" === n ? i : "XY"; var i, n; if (t instanceof Ip) { const i = t.getGeometriesArray(); for (let t = 0; t < i.length && "XY" !== e; t++)e = this.findMinimumLayout(i[t], e) } return e } writeGeometry(t, e) { const i = { Point: zw, LineString: Xw, Polygon: Vw, MultiPoint: Ww, MultiLineString: Zw, MultiPolygon: Yw, GeometryCollection: Kw }, n = t.getType(), r = i[n]; if (!r) throw new Error("GeometryType " + n + " is not supported"); if (this.layout_ || (this.layout_ = this.findMinimumLayout(t)), this.writeWkbHeader(r, e), t instanceof _n) { ({ Point: this.writePoint, LineString: this.writeLineString, Polygon: this.writePolygon, MultiPoint: this.writeMultiPoint, MultiLineString: this.writeMultiLineString, MultiPolygon: this.writeMultiPolygon })[n].call(this, t.getCoordinates(), t.getLayout()) } else t instanceof Ip && this.writeGeometryCollection(t.getGeometriesArray()) } getBuffer() { const t = this.writeQueue_.reduce(((t, e) => t + e[0]), 0), e = new ArrayBuffer(t), i = new DataView(e); let n = 0; return this.writeQueue_.forEach((t => { switch (t[0]) { case 1: i.setUint8(n, t[1]); break; case 4: i.setUint32(n, t[1], this.isLittleEndian_); break; case 8: i.setFloat64(n, t[1], this.isLittleEndian_) }n += t[0] })), e } } function tE(t) { return "string" == typeof t ? function (t) { const e = new Uint8Array(t.length / 2); for (let i = 0; i < t.length / 2; i++)e[i] = parseInt(t.substr(2 * i, 2), 16); return new DataView(e.buffer) }(t) : ArrayBuffer.isView(t) ? t instanceof DataView ? t : new DataView(t.buffer, t.byteOffset, t.byteLength) : t instanceof ArrayBuffer ? new DataView(t) : null } const eE = { POINT: Wn, LINESTRING: Op, POLYGON: ur, MULTIPOINT: Dp, MULTILINESTRING: Np, MULTIPOLYGON: Gp }, iE = "EMPTY", nE = 0, rE = 1, sE = 2, oE = 3, aE = 4, lE = 5, hE = 6, cE = { Point: "POINT", LineString: "LINESTRING", Polygon: "POLYGON", MultiPoint: "MULTIPOINT", MultiLineString: "MULTILINESTRING", MultiPolygon: "MULTIPOLYGON", GeometryCollection: "GEOMETRYCOLLECTION", Circle: "CIRCLE" }; class uE { constructor(t) { this.wkt = t, this.index_ = -1 } isAlpha_(t) { return t >= "a" && t <= "z" || t >= "A" && t <= "Z" } isNumeric_(t, e) { return e = void 0 !== e && e, t >= "0" && t <= "9" || "." == t && !e } isWhiteSpace_(t) { return " " == t || "\t" == t || "\r" == t || "\n" == t } nextChar_() { return this.wkt.charAt(++this.index_) } nextToken() { const t = this.nextChar_(), e = this.index_; let i, n = t; if ("(" == t) i = sE; else if ("," == t) i = lE; else if (")" == t) i = oE; else if (this.isNumeric_(t) || "-" == t) i = aE, n = this.readNumber_(); else if (this.isAlpha_(t)) i = rE, n = this.readText_(); else { if (this.isWhiteSpace_(t)) return this.nextToken(); if ("" !== t) throw new Error("Unexpected character: " + t); i = hE } return { position: e, value: n, type: i } } readNumber_() { let t; const e = this.index_; let i = !1, n = !1; do { "." == t ? i = !0 : "e" != t && "E" != t || (n = !0), t = this.nextChar_() } while (this.isNumeric_(t, i) || !n && ("e" == t || "E" == t) || n && ("-" == t || "+" == t)); return parseFloat(this.wkt.substring(e, this.index_--)) } readText_() { let t; const e = this.index_; do { t = this.nextChar_() } while (this.isAlpha_(t)); return this.wkt.substring(e, this.index_--).toUpperCase() } } class dE { constructor(t) { this.lexer_ = t, this.token_ = { position: 0, type: nE }, this.layout_ = "XY" } consume_() { this.token_ = this.lexer_.nextToken() } isTokenType(t) { return this.token_.type == t } match(t) { const e = this.isTokenType(t); return e && this.consume_(), e } parse() { return this.consume_(), this.parseGeometry_() } parseGeometryLayout_() { let t = "XY"; const e = this.token_; if (this.isTokenType(rE)) { const i = e.value; "Z" === i ? t = "XYZ" : "M" === i ? t = "XYM" : "ZM" === i && (t = "XYZM"), "XY" !== t && this.consume_() } return t } parseGeometryCollectionText_() { if (this.match(sE)) { const t = []; do { t.push(this.parseGeometry_()) } while (this.match(lE)); if (this.match(oE)) return t } throw new Error(this.formatErrorMessage_()) } parsePointText_() { if (this.match(sE)) { const t = this.parsePoint_(); if (this.match(oE)) return t } throw new Error(this.formatErrorMessage_()) } parseLineStringText_() { if (this.match(sE)) { const t = this.parsePointList_(); if (this.match(oE)) return t } throw new Error(this.formatErrorMessage_()) } parsePolygonText_() { if (this.match(sE)) { const t = this.parseLineStringTextList_(); if (this.match(oE)) return t } throw new Error(this.formatErrorMessage_()) } parseMultiPointText_() { if (this.match(sE)) { let t; if (t = this.token_.type == sE ? this.parsePointTextList_() : this.parsePointList_(), this.match(oE)) return t } throw new Error(this.formatErrorMessage_()) } parseMultiLineStringText_() { if (this.match(sE)) { const t = this.parseLineStringTextList_(); if (this.match(oE)) return t } throw new Error(this.formatErrorMessage_()) } parseMultiPolygonText_() { if (this.match(sE)) { const t = this.parsePolygonTextList_(); if (this.match(oE)) return t } throw new Error(this.formatErrorMessage_()) } parsePoint_() { const t = [], e = this.layout_.length; for (let i = 0; i < e; ++i) { const e = this.token_; if (!this.match(aE)) break; t.push(e.value) } if (t.length == e) return t; throw new Error(this.formatErrorMessage_()) } parsePointList_() { const t = [this.parsePoint_()]; for (; this.match(lE);)t.push(this.parsePoint_()); return t } parsePointTextList_() { const t = [this.parsePointText_()]; for (; this.match(lE);)t.push(this.parsePointText_()); return t } parseLineStringTextList_() { const t = [this.parseLineStringText_()]; for (; this.match(lE);)t.push(this.parseLineStringText_()); return t } parsePolygonTextList_() { const t = [this.parsePolygonText_()]; for (; this.match(lE);)t.push(this.parsePolygonText_()); return t } isEmptyGeometry_() { const t = this.isTokenType(rE) && this.token_.value == iE; return t && this.consume_(), t } formatErrorMessage_() { return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`" } parseGeometry_() { const t = this.token_; if (this.match(rE)) { const e = t.value; this.layout_ = this.parseGeometryLayout_(); const i = this.isEmptyGeometry_(); if ("GEOMETRYCOLLECTION" == e) { if (i) return new Ip([]); const t = this.parseGeometryCollectionText_(); return new Ip(t) } { const t = eE[e]; if (!t) throw new Error("Invalid geometry type: " + e); let n; if (i) n = "POINT" == e ? [NaN, NaN] : []; else switch (e) { case "POINT": n = this.parsePointText_(); break; case "LINESTRING": n = this.parseLineStringText_(); break; case "POLYGON": n = this.parsePolygonText_(); break; case "MULTIPOINT": n = this.parseMultiPointText_(); break; case "MULTILINESTRING": n = this.parseMultiLineStringText_(); break; case "MULTIPOLYGON": n = this.parseMultiPolygonText_() }return new t(n, this.layout_) } } throw new Error(this.formatErrorMessage_()) } } function gE(t) { const e = t.getCoordinates(); return 0 === e.length ? "" : e.join(" ") } function fE(t) { const e = t.getCoordinates(), i = []; for (let t = 0, n = e.length; t < n; ++t)i.push(e[t].join(" ")); return i.join(",") } function pE(t) { const e = [], i = t.getLinearRings(); for (let t = 0, n = i.length; t < n; ++t)e.push("(" + fE(i[t]) + ")"); return e.join(",") } const mE = { Point: gE, LineString: fE, Polygon: pE, MultiPoint: function (t) { const e = [], i = t.getPoints(); for (let t = 0, n = i.length; t < n; ++t)e.push("(" + gE(i[t]) + ")"); return e.join(",") }, MultiLineString: function (t) { const e = [], i = t.getLineStrings(); for (let t = 0, n = i.length; t < n; ++t)e.push("(" + fE(i[t]) + ")"); return e.join(",") }, MultiPolygon: function (t) { const e = [], i = t.getPolygons(); for (let t = 0, n = i.length; t < n; ++t)e.push("(" + pE(i[t]) + ")"); return e.join(",") }, GeometryCollection: function (t) { const e = [], i = t.getGeometries(); for (let t = 0, n = i.length; t < n; ++t)e.push(_E(i[t])); return e.join(",") } }; function _E(t) { const e = t.getType(), i = (0, mE[e])(t); let n = cE[e]; if ("function" == typeof t.getFlatCoordinates) { const e = function (t) { const e = t.getLayout(); let i = ""; return "XYZ" !== e && "XYZM" !== e || (i += "Z"), "XYM" !== e && "XYZM" !== e || (i += "M"), i }(t); e.length > 0 && (n += " " + e) } return 0 === i.length ? n + " " + iE : n + "(" + i + ")" } const yE = [null, "http://www.opengis.net/wms"], xE = Pu(yE, { Service: wu((function (t, e) { return Lu({}, SE, t, e) })), Capability: wu((function (t, e) { return Lu({}, vE, t, e) })) }), vE = Pu(yE, { Request: wu((function (t, e) { return Lu({}, IE, t, e) })), Exception: wu((function (t, e) { return Lu([], CE, t, e) })), Layer: wu((function (t, e) { const i = Lu({}, bE, t, e); if (void 0 === i.Layer) return Object.assign(i, DE(t, e)); return i })) }); const SE = Pu(yE, { Name: wu(z_), Title: wu(z_), Abstract: wu(z_), KeywordList: wu(BE), OnlineResource: wu(Yv), ContactInformation: wu((function (t, e) { return Lu({}, wE, t, e) })), Fees: wu(z_), AccessConstraints: wu(z_), LayerLimit: wu(B_), MaxWidth: wu(B_), MaxHeight: wu(B_) }), wE = Pu(yE, { ContactPersonPrimary: wu((function (t, e) { return Lu({}, EE, t, e) })), ContactPosition: wu(z_), ContactAddress: wu((function (t, e) { return Lu({}, TE, t, e) })), ContactVoiceTelephone: wu(z_), ContactFacsimileTelephone: wu(z_), ContactElectronicMailAddress: wu(z_) }), EE = Pu(yE, { ContactPerson: wu(z_), ContactOrganization: wu(z_) }), TE = Pu(yE, { AddressType: wu(z_), Address: wu(z_), City: wu(z_), StateOrProvince: wu(z_), PostCode: wu(z_), Country: wu(z_) }), CE = Pu(yE, { Format: xu(z_) }), bE = Pu(yE, { Name: wu(z_), Title: wu(z_), Abstract: wu(z_), KeywordList: wu(BE), CRS: Su(z_), EX_GeographicBoundingBox: wu((function (t, e) { const i = Lu({}, PE, t, e); if (!i) return; const n = i.westBoundLongitude, r = i.southBoundLatitude, s = i.eastBoundLongitude, o = i.northBoundLatitude; if (void 0 === n || void 0 === r || void 0 === s || void 0 === o) return; return [n, r, s, o] })), BoundingBox: Su((function (t, e) { const i = [j_(t.getAttribute("minx")), j_(t.getAttribute("miny")), j_(t.getAttribute("maxx")), j_(t.getAttribute("maxy"))], n = [j_(t.getAttribute("resx")), j_(t.getAttribute("resy"))]; return { crs: t.getAttribute("CRS"), extent: i, res: n } })), Dimension: Su((function (t, e) { return { name: t.getAttribute("name"), units: t.getAttribute("units"), unitSymbol: t.getAttribute("unitSymbol"), default: t.getAttribute("default"), multipleValues: D_(t.getAttribute("multipleValues")), nearestValue: D_(t.getAttribute("nearestValue")), current: D_(t.getAttribute("current")), values: z_(t) } })), Attribution: wu((function (t, e) { return Lu({}, RE, t, e) })), AuthorityURL: Su((function (t, e) { const i = kE(t, e); if (i) return i.name = t.getAttribute("name"), i; return })), Identifier: Su(z_), MetadataURL: Su((function (t, e) { const i = kE(t, e); if (i) return i.type = t.getAttribute("type"), i; return })), DataURL: Su(kE), FeatureListURL: Su(kE), Style: Su((function (t, e) { return Lu({}, AE, t, e) })), MinScaleDenominator: wu(G_), MaxScaleDenominator: wu(G_), Layer: Su(DE) }), RE = Pu(yE, { Title: wu(z_), OnlineResource: wu(Yv), LogoURL: wu(jE) }), PE = Pu(yE, { westBoundLongitude: wu(G_), eastBoundLongitude: wu(G_), southBoundLatitude: wu(G_), northBoundLatitude: wu(G_) }), IE = Pu(yE, { GetCapabilities: wu(GE), GetMap: wu(GE), GetFeatureInfo: wu(GE) }), LE = Pu(yE, { Format: Su(z_), DCPType: Su((function (t, e) { return Lu({}, ME, t, e) })) }), ME = Pu(yE, { HTTP: wu((function (t, e) { return Lu({}, FE, t, e) })) }), FE = Pu(yE, { Get: wu(kE), Post: wu(kE) }), AE = Pu(yE, { Name: wu(z_), Title: wu(z_), Abstract: wu(z_), LegendURL: Su(jE), StyleSheetURL: wu(kE), StyleURL: wu(kE) }), OE = Pu(yE, { Format: wu(z_), OnlineResource: wu(Yv) }), NE = Pu(yE, { Keyword: xu(z_) }); function DE(t, e) { const i = e[e.length - 1], n = Lu({}, bE, t, e); if (!n) return; let r = D_(t.getAttribute("queryable")); void 0 === r && (r = i.queryable), n.queryable = void 0 !== r && r; let s = U_(t.getAttribute("cascaded")); void 0 === s && (s = i.cascaded), n.cascaded = s; let o = D_(t.getAttribute("opaque")); void 0 === o && (o = i.opaque), n.opaque = void 0 !== o && o; let a = D_(t.getAttribute("noSubsets")); void 0 === a && (a = i.noSubsets), n.noSubsets = void 0 !== a && a; let l = j_(t.getAttribute("fixedWidth")); l || (l = i.fixedWidth), n.fixedWidth = l; let h = j_(t.getAttribute("fixedHeight")); h || (h = i.fixedHeight), n.fixedHeight = h;["Style", "CRS", "AuthorityURL"].forEach((function (t) { if (t in i) { const e = n[t] || []; n[t] = e.concat(i[t]) } })); return ["EX_GeographicBoundingBox", "BoundingBox", "Dimension", "Attribution", "MinScaleDenominator", "MaxScaleDenominator"].forEach((function (t) { if (!(t in n)) { const e = i[t]; n[t] = e } })), n } function kE(t, e) { return Lu({}, OE, t, e) } function GE(t, e) { return Lu({}, LE, t, e) } function jE(t, e) { const i = kE(t, e); if (i) { const e = [U_(t.getAttribute("width")), U_(t.getAttribute("height"))]; return i.size = e, i } } function BE(t, e) { return Lu([], NE, t, e) } const UE = [null, "http://www.opengis.net/wmts/1.0"], zE = [null, "http://www.opengis.net/ows/1.1"], XE = Pu(UE, { Contents: wu((function (t, e) { return Lu({}, VE, t, e) })) }); const VE = Pu(UE, { Layer: Su((function (t, e) { return Lu({}, WE, t, e) })), TileMatrixSet: Su((function (t, e) { return Lu({}, JE, t, e) })) }), WE = Pu(UE, { Style: Su((function (t, e) { const i = Lu({}, ZE, t, e); if (!i) return; const n = "true" === t.getAttribute("isDefault"); return i.isDefault = n, i })), Format: Su(z_), TileMatrixSetLink: Su((function (t, e) { return Lu({}, YE, t, e) })), Dimension: Su((function (t, e) { return Lu({}, HE, t, e) })), ResourceURL: Su((function (t, e) { const i = t.getAttribute("format"), n = t.getAttribute("template"), r = t.getAttribute("resourceType"), s = {}; i && (s.format = i); n && (s.template = n); r && (s.resourceType = r); return s })) }, Pu(zE, { Title: wu(z_), Abstract: wu(z_), WGS84BoundingBox: wu(tT), Identifier: wu(z_) })), ZE = Pu(UE, { LegendURL: Su((function (t, e) { const i = {}; return i.format = t.getAttribute("format"), i.href = Yv(t), i })) }, Pu(zE, { Title: wu(z_), Identifier: wu(z_) })), YE = Pu(UE, { TileMatrixSet: wu(z_), TileMatrixSetLimits: wu((function (t, e) { return Lu([], KE, t, e) })) }), KE = Pu(UE, { TileMatrixLimits: xu((function (t, e) { return Lu({}, qE, t, e) })) }), qE = Pu(UE, { TileMatrix: wu(z_), MinTileRow: wu(B_), MaxTileRow: wu(B_), MinTileCol: wu(B_), MaxTileCol: wu(B_) }), HE = Pu(UE, { Default: wu(z_), Value: Su(z_) }, Pu(zE, { Identifier: wu(z_) })), $E = Pu(zE, { LowerCorner: xu(eT), UpperCorner: xu(eT) }), JE = Pu(UE, { WellKnownScaleSet: wu(z_), TileMatrix: Su((function (t, e) { return Lu({}, QE, t, e) })) }, Pu(zE, { SupportedCRS: wu(z_), Identifier: wu(z_), BoundingBox: wu(tT) })), QE = Pu(UE, { TopLeftCorner: wu(eT), ScaleDenominator: wu(G_), TileWidth: wu(B_), TileHeight: wu(B_), MatrixWidth: wu(B_), MatrixHeight: wu(B_) }, Pu(zE, { Identifier: wu(z_) })); function tT(t, e) { const i = Lu([], $E, t, e); if (2 == i.length) return zt(i) } function eT(t, e) { const i = z_(t).split(/\s+/); if (!i || 2 != i.length) return; const n = +i[0], r = +i[1]; return isNaN(n) || isNaN(r) ? void 0 : [n, r] } const iT = ["fullscreenchange", "webkitfullscreenchange", "MSFullscreenChange"], nT = "enterfullscreen", rT = "leavefullscreen"; function sT(t) { const e = t.body; return !!(e.webkitRequestFullscreen || e.requestFullscreen && t.fullscreenEnabled) } function oT(t) { return !(!t.webkitIsFullScreen && !t.fullscreenElement) } function aT(t) { t.requestFullscreen ? t.requestFullscreen() : t.webkitRequestFullscreen && t.webkitRequestFullscreen() } const lT = "projection", hT = "coordinateFormat"; const cT = .75, uT = .1; const dT = "units", gT = [1, 2, 5], fT = 25.4 / .28; const pT = 0, mT = 1; var _T = {}; return _T.AssertionError = e, _T.Collection = q, _T.Collection.CollectionEvent = K, _T.DataTile = ot, _T.Disposable = s, _T.Feature = lt, _T.Feature.createStyleFunction = ht, _T.Geolocation = class extends V { constructor(t) { super(), this.on, this.once, this.un, t = t || {}, this.position_ = null, this.transform_ = Gi, this.watchId_ = void 0, this.addChangeListener(wr, this.handleProjectionChanged_), this.addChangeListener(Tr, this.handleTrackingChanged_), void 0 !== t.projection && this.setProjection(t.projection), void 0 !== t.trackingOptions && this.setTrackingOptions(t.trackingOptions), this.setTracking(void 0 !== t.tracking && t.tracking) } disposeInternal() { this.setTracking(!1), super.disposeInternal() } handleProjectionChanged_() { const t = this.getProjection(); t && (this.transform_ = qi(Ui("EPSG:4326"), t), this.position_ && this.set(Sr, this.transform_(this.position_))) } handleTrackingChanged_() { if ("geolocation" in navigator) { const t = this.getTracking(); t && void 0 === this.watchId_ ? this.watchId_ = navigator.geolocation.watchPosition(this.positionChange_.bind(this), this.positionError_.bind(this), this.getTrackingOptions()) : t || void 0 === this.watchId_ || (navigator.geolocation.clearWatch(this.watchId_), this.watchId_ = void 0) } } positionChange_(t) { const e = t.coords; this.set(mr, e.accuracy), this.set(yr, null === e.altitude ? void 0 : e.altitude), this.set(xr, null === e.altitudeAccuracy ? void 0 : e.altitudeAccuracy), this.set(vr, null === e.heading ? void 0 : ai(e.heading)), this.position_ ? (this.position_[0] = e.longitude, this.position_[1] = e.latitude) : this.position_ = [e.longitude, e.latitude]; const i = this.transform_(this.position_); this.set(Sr, i), this.set(Er, null === e.speed ? void 0 : e.speed); const n = dr(this.position_, e.accuracy); n.applyTransform(this.transform_), this.set(_r, n), this.changed() } positionError_(t) { this.dispatchEvent(new br(t)) } getAccuracy() { return this.get(mr) } getAccuracyGeometry() { return this.get(_r) || null } getAltitude() { return this.get(yr) } getAltitudeAccuracy() { return this.get(xr) } getHeading() { return this.get(vr) } getPosition() { return this.get(Sr) } getProjection() { return this.get(wr) } getSpeed() { return this.get(Er) } getTracking() { return this.get(Tr) } getTrackingOptions() { return this.get(Cr) } setProjection(t) { this.set(wr, Ui(t)) } setTracking(t) { this.set(Tr, t) } setTrackingOptions(t) { this.set(Cr, t) } }, _T.Image = Ar, _T.Image.listenImage = Or, _T.ImageBase = Rr, _T.ImageCanvas = Nr, _T.ImageTile = Vr, _T.Kinetic = Wr, _T.Map = Ya, _T.MapBrowserEvent = oo, _T.MapBrowserEventHandler = go, _T.MapEvent = so, _T.Object = V, _T.Object.ObjectEvent = X, _T.Observable = G, _T.Observable.unByKey = j, _T.Overlay = Qa, _T.Tile = st, _T.TileCache = ll, _T.TileQueue = Co, _T.TileQueue.getTilePriority = bo, _T.TileRange = hl, _T.TileRange.createOrUpdate = cl, _T.VectorRenderTile = dl, _T.VectorTile = gl, _T.View = zo, _T.View.createCenterConstraint = Vo, _T.View.createResolutionConstraint = Wo, _T.View.createRotationConstraint = Zo, _T.View.isNoopAnimation = Yo, _T.array = {}, _T.array.binarySearch = o, _T.array.equals = u, _T.array.extend = c, _T.array.isSorted = d, _T.array.linearFindNearest = l, _T.array.numberSafeCompareFunction = a, _T.array.remove = function (t, e) { const i = t.indexOf(e), n = i > -1; return n && t.splice(i, 1), n }, _T.array.reverseSubArray = h, _T.array.stableSort = function (t, e) { const i = t.length, n = Array(t.length); let r; for (r = 0; r < i; r++)n[r] = { index: r, value: t[r] }; for (n.sort((function (t, i) { return e(t.value, i.value) || t.index - i.index })), r = 0; r < t.length; r++)t[r] = n[r].value }, _T.asserts = {}, _T.asserts.assert = at, _T.centerconstraint = {}, _T.centerconstraint.createExtent = Mo, _T.centerconstraint.none = Fo, _T.color = {}, _T.color.asArray = $r, _T.color.asString = Kr, _T.color.fromString = Hr, _T.color.isStringColor = ts, _T.color.normalize = Jr, _T.color.toString = Qr, _T.colorlike = {}, _T.colorlike.asColorLike = fl, _T.control = {}, _T.control.Attribution = Ho, _T.control.Control = qo, _T.control.FullScreen = class extends qo { constructor(t) { t = t || {}, super({ element: document.createElement("div"), target: t.target }), this.on, this.once, this.un, this.keys_ = void 0 !== t.keys && t.keys, this.source_ = t.source, this.isInFullscreen_ = !1, this.boundHandleMapTargetChange_ = this.handleMapTargetChange_.bind(this), this.cssClassName_ = void 0 !== t.className ? t.className : "ol-full-screen", this.documentListeners_ = [], this.activeClassName_ = void 0 !== t.activeClassName ? t.activeClassName.split(" ") : [this.cssClassName_ + "-true"], this.inactiveClassName_ = void 0 !== t.inactiveClassName ? t.inactiveClassName.split(" ") : [this.cssClassName_ + "-false"]; const e = void 0 !== t.label ? t.label : "⤢"; this.labelNode_ = "string" == typeof e ? document.createTextNode(e) : e; const i = void 0 !== t.labelActive ? t.labelActive : "×"; this.labelActiveNode_ = "string" == typeof i ? document.createTextNode(i) : i; const n = t.tipLabel ? t.tipLabel : "Toggle full-screen"; this.button_ = document.createElement("button"), this.button_.title = n, this.button_.setAttribute("type", "button"), this.button_.appendChild(this.labelNode_), this.button_.addEventListener(T, this.handleClick_.bind(this), !1), this.setClassName_(this.button_, this.isInFullscreen_), this.element.className = `${this.cssClassName_} ol-unselectable ol-control`, this.element.appendChild(this.button_) } handleClick_(t) { t.preventDefault(), this.handleFullScreen_() } handleFullScreen_() { const t = this.getMap(); if (!t) return; const e = t.getOwnerDocument(); if (sT(e)) if (oT(e)) !function (t) { t.exitFullscreen ? t.exitFullscreen() : t.webkitExitFullscreen && t.webkitExitFullscreen() }(e); else { let i; i = this.source_ ? "string" == typeof this.source_ ? e.getElementById(this.source_) : this.source_ : t.getTargetElement(), this.keys_ ? function (t) { t.webkitRequestFullscreen ? t.webkitRequestFullscreen() : aT(t) }(i) : aT(i) } } handleFullScreenChange_() { const t = this.getMap(); if (!t) return; const e = this.isInFullscreen_; this.isInFullscreen_ = oT(t.getOwnerDocument()), e !== this.isInFullscreen_ && (this.setClassName_(this.button_, this.isInFullscreen_), this.isInFullscreen_ ? (Br(this.labelActiveNode_, this.labelNode_), this.dispatchEvent(nT)) : (Br(this.labelNode_, this.labelActiveNode_), this.dispatchEvent(rT)), t.updateSize()) } setClassName_(t, e) { e ? (t.classList.remove(...this.inactiveClassName_), t.classList.add(...this.activeClassName_)) : (t.classList.remove(...this.activeClassName_), t.classList.add(...this.inactiveClassName_)) } setMap(t) { const e = this.getMap(); e && e.removeChangeListener(So, this.boundHandleMapTargetChange_), super.setMap(t), this.handleMapTargetChange_(), t && t.addChangeListener(So, this.boundHandleMapTargetChange_) } handleMapTargetChange_() { const t = this.documentListeners_; for (let e = 0, i = t.length; e < i; ++e)k(t[e]); t.length = 0; const e = this.getMap(); if (e) { const i = e.getOwnerDocument(); sT(i) ? this.element.classList.remove(Ps) : this.element.classList.add(Ps); for (let e = 0, n = iT.length; e < n; ++e)t.push(N(i, iT[e], this.handleFullScreenChange_, this)); this.handleFullScreenChange_() } } }, _T.control.MousePosition = class extends qo { constructor(t) { t = t || {}; const e = document.createElement("div"); e.className = void 0 !== t.className ? t.className : "ol-mouse-position", super({ element: e, render: t.render, target: t.target }), this.on, this.once, this.un, this.addChangeListener(lT, this.handleProjectionChanged_), t.coordinateFormat && this.setCoordinateFormat(t.coordinateFormat), t.projection && this.setProjection(t.projection), this.renderOnMouseOut_ = void 0 !== t.placeholder, this.placeholder_ = this.renderOnMouseOut_ ? t.placeholder : "&#160;", this.renderedHTML_ = e.innerHTML, this.mapProjection_ = null, this.transform_ = null } handleProjectionChanged_() { this.transform_ = null } getCoordinateFormat() { return this.get(hT) } getProjection() { return this.get(lT) } handleMouseMove(t) { const e = this.getMap(); this.updateHTML_(e.getEventPixel(t)) } handleMouseOut(t) { this.updateHTML_(null) } setMap(t) { if (super.setMap(t), t) { const e = t.getViewport(); this.listenerKeys.push(N(e, lo, this.handleMouseMove, this)), this.renderOnMouseOut_ && this.listenerKeys.push(N(e, uo, this.handleMouseOut, this)), this.updateHTML_(null) } } setCoordinateFormat(t) { this.set(hT, t) } setProjection(t) { this.set(lT, Ui(t)) } updateHTML_(t) { let e = this.placeholder_; if (t && this.mapProjection_) { if (!this.transform_) { const t = this.getProjection(); this.transform_ = t ? qi(this.mapProjection_, t) : Gi } const i = this.getMap().getCoordinateFromPixelInternal(t); if (i) { const t = en(); t && (this.transform_ = qi(this.mapProjection_, t)), this.transform_(i, i); const n = this.getCoordinateFormat(); e = n ? n(i) : i.toString() } } this.renderedHTML_ && e === this.renderedHTML_ || (this.element.innerHTML = e, this.renderedHTML_ = e) } render(t) { const e = t.frameState; e ? this.mapProjection_ != e.viewState.projection && (this.mapProjection_ = e.viewState.projection, this.transform_ = null) : this.mapProjection_ = null } }, _T.control.OverviewMap = class extends qo { constructor(t) { t = t || {}, super({ element: document.createElement("div"), render: t.render, target: t.target }), this.boundHandleRotationChanged_ = this.handleRotationChanged_.bind(this), this.collapsed_ = void 0 === t.collapsed || t.collapsed, this.collapsible_ = void 0 === t.collapsible || t.collapsible, this.collapsible_ || (this.collapsed_ = !1), this.rotateWithView_ = void 0 !== t.rotateWithView && t.rotateWithView, this.viewExtent_ = void 0; const e = void 0 !== t.className ? t.className : "ol-overviewmap", i = void 0 !== t.tipLabel ? t.tipLabel : "Overview map", n = void 0 !== t.collapseLabel ? t.collapseLabel : "‹"; "string" == typeof n ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = n) : this.collapseLabel_ = n; const r = void 0 !== t.label ? t.label : "›"; "string" == typeof r ? (this.label_ = document.createElement("span"), this.label_.textContent = r) : this.label_ = r; const s = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_, o = document.createElement("button"); o.setAttribute("type", "button"), o.title = i, o.appendChild(s), o.addEventListener(T, this.handleClick_.bind(this), !1), this.ovmapDiv_ = document.createElement("div"), this.ovmapDiv_.className = "ol-overviewmap-map", this.view_ = t.view; const a = new Ya({ view: t.view, controls: new q, interactions: new q }); this.ovmap_ = a, t.layers && t.layers.forEach((function (t) { a.addLayer(t) })); const l = document.createElement("div"); l.className = "ol-overviewmap-box", l.style.boxSizing = "border-box", this.boxOverlay_ = new Qa({ position: [0, 0], positioning: "center-center", element: l }), this.ovmap_.addOverlay(this.boxOverlay_); const h = e + " " + "ol-unselectable " + Is + (this.collapsed_ && this.collapsible_ ? " ol-collapsed" : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), c = this.element; c.className = h, c.appendChild(this.ovmapDiv_), c.appendChild(o); const u = this, d = this.boxOverlay_, g = this.boxOverlay_.getElement(), f = function (t) { const e = { clientX: (i = t).clientX, clientY: i.clientY }; var i; const n = a.getEventCoordinateInternal(e); d.setPosition(n) }, p = function (t) { const e = a.getEventCoordinateInternal(t); u.getMap().getView().setCenterInternal(e), window.removeEventListener("mousemove", f), window.removeEventListener("mouseup", p) }; g.addEventListener("mousedown", (function () { window.addEventListener("mousemove", f), window.addEventListener("mouseup", p) })) } setMap(t) { const e = this.getMap(); if (t !== e) { if (e) { const t = e.getView(); t && this.unbindView_(t), this.ovmap_.setTarget(null) } if (super.setMap(t), t) { this.ovmap_.setTarget(this.ovmapDiv_), this.listenerKeys.push(N(t, r, this.handleMapPropertyChange_, this)); const e = t.getView(); e && (this.bindView_(e), e.isDef() && (this.ovmap_.updateSize(), this.resetExtent_())), this.ovmap_.isRendered() || this.updateBoxAfterOvmapIsRendered_() } } } handleMapPropertyChange_(t) { if (t.key === wo) { const e = t.oldValue; e && this.unbindView_(e); const i = this.getMap().getView(); this.bindView_(i) } else this.ovmap_.isRendered() || t.key !== So && t.key !== vo || this.ovmap_.updateSize() } bindView_(t) { if (!this.view_) { const e = new zo({ projection: t.getProjection() }); this.ovmap_.setView(e) } t.addChangeListener(Io.ROTATION, this.boundHandleRotationChanged_), this.handleRotationChanged_() } unbindView_(t) { t.removeChangeListener(Io.ROTATION, this.boundHandleRotationChanged_) } handleRotationChanged_() { this.rotateWithView_ && this.ovmap_.getView().setRotation(this.getMap().getView().getRotation()) } validateExtent_() { const t = this.getMap(), e = this.ovmap_; if (!t.isRendered() || !e.isRendered()) return; const i = t.getSize(), n = t.getView().calculateExtentInternal(i); if (this.viewExtent_ && ee(n, this.viewExtent_)) return; this.viewExtent_ = n; const r = e.getSize(), s = e.getView().calculateExtentInternal(r), o = e.getPixelFromCoordinateInternal(xe(n)), a = e.getPixelFromCoordinateInternal(de(n)), l = Math.abs(o[0] - a[0]), h = Math.abs(o[1] - a[1]), c = r[0], u = r[1]; l < c * uT || h < u * uT || l > c * cT || h > u * cT ? this.resetExtent_() : Yt(s, n) || this.recenter_() } resetExtent_() { const t = this.getMap(), e = this.ovmap_, i = t.getSize(), n = t.getView().calculateExtentInternal(i), r = e.getView(), s = Math.log(7.5) / Math.LN2; Ce(n, 1 / (Math.pow(2, s / 2) * uT)), r.fitInternal(gr(n)) } recenter_() { const t = this.getMap(), e = this.ovmap_, i = t.getView(); e.getView().setCenterInternal(i.getCenterInternal()) } updateBox_() { const t = this.getMap(), e = this.ovmap_; if (!t.isRendered() || !e.isRendered()) return; const i = t.getSize(), n = t.getView(), r = e.getView(), s = this.rotateWithView_ ? 0 : -n.getRotation(), o = this.boxOverlay_, a = this.boxOverlay_.getElement(), l = n.getCenterInternal(), h = n.getResolution(), c = r.getResolution(), u = i[0] * h / c, d = i[1] * h / c; if (o.setPosition(l), a) { a.style.width = u + "px", a.style.height = d + "px"; const t = "rotate(" + s + "rad)"; a.style.transform = t } } updateBoxAfterOvmapIsRendered_() { this.ovmapPostrenderKey_ || (this.ovmapPostrenderKey_ = D(this.ovmap_, fo, (function (t) { delete this.ovmapPostrenderKey_, this.updateBox_() }), this)) } handleClick_(t) { t.preventDefault(), this.handleToggle_() } handleToggle_() { this.element.classList.toggle(Ls), this.collapsed_ ? Br(this.collapseLabel_, this.label_) : Br(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_; const t = this.ovmap_; if (!this.collapsed_) { if (t.isRendered()) return this.viewExtent_ = void 0, void t.render(); t.updateSize(), this.resetExtent_(), this.updateBoxAfterOvmapIsRendered_() } } getCollapsible() { return this.collapsible_ } setCollapsible(t) { this.collapsible_ !== t && (this.collapsible_ = t, this.element.classList.toggle("ol-uncollapsible"), !t && this.collapsed_ && this.handleToggle_()) } setCollapsed(t) { this.collapsible_ && this.collapsed_ !== t && this.handleToggle_() } getCollapsed() { return this.collapsed_ } getRotateWithView() { return this.rotateWithView_ } setRotateWithView(t) { this.rotateWithView_ !== t && (this.rotateWithView_ = t, 0 !== this.getMap().getView().getRotation() && (this.rotateWithView_ ? this.handleRotationChanged_() : this.ovmap_.getView().setRotation(0), this.viewExtent_ = void 0, this.validateExtent_(), this.updateBox_())) } getOverviewMap() { return this.ovmap_ } render(t) { this.validateExtent_(), this.updateBox_() } }, _T.control.Rotate = $o, _T.control.ScaleLine = class extends qo { constructor(t) { t = t || {}; const e = document.createElement("div"); e.style.pointerEvents = "none", super({ element: e, render: t.render, target: t.target }), this.on, this.once, this.un; const i = void 0 !== t.className ? t.className : t.bar ? "ol-scale-bar" : "ol-scale-line"; this.innerElement_ = document.createElement("div"), this.innerElement_.className = i + "-inner", this.element.className = i + " " + Rs, this.element.appendChild(this.innerElement_), this.viewState_ = null, this.minWidth_ = void 0 !== t.minWidth ? t.minWidth : 64, this.maxWidth_ = t.maxWidth, this.renderedVisible_ = !1, this.renderedWidth_ = void 0, this.renderedHTML_ = "", this.addChangeListener(dT, this.handleUnitsChanged_), this.setUnits(t.units || "metric"), this.scaleBar_ = t.bar || !1, this.scaleBarSteps_ = t.steps || 4, this.scaleBarText_ = t.text || !1, this.dpi_ = t.dpi || void 0 } getUnits() { return this.get(dT) } handleUnitsChanged_() { this.updateElement_() } setUnits(t) { this.set(dT, t) } setDpi(t) { this.dpi_ = t } updateElement_() { const t = this.viewState_; if (!t) return void (this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1)); const e = t.center, i = t.projection, n = this.getUnits(), r = "degrees" == n ? "degrees" : "m"; let s = zi(i, t.resolution, e, r); const o = this.minWidth_ * (this.dpi_ || fT) / fT, a = void 0 !== this.maxWidth_ ? this.maxWidth_ * (this.dpi_ || fT) / fT : void 0; let l = o * s, h = ""; if ("degrees" == n) { const t = Fe.degrees; l *= t, l < t / 60 ? (h = "″", s *= 3600) : l < t ? (h = "′", s *= 60) : h = "°" } else "imperial" == n ? l < .9144 ? (h = "in", s /= .0254) : l < 1609.344 ? (h = "ft", s /= .3048) : (h = "mi", s /= 1609.344) : "nautical" == n ? (s /= 1852, h = "NM") : "metric" == n ? l < .001 ? (h = "μm", s *= 1e6) : l < 1 ? (h = "mm", s *= 1e3) : l < 1e3 ? h = "m" : (h = "km", s /= 1e3) : "us" == n ? l < .9144 ? (h = "in", s *= 39.37) : l < 1609.344 ? (h = "ft", s /= .30480061) : (h = "mi", s /= 1609.3472) : at(!1, 33); let c, u, d, g, f, p, m = 3 * Math.floor(Math.log(o * s) / Math.log(10)); for (; ;) { d = Math.floor(m / 3); const t = Math.pow(10, d); if (c = gT[(m % 3 + 3) % 3] * t, u = Math.round(c / s), isNaN(u)) return this.element.style.display = "none", void (this.renderedVisible_ = !1); if (void 0 !== a && u >= a) { c = g, u = f, d = p; break } if (u >= o) break; g = c, f = u, p = d, ++m } const _ = this.scaleBar_ ? this.createScaleBar(u, c, h) : c.toFixed(d < 0 ? -d : 0) + " " + h; this.renderedHTML_ != _ && (this.innerElement_.innerHTML = _, this.renderedHTML_ = _), this.renderedWidth_ != u && (this.innerElement_.style.width = u + "px", this.renderedWidth_ = u), this.renderedVisible_ || (this.element.style.display = "", this.renderedVisible_ = !0) } createScaleBar(t, e, i) { const n = this.getScaleForResolution(), r = n < 1 ? Math.round(1 / n).toLocaleString() + " : 1" : "1 : " + Math.round(n).toLocaleString(), s = this.scaleBarSteps_, o = t / s, a = [this.createMarker("absolute")]; for (let n = 0; n < s; ++n) { const r = n % 2 == 0 ? "ol-scale-singlebar-odd" : "ol-scale-singlebar-even"; a.push(`<div><div class="ol-scale-singlebar ${r}" style="width: ${o}px;"></div>` + this.createMarker("relative") + (n % 2 == 0 || 2 === s ? this.createStepText(n, t, !1, e, i) : "") + "</div>") } a.push(this.createStepText(s, t, !0, e, i)); return (this.scaleBarText_ ? `<div class="ol-scale-text" style="width: ${t}px;">` + r + "</div>" : "") + a.join("") } createMarker(t) { return `<div class="ol-scale-step-marker" style="position: ${t}; top: ${"absolute" === t ? 3 : -10}px;"></div>` } createStepText(t, e, i, n, r) { const s = (0 === t ? 0 : Math.round(n / this.scaleBarSteps_ * t * 100) / 100) + (0 === t ? "" : " " + r); return `<div class="ol-scale-step-text" style="margin-left: ${0 === t ? -3 : e / this.scaleBarSteps_ * -1}px;text-align: ${0 === t ? "left" : "center"};min-width: ${0 === t ? 0 : e / this.scaleBarSteps_ * 2}px;left: ${i ? e + "px" : "unset"};">` + s + "</div>" } getScaleForResolution() { return zi(this.viewState_.projection, this.viewState_.resolution, this.viewState_.center, "m") * (1e3 / 25.4) * (this.dpi_ || fT) } render(t) { const e = t.frameState; this.viewState_ = e ? e.viewState : null, this.updateElement_() } }, _T.control.Zoom = Jo, _T.control.ZoomSlider = class extends qo { constructor(t) { t = t || {}, super({ element: document.createElement("div"), render: t.render }), this.dragListenerKeys_ = [], this.currentResolution_ = void 0, this.direction_ = pT, this.dragging_, this.heightLimit_ = 0, this.widthLimit_ = 0, this.startX_, this.startY_, this.thumbSize_ = null, this.sliderInitialized_ = !1, this.duration_ = void 0 !== t.duration ? t.duration : 200; const e = void 0 !== t.className ? t.className : "ol-zoomslider", i = document.createElement("button"); i.setAttribute("type", "button"), i.className = e + "-thumb " + Rs; const r = this.element; r.className = e + " " + "ol-unselectable " + Is, r.appendChild(i), r.addEventListener(ho, this.handleDraggerStart_.bind(this), !1), r.addEventListener(lo, this.handleDraggerDrag_.bind(this), !1), r.addEventListener(co, this.handleDraggerEnd_.bind(this), !1), r.addEventListener(T, this.handleContainerClick_.bind(this), !1), i.addEventListener(T, n, !1) } setMap(t) { super.setMap(t), t && t.render() } initSlider_() { const t = this.element; let e = t.offsetWidth, i = t.offsetHeight; if (0 === e && 0 === i) return this.sliderInitialized_ = !1; const n = getComputedStyle(t); e -= parseFloat(n.paddingRight) + parseFloat(n.paddingLeft), i -= parseFloat(n.paddingTop) + parseFloat(n.paddingBottom); const r = t.firstElementChild, s = getComputedStyle(r), o = r.offsetWidth + parseFloat(s.marginRight) + parseFloat(s.marginLeft), a = r.offsetHeight + parseFloat(s.marginTop) + parseFloat(s.marginBottom); return this.thumbSize_ = [o, a], e > i ? (this.direction_ = mT, this.widthLimit_ = e - o) : (this.direction_ = pT, this.heightLimit_ = i - a), this.sliderInitialized_ = !0 } handleContainerClick_(t) { const e = this.getMap().getView(), i = this.getRelativePosition_(t.offsetX - this.thumbSize_[0] / 2, t.offsetY - this.thumbSize_[1] / 2), n = this.getResolutionForPosition_(i), r = e.getConstrainedZoom(e.getZoomForResolution(n)); e.animateInternal({ zoom: r, duration: this.duration_, easing: it }) } handleDraggerStart_(t) { if (!this.dragging_ && t.target === this.element.firstElementChild) { const e = this.element.firstElementChild; if (this.getMap().getView().beginInteraction(), this.startX_ = t.clientX - parseFloat(e.style.left), this.startY_ = t.clientY - parseFloat(e.style.top), this.dragging_ = !0, 0 === this.dragListenerKeys_.length) { const t = this.handleDraggerDrag_, e = this.handleDraggerEnd_, i = this.getMap().getOwnerDocument(); this.dragListenerKeys_.push(N(i, lo, t, this), N(i, co, e, this)) } } } handleDraggerDrag_(t) { if (this.dragging_) { const e = t.clientX - this.startX_, i = t.clientY - this.startY_, n = this.getRelativePosition_(e, i); this.currentResolution_ = this.getResolutionForPosition_(n), this.getMap().getView().setResolution(this.currentResolution_) } } handleDraggerEnd_(t) { if (this.dragging_) { this.getMap().getView().endInteraction(), this.dragging_ = !1, this.startX_ = void 0, this.startY_ = void 0, this.dragListenerKeys_.forEach(k), this.dragListenerKeys_.length = 0 } } setThumbPosition_(t) { const e = this.getPositionForResolution_(t), i = this.element.firstElementChild; this.direction_ == mT ? i.style.left = this.widthLimit_ * e + "px" : i.style.top = this.heightLimit_ * e + "px" } getRelativePosition_(t, e) { let i; return i = this.direction_ === mT ? t / this.widthLimit_ : e / this.heightLimit_, ii(i, 0, 1) } getResolutionForPosition_(t) { return this.getMap().getView().getResolutionForValueFunction()(1 - t) } getPositionForResolution_(t) { return ii(1 - this.getMap().getView().getValueForResolutionFunction()(t), 0, 1) } render(t) { if (!t.frameState) return; if (!this.sliderInitialized_ && !this.initSlider_()) return; const e = t.frameState.viewState.resolution; this.currentResolution_ = e, this.setThumbPosition_(e) } }, _T.control.ZoomToExtent = class extends qo { constructor(t) { t = t || {}, super({ element: document.createElement("div"), target: t.target }), this.extent = t.extent ? t.extent : null; const e = void 0 !== t.className ? t.className : "ol-zoom-extent", i = void 0 !== t.label ? t.label : "E", n = void 0 !== t.tipLabel ? t.tipLabel : "Fit to extent", r = document.createElement("button"); r.setAttribute("type", "button"), r.title = n, r.appendChild("string" == typeof i ? document.createTextNode(i) : i), r.addEventListener(T, this.handleClick_.bind(this), !1); const s = e + " " + "ol-unselectable " + Is, o = this.element; o.className = s, o.appendChild(r) } handleClick_(t) { t.preventDefault(), this.handleZoomToExtent() } handleZoomToExtent() { const t = this.getMap().getView(), e = this.extent ? this.extent : t.getProjection().getExtent(); t.fitInternal(gr(e)) } }, _T.control.defaults = {}, _T.control.defaults.defaults = Qo, _T.coordinate = {}, _T.coordinate.add = mi, _T.coordinate.closestOnCircle = _i, _T.coordinate.closestOnSegment = yi, _T.coordinate.createStringXY = function (t) { return function (e) { return Ri(e, t) } }, _T.coordinate.degreesToStringHDMS = xi, _T.coordinate.distance = Ci, _T.coordinate.equals = Si, _T.coordinate.format = vi, _T.coordinate.getWorldsAway = Ii, _T.coordinate.rotate = wi, _T.coordinate.scale = Ei, _T.coordinate.squaredDistance = Ti, _T.coordinate.squaredDistanceToSegment = bi, _T.coordinate.toStringHDMS = function (t, e) { return t ? xi("NS", t[1], e) + " " + xi("EW", t[0], e) : "" }, _T.coordinate.toStringXY = Ri, _T.coordinate.wrapX = Pi, _T.css = {}, _T.css.CLASS_COLLAPSED = Ls, _T.css.CLASS_CONTROL = Is, _T.css.CLASS_HIDDEN = Cs, _T.css.CLASS_SELECTABLE = bs, _T.css.CLASS_UNSELECTABLE = Rs, _T.css.CLASS_UNSUPPORTED = Ps, _T.css.getFontParameters = As, _T.dom = {}, _T.dom.createCanvasContext2D = Dr, _T.dom.outerHeight = jr, _T.dom.outerWidth = Gr, _T.dom.releaseCanvas = kr, _T.dom.removeChildren = zr, _T.dom.removeNode = Ur, _T.dom.replaceChildren = Xr, _T.dom.replaceNode = Br, _T.easing = {}, _T.easing.easeIn = et, _T.easing.easeOut = it, _T.easing.inAndOut = nt, _T.easing.linear = rt, _T.easing.upAndDown = function (t) { return t < .5 ? nt(2 * t) : 1 - nt(2 * (t - .5)) }, _T.events = {}, _T.events.Event = i, _T.events.Event.preventDefault = function (t) { t.preventDefault() }, _T.events.Event.stopPropagation = n, _T.events.Target = v, _T.events.condition = {}, _T.events.condition.all = aa, _T.events.condition.altKeyOnly = la, _T.events.condition.altShiftKeysOnly = ha, _T.events.condition.always = da, _T.events.condition.click = function (t) { return t.type == ao.CLICK }, _T.events.condition.doubleClick = function (t) { return t.type == ao.DBLCLICK }, _T.events.condition.focus = ca, _T.events.condition.focusWithTabindex = ua, _T.events.condition.mouseActionButton = ga, _T.events.condition.mouseOnly = xa, _T.events.condition.never = fa, _T.events.condition.noModifierKeys = ma, _T.events.condition.penOnly = function (t) { const e = t.originalEvent; return at(void 0 !== e, 56), "pen" === e.pointerType }, _T.events.condition.platformModifierKeyOnly = function (t) { const e = t.originalEvent; return !e.altKey && (pt ? e.metaKey : e.ctrlKey) && !e.shiftKey }, _T.events.condition.pointerMove = function (t) { return "pointermove" == t.type }, _T.events.condition.primaryAction = va, _T.events.condition.shiftKeyOnly = _a, _T.events.condition.singleClick = pa, _T.events.condition.targetNotEditable = ya, _T.events.condition.touchOnly = function (t) { const e = t.originalEvent; return at(void 0 !== e, 56), "touch" === e.pointerType }, _T.events.listen = N, _T.events.listenOnce = D, _T.events.unlistenByKey = k, _T.extent = {}, _T.extent.applyTransform = Re, _T.extent.approximatelyEquals = ie, _T.extent.boundingExtent = zt, _T.extent.buffer = Xt, _T.extent.clone = Vt, _T.extent.closestSquaredDistanceXY = Wt, _T.extent.containsCoordinate = Zt, _T.extent.containsExtent = Yt, _T.extent.containsXY = Kt, _T.extent.coordinateRelationship = qt, _T.extent.createEmpty = Ht, _T.extent.createOrUpdate = $t, _T.extent.createOrUpdateEmpty = Jt, _T.extent.createOrUpdateFromCoordinate = Qt, _T.extent.createOrUpdateFromCoordinates = function (t, e) { return se(Jt(e), t) }, _T.extent.createOrUpdateFromFlatCoordinates = te, _T.extent.createOrUpdateFromRings = function (t, e) { return ae(Jt(e), t) }, _T.extent.equals = ee, _T.extent.extend = ne, _T.extent.extendCoordinate = re, _T.extent.extendCoordinates = se, _T.extent.extendFlatCoordinates = oe, _T.extent.extendRings = ae, _T.extent.extendXY = le, _T.extent.forEachCorner = he, _T.extent.getArea = ce, _T.extent.getBottomLeft = ue, _T.extent.getBottomRight = de, _T.extent.getCenter = ge, _T.extent.getCorner = fe, _T.extent.getEnlargedArea = function (t, e) { const i = Math.min(t[0], e[0]), n = Math.min(t[1], e[1]); return (Math.max(t[2], e[2]) - i) * (Math.max(t[3], e[3]) - n) }, _T.extent.getForViewAndSize = pe, _T.extent.getHeight = _e, _T.extent.getIntersection = ye, _T.extent.getIntersectionArea = function (t, e) { return ce(ye(t, e)) }, _T.extent.getMargin = function (t) { return Se(t) + _e(t) }, _T.extent.getRotatedViewport = me, _T.extent.getSize = function (t) { return [t[2] - t[0], t[3] - t[1]] }, _T.extent.getTopLeft = xe, _T.extent.getTopRight = ve, _T.extent.getWidth = Se, _T.extent.intersects = we, _T.extent.intersectsSegment = be, _T.extent.isEmpty = Ee, _T.extent.returnOrUpdate = Te, _T.extent.scaleFromCenter = Ce, _T.extent.wrapAndSliceX = Ie, _T.extent.wrapX = Pe, _T.featureloader = {}, _T.featureloader.loadFeaturesXhr = _l, _T.featureloader.setWithCredentials = function (t) { ml = t }, _T.featureloader.xhr = yl, _T.format = {}, _T.format.EsriJSON = class extends E_ { constructor(t) { t = t || {}, super(), this.geometryName_ = t.geometryName } readFeatureFromObject(t, e, i) { const n = t, r = R_(n.geometry, e), s = new lt; if (this.geometryName_ && s.setGeometryName(this.geometryName_), s.setGeometry(r), n.attributes) { s.setProperties(n.attributes, !0); const t = n.attributes[i]; void 0 !== t && s.setId(t) } return s } readFeaturesFromObject(t, e) { if (e = e || {}, t.features) { const i = [], n = t.features; for (let r = 0, s = n.length; r < s; ++r)i.push(this.readFeatureFromObject(n[r], e, t.objectIdFieldName)); return i } return [this.readFeatureFromObject(t, e)] } readGeometryFromObject(t, e) { return R_(t, e) } readProjectionFromObject(t) { if (t.spatialReference && void 0 !== t.spatialReference.wkid) { return Ui("EPSG:" + t.spatialReference.wkid) } return null } writeGeometryObject(t, e) { return L_(t, this.adaptOptions(e)) } writeFeatureObject(t, e) { e = this.adaptOptions(e); const i = {}; if (!t.hasProperties()) return i.attributes = {}, i; const n = t.getProperties(), r = t.getGeometry(); if (r) { i.geometry = L_(r, e); const s = e && (e.dataProjection || e.featureProjection); s && (i.geometry.spatialReference = { wkid: Number(Ui(s).getCode().split(":").pop()) }), delete n[t.getGeometryName()] } return x(n) ? i.attributes = {} : i.attributes = n, i } writeFeaturesObject(t, e) { e = this.adaptOptions(e); const i = []; for (let n = 0, r = t.length; n < r; ++n)i.push(this.writeFeatureObject(t[n], e)); return { features: i } } }, _T.format.Feature = Jp, _T.format.Feature.transformExtentWithOptions = tm, _T.format.Feature.transformGeometryWithOptions = Qp, _T.format.GML = Q_, _T.format.GML2 = H_, _T.format.GML3 = J_, _T.format.GML32 = ty, _T.format.GMLBase = O_, _T.format.GMLBase.GMLNS = F_, _T.format.GPX = class extends M_ { constructor(t) { super(), t = t || {}, this.dataProjection = Ui("EPSG:4326"), this.readExtensions_ = t.readExtensions } handleReadExtensions_(t) { t || (t = []); for (let e = 0, i = t.length; e < i; ++e) { const i = t[e]; if (this.readExtensions_) { const t = i.get("extensionsNode_") || null; this.readExtensions_(i, t) } i.set("extensionsNode_", void 0) } } readFeatureFromNode(t, e) { if (!ey.includes(t.namespaceURI)) return null; const i = iy[t.localName]; if (!i) return null; const n = i(t, [this.getReadOptions(t, e)]); return n ? (this.handleReadExtensions_([n]), n) : null } readFeaturesFromNode(t, e) { if (!ey.includes(t.namespaceURI)) return []; if ("gpx" == t.localName) { const i = Lu([], ny, t, [this.getReadOptions(t, e)]); return i ? (this.handleReadExtensions_(i), i) : [] } return [] } writeFeaturesNode(t, e) { e = this.adaptOptions(e); const i = du("http://www.topografix.com/GPX/1/1", "gpx"); return i.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xsi", uu), i.setAttributeNS(uu, "xsi:schemaLocation", "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd"), i.setAttribute("version", "1.1"), i.setAttribute("creator", "OpenLayers"), Fu({ node: i }, sy, Ty, t, [e]), i } }, _T.format.GeoJSON = class extends E_ { constructor(t) { t = t || {}, super(), this.dataProjection = Ui(t.dataProjection ? t.dataProjection : "EPSG:4326"), t.featureProjection && (this.defaultFeatureProjection = Ui(t.featureProjection)), this.geometryName_ = t.geometryName, this.extractGeometryName_ = t.extractGeometryName, this.supportedMediaTypes = ["application/geo+json", "application/vnd.geo+json"] } readFeatureFromObject(t, e) { let i = null; i = "Feature" === t.type ? t : { type: "Feature", geometry: t, properties: null }; const n = Oy(i.geometry, e), r = new lt; return this.geometryName_ ? r.setGeometryName(this.geometryName_) : this.extractGeometryName_ && "geometry_name" in i !== void 0 && r.setGeometryName(i.geometry_name), r.setGeometry(n), "id" in i && r.setId(i.id), i.properties && r.setProperties(i.properties, !0), r } readFeaturesFromObject(t, e) { let i = null; if ("FeatureCollection" === t.type) { i = []; const n = t.features; for (let t = 0, r = n.length; t < r; ++t)i.push(this.readFeatureFromObject(n[t], e)) } else i = [this.readFeatureFromObject(t, e)]; return i } readGeometryFromObject(t, e) { return Oy(t, e) } readProjectionFromObject(t) { const e = t.crs; let i; return e ? "name" == e.type ? i = Ui(e.properties.name) : "EPSG" === e.type ? i = Ui("EPSG:" + e.properties.code) : at(!1, 36) : i = this.dataProjection, i } writeFeatureObject(t, e) { e = this.adaptOptions(e); const i = { type: "Feature", geometry: null, properties: null }, n = t.getId(); if (void 0 !== n && (i.id = n), !t.hasProperties()) return i; const r = t.getProperties(), s = t.getGeometry(); return s && (i.geometry = Ny(s, e), delete r[t.getGeometryName()]), x(r) || (i.properties = r), i } writeFeaturesObject(t, e) { e = this.adaptOptions(e); const i = []; for (let n = 0, r = t.length; n < r; ++n)i.push(this.writeFeatureObject(t[n], e)); return { type: "FeatureCollection", features: i } } writeGeometryObject(t, e) { return Ny(t, this.adaptOptions(e)) } }, _T.format.IGC = class extends Dy { constructor(t) { super(), t = t || {}, this.dataProjection = Ui("EPSG:4326"), this.altitudeMode_ = t.altitudeMode ? t.altitudeMode : "none" } readFeatureFromText(t, e) { const i = this.altitudeMode_, n = t.split(Uy), r = {}, s = []; let o, a, l = 2e3, h = 0, c = 1, u = -1; for (o = 0, a = n.length; o < a; ++o) { const t = n[o]; let e; if ("B" == t.charAt(0)) { if (e = Gy.exec(t), e) { const t = parseInt(e[1], 10), n = parseInt(e[2], 10), r = parseInt(e[3], 10); let o = parseInt(e[4], 10) + parseInt(e[5], 10) / 6e4; "S" == e[6] && (o = -o); let a = parseInt(e[7], 10) + parseInt(e[8], 10) / 6e4; if ("W" == e[9] && (a = -a), s.push(a, o), "none" != i) { let t; t = "gps" == i ? parseInt(e[11], 10) : "barometric" == i ? parseInt(e[12], 10) : 0, s.push(t) } let d = Date.UTC(l, h, c, t, n, r); d < u && (d = Date.UTC(l, h, c + 1, t, n, r)), s.push(d / 1e3), u = d } } else "H" == t.charAt(0) && (e = By.exec(t), e ? (c = parseInt(e[1], 10), h = parseInt(e[2], 10) - 1, l = 2e3 + parseInt(e[3], 10)) : (e = jy.exec(t), e && (r[e[1]] = e[2].trim()))) } if (0 === s.length) return null; const d = new Op(s, "none" == i ? "XYM" : "XYZM"), g = new lt(Qp(d, !1, e)); return g.setProperties(r, !0), g } readFeaturesFromText(t, e) { const i = this.readFeatureFromText(t, e); return i ? [i] : [] } }, _T.format.IIIFInfo = class { constructor(t) { this.setImageInfo(t) } setImageInfo(t) { this.imageInfo = "string" == typeof t ? JSON.parse(t) : t } getImageApiVersion() { if (void 0 === this.imageInfo) return; let t = this.imageInfo["@context"] || "ol-no-context"; "string" == typeof t && (t = [t]); for (let e = 0; e < t.length; e++)switch (t[e]) { case "http://library.stanford.edu/iiif/image-api/1.1/context.json": case "http://iiif.io/api/image/1/context.json": return rc; case "http://iiif.io/api/image/2/context.json": return sc; case "http://iiif.io/api/image/3/context.json": return oc; case "ol-no-context": if (this.getComplianceLevelEntryFromProfile(rc) && this.imageInfo.identifier) return rc }at(!1, 61) } getComplianceLevelEntryFromProfile(t) { if (void 0 !== this.imageInfo && void 0 !== this.imageInfo.profile) switch (void 0 === t && (t = this.getImageApiVersion()), t) { case rc: if (lc.test(this.imageInfo.profile)) return this.imageInfo.profile; break; case oc: if (cc.test(this.imageInfo.profile)) return this.imageInfo.profile; break; case sc: if ("string" == typeof this.imageInfo.profile && hc.test(this.imageInfo.profile)) return this.imageInfo.profile; if (Array.isArray(this.imageInfo.profile) && this.imageInfo.profile.length > 0 && "string" == typeof this.imageInfo.profile[0] && hc.test(this.imageInfo.profile[0])) return this.imageInfo.profile[0] } } getComplianceLevelFromProfile(t) { const e = this.getComplianceLevelEntryFromProfile(t); if (void 0 === e) return; const i = e.match(/level[0-2](?:\.json)?$/g); return Array.isArray(i) ? i[0].replace(".json", "") : void 0 } getComplianceLevelSupportedFeatures() { if (void 0 === this.imageInfo) return; const t = this.getImageApiVersion(), e = this.getComplianceLevelFromProfile(t); return void 0 === e ? ac.none.none : ac[t][e] } getTileSourceOptions(t) { const e = t || {}, i = this.getImageApiVersion(); if (void 0 === i) return; const n = void 0 === i ? void 0 : uc[i](this); return void 0 !== n ? { url: n.url, version: i, size: [this.imageInfo.width, this.imageInfo.height], sizes: n.sizes, format: void 0 !== e.format && n.formats.includes(e.format) ? e.format : void 0 !== n.preferredFormat ? n.preferredFormat : "jpg", supports: n.supports, quality: e.quality && n.qualities.includes(e.quality) ? e.quality : n.qualities.includes("native") ? "native" : "default", resolutions: Array.isArray(n.resolutions) ? n.resolutions.sort((function (t, e) { return e - t })) : void 0, tileSize: n.tileSize } : void 0 } }, _T.format.JSONFeature = E_, _T.format.KML = class extends M_ { constructor(t) { super(), t = t || {}, ux || ($y = [255, 255, 255, 1], nx = new rg({ color: $y }), Jy = [20, 2], Qy = "pixels", tx = "pixels", ex = [64, 64], ix = "https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png", sx = new lg({ anchor: Jy, anchorOrigin: "bottom-left", anchorXUnits: Qy, anchorYUnits: tx, crossOrigin: "anonymous", rotation: 0, scale: dx(ex), size: ex, src: ix }), rx = "NO_IMAGE", ax = new hg({ color: $y, width: 1 }), ox = new hg({ color: [51, 51, 51, 1], width: 2 }), lx = new mg({ font: "bold 16px Helvetica", fill: nx, stroke: ox, scale: .8 }), hx = new cg({ fill: nx, image: sx, text: lx, stroke: ax, zIndex: 0 }), ux = [hx]), this.dataProjection = Ui("EPSG:4326"), this.defaultStyle_ = t.defaultStyle ? t.defaultStyle : ux, this.extractStyles_ = void 0 === t.extractStyles || t.extractStyles, this.writeStyles_ = void 0 === t.writeStyles || t.writeStyles, this.sharedStyles_ = {}, this.showPointNames_ = void 0 === t.showPointNames || t.showPointNames, this.crossOrigin_ = void 0 !== t.crossOrigin ? t.crossOrigin : "anonymous", this.iconUrlFunction_ = t.iconUrlFunction ? t.iconUrlFunction : gx, this.supportedMediaTypes = ["application/vnd.google-earth.kml+xml"] } readDocumentOrFolder_(t, e) { const i = Lu([], Pu(Xy, { Document: yu(this.readDocumentOrFolder_, this), Folder: yu(this.readDocumentOrFolder_, this), Placemark: xu(this.readPlacemark_, this), Style: this.readSharedStyle_.bind(this), StyleMap: this.readSharedStyleMap_.bind(this) }), t, e, this); return i || void 0 } readPlacemark_(t, e) { const i = Lu({ geometry: null }, Wy, t, e, this); if (!i) return; const n = new lt, r = t.getAttribute("id"); null !== r && n.setId(r); const s = e[0], o = i.geometry; if (o && Qp(o, !1, s), n.setGeometry(o), delete i.geometry, this.extractStyles_) { const t = function (t, e, i, n, r) { return function (s, o) { let a = r, l = "", h = []; if (a) { const t = s.getGeometry(); if (t) if (t instanceof Ip) h = t.getGeometriesArrayRecursive().filter((function (t) { const e = t.getType(); return "Point" === e || "MultiPoint" === e })), a = h.length > 0; else { const e = t.getType(); a = "Point" === e || "MultiPoint" === e } } a && (l = s.get("name"), a = a && !!l, a && /&[^&]+;/.test(l) && (cx || (cx = document.createElement("textarea")), cx.innerHTML = l, l = cx.value)); let c = i; if (t ? c = t : e && (c = fx(e, i, n)), a) { const t = function (t, e) { const i = [0, 0]; let n = "start"; const r = t.getImage(); if (r) { const t = r.getSize(); if (t && 2 == t.length) { const e = r.getScaleArray(), s = r.getAnchor(); i[0] = e[0] * (t[0] - s[0]), i[1] = e[1] * (t[1] / 2 - s[1]), n = "left" } } let s = t.getText(); s ? (s = s.clone(), s.setFont(s.getFont() || lx.getFont()), s.setScale(s.getScale() || lx.getScale()), s.setFill(s.getFill() || lx.getFill()), s.setStroke(s.getStroke() || ox)) : s = lx.clone(); s.setText(e), s.setOffsetX(i[0]), s.setOffsetY(i[1]), s.setTextAlign(n); return new cg({ image: r, text: s }) }(c[0], l); if (h.length > 0) { t.setGeometry(new Ip(h)); return [t, new cg({ geometry: c[0].getGeometry(), image: null, fill: c[0].getFill(), stroke: c[0].getStroke(), text: null })].concat(c.slice(1)) } return t } return c } }(i.Style, i.styleUrl, this.defaultStyle_, this.sharedStyles_, this.showPointNames_); n.setStyle(t) } return delete i.Style, n.setProperties(i, !0), n } readSharedStyle_(t, e) { const i = t.getAttribute("id"); if (null !== i) { const n = Xx.call(this, t, e); if (n) { let e, r = t.baseURI; if (r && "about:blank" != r || (r = window.location.href), r) { e = new URL("#" + i, r).href } else e = "#" + i; this.sharedStyles_[e] = n } } } readSharedStyleMap_(t, e) { const i = t.getAttribute("id"); if (null === i) return; const n = Sx.call(this, t, e); if (!n) return; let r, s = t.baseURI; if (s && "about:blank" != s || (s = window.location.href), s) { r = new URL("#" + i, s).href } else r = "#" + i; this.sharedStyles_[r] = n } readFeatureFromNode(t, e) { if (!Xy.includes(t.namespaceURI)) return null; const i = this.readPlacemark_(t, [this.getReadOptions(t, e)]); return i || null } readFeaturesFromNode(t, e) { if (!Xy.includes(t.namespaceURI)) return []; let i; const n = t.localName; if ("Document" == n || "Folder" == n) return i = this.readDocumentOrFolder_(t, [this.getReadOptions(t, e)]), i || []; if ("Placemark" == n) { const i = this.readPlacemark_(t, [this.getReadOptions(t, e)]); return i ? [i] : [] } if ("kml" == n) { i = []; for (let n = t.firstElementChild; n; n = n.nextElementSibling) { const t = this.readFeaturesFromNode(n, e); t && c(i, t) } return i } return [] } readName(t) { if (t) { if ("string" == typeof t) { const e = _u(t); return this.readNameFromDocument(e) } return pu(t) ? this.readNameFromDocument(t) : this.readNameFromNode(t) } } readNameFromDocument(t) { for (let e = t.firstChild; e; e = e.nextSibling)if (e.nodeType == Node.ELEMENT_NODE) { const t = this.readNameFromNode(e); if (t) return t } } readNameFromNode(t) { for (let e = t.firstElementChild; e; e = e.nextElementSibling)if (Xy.includes(e.namespaceURI) && "name" == e.localName) return z_(e); for (let e = t.firstElementChild; e; e = e.nextElementSibling) { const t = e.localName; if (Xy.includes(e.namespaceURI) && ("Document" == t || "Folder" == t || "Placemark" == t || "kml" == t)) { const t = this.readNameFromNode(e); if (t) return t } } } readNetworkLinks(t) { const e = []; if ("string" == typeof t) { const i = _u(t); c(e, this.readNetworkLinksFromDocument(i)) } else pu(t) ? c(e, this.readNetworkLinksFromDocument(t)) : c(e, this.readNetworkLinksFromNode(t)); return e } readNetworkLinksFromDocument(t) { const e = []; for (let i = t.firstChild; i; i = i.nextSibling)i.nodeType == Node.ELEMENT_NODE && c(e, this.readNetworkLinksFromNode(i)); return e } readNetworkLinksFromNode(t) { const e = []; for (let i = t.firstElementChild; i; i = i.nextElementSibling)if (Xy.includes(i.namespaceURI) && "NetworkLink" == i.localName) { const t = Lu({}, Zy, i, []); e.push(t) } for (let i = t.firstElementChild; i; i = i.nextElementSibling) { const t = i.localName; !Xy.includes(i.namespaceURI) || "Document" != t && "Folder" != t && "kml" != t || c(e, this.readNetworkLinksFromNode(i)) } return e } readRegion(t) { const e = []; if ("string" == typeof t) { const i = _u(t); c(e, this.readRegionFromDocument(i)) } else pu(t) ? c(e, this.readRegionFromDocument(t)) : c(e, this.readRegionFromNode(t)); return e } readRegionFromDocument(t) { const e = []; for (let i = t.firstChild; i; i = i.nextSibling)i.nodeType == Node.ELEMENT_NODE && c(e, this.readRegionFromNode(i)); return e } readRegionFromNode(t) { const e = []; for (let i = t.firstElementChild; i; i = i.nextElementSibling)if (Xy.includes(i.namespaceURI) && "Region" == i.localName) { const t = Lu({}, Ky, i, []); e.push(t) } for (let i = t.firstElementChild; i; i = i.nextElementSibling) { const t = i.localName; !Xy.includes(i.namespaceURI) || "Document" != t && "Folder" != t && "kml" != t || c(e, this.readRegionFromNode(i)) } return e } writeFeaturesNode(t, e) { e = this.adaptOptions(e); const i = du(Xy[4], "kml"), n = "http://www.w3.org/2000/xmlns/"; i.setAttributeNS(n, "xmlns:gx", zy[0]), i.setAttributeNS(n, "xmlns:xsi", uu), i.setAttributeNS(uu, "xsi:schemaLocation", "http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd"); const r = { node: i }, s = {}; t.length > 1 ? s.Document = t : 1 == t.length && (s.Placemark = t[0]); const o = qy[i.namespaceURI], a = Ru(s, o); return Fu(r, Hy, bu, a, [e], o, this), i } }, _T.format.KML.getDefaultFillStyle = function () { return nx }, _T.format.KML.getDefaultImageStyle = function () { return sx }, _T.format.KML.getDefaultStrokeStyle = function () { return ax }, _T.format.KML.getDefaultStyle = function () { return hx }, _T.format.KML.getDefaultStyleArray = function () { return ux }, _T.format.KML.getDefaultTextStyle = function () { return lx }, _T.format.KML.readFlatCoordinates = mx, _T.format.MVT = Em, _T.format.OSMXML = class extends M_ { constructor() { super(), this.dataProjection = Ui("EPSG:4326") } readFeaturesFromNode(t, e) { if (e = this.getReadOptions(t, e), "osm" == t.localName) { const i = Lu({ nodes: {}, ways: [], features: [] }, Xv, t, [e]); for (let t = 0; t < i.ways.length; t++) { const n = i.ways[t], r = []; for (let t = 0, e = n.ndrefs.length; t < e; t++) { c(r, i.nodes[n.ndrefs[t]]) } let s; s = n.ndrefs[0] == n.ndrefs[n.ndrefs.length - 1] ? new ur(r, "XY", [r.length]) : new Op(r, "XY"), Qp(s, !1, e); const o = new lt(s); void 0 !== n.id && o.setId(n.id), o.setProperties(n.tags, !0), i.features.push(o) } if (i.features) return i.features } return [] } }, _T.format.OWS = Hv, _T.format.Polyline = class extends Dy { constructor(t) { super(), t = t || {}, this.dataProjection = Ui("EPSG:4326"), this.factor_ = t.factor ? t.factor : 1e5, this.geometryLayout_ = t.geometryLayout ? t.geometryLayout : "XY" } readFeatureFromText(t, e) { const i = this.readGeometryFromText(t, e); return new lt(i) } readFeaturesFromText(t, e) { return [this.readFeatureFromText(t, e)] } readGeometryFromText(t, e) { const i = yn(this.geometryLayout_), n = uS(t, i, this.factor_); w_(n, 0, n.length, i, n); const r = Gn(n, 0, n.length, i); return Qp(new Op(r, this.geometryLayout_), !1, this.adaptOptions(e)) } writeFeatureText(t, e) { const i = t.getGeometry(); return i ? this.writeGeometryText(i, e) : (at(!1, 40), "") } writeFeaturesText(t, e) { return this.writeFeatureText(t[0], e) } writeGeometryText(t, e) { const i = (t = Qp(t, !0, this.adaptOptions(e))).getFlatCoordinates(), n = t.getStride(); return w_(i, 0, i.length, n, i), cS(i, n, this.factor_) } }, _T.format.Polyline.decodeDeltas = uS, _T.format.Polyline.decodeFloats = gS, _T.format.Polyline.decodeSignedIntegers = pS, _T.format.Polyline.decodeUnsignedIntegers = _S, _T.format.Polyline.encodeDeltas = cS, _T.format.Polyline.encodeFloats = dS, _T.format.Polyline.encodeSignedIntegers = fS, _T.format.Polyline.encodeUnsignedInteger = yS, _T.format.Polyline.encodeUnsignedIntegers = mS, _T.format.TextFeature = Dy, _T.format.TopoJSON = class extends E_ { constructor(t) { super(), t = t || {}, this.layerName_ = t.layerName, this.layers_ = t.layers ? t.layers : null, this.dataProjection = Ui(t.dataProjection ? t.dataProjection : "EPSG:4326") } readFeaturesFromObject(t, e) { if ("Topology" == t.type) { const i = t; let n, r = null, s = null; i.transform && (n = i.transform, r = n.scale, s = n.translate); const o = i.arcs; n && function (t, e, i) { for (let n = 0, r = t.length; n < r; ++n)ES(t[n], e, i) }(o, r, s); const a = [], l = i.objects, h = this.layerName_; let c; for (const t in l) this.layers_ && !this.layers_.includes(t) || ("GeometryCollection" === l[t].type ? (c = l[t], a.push.apply(a, SS(c, o, r, s, h, t, e))) : (c = l[t], a.push(wS(c, o, r, s, h, t, e)))); return a } return [] } readProjectionFromObject(t) { return this.dataProjection } }, _T.format.WFS = class extends M_ { constructor(t) { super(), t = t || {}, this.version_ = t.version ? t.version : "1.1.0", this.featureType_ = t.featureType, this.featureNS_ = t.featureNS, this.gmlFormat_ = t.gmlFormat ? t.gmlFormat : new hw[this.version_], this.schemaLocation_ = t.schemaLocation ? t.schemaLocation : lw[this.version_] } getFeatureType() { return this.featureType_ } setFeatureType(t) { this.featureType_ = t } readFeaturesFromNode(t, e) { const i = { node: t }; Object.assign(i, { featureType: this.featureType_, featureNS: this.featureNS_ }), Object.assign(i, this.getReadOptions(t, e || {})); const n = [i]; let r; r = "2.0.0" === this.version_ ? JS : this.gmlFormat_.FEATURE_COLLECTION_PARSERS; let s = Lu([], r, t, n, this.gmlFormat_); return s || (s = []), s } readTransactionResponse(t) { if (t) { if ("string" == typeof t) { const e = _u(t); return this.readTransactionResponseFromDocument(e) } return pu(t) ? this.readTransactionResponseFromDocument(t) : this.readTransactionResponseFromNode(t) } } readFeatureCollectionMetadata(t) { if (t) { if ("string" == typeof t) { const e = _u(t); return this.readFeatureCollectionMetadataFromDocument(e) } return pu(t) ? this.readFeatureCollectionMetadataFromDocument(t) : this.readFeatureCollectionMetadataFromNode(t) } } readFeatureCollectionMetadataFromDocument(t) { for (let e = t.firstChild; e; e = e.nextSibling)if (e.nodeType == Node.ELEMENT_NODE) return this.readFeatureCollectionMetadataFromNode(e) } readFeatureCollectionMetadataFromNode(t) { const e = {}, i = U_(t.getAttribute("numberOfFeatures")); return e.numberOfFeatures = i, Lu(e, JS, t, [], this.gmlFormat_) } readTransactionResponseFromDocument(t) { for (let e = t.firstChild; e; e = e.nextSibling)if (e.nodeType == Node.ELEMENT_NODE) return this.readTransactionResponseFromNode(e) } readTransactionResponseFromNode(t) { return Lu({}, tw, t, []) } writeGetFeature(t) { const e = du(ow[this.version_], "GetFeature"); e.setAttribute("service", "WFS"), e.setAttribute("version", this.version_), t.handle && e.setAttribute("handle", t.handle), t.outputFormat && e.setAttribute("outputFormat", t.outputFormat), void 0 !== t.maxFeatures && e.setAttribute("maxFeatures", String(t.maxFeatures)), t.resultType && e.setAttribute("resultType", t.resultType), void 0 !== t.startIndex && e.setAttribute("startIndex", String(t.startIndex)), void 0 !== t.count && e.setAttribute("count", String(t.count)), void 0 !== t.viewParams && e.setAttribute("viewParams", t.viewParams), e.setAttributeNS(uu, "xsi:schemaLocation", this.schemaLocation_); const i = { node: e }; if (Object.assign(i, { version: this.version_, srsName: t.srsName, featureNS: t.featureNS ? t.featureNS : this.featureNS_, featurePrefix: t.featurePrefix, propertyNames: t.propertyNames ? t.propertyNames : [] }), at(Array.isArray(t.featureTypes), 11), "string" == typeof t.featureTypes[0]) { let n = t.filter; t.bbox && (at(t.geometryName, 12), n = this.combineBboxAndFilter(t.geometryName, t.bbox, t.srsName, n)), Object.assign(i, { geometryName: t.geometryName, filter: n }), Bw(e, t.featureTypes, [i]) } else t.featureTypes.forEach((n => { const r = this.combineBboxAndFilter(n.geometryName, n.bbox, t.srsName, t.filter); Object.assign(i, { geometryName: n.geometryName, filter: r }), Bw(e, [n.name], [i]) })); return e } combineBboxAndFilter(t, e, i, n) { const r = $S(t, e, i); return n ? HS(n, r) : r } writeTransaction(t, e, i, n) { const r = [], s = n.version ? n.version : this.version_, o = du(ow[s], "Transaction"); let a; o.setAttribute("service", "WFS"), o.setAttribute("version", s), n && (a = n.gmlOptions ? n.gmlOptions : {}, n.handle && o.setAttribute("handle", n.handle)), o.setAttributeNS(uu, "xsi:schemaLocation", lw[s]); const l = function (t, e, i, n) { const r = n.featurePrefix ? n.featurePrefix : nw; let s; "1.0.0" === i ? s = 2 : "1.1.0" === i ? s = 3 : "2.0.0" === i && (s = 3.2); return Object.assign({ node: t }, { version: i, featureNS: n.featureNS, featureType: n.featureType, featurePrefix: r, gmlVersion: s, hasZ: n.hasZ, srsName: n.srsName }, e) }(o, a, s, n); return t && cw("Insert", t, r, l), e && cw("Update", e, r, l), i && cw("Delete", i, r, l), n.nativeElements && cw("Native", n.nativeElements, r, l), o } readProjectionFromDocument(t) { for (let e = t.firstChild; e; e = e.nextSibling)if (e.nodeType == Node.ELEMENT_NODE) return this.readProjectionFromNode(e); return null } readProjectionFromNode(t) { if (t.firstElementChild && t.firstElementChild.firstElementChild) for (let e = (t = t.firstElementChild.firstElementChild).firstElementChild; e; e = e.nextElementSibling)if (0 !== e.childNodes.length && (1 !== e.childNodes.length || 3 !== e.firstChild.nodeType)) { const t = [{}]; return this.gmlFormat_.readGeometryElement(e, t), Ui(t.pop().srsName) } return null } }, _T.format.WFS.writeFilter = function (t, e) { const i = du(Uw(e = e || "1.1.0"), "Filter"), n = { node: i }; return Object.assign(n, { version: e, filter: t }), Cw(i, t, [n]), i }, _T.format.WKB = class extends Jp { constructor(t) { super(), t = t || {}, this.splitCollection = Boolean(t.splitCollection), this.viewCache_ = null, this.hex_ = !1 !== t.hex, this.littleEndian_ = !1 !== t.littleEndian, this.ewkb_ = !1 !== t.ewkb, this.layout_ = t.geometryLayout, this.nodataZ_ = t.nodataZ || 0, this.nodataM_ = t.nodataM || 0, this.srid_ = t.srid } getType() { return this.hex_ ? "text" : "arraybuffer" } readFeature(t, e) { return new lt({ geometry: this.readGeometry(t, e) }) } readFeatures(t, e) { let i = []; const n = this.readGeometry(t, e); return i = this.splitCollection && n instanceof Ip ? n.getGeometriesArray() : [n], i.map((t => new lt({ geometry: t }))) } readGeometry(t, e) { const i = tE(t); if (!i) return null; const n = new Jw(i).readGeometry(); return this.viewCache_ = i, e = this.getReadOptions(t, e), this.viewCache_ = null, Qp(n, !1, e) } readProjection(t) { const e = this.viewCache_ || tE(t); if (!e) return; const i = new Jw(e); return i.readWkbHeader(), i.getSrid() && Ui("EPSG:" + i.getSrid()) || void 0 } writeFeature(t, e) { return this.writeGeometry(t.getGeometry(), e) } writeFeatures(t, e) { return this.writeGeometry(new Ip(t.map((t => t.getGeometry()))), e) } writeGeometry(t, e) { e = this.adaptOptions(e); const i = new Qw({ layout: this.layout_, littleEndian: this.littleEndian_, ewkb: this.ewkb_, nodata: { Z: this.nodataZ_, M: this.nodataM_ } }); let n = Number.isInteger(this.srid_) ? Number(this.srid_) : null; if (!1 !== this.srid_ && !Number.isInteger(this.srid_)) { const t = e.dataProjection && Ui(e.dataProjection); if (t) { const e = t.getCode(); e.startsWith("EPSG:") && (n = Number(e.substring(5))) } } i.writeGeometry(Qp(t, !0, e), n); const r = i.getBuffer(); return this.hex_ ? function (t) { const e = new Uint8Array(t); return Array.from(e.values()).map((t => (t < 16 ? "0" : "") + Number(t).toString(16).toUpperCase())).join("") }(r) : r } }, _T.format.WKT = class extends Dy { constructor(t) { super(), t = t || {}, this.splitCollection_ = void 0 !== t.splitCollection && t.splitCollection } parse_(t) { const e = new uE(t); return new dE(e).parse() } readFeatureFromText(t, e) { const i = this.readGeometryFromText(t, e), n = new lt; return n.setGeometry(i), n } readFeaturesFromText(t, e) { let i = []; const n = this.readGeometryFromText(t, e); i = this.splitCollection_ && "GeometryCollection" == n.getType() ? n.getGeometriesArray() : [n]; const r = []; for (let t = 0, e = i.length; t < e; ++t) { const e = new lt; e.setGeometry(i[t]), r.push(e) } return r } readGeometryFromText(t, e) { return Qp(this.parse_(t), !1, e) } writeFeatureText(t, e) { const i = t.getGeometry(); return i ? this.writeGeometryText(i, e) : "" } writeFeaturesText(t, e) { if (1 == t.length) return this.writeFeatureText(t[0], e); const i = []; for (let e = 0, n = t.length; e < n; ++e)i.push(t[e].getGeometry()); const n = new Ip(i); return this.writeGeometryText(n, e) } writeGeometryText(t, e) { return _E(Qp(t, !0, e)) } }, _T.format.WMSCapabilities = class extends Zv { constructor() { super(), this.version = void 0 } readFromNode(t) { this.version = t.getAttribute("version").trim(); const e = Lu({ version: this.version }, xE, t, []); return e || null } }, _T.format.WMSGetFeatureInfo = class extends M_ { constructor(t) { super(), t = t || {}, this.featureNS_ = "http://mapserver.gis.umn.edu/mapserver", this.gmlFormat_ = new H_, this.layers_ = t.layers ? t.layers : null } getLayers() { return this.layers_ } setLayers(t) { this.layers_ = t } readFeatures_(t, e) { t.setAttribute("namespaceURI", this.featureNS_); const i = t.localName; let n = []; if (0 === t.childNodes.length) return n; if ("msGMLOutput" == i) for (let i = 0, r = t.childNodes.length; i < r; i++) { const r = t.childNodes[i]; if (r.nodeType !== Node.ELEMENT_NODE) continue; const s = r, o = e[0], a = "_layer", l = s.localName.replace(a, ""); if (this.layers_ && !this.layers_.includes(l)) continue; const h = l + "_feature"; o.featureType = h, o.featureNS = this.featureNS_; const u = {}; u[h] = xu(this.gmlFormat_.readFeatureElement, this.gmlFormat_); const d = Pu([o.featureNS, null], u); s.setAttribute("namespaceURI", this.featureNS_); const g = Lu([], d, s, e, this.gmlFormat_); g && c(n, g) } if ("FeatureCollection" == i) { const e = Lu([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, t, [{}], this.gmlFormat_); e && (n = e) } return n } readFeaturesFromNode(t, e) { const i = {}; return e && Object.assign(i, this.getReadOptions(t, e)), this.readFeatures_(t, [i]) } }, _T.format.WMTSCapabilities = class extends Zv { constructor() { super(), this.owsParser_ = new Hv } readFromNode(t) { let e = t.getAttribute("version"); e && (e = e.trim()); let i = this.owsParser_.readFromNode(t); return i ? (i.version = e, i = Lu(i, XE, t, []), i || null) : null } }, _T.format.XML = Zv, _T.format.XMLFeature = M_, _T.format.filter = {}, _T.format.filter.And = RS, _T.format.filter.Bbox = PS, _T.format.filter.Comparison = AS, _T.format.filter.ComparisonBinary = NS, _T.format.filter.Contains = LS, _T.format.filter.DWithin = MS, _T.format.filter.Disjoint = FS, _T.format.filter.During = OS, _T.format.filter.EqualTo = DS, _T.format.filter.Filter = CS, _T.format.filter.GreaterThan = kS, _T.format.filter.GreaterThanOrEqualTo = GS, _T.format.filter.Intersects = jS, _T.format.filter.IsBetween = BS, _T.format.filter.IsLike = US, _T.format.filter.IsNull = zS, _T.format.filter.LessThan = XS, _T.format.filter.LessThanOrEqualTo = VS, _T.format.filter.LogicalNary = bS, _T.format.filter.Not = WS, _T.format.filter.NotEqualTo = ZS, _T.format.filter.Or = YS, _T.format.filter.ResourceId = KS, _T.format.filter.Spatial = IS, _T.format.filter.Within = qS, _T.format.filter.and = HS, _T.format.filter.bbox = $S, _T.format.filter.between = function (t, e, i) { return new BS(t, e, i) }, _T.format.filter.contains = function (t, e, i) { return new LS(t, e, i) }, _T.format.filter.disjoint = function (t, e, i) { return new FS(t, e, i) }, _T.format.filter.during = function (t, e, i) { return new OS(t, e, i) }, _T.format.filter.dwithin = function (t, e, i, n, r) { return new MS(t, e, i, n, r) }, _T.format.filter.equalTo = function (t, e, i) { return new DS(t, e, i) }, _T.format.filter.greaterThan = function (t, e) { return new kS(t, e) }, _T.format.filter.greaterThanOrEqualTo = function (t, e) { return new GS(t, e) }, _T.format.filter.intersects = function (t, e, i) { return new jS(t, e, i) }, _T.format.filter.isNull = function (t) { return new zS(t) }, _T.format.filter.lessThan = function (t, e) { return new XS(t, e) }, _T.format.filter.lessThanOrEqualTo = function (t, e) { return new VS(t, e) }, _T.format.filter.like = function (t, e, i, n, r, s) { return new US(t, e, i, n, r, s) }, _T.format.filter.not = function (t) { return new WS(t) }, _T.format.filter.notEqualTo = function (t, e, i) { return new ZS(t, e, i) }, _T.format.filter.or = function (t) { const e = [null].concat(Array.prototype.slice.call(arguments)); return new (Function.prototype.bind.apply(YS, e)) }, _T.format.filter.resourceId = function (t) { return new KS(t) }, _T.format.filter.within = function (t, e, i) { return new qS(t, e, i) }, _T.format.xlink = {}, _T.format.xlink.readHref = Yv, _T.format.xsd = {}, _T.format.xsd.readBoolean = N_, _T.format.xsd.readBooleanString = D_, _T.format.xsd.readDateTime = k_, _T.format.xsd.readDecimal = G_, _T.format.xsd.readDecimalString = j_, _T.format.xsd.readNonNegativeIntegerString = U_, _T.format.xsd.readPositiveInteger = B_, _T.format.xsd.readString = z_, _T.format.xsd.writeBooleanTextNode = X_, _T.format.xsd.writeCDATASection = V_, _T.format.xsd.writeDateTimeTextNode = W_, _T.format.xsd.writeDecimalTextNode = Z_, _T.format.xsd.writeNonNegativeIntegerTextNode = Y_, _T.format.xsd.writeStringTextNode = K_, _T.functions = {}, _T.functions.FALSE = f, _T.functions.TRUE = g, _T.functions.VOID = p, _T.functions.memoizeOne = m, _T.functions.toPromise = _, _T.geom = {}, _T.geom.Circle = Pp, _T.geom.Geometry = mn, _T.geom.GeometryCollection = Ip, _T.geom.LineString = Op, _T.geom.LinearRing = Vn, _T.geom.MultiLineString = Np, _T.geom.MultiPoint = Dp, _T.geom.MultiPolygon = Gp, _T.geom.Point = Wn, _T.geom.Polygon = ur, _T.geom.Polygon.circular = dr, _T.geom.Polygon.fromCircle = fr, _T.geom.Polygon.fromExtent = gr, _T.geom.Polygon.makeRegular = pr, _T.geom.SimpleGeometry = _n, _T.geom.SimpleGeometry.getStrideForLayout = yn, _T.geom.SimpleGeometry.transformGeom2D = xn, _T.geom.flat = {}, _T.geom.flat.area = {}, _T.geom.flat.area.linearRing = Un, _T.geom.flat.area.linearRings = zn, _T.geom.flat.area.linearRingss = Xn, _T.geom.flat.center = {}, _T.geom.flat.center.linearRingss = kp, _T.geom.flat.closest = {}, _T.geom.flat.closest.arrayMaxSquaredDelta = wn, _T.geom.flat.closest.assignClosestArrayPoint = Cn, _T.geom.flat.closest.assignClosestMultiArrayPoint = bn, _T.geom.flat.closest.assignClosestPoint = Tn, _T.geom.flat.closest.maxSquaredDelta = Sn, _T.geom.flat.closest.multiArrayMaxSquaredDelta = En, _T.geom.flat.contains = {}, _T.geom.flat.contains.linearRingContainsExtent = Zn, _T.geom.flat.contains.linearRingContainsXY = Yn, _T.geom.flat.contains.linearRingsContainsXY = Kn, _T.geom.flat.contains.linearRingssContainsXY = qn, _T.geom.flat.deflate = {}, _T.geom.flat.deflate.deflateCoordinate = Rn, _T.geom.flat.deflate.deflateCoordinates = Pn, _T.geom.flat.deflate.deflateCoordinatesArray = In, _T.geom.flat.deflate.deflateMultiCoordinatesArray = Ln, _T.geom.flat.flip = {}, _T.geom.flat.flip.flipXY = w_, _T.geom.flat.geodesic = {}, _T.geom.flat.geodesic.greatCircleArc = function (t, e, i, n, r, s) { const o = Ui("EPSG:4326"), a = Math.cos(ai(e)), l = Math.sin(ai(e)), h = Math.cos(ai(n)), c = Math.sin(ai(n)), u = Math.cos(ai(i - t)), d = Math.sin(ai(i - t)), g = l * c + a * h * u; return Xp((function (e) { if (1 <= g) return [i, n]; const r = e * Math.acos(g), s = Math.cos(r), o = Math.sin(r), f = d * h, p = a * c - l * h * u, m = Math.atan2(f, p), _ = Math.asin(l * s + a * o * Math.cos(m)); return [oi(ai(t) + Math.atan2(Math.sin(m) * o * a, s - l * Math.sin(_))), oi(_)] }), Hi(o, r), s) }, _T.geom.flat.geodesic.meridian = Vp, _T.geom.flat.geodesic.parallel = Wp, _T.geom.flat.inflate = {}, _T.geom.flat.inflate.inflateCoordinates = Gn, _T.geom.flat.inflate.inflateCoordinatesArray = jn, _T.geom.flat.inflate.inflateMultiCoordinatesArray = Bn, _T.geom.flat.interiorpoint = {}, _T.geom.flat.interiorpoint.getInteriorPointOfArray = Hn, _T.geom.flat.interiorpoint.getInteriorPointsOfMultiArray = $n, _T.geom.flat.interpolate = {}, _T.geom.flat.interpolate.interpolatePoint = Mp, _T.geom.flat.interpolate.lineStringCoordinateAtM = Fp, _T.geom.flat.interpolate.lineStringsCoordinateAtM = Ap, _T.geom.flat.intersectsextent = {}, _T.geom.flat.intersectsextent.intersectsLineString = Qn, _T.geom.flat.intersectsextent.intersectsLineStringArray = tr, _T.geom.flat.intersectsextent.intersectsLinearRing = er, _T.geom.flat.intersectsextent.intersectsLinearRingArray = ir, _T.geom.flat.intersectsextent.intersectsLinearRingMultiArray = nr, _T.geom.flat.length = {}, _T.geom.flat.length.lineStringLength = sp, _T.geom.flat.length.linearRingLength = function (t, e, i, n) { let r = sp(t, e, i, n); const s = t[i - n] - t[e], o = t[i - n + 1] - t[e + 1]; return r += Math.sqrt(s * s + o * o), r }, _T.geom.flat.orient = {}, _T.geom.flat.orient.inflateEnds = cr, _T.geom.flat.orient.linearRingIsClockwise = sr, _T.geom.flat.orient.linearRingsAreOriented = or, _T.geom.flat.orient.linearRingssAreOriented = ar, _T.geom.flat.orient.orientLinearRings = lr, _T.geom.flat.orient.orientLinearRingsArray = hr, _T.geom.flat.reverse = {}, _T.geom.flat.reverse.coordinates = rr, _T.geom.flat.segments = {}, _T.geom.flat.segments.forEach = Jn, _T.geom.flat.simplify = {}, _T.geom.flat.simplify.douglasPeucker = Mn, _T.geom.flat.simplify.douglasPeuckerArray = Fn, _T.geom.flat.simplify.douglasPeuckerMultiArray = function (t, e, i, n, r, s, o, a) { for (let l = 0, h = i.length; l < h; ++l) { const h = i[l], c = []; o = Fn(t, e, h, n, r, s, o, c), a.push(c), e = h[h.length - 1] } return o }, _T.geom.flat.simplify.quantize = Nn, _T.geom.flat.simplify.quantizeArray = Dn, _T.geom.flat.simplify.quantizeMultiArray = kn, _T.geom.flat.simplify.radialDistance = An, _T.geom.flat.simplify.simplifyLineString = function (t, e, i, n, r, s, o) { return o = void 0 !== o ? o : [], s || (i = An(t, e, i, n, r, o, 0), t = o, e = 0, n = 2), o.length = Mn(t, e, i, n, r, o, 0), o }, _T.geom.flat.simplify.snap = On, _T.geom.flat.straightchunk = {}, _T.geom.flat.straightchunk.matchingChunk = Qf, _T.geom.flat.textpath = {}, _T.geom.flat.textpath.drawTextOnPath = rp, _T.geom.flat.topology = {}, _T.geom.flat.topology.lineStringIsClosed = function (t, e, i, n) { const r = i - n; return t[e] === t[r] && t[e + 1] === t[r + 1] && (i - e) / n > 3 && !!Un(t, e, i, n) }, _T.geom.flat.transform = {}, _T.geom.flat.transform.rotate = dn, _T.geom.flat.transform.scale = gn, _T.geom.flat.transform.transform2D = un, _T.geom.flat.transform.translate = fn, _T.has = {}, _T.has.DEVICE_PIXEL_RATIO = mt, _T.has.FIREFOX = ut, _T.has.IMAGE_DECODE = yt, _T.has.MAC = pt, _T.has.PASSIVE_EVENT_LISTENERS = xt, _T.has.SAFARI = dt, _T.has.SAFARI_BUG_237906 = gt, _T.has.WEBKIT = ft, _T.has.WORKER_OFFSCREEN_CANVAS = _t, _T.interaction = {}, _T.interaction.DoubleClickZoom = ra, _T.interaction.DragAndDrop = class extends ea { constructor(t) { t = t || {}, super({ handleEvent: g }), this.on, this.once, this.un, this.readAsBuffer_ = !1, this.formats_ = []; const e = t.formatConstructors ? t.formatConstructors : []; for (let t = 0, i = e.length; t < i; ++t) { let i = e[t]; "function" == typeof i && (i = new i), this.formats_.push(i), this.readAsBuffer_ = this.readAsBuffer_ || "arraybuffer" === i.getType() } this.projection_ = t.projection ? Ui(t.projection) : null, this.dropListenKeys_ = null, this.source_ = t.source || null, this.target = t.target ? t.target : null } handleResult_(t, e) { const i = e.target.result, n = this.getMap(); let r, s = this.projection_; if (!s && (s = en(), !s)) { s = n.getView().getProjection() } const o = this.formats_; for (let e = 0, n = o.length; e < n; ++e) { const n = o[e]; let a = i; this.readAsBuffer_ && "arraybuffer" !== n.getType() && (void 0 === r && (r = (new TextDecoder).decode(i)), a = r); const l = this.tryReadFeatures_(n, a, { featureProjection: s }); if (l && l.length > 0) { this.source_ && (this.source_.clear(), this.source_.addFeatures(l)), this.dispatchEvent(new Am(Fm, t, l, s)); break } } } registerListeners_() { const t = this.getMap(); if (t) { const e = this.target ? this.target : t.getViewport(); this.dropListenKeys_ = [N(e, P, this.handleDrop, this), N(e, b, this.handleStop, this), N(e, R, this.handleStop, this), N(e, P, this.handleStop, this)] } } setActive(t) { !this.getActive() && t && this.registerListeners_(), this.getActive() && !t && this.unregisterListeners_(), super.setActive(t) } setMap(t) { this.unregisterListeners_(), super.setMap(t), this.getActive() && this.registerListeners_() } tryReadFeatures_(t, e, i) { try { return t.readFeatures(e, i) } catch (t) { return null } } unregisterListeners_() { this.dropListenKeys_ && (this.dropListenKeys_.forEach(k), this.dropListenKeys_ = null) } handleDrop(t) { const e = t.dataTransfer.files; for (let t = 0, i = e.length; t < i; ++t) { const i = e.item(t), n = new FileReader; n.addEventListener(M, this.handleResult_.bind(this, i)), this.readAsBuffer_ ? n.readAsArrayBuffer(i) : n.readAsText(i) } } handleStop(t) { t.stopPropagation(), t.preventDefault(), t.dataTransfer.dropEffect = "copy" } }, _T.interaction.DragAndDrop.DragAndDropEvent = Am, _T.interaction.DragBox = Ia, _T.interaction.DragBox.DragBoxEvent = Pa, _T.interaction.DragPan = Sa, _T.interaction.DragRotate = wa, _T.interaction.DragRotateAndZoom = class extends sa { constructor(t) { super(t = t || {}), this.condition_ = t.condition ? t.condition : _a, this.lastAngle_ = void 0, this.lastMagnitude_ = void 0, this.lastScaleDelta_ = 0, this.duration_ = void 0 !== t.duration ? t.duration : 400 } handleDragEvent(t) { if (!xa(t)) return; const e = t.map, i = e.getSize(), n = t.pixel, r = n[0] - i[0] / 2, s = i[1] / 2 - n[1], o = Math.atan2(s, r), a = Math.sqrt(r * r + s * s), l = e.getView(); if (void 0 !== this.lastAngle_) { const t = this.lastAngle_ - o; l.adjustRotationInternal(t) } this.lastAngle_ = o, void 0 !== this.lastMagnitude_ && l.adjustResolutionInternal(this.lastMagnitude_ / a), void 0 !== this.lastMagnitude_ && (this.lastScaleDelta_ = this.lastMagnitude_ / a), this.lastMagnitude_ = a } handleUpEvent(t) { if (!xa(t)) return !0; const e = t.map.getView(), i = this.lastScaleDelta_ > 1 ? 1 : -1; return e.endInteraction(this.duration_, i), this.lastScaleDelta_ = 0, !1 } handleDownEvent(t) { return !!xa(t) && (!!this.condition_(t) && (t.map.getView().beginInteraction(), this.lastAngle_ = void 0, this.lastMagnitude_ = void 0, !0)) } }, _T.interaction.DragZoom = La, _T.interaction.Draw = class extends sa { constructor(t) { const e = t; e.stopDown || (e.stopDown = f), super(e), this.on, this.once, this.un, this.shouldHandle_ = !1, this.downPx_ = null, this.downTimeout_, this.lastDragTime_, this.pointerType_, this.freehand_ = !1, this.source_ = t.source ? t.source : null, this.features_ = t.features ? t.features : null, this.snapTolerance_ = t.snapTolerance ? t.snapTolerance : 12, this.type_ = t.type, this.mode_ = function (t) { switch (t) { case "Point": case "MultiPoint": return "Point"; case "LineString": case "MultiLineString": return "LineString"; case "Polygon": case "MultiPolygon": return "Polygon"; case "Circle": return "Circle"; default: throw new Error("Invalid type: " + t) } }(this.type_), this.stopClick_ = !!t.stopClick, this.minPoints_ = t.minPoints ? t.minPoints : "Polygon" === this.mode_ ? 3 : 2, this.maxPoints_ = "Circle" === this.mode_ ? 2 : t.maxPoints ? t.maxPoints : 1 / 0, this.finishCondition_ = t.finishCondition ? t.finishCondition : g, this.geometryLayout_ = t.geometryLayout ? t.geometryLayout : "XY"; let i = t.geometryFunction; if (!i) { const t = this.mode_; if ("Circle" === t) i = function (t, e, i) { const n = e || new Pp([NaN, NaN]), r = rn(t[0], i), s = Ti(r, rn(t[t.length - 1], i)); n.setCenterAndRadius(r, Math.sqrt(s), this.geometryLayout_); const o = en(); return o && n.transform(i, o), n }; else { let e; "Point" === t ? e = Wn : "LineString" === t ? e = Op : "Polygon" === t && (e = ur), i = function (i, n, r) { return n ? "Polygon" === t ? i[0].length ? n.setCoordinates([i[0].concat([i[0][0]])], this.geometryLayout_) : n.setCoordinates([], this.geometryLayout_) : n.setCoordinates(i, this.geometryLayout_) : n = new e(i, this.geometryLayout_), n } } } this.geometryFunction_ = i, this.dragVertexDelay_ = void 0 !== t.dragVertexDelay ? t.dragVertexDelay : 500, this.finishCoordinate_ = null, this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchCoords_ = null, this.sketchLine_ = null, this.sketchLineCoords_ = null, this.squaredClickTolerance_ = t.clickTolerance ? t.clickTolerance * t.clickTolerance : 36, this.overlay_ = new zp({ source: new zh({ useSpatialIndex: !1, wrapX: !!t.wrapX && t.wrapX }), style: t.style ? t.style : Ym(), updateWhileInteracting: !0 }), this.geometryName_ = t.geometryName, this.condition_ = t.condition ? t.condition : ma, this.freehandCondition_, t.freehand ? this.freehandCondition_ = da : this.freehandCondition_ = t.freehandCondition ? t.freehandCondition : _a, this.traceCondition_, this.setTrace(t.trace || !1), this.traceState_ = { active: !1 }, this.traceSource_ = t.traceSource || t.source || null, this.addChangeListener(ta, this.updateState_) } setTrace(t) { let e; e = t ? !0 === t ? da : t : fa, this.traceCondition_ = e } setMap(t) { super.setMap(t), this.updateState_() } getOverlay() { return this.overlay_ } handleEvent(t) { t.originalEvent.type === E && t.originalEvent.preventDefault(), this.freehand_ = "Point" !== this.mode_ && this.freehandCondition_(t); let e = t.type === ao.POINTERMOVE, i = !0; if (!this.freehand_ && this.lastDragTime_ && t.type === ao.POINTERDRAG) { Date.now() - this.lastDragTime_ >= this.dragVertexDelay_ ? (this.downPx_ = t.pixel, this.shouldHandle_ = !this.freehand_, e = !0) : this.lastDragTime_ = void 0, this.shouldHandle_ && void 0 !== this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0) } return this.freehand_ && t.type === ao.POINTERDRAG && null !== this.sketchFeature_ ? (this.addToDrawing_(t.coordinate), i = !1) : this.freehand_ && t.type === ao.POINTERDOWN ? i = !1 : e && this.getPointerCount() < 2 ? (i = t.type === ao.POINTERMOVE, i && this.freehand_ ? (this.handlePointerMove_(t), this.shouldHandle_ && t.originalEvent.preventDefault()) : ("mouse" === t.originalEvent.pointerType || t.type === ao.POINTERDRAG && void 0 === this.downTimeout_) && this.handlePointerMove_(t)) : t.type === ao.DBLCLICK && (i = !1), super.handleEvent(t) && i } handleDownEvent(t) { return this.shouldHandle_ = !this.freehand_, this.freehand_ ? (this.downPx_ = t.pixel, this.finishCoordinate_ || this.startDrawing_(t.coordinate), !0) : this.condition_(t) ? (this.lastDragTime_ = Date.now(), this.downTimeout_ = setTimeout(function () { this.handlePointerMove_(new oo(ao.POINTERMOVE, t.map, t.originalEvent, !1, t.frameState)) }.bind(this), this.dragVertexDelay_), this.downPx_ = t.pixel, !0) : (this.lastDragTime_ = void 0, !1) } deactivateTrace_() { this.traceState_ = { active: !1 } } toggleTraceState_(t) { if (!this.traceSource_ || !this.traceCondition_(t)) return; if (this.traceState_.active) return void this.deactivateTrace_(); const e = this.getMap(), i = zt([e.getCoordinateFromPixel([t.pixel[0] - this.snapTolerance_, t.pixel[1] + this.snapTolerance_]), e.getCoordinateFromPixel([t.pixel[0] + this.snapTolerance_, t.pixel[1] - this.snapTolerance_])]), n = this.traceSource_.getFeaturesInExtent(i); if (0 === n.length) return; const r = function (t, e) { const i = []; for (let n = 0; n < e.length; ++n)Um(t, e[n].getGeometry(), i); return i }(t.coordinate, n); r.length && (this.traceState_ = { active: !0, startPx: t.pixel.slice(), targets: r, targetIndex: -1 }) } addOrRemoveTracedCoordinates_(t, e) { const i = t.startIndex <= t.endIndex; i === t.startIndex <= e ? i && e > t.endIndex || !i && e < t.endIndex ? this.addTracedCoordinates_(t, t.endIndex, e) : (i && e < t.endIndex || !i && e > t.endIndex) && this.removeTracedCoordinates_(e, t.endIndex) : (this.removeTracedCoordinates_(t.startIndex, t.endIndex), this.addTracedCoordinates_(t, t.startIndex, e)) } removeTracedCoordinates_(t, e) { if (t === e) return; let i = 0; if (t < e) { const n = Math.ceil(t); let r = Math.floor(e); r === e && (r -= 1), i = r - n + 1 } else { const n = Math.floor(t); let r = Math.ceil(e); r === e && (r += 1), i = n - r + 1 } i > 0 && this.removeLastPoints_(i) } addTracedCoordinates_(t, e, i) { if (e === i) return; const n = []; if (e < i) { const r = Math.ceil(e); let s = Math.floor(i); s === i && (s -= 1); for (let e = r; e <= s; ++e)n.push(jm(t.coordinates, e)) } else { const r = Math.floor(e); let s = Math.ceil(i); s === i && (s += 1); for (let e = r; e >= s; --e)n.push(jm(t.coordinates, e)) } n.length && this.appendCoordinates(n) } updateTrace_(t) { const e = this.traceState_; if (!e.active) return; if (-1 === e.targetIndex && Ci(e.startPx, t.pixel) < this.snapTolerance_) return; const i = function (t, e, i, n) { const r = t[0], s = t[1]; let o = 1 / 0, a = -1, l = NaN; for (let t = 0; t < e.targets.length; ++t) { const i = e.targets[t], n = i.coordinates; let h, c = 1 / 0; for (let t = 0; t < n.length - 1; ++t) { const e = Wm(r, s, n[t], n[t + 1]); e.squaredDistance < c && (c = e.squaredDistance, h = t + e.along) } c < o && (o = c, i.ring && e.targetIndex === t && (i.endIndex > i.startIndex ? h < i.startIndex && (h += n.length) : i.endIndex < i.startIndex && h > i.startIndex && (h -= n.length)), l = h, a = t) } const h = e.targets[a]; let c = h.ring; if (e.targetIndex === a && c) { const t = Zm(h.coordinates, l); Ci(i.getPixelFromCoordinate(t), e.startPx) > n && (c = !1) } if (c) { const t = h.coordinates, e = t.length, i = h.startIndex, n = l; if (i < n) { const r = Bm(t, i, n); Bm(t, i, n - e) < r && (l -= e) } else { const r = Bm(t, i, n); Bm(t, i, n + e) < r && (l += e) } } return zm.index = a, zm.endIndex = l, zm }(t.coordinate, e, this.getMap(), this.snapTolerance_); if (e.targetIndex !== i.index) { if (-1 !== e.targetIndex) { const t = e.targets[e.targetIndex]; this.removeTracedCoordinates_(t.startIndex, t.endIndex) } const t = e.targets[i.index]; this.addTracedCoordinates_(t, t.startIndex, i.endIndex) } else { const t = e.targets[e.targetIndex]; this.addOrRemoveTracedCoordinates_(t, i.endIndex) } e.targetIndex = i.index; const n = e.targets[e.targetIndex]; n.endIndex = i.endIndex; const r = Zm(n.coordinates, n.endIndex), s = this.getMap().getPixelFromCoordinate(r); t.coordinate = r, t.pixel = [Math.round(s[0]), Math.round(s[1])] } handleUpEvent(t) { let e = !0; if (0 === this.getPointerCount()) { this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0), this.handlePointerMove_(t); const i = this.traceState_.active; if (this.toggleTraceState_(t), this.shouldHandle_) { const n = !this.finishCoordinate_; n && this.startDrawing_(t.coordinate), !n && this.freehand_ ? this.finishDrawing() : this.freehand_ || n && "Point" !== this.mode_ || (this.atFinish_(t.pixel, i) ? this.finishCondition_(t) && this.finishDrawing() : this.addToDrawing_(t.coordinate)), e = !1 } else this.freehand_ && this.abortDrawing() } return !e && this.stopClick_ && t.preventDefault(), e } handlePointerMove_(t) { if (this.pointerType_ = t.originalEvent.pointerType, this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) { const e = this.downPx_, i = t.pixel, n = e[0] - i[0], r = e[1] - i[1], s = n * n + r * r; if (this.shouldHandle_ = this.freehand_ ? s > this.squaredClickTolerance_ : s <= this.squaredClickTolerance_, !this.shouldHandle_) return } this.finishCoordinate_ ? (this.updateTrace_(t), this.modifyDrawing_(t.coordinate)) : this.createOrUpdateSketchPoint_(t.coordinate.slice()) } atFinish_(t, e) { let i = !1; if (this.sketchFeature_) { let n = !1, r = [this.finishCoordinate_]; const s = this.mode_; if ("Point" === s) i = !0; else if ("Circle" === s) i = 2 === this.sketchCoords_.length; else if ("LineString" === s) n = !e && this.sketchCoords_.length > this.minPoints_; else if ("Polygon" === s) { const t = this.sketchCoords_; n = t[0].length > this.minPoints_, r = [t[0][0], t[0][t[0].length - 2]], r = e ? [t[0][0]] : [t[0][0], t[0][t[0].length - 2]] } if (n) { const e = this.getMap(); for (let n = 0, s = r.length; n < s; n++) { const s = r[n], o = e.getPixelFromCoordinate(s), a = t[0] - o[0], l = t[1] - o[1], h = this.freehand_ ? 1 : this.snapTolerance_; if (i = Math.sqrt(a * a + l * l) <= h, i) { this.finishCoordinate_ = s; break } } } } return i } createOrUpdateSketchPoint_(t) { if (this.sketchPoint_) { this.sketchPoint_.getGeometry().setCoordinates(t) } else this.sketchPoint_ = new lt(new Wn(t)), this.updateSketchFeatures_() } createOrUpdateCustomSketchLine_(t) { this.sketchLine_ || (this.sketchLine_ = new lt); const e = t.getLinearRing(0); let i = this.sketchLine_.getGeometry(); i ? (i.setFlatCoordinates(e.getLayout(), e.getFlatCoordinates()), i.changed()) : (i = new Op(e.getFlatCoordinates(), e.getLayout()), this.sketchLine_.setGeometry(i)) } startDrawing_(t) { const e = this.getMap().getView().getProjection(), i = yn(this.geometryLayout_); for (; t.length < i;)t.push(0); this.finishCoordinate_ = t, "Point" === this.mode_ ? this.sketchCoords_ = t.slice() : "Polygon" === this.mode_ ? (this.sketchCoords_ = [[t.slice(), t.slice()]], this.sketchLineCoords_ = this.sketchCoords_[0]) : this.sketchCoords_ = [t.slice(), t.slice()], this.sketchLineCoords_ && (this.sketchLine_ = new lt(new Op(this.sketchLineCoords_))); const n = this.geometryFunction_(this.sketchCoords_, void 0, e); this.sketchFeature_ = new lt, this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_), this.sketchFeature_.setGeometry(n), this.updateSketchFeatures_(), this.dispatchEvent(new km(Om, this.sketchFeature_)) } modifyDrawing_(t) { const e = this.getMap(), i = this.sketchFeature_.getGeometry(), n = e.getView().getProjection(), r = yn(this.geometryLayout_); let s, o; for (; t.length < r;)t.push(0); if ("Point" === this.mode_ ? o = this.sketchCoords_ : "Polygon" === this.mode_ ? (s = this.sketchCoords_[0], o = s[s.length - 1], this.atFinish_(e.getPixelFromCoordinate(t)) && (t = this.finishCoordinate_.slice())) : (s = this.sketchCoords_, o = s[s.length - 1]), o[0] = t[0], o[1] = t[1], this.geometryFunction_(this.sketchCoords_, i, n), this.sketchPoint_) { this.sketchPoint_.getGeometry().setCoordinates(t) } if ("Polygon" === i.getType() && "Polygon" !== this.mode_) this.createOrUpdateCustomSketchLine_(i); else if (this.sketchLineCoords_) { this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_) } this.updateSketchFeatures_() } addToDrawing_(t) { const e = this.sketchFeature_.getGeometry(), i = this.getMap().getView().getProjection(); let n, r; const s = this.mode_; "LineString" === s || "Circle" === s ? (this.finishCoordinate_ = t.slice(), r = this.sketchCoords_, r.length >= this.maxPoints_ && (this.freehand_ ? r.pop() : n = !0), r.push(t.slice()), this.geometryFunction_(r, e, i)) : "Polygon" === s && (r = this.sketchCoords_[0], r.length >= this.maxPoints_ && (this.freehand_ ? r.pop() : n = !0), r.push(t.slice()), n && (this.finishCoordinate_ = r[0]), this.geometryFunction_(this.sketchCoords_, e, i)), this.createOrUpdateSketchPoint_(t.slice()), this.updateSketchFeatures_(), n && this.finishDrawing() } removeLastPoints_(t) { if (!this.sketchFeature_) return; const e = this.sketchFeature_.getGeometry(), i = this.getMap().getView().getProjection(), n = this.mode_; for (let r = 0; r < t; ++r) { let t; if ("LineString" === n || "Circle" === n) { if (t = this.sketchCoords_, t.splice(-2, 1), t.length >= 2) { this.finishCoordinate_ = t[t.length - 2].slice(); const e = this.finishCoordinate_.slice(); t[t.length - 1] = e, this.createOrUpdateSketchPoint_(e) } this.geometryFunction_(t, e, i), "Polygon" === e.getType() && this.sketchLine_ && this.createOrUpdateCustomSketchLine_(e) } else if ("Polygon" === n) { t = this.sketchCoords_[0], t.splice(-2, 1); const n = this.sketchLine_.getGeometry(); if (t.length >= 2) { const e = t[t.length - 2].slice(); t[t.length - 1] = e, this.createOrUpdateSketchPoint_(e) } n.setCoordinates(t), this.geometryFunction_(this.sketchCoords_, e, i) } if (1 === t.length) { this.abortDrawing(); break } } this.updateSketchFeatures_() } removeLastPoint() { this.removeLastPoints_(1) } finishDrawing() { const t = this.abortDrawing_(); if (!t) return; let e = this.sketchCoords_; const i = t.getGeometry(), n = this.getMap().getView().getProjection(); "LineString" === this.mode_ ? (e.pop(), this.geometryFunction_(e, i, n)) : "Polygon" === this.mode_ && (e[0].pop(), this.geometryFunction_(e, i, n), e = i.getCoordinates()), "MultiPoint" === this.type_ ? t.setGeometry(new Dp([e])) : "MultiLineString" === this.type_ ? t.setGeometry(new Np([e])) : "MultiPolygon" === this.type_ && t.setGeometry(new Gp([e])), this.dispatchEvent(new km(Nm, t)), this.features_ && this.features_.push(t), this.source_ && this.source_.addFeature(t) } abortDrawing_() { this.finishCoordinate_ = null; const t = this.sketchFeature_; return this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchLine_ = null, this.overlay_.getSource().clear(!0), this.deactivateTrace_(), t } abortDrawing() { const t = this.abortDrawing_(); t && this.dispatchEvent(new km(Dm, t)) } appendCoordinates(t) { const e = this.mode_, i = !this.sketchFeature_; let n; if (i && this.startDrawing_(t[0]), "LineString" === e || "Circle" === e) n = this.sketchCoords_; else { if ("Polygon" !== e) return; n = this.sketchCoords_ && this.sketchCoords_.length ? this.sketchCoords_[0] : [] } i && n.shift(), n.pop(); for (let e = 0; e < t.length; e++)this.addToDrawing_(t[e]); const r = t[t.length - 1]; this.addToDrawing_(r), this.modifyDrawing_(r) } extend(t) { const e = t.getGeometry(); this.sketchFeature_ = t, this.sketchCoords_ = e.getCoordinates(); const i = this.sketchCoords_[this.sketchCoords_.length - 1]; this.finishCoordinate_ = i.slice(), this.sketchCoords_.push(i.slice()), this.sketchPoint_ = new lt(new Wn(i)), this.updateSketchFeatures_(), this.dispatchEvent(new km(Om, this.sketchFeature_)) } updateSketchFeatures_() { const t = []; this.sketchFeature_ && t.push(this.sketchFeature_), this.sketchLine_ && t.push(this.sketchLine_), this.sketchPoint_ && t.push(this.sketchPoint_); const e = this.overlay_.getSource(); e.clear(!0), e.addFeatures(t) } updateState_() { const t = this.getMap(), e = this.getActive(); t && e || this.abortDrawing(), this.overlay_.setMap(e ? t : null) } }, _T.interaction.Draw.DrawEvent = km, _T.interaction.Draw.createBox = function () { return function (t, e, i) { const n = zt([t[0], t[t.length - 1]].map((function (t) { return rn(t, i) }))), r = [[ue(n), de(n), ve(n), xe(n), ue(n)]]; e ? e.setCoordinates(r) : e = new ur(r); const s = en(); return s && e.transform(i, s), e } }, _T.interaction.Draw.createRegularPolygon = function (t, e) { return function (i, n, r) { const s = rn(i[0], r), o = rn(i[i.length - 1], r), a = Math.sqrt(Ti(s, o)); n = n || fr(new Pp(s), t); let l = e; if (!e && 0 !== e) { const t = o[0] - s[0], e = o[1] - s[1]; l = Math.atan2(e, t) } pr(n, s, a, l); const h = en(); return h && n.transform(r, h), n } }, _T.interaction.Extent = class extends sa { constructor(t) { super(t = t || {}), this.on, this.once, this.un, this.condition_ = t.condition ? t.condition : da, this.extent_ = null, this.pointerHandler_ = null, this.pixelTolerance_ = void 0 !== t.pixelTolerance ? t.pixelTolerance : 10, this.snappedToVertex_ = !1, this.extentFeature_ = null, this.vertexFeature_ = null, t || (t = {}), this.extentOverlay_ = new zp({ source: new zh({ useSpatialIndex: !1, wrapX: !!t.wrapX }), style: t.boxStyle ? t.boxStyle : Hm(), updateWhileAnimating: !0, updateWhileInteracting: !0 }), this.vertexOverlay_ = new zp({ source: new zh({ useSpatialIndex: !1, wrapX: !!t.wrapX }), style: t.pointerStyle ? t.pointerStyle : $m(), updateWhileAnimating: !0, updateWhileInteracting: !0 }), t.extent && this.setExtent(t.extent) } snapToVertex_(t, e) { const i = e.getCoordinateFromPixelInternal(t), n = function (t, e) { return bi(i, t) - bi(i, e) }, r = this.getExtentInternal(); if (r) { const s = function (t) { return [[[t[0], t[1]], [t[0], t[3]]], [[t[0], t[3]], [t[2], t[3]]], [[t[2], t[3]], [t[2], t[1]]], [[t[2], t[1]], [t[0], t[1]]]] }(r); s.sort(n); const o = s[0]; let a = yi(i, o); const l = e.getPixelFromCoordinateInternal(a); if (Ci(t, l) <= this.pixelTolerance_) { const t = e.getPixelFromCoordinateInternal(o[0]), i = e.getPixelFromCoordinateInternal(o[1]), n = Ti(l, t), r = Ti(l, i), s = Math.sqrt(Math.min(n, r)); return this.snappedToVertex_ = s <= this.pixelTolerance_, this.snappedToVertex_ && (a = n > r ? o[1] : o[0]), a } } return null } handlePointerMove_(t) { const e = t.pixel, i = t.map; let n = this.snapToVertex_(e, i); n || (n = i.getCoordinateFromPixelInternal(e)), this.createOrUpdatePointerFeature_(n) } createOrUpdateExtentFeature_(t) { let e = this.extentFeature_; return e ? t ? e.setGeometry(gr(t)) : e.setGeometry(void 0) : (e = new lt(t ? gr(t) : {}), this.extentFeature_ = e, this.extentOverlay_.getSource().addFeature(e)), e } createOrUpdatePointerFeature_(t) { let e = this.vertexFeature_; if (e) { e.getGeometry().setCoordinates(t) } else e = new lt(new Wn(t)), this.vertexFeature_ = e, this.vertexOverlay_.getSource().addFeature(e); return e } handleEvent(t) { return !t.originalEvent || !this.condition_(t) || (t.type != ao.POINTERMOVE || this.handlingDownUpSequence || this.handlePointerMove_(t), super.handleEvent(t), !1) } handleDownEvent(t) { const e = t.pixel, i = t.map, n = this.getExtentInternal(); let r = this.snapToVertex_(e, i); const s = function (t) { let e = null, i = null; return t[0] == n[0] ? e = n[2] : t[0] == n[2] && (e = n[0]), t[1] == n[1] ? i = n[3] : t[1] == n[3] && (i = n[1]), null !== e && null !== i ? [e, i] : null }; if (r && n) { const t = r[0] == n[0] || r[0] == n[2] ? r[0] : null, e = r[1] == n[1] || r[1] == n[3] ? r[1] : null; null !== t && null !== e ? this.pointerHandler_ = Jm(s(r)) : null !== t ? this.pointerHandler_ = Qm(s([t, n[1]]), s([t, n[3]])) : null !== e && (this.pointerHandler_ = Qm(s([n[0], e]), s([n[2], e]))) } else r = i.getCoordinateFromPixelInternal(e), this.setExtent([r[0], r[1], r[0], r[1]]), this.pointerHandler_ = Jm(r); return !0 } handleDragEvent(t) { if (this.pointerHandler_) { const e = t.coordinate; this.setExtent(this.pointerHandler_(e)), this.createOrUpdatePointerFeature_(e) } } handleUpEvent(t) { this.pointerHandler_ = null; const e = this.getExtentInternal(); return e && 0 !== ce(e) || this.setExtent(null), !1 } setMap(t) { this.extentOverlay_.setMap(t), this.vertexOverlay_.setMap(t), super.setMap(t) } getExtent() { return sn(this.getExtentInternal(), this.getMap().getView().getProjection()) } getExtentInternal() { return this.extent_ } setExtent(t) { this.extent_ = t || null, this.createOrUpdateExtentFeature_(t), this.dispatchEvent(new qm(this.extent_)) } }, _T.interaction.Extent.ExtentEvent = qm, _T.interaction.Interaction = ea, _T.interaction.Interaction.pan = ia, _T.interaction.Interaction.zoomByDelta = na, _T.interaction.KeyboardPan = Na, _T.interaction.KeyboardZoom = Da, _T.interaction.Link = class extends ea { constructor(t) { let e; super(), e = !0 === (t = Object.assign({ animate: !0, replace: !1, prefix: "" }, t || {})).animate ? { duration: 250 } : t.animate ? t.animate : null, this.animationOptions_ = e, this.replace_ = t.replace, this.prefix_ = t.prefix, this.listenerKeys_ = [], this.initial_ = !0, this.updateState_ = this.updateState_.bind(this) } getParamName_(t) { return this.prefix_ ? this.prefix_ + t : t } get_(t, e) { return t.get(this.getParamName_(e)) } set_(t, e, i) { t.set(this.getParamName_(e), i) } delete_(t, e) { t.delete(this.getParamName_(e)) } setMap(t) { const e = this.getMap(); super.setMap(t), t !== e && (e && this.unregisterListeners_(e), t && (this.initial_ = !0, this.updateState_(), this.registerListeners_(t))) } registerListeners_(t) { this.listenerKeys_.push(N(t, mo, this.updateUrl_, this), N(t.getLayerGroup(), S, this.updateUrl_, this), N(t, "change:layergroup", this.handleChangeLayerGroup_, this)), this.replace_ || addEventListener("popstate", this.updateState_) } unregisterListeners_(t) { for (let t = 0, e = this.listenerKeys_.length; t < e; ++t)k(this.listenerKeys_[t]); this.listenerKeys_.length = 0, this.replace_ || removeEventListener("popstate", this.updateState_); const e = new URL(window.location.href), i = e.searchParams; this.delete_(i, "x"), this.delete_(i, "y"), this.delete_(i, "z"), this.delete_(i, "r"), this.delete_(i, "l"), window.history.replaceState(null, "", e) } handleChangeLayerGroup_() { const t = this.getMap(); t && (this.unregisterListeners_(t), this.registerListeners_(t), this.initial_ = !0, this.updateUrl_()) } updateState_() { const t = this.getMap(); if (!t) return; const e = t.getView(); if (!e) return; const i = new URL(window.location.href).searchParams; let n = !1; const r = {}, s = t_(this.get_(i, "z")); i_(s, e.getZoom()) && (n = !0, r.zoom = s); const o = t_(this.get_(i, "r")); i_(o, e.getRotation()) && (n = !0, r.rotation = o); const a = [t_(this.get_(i, "x")), t_(this.get_(i, "y"))]; var l, h; l = a, h = e.getCenter(), (i_(l[0], h[0]) || i_(l[1], h[1])) && (n = !0, r.center = a), n && (!this.initial_ && this.animationOptions_ ? e.animate(Object.assign(r, this.animationOptions_)) : (r.center && e.setCenter(r.center), "zoom" in r && e.setZoom(r.zoom), "rotation" in r && e.setRotation(r.rotation))); const c = t.getAllLayers(), u = this.get_(i, "l"); if (u && u.length === c.length) for (let t = 0, e = c.length; t < e; ++t) { const e = parseInt(u[t]); if (!isNaN(e)) { const i = Boolean(e), n = c[t]; n.getVisible() !== i && n.setVisible(i) } } } updateUrl_() { const t = this.getMap(); if (!t) return; const e = t.getView(); if (!e) return; const i = this.initial_; this.initial_ = !1; const n = e.getCenter(), r = e.getZoom(), s = e.getRotation(), o = t.getAllLayers(), a = new Array(o.length); for (let t = 0, e = o.length; t < e; ++t)a[t] = o[t].getVisible() ? "1" : "0"; const l = new URL(window.location.href), h = l.searchParams; this.set_(h, "x", e_(n[0])), this.set_(h, "y", e_(n[1])), this.set_(h, "z", e_(r)), this.set_(h, "r", e_(s)), this.set_(h, "l", a.join("")), l.href !== window.location.href && (i || this.replace_ ? window.history.replaceState(null, "", l) : window.history.pushState(null, "", l)) } }, _T.interaction.Modify = class extends sa { constructor(t) { let e; if (super(t), this.on, this.once, this.un, this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this), this.condition_ = t.condition ? t.condition : va, this.defaultDeleteCondition_ = function (t) { return la(t) && pa(t) }, this.deleteCondition_ = t.deleteCondition ? t.deleteCondition : this.defaultDeleteCondition_, this.insertVertexCondition_ = t.insertVertexCondition ? t.insertVertexCondition : da, this.vertexFeature_ = null, this.vertexSegments_ = null, this.lastPixel_ = [0, 0], this.ignoreNextSingleClick_ = !1, this.featuresBeingModified_ = null, this.rBush_ = new Ah, this.pixelTolerance_ = void 0 !== t.pixelTolerance ? t.pixelTolerance : 10, this.snappedToVertex_ = !1, this.changingFeature_ = !1, this.dragSegments_ = [], this.overlay_ = new zp({ source: new zh({ useSpatialIndex: !1, wrapX: !!t.wrapX }), style: t.style ? t.style : u_(), updateWhileAnimating: !0, updateWhileInteracting: !0 }), this.SEGMENT_WRITERS_ = { Point: this.writePointGeometry_.bind(this), LineString: this.writeLineStringGeometry_.bind(this), LinearRing: this.writeLineStringGeometry_.bind(this), Polygon: this.writePolygonGeometry_.bind(this), MultiPoint: this.writeMultiPointGeometry_.bind(this), MultiLineString: this.writeMultiLineStringGeometry_.bind(this), MultiPolygon: this.writeMultiPolygonGeometry_.bind(this), Circle: this.writeCircleGeometry_.bind(this), GeometryCollection: this.writeGeometryCollectionGeometry_.bind(this) }, this.source_ = null, this.hitDetection_ = null, t.features ? e = t.features : t.source && (this.source_ = t.source, e = new q(this.source_.getFeatures()), this.source_.addEventListener(Oh, this.handleSourceAdd_.bind(this)), this.source_.addEventListener(kh, this.handleSourceRemove_.bind(this))), !e) throw new Error("The modify interaction requires features, a source or a layer"); t.hitDetection && (this.hitDetection_ = t.hitDetection), this.features_ = e, this.features_.forEach(this.addFeature_.bind(this)), this.features_.addEventListener(W, this.handleFeatureAdd_.bind(this)), this.features_.addEventListener(Z, this.handleFeatureRemove_.bind(this)), this.lastPointerEvent_ = null, this.delta_ = [0, 0], this.snapToPointer_ = void 0 === t.snapToPointer ? !this.hitDetection_ : t.snapToPointer } addFeature_(t) { const e = t.getGeometry(); if (e) { const i = this.SEGMENT_WRITERS_[e.getType()]; i && i(t, e) } const i = this.getMap(); i && i.isRendered() && this.getActive() && this.handlePointerAtPixel_(this.lastPixel_, i), t.addEventListener(S, this.boundHandleFeatureChange_) } willModifyFeatures_(t, e) { if (!this.featuresBeingModified_) { this.featuresBeingModified_ = new q; const i = this.featuresBeingModified_.getArray(); for (let t = 0, n = e.length; t < n; ++t) { const n = e[t]; for (let t = 0, e = n.length; t < e; ++t) { const e = n[t].feature; e && !i.includes(e) && this.featuresBeingModified_.push(e) } } 0 === this.featuresBeingModified_.getLength() ? this.featuresBeingModified_ = null : this.dispatchEvent(new a_(s_, this.featuresBeingModified_, t)) } } removeFeature_(t) { this.removeFeatureSegmentData_(t), this.vertexFeature_ && 0 === this.features_.getLength() && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), t.removeEventListener(S, this.boundHandleFeatureChange_) } removeFeatureSegmentData_(t) { const e = this.rBush_, i = []; e.forEach((function (e) { t === e.feature && i.push(e) })); for (let t = i.length - 1; t >= 0; --t) { const n = i[t]; for (let t = this.dragSegments_.length - 1; t >= 0; --t)this.dragSegments_[t][0] === n && this.dragSegments_.splice(t, 1); e.remove(n) } } setActive(t) { this.vertexFeature_ && !t && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), super.setActive(t) } setMap(t) { this.overlay_.setMap(t), super.setMap(t) } getOverlay() { return this.overlay_ } handleSourceAdd_(t) { t.feature && this.features_.push(t.feature) } handleSourceRemove_(t) { t.feature && this.features_.remove(t.feature) } handleFeatureAdd_(t) { this.addFeature_(t.element) } handleFeatureChange_(t) { if (!this.changingFeature_) { const e = t.target; this.removeFeature_(e), this.addFeature_(e) } } handleFeatureRemove_(t) { this.removeFeature_(t.element) } writePointGeometry_(t, e) { const i = e.getCoordinates(), n = { feature: t, geometry: e, segment: [i, i] }; this.rBush_.insert(e.getExtent(), n) } writeMultiPointGeometry_(t, e) { const i = e.getCoordinates(); for (let n = 0, r = i.length; n < r; ++n) { const r = i[n], s = { feature: t, geometry: e, depth: [n], index: n, segment: [r, r] }; this.rBush_.insert(e.getExtent(), s) } } writeLineStringGeometry_(t, e) { const i = e.getCoordinates(); for (let n = 0, r = i.length - 1; n < r; ++n) { const r = i.slice(n, n + 2), s = { feature: t, geometry: e, index: n, segment: r }; this.rBush_.insert(zt(r), s) } } writeMultiLineStringGeometry_(t, e) { const i = e.getCoordinates(); for (let n = 0, r = i.length; n < r; ++n) { const r = i[n]; for (let i = 0, s = r.length - 1; i < s; ++i) { const s = r.slice(i, i + 2), o = { feature: t, geometry: e, depth: [n], index: i, segment: s }; this.rBush_.insert(zt(s), o) } } } writePolygonGeometry_(t, e) { const i = e.getCoordinates(); for (let n = 0, r = i.length; n < r; ++n) { const r = i[n]; for (let i = 0, s = r.length - 1; i < s; ++i) { const s = r.slice(i, i + 2), o = { feature: t, geometry: e, depth: [n], index: i, segment: s }; this.rBush_.insert(zt(s), o) } } } writeMultiPolygonGeometry_(t, e) { const i = e.getCoordinates(); for (let n = 0, r = i.length; n < r; ++n) { const r = i[n]; for (let i = 0, s = r.length; i < s; ++i) { const s = r[i]; for (let r = 0, o = s.length - 1; r < o; ++r) { const o = s.slice(r, r + 2), a = { feature: t, geometry: e, depth: [i, n], index: r, segment: o }; this.rBush_.insert(zt(o), a) } } } } writeCircleGeometry_(t, e) { const i = e.getCenter(), n = { feature: t, geometry: e, index: 0, segment: [i, i] }, r = { feature: t, geometry: e, index: 1, segment: [i, i] }, s = [n, r]; n.featureSegments = s, r.featureSegments = s, this.rBush_.insert(Qt(i), n); let o = e; const a = en(); if (a && this.getMap()) { const t = this.getMap().getView().getProjection(); o = o.clone().transform(a, t), o = fr(o).transform(t, a) } this.rBush_.insert(o.getExtent(), r) } writeGeometryCollectionGeometry_(t, e) { const i = e.getGeometriesArray(); for (let e = 0; e < i.length; ++e) { const n = i[e]; (0, this.SEGMENT_WRITERS_[n.getType()])(t, n) } } createOrUpdateVertexFeature_(t, e, i) { let n = this.vertexFeature_; if (n) { n.getGeometry().setCoordinates(t) } else n = new lt(new Wn(t)), this.vertexFeature_ = n, this.overlay_.getSource().addFeature(n); return n.set("features", e), n.set("geometries", i), n } handleEvent(t) { if (!t.originalEvent) return !0; let e; return this.lastPointerEvent_ = t, t.map.getView().getInteracting() || t.type != ao.POINTERMOVE || this.handlingDownUpSequence || this.handlePointerMove_(t), this.vertexFeature_ && this.deleteCondition_(t) && (e = !(t.type != ao.SINGLECLICK || !this.ignoreNextSingleClick_) || this.removePoint()), t.type == ao.SINGLECLICK && (this.ignoreNextSingleClick_ = !1), super.handleEvent(t) && !e } handleDragEvent(t) { this.ignoreNextSingleClick_ = !1, this.willModifyFeatures_(t, this.dragSegments_); const e = [t.coordinate[0] + this.delta_[0], t.coordinate[1] + this.delta_[1]], i = [], n = []; for (let r = 0, s = this.dragSegments_.length; r < s; ++r) { const s = this.dragSegments_[r], o = s[0], a = o.feature; i.includes(a) || i.push(a); const l = o.geometry; n.includes(l) || n.push(l); const h = o.depth; let c; const u = o.segment, d = s[1]; for (; e.length < l.getStride();)e.push(u[d][e.length]); switch (l.getType()) { case "Point": c = e, u[0] = e, u[1] = e; break; case "MultiPoint": c = l.getCoordinates(), c[o.index] = e, u[0] = e, u[1] = e; break; case "LineString": c = l.getCoordinates(), c[o.index + d] = e, u[d] = e; break; case "MultiLineString": case "Polygon": c = l.getCoordinates(), c[h[0]][o.index + d] = e, u[d] = e; break; case "MultiPolygon": c = l.getCoordinates(), c[h[1]][h[0]][o.index + d] = e, u[d] = e; break; case "Circle": if (u[0] = e, u[1] = e, 0 === o.index) this.changingFeature_ = !0, l.setCenter(e), this.changingFeature_ = !1; else { this.changingFeature_ = !0; const i = t.map.getView().getProjection(); let n = Ci(rn(l.getCenter(), i), rn(e, i)); const r = en(); if (r) { const t = l.clone().transform(r, i); t.setRadius(n), n = t.transform(i, r).getRadius() } l.setRadius(n), this.changingFeature_ = !1 } }c && this.setGeometryCoordinates_(l, c) } this.createOrUpdateVertexFeature_(e, i, n) } handleDownEvent(t) { if (!this.condition_(t)) return !1; const e = t.coordinate; this.handlePointerAtPixel_(t.pixel, t.map, e), this.dragSegments_.length = 0, this.featuresBeingModified_ = null; const i = this.vertexFeature_; if (i) { const n = t.map.getView().getProjection(), r = [], s = i.getGeometry().getCoordinates(), o = zt([s]), a = this.rBush_.getInExtent(o), l = {}; a.sort(l_); for (let i = 0, o = a.length; i < o; ++i) { const o = a[i], h = o.segment; let c = z(o.geometry); const u = o.depth; if (u && (c += "-" + u.join("-")), l[c] || (l[c] = new Array(2)), "Circle" !== o.geometry.getType() || 1 !== o.index) if (!Si(h[0], s) || l[c][0]) if (!Si(h[1], s) || l[c][1]) z(h) in this.vertexSegments_ && !l[c][0] && !l[c][1] && this.insertVertexCondition_(t) && r.push(o); else { if (l[c][0] && 0 === l[c][0].index) { let t = o.geometry.getCoordinates(); switch (o.geometry.getType()) { case "LineString": case "MultiLineString": continue; case "MultiPolygon": t = t[u[1]]; case "Polygon": if (o.index !== t[u[0]].length - 2) continue } } this.dragSegments_.push([o, 1]), l[c][1] = o } else this.dragSegments_.push([o, 0]), l[c][0] = o; else { Si(c_(e, o, n), s) && !l[c][0] && (this.dragSegments_.push([o, 0]), l[c][0] = o) } } r.length && this.willModifyFeatures_(t, [r]); for (let t = r.length - 1; t >= 0; --t)this.insertVertex_(r[t], s) } return !!this.vertexFeature_ } handleUpEvent(t) { for (let e = this.dragSegments_.length - 1; e >= 0; --e) { const i = this.dragSegments_[e][0], n = i.geometry; if ("Circle" === n.getType()) { const e = n.getCenter(), r = i.featureSegments[0], s = i.featureSegments[1]; r.segment[0] = e, r.segment[1] = e, s.segment[0] = e, s.segment[1] = e, this.rBush_.update(Qt(e), r); let o = n; const a = en(); if (a) { const e = t.map.getView().getProjection(); o = o.clone().transform(a, e), o = fr(o).transform(e, a) } this.rBush_.update(o.getExtent(), s) } else this.rBush_.update(zt(i.segment), i) } return this.featuresBeingModified_ && (this.dispatchEvent(new a_(o_, this.featuresBeingModified_, t)), this.featuresBeingModified_ = null), !1 } handlePointerMove_(t) { this.lastPixel_ = t.pixel, this.handlePointerAtPixel_(t.pixel, t.map, t.coordinate) } handlePointerAtPixel_(t, e, i) { const n = i || e.getCoordinateFromPixel(t), r = e.getView().getProjection(), s = function (t, e) { return h_(n, t, r) - h_(n, e, r) }; let o, a; if (this.hitDetection_) { const i = "object" == typeof this.hitDetection_ ? t => t === this.hitDetection_ : void 0; e.forEachFeatureAtPixel(t, ((t, e, i) => { if ("Point" === (i = i || t.getGeometry()).getType() && this.features_.getArray().includes(t)) { a = i; const e = i.getFlatCoordinates().slice(0, 2); o = [{ feature: t, geometry: i, segment: [e, e] }] } return !0 }), { layerFilter: i }) } if (!o) { const t = sn(Xt(on(Qt(n, n_), r), e.getView().getResolution() * this.pixelTolerance_, n_), r); o = this.rBush_.getInExtent(t) } if (o && o.length > 0) { const i = o.sort(s)[0], l = i.segment; let h = c_(n, i, r); const c = e.getPixelFromCoordinate(h); let u = Ci(t, c); if (a || u <= this.pixelTolerance_) { const t = {}; if (t[z(l)] = !0, this.snapToPointer_ || (this.delta_[0] = h[0] - n[0], this.delta_[1] = h[1] - n[1]), "Circle" === i.geometry.getType() && 1 === i.index) this.snappedToVertex_ = !0, this.createOrUpdateVertexFeature_(h, [i.feature], [i.geometry]); else { const n = e.getPixelFromCoordinate(l[0]), r = e.getPixelFromCoordinate(l[1]), s = Ti(c, n), a = Ti(c, r); u = Math.sqrt(Math.min(s, a)), this.snappedToVertex_ = u <= this.pixelTolerance_, this.snappedToVertex_ && (h = s > a ? l[1] : l[0]), this.createOrUpdateVertexFeature_(h, [i.feature], [i.geometry]); const d = {}; d[z(i.geometry)] = !0; for (let e = 1, i = o.length; e < i; ++e) { const i = o[e].segment; if (!(Si(l[0], i[0]) && Si(l[1], i[1]) || Si(l[0], i[1]) && Si(l[1], i[0]))) break; { const n = z(o[e].geometry); n in d || (d[n] = !0, t[z(i)] = !0) } } } return void (this.vertexSegments_ = t) } } this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null) } insertVertex_(t, e) { const i = t.segment, n = t.feature, r = t.geometry, s = t.depth, o = t.index; let a; for (; e.length < r.getStride();)e.push(0); switch (r.getType()) { case "MultiLineString": case "Polygon": a = r.getCoordinates(), a[s[0]].splice(o + 1, 0, e); break; case "MultiPolygon": a = r.getCoordinates(), a[s[1]][s[0]].splice(o + 1, 0, e); break; case "LineString": a = r.getCoordinates(), a.splice(o + 1, 0, e); break; default: return }this.setGeometryCoordinates_(r, a); const l = this.rBush_; l.remove(t), this.updateSegmentIndices_(r, o, s, 1); const h = { segment: [i[0], e], feature: n, geometry: r, depth: s, index: o }; l.insert(zt(h.segment), h), this.dragSegments_.push([h, 1]); const c = { segment: [e, i[1]], feature: n, geometry: r, depth: s, index: o + 1 }; l.insert(zt(c.segment), c), this.dragSegments_.push([c, 0]), this.ignoreNextSingleClick_ = !0 } removePoint() { if (this.lastPointerEvent_ && this.lastPointerEvent_.type != ao.POINTERDRAG) { const t = this.lastPointerEvent_; this.willModifyFeatures_(t, this.dragSegments_); const e = this.removeVertex_(); return this.featuresBeingModified_ && this.dispatchEvent(new a_(o_, this.featuresBeingModified_, t)), this.featuresBeingModified_ = null, e } return !1 } removeVertex_() { const t = this.dragSegments_, e = {}; let i, n, r, s, o, a, l, h, c, u, d, g = !1; for (o = t.length - 1; o >= 0; --o)r = t[o], u = r[0], d = z(u.feature), u.depth && (d += "-" + u.depth.join("-")), d in e || (e[d] = {}), 0 === r[1] ? (e[d].right = u, e[d].index = u.index) : 1 == r[1] && (e[d].left = u, e[d].index = u.index + 1); for (d in e) { switch (c = e[d].right, l = e[d].left, a = e[d].index, h = a - 1, u = void 0 !== l ? l : c, h < 0 && (h = 0), s = u.geometry, n = s.getCoordinates(), i = n, g = !1, s.getType()) { case "MultiLineString": n[u.depth[0]].length > 2 && (n[u.depth[0]].splice(a, 1), g = !0); break; case "LineString": n.length > 2 && (n.splice(a, 1), g = !0); break; case "MultiPolygon": i = i[u.depth[1]]; case "Polygon": i = i[u.depth[0]], i.length > 4 && (a == i.length - 1 && (a = 0), i.splice(a, 1), g = !0, 0 === a && (i.pop(), i.push(i[0]), h = i.length - 1)) }if (g) { this.setGeometryCoordinates_(s, n); const e = []; if (void 0 !== l && (this.rBush_.remove(l), e.push(l.segment[0])), void 0 !== c && (this.rBush_.remove(c), e.push(c.segment[1])), void 0 !== l && void 0 !== c) { const t = { depth: u.depth, feature: u.feature, geometry: u.geometry, index: h, segment: e }; this.rBush_.insert(zt(t.segment), t) } this.updateSegmentIndices_(s, a, u.depth, -1), this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), t.length = 0 } } return g } setGeometryCoordinates_(t, e) { this.changingFeature_ = !0, t.setCoordinates(e), this.changingFeature_ = !1 } updateSegmentIndices_(t, e, i, n) { this.rBush_.forEachInExtent(t.getExtent(), (function (r) { r.geometry === t && (void 0 === i || void 0 === r.depth || u(r.depth, i)) && r.index > e && (r.index += n) })) } }, _T.interaction.Modify.ModifyEvent = a_, _T.interaction.MouseWheelZoom = ka, _T.interaction.PinchRotate = Ga, _T.interaction.PinchZoom = ja, _T.interaction.Pointer = sa, _T.interaction.Pointer.centroid = oa, _T.interaction.Select = p_, _T.interaction.Select.SelectEvent = g_, _T.interaction.Snap = class extends sa { constructor(t) { const e = t = t || {}; e.handleDownEvent || (e.handleDownEvent = g), e.stopDown || (e.stopDown = f), super(e), this.source_ = t.source ? t.source : null, this.vertex_ = void 0 === t.vertex || t.vertex, this.edge_ = void 0 === t.edge || t.edge, this.features_ = t.features ? t.features : null, this.featuresListenerKeys_ = [], this.featureChangeListenerKeys_ = {}, this.indexedFeaturesExtents_ = {}, this.pendingFeatures_ = {}, this.pixelTolerance_ = void 0 !== t.pixelTolerance ? t.pixelTolerance : 10, this.rBush_ = new Ah, this.GEOMETRY_SEGMENTERS_ = { Point: this.segmentPointGeometry_.bind(this), LineString: this.segmentLineStringGeometry_.bind(this), LinearRing: this.segmentLineStringGeometry_.bind(this), Polygon: this.segmentPolygonGeometry_.bind(this), MultiPoint: this.segmentMultiPointGeometry_.bind(this), MultiLineString: this.segmentMultiLineStringGeometry_.bind(this), MultiPolygon: this.segmentMultiPolygonGeometry_.bind(this), GeometryCollection: this.segmentGeometryCollectionGeometry_.bind(this), Circle: this.segmentCircleGeometry_.bind(this) } } addFeature(t, e) { e = void 0 === e || e; const i = z(t), n = t.getGeometry(); if (n) { const e = this.GEOMETRY_SEGMENTERS_[n.getType()]; if (e) { this.indexedFeaturesExtents_[i] = n.getExtent([1 / 0, 1 / 0, -1 / 0, -1 / 0]); const r = []; if (e(r, n), 1 === r.length) this.rBush_.insert(zt(r[0]), { feature: t, segment: r[0] }); else if (r.length > 1) { const e = r.map((t => zt(t))), i = r.map((e => ({ feature: t, segment: e }))); this.rBush_.load(e, i) } } } e && (this.featureChangeListenerKeys_[i] = N(t, S, this.handleFeatureChange_, this)) } forEachFeatureAdd_(t) { this.addFeature(t) } forEachFeatureRemove_(t) { this.removeFeature(t) } getFeatures_() { let t; return this.features_ ? t = this.features_ : this.source_ && (t = this.source_.getFeatures()), t } handleEvent(t) { const e = this.snapTo(t.pixel, t.coordinate, t.map); return e && (t.coordinate = e.vertex.slice(0, 2), t.pixel = e.vertexPixel), super.handleEvent(t) } handleFeatureAdd_(t) { const e = m_(t); this.addFeature(e) } handleFeatureRemove_(t) { const e = m_(t); this.removeFeature(e) } handleFeatureChange_(t) { const e = t.target; if (this.handlingDownUpSequence) { const t = z(e); t in this.pendingFeatures_ || (this.pendingFeatures_[t] = e) } else this.updateFeature_(e) } handleUpEvent(t) { const e = Object.values(this.pendingFeatures_); return e.length && (e.forEach(this.updateFeature_.bind(this)), this.pendingFeatures_ = {}), !1 } removeFeature(t, e) { const i = void 0 === e || e, n = z(t), r = this.indexedFeaturesExtents_[n]; if (r) { const e = this.rBush_, i = []; e.forEachInExtent(r, (function (e) { t === e.feature && i.push(e) })); for (let t = i.length - 1; t >= 0; --t)e.remove(i[t]) } i && (k(this.featureChangeListenerKeys_[n]), delete this.featureChangeListenerKeys_[n]) } setMap(t) { const e = this.getMap(), i = this.featuresListenerKeys_, n = this.getFeatures_(); e && (i.forEach(k), i.length = 0, n.forEach(this.forEachFeatureRemove_.bind(this))), super.setMap(t), t && (this.features_ ? i.push(N(this.features_, W, this.handleFeatureAdd_, this), N(this.features_, Z, this.handleFeatureRemove_, this)) : this.source_ && i.push(N(this.source_, Oh, this.handleFeatureAdd_, this), N(this.source_, kh, this.handleFeatureRemove_, this)), n.forEach(this.forEachFeatureAdd_.bind(this))) } snapTo(t, e, i) { const n = zt([i.getCoordinateFromPixel([t[0] - this.pixelTolerance_, t[1] + this.pixelTolerance_]), i.getCoordinateFromPixel([t[0] + this.pixelTolerance_, t[1] - this.pixelTolerance_])]), r = this.rBush_.getInExtent(n), s = r.length; if (0 === s) return null; const o = i.getView().getProjection(), a = rn(e, o); let l, h = 1 / 0; const c = this.pixelTolerance_ * this.pixelTolerance_, u = () => { if (l) { const e = i.getPixelFromCoordinate(l); if (Ti(t, e) <= c) return { vertex: l, vertexPixel: [Math.round(e[0]), Math.round(e[1])] } } return null }; if (this.vertex_) { for (let t = 0; t < s; ++t) { const e = r[t]; "Circle" !== e.feature.getGeometry().getType() && e.segment.forEach((t => { const e = rn(t, o), i = Ti(a, e); i < h && (l = t, h = i) })) } const t = u(); if (t) return t } if (this.edge_) { for (let t = 0; t < s; ++t) { let e = null; const i = r[t]; if ("Circle" === i.feature.getGeometry().getType()) { let t = i.feature.getGeometry(); const n = en(); n && (t = t.clone().transform(n, o)), e = nn(_i(a, t), o) } else { const [t, n] = i.segment; n && (__[0] = rn(t, o), __[1] = rn(n, o), e = yi(a, __)) } if (e) { const t = Ti(a, e); t < h && (l = e, h = t) } } const t = u(); if (t) return t } return null } updateFeature_(t) { this.removeFeature(t, !1), this.addFeature(t, !1) } segmentCircleGeometry_(t, e) { const i = this.getMap().getView().getProjection(); let n = e; const r = en(); r && (n = n.clone().transform(r, i)); const s = fr(n); r && s.transform(i, r); const o = s.getCoordinates()[0]; for (let e = 0, i = o.length - 1; e < i; ++e)t.push(o.slice(e, e + 2)) } segmentGeometryCollectionGeometry_(t, e) { const i = e.getGeometriesArray(); for (let e = 0; e < i.length; ++e) { const n = this.GEOMETRY_SEGMENTERS_[i[e].getType()]; n && n(t, i[e]) } } segmentLineStringGeometry_(t, e) { const i = e.getCoordinates(); for (let e = 0, n = i.length - 1; e < n; ++e)t.push(i.slice(e, e + 2)) } segmentMultiLineStringGeometry_(t, e) { const i = e.getCoordinates(); for (let e = 0, n = i.length; e < n; ++e) { const n = i[e]; for (let e = 0, i = n.length - 1; e < i; ++e)t.push(n.slice(e, e + 2)) } } segmentMultiPointGeometry_(t, e) { e.getCoordinates().forEach((e => { t.push([e]) })) } segmentMultiPolygonGeometry_(t, e) { const i = e.getCoordinates(); for (let e = 0, n = i.length; e < n; ++e) { const n = i[e]; for (let e = 0, i = n.length; e < i; ++e) { const i = n[e]; for (let e = 0, n = i.length - 1; e < n; ++e)t.push(i.slice(e, e + 2)) } } } segmentPointGeometry_(t, e) { t.push([e.getCoordinates()]) } segmentPolygonGeometry_(t, e) { const i = e.getCoordinates(); for (let e = 0, n = i.length; e < n; ++e) { const n = i[e]; for (let e = 0, i = n.length - 1; e < i; ++e)t.push(n.slice(e, e + 2)) } } }, _T.interaction.Translate = class extends sa { constructor(t) { let e; if (super(t = t || {}), this.on, this.once, this.un, this.lastCoordinate_ = null, this.startCoordinate_ = null, this.features_ = void 0 !== t.features ? t.features : null, t.layers && !this.features_) if ("function" == typeof t.layers) e = t.layers; else { const i = t.layers; e = function (t) { return i.includes(t) } } else e = g; this.layerFilter_ = e, this.filter_ = t.filter && !this.features_ ? t.filter : g, this.hitTolerance_ = t.hitTolerance ? t.hitTolerance : 0, this.condition_ = t.condition ? t.condition : da, this.lastFeature_ = null, this.addChangeListener(ta, this.handleActiveChanged_) } handleDownEvent(t) { if (!t.originalEvent || !this.condition_(t)) return !1; if (this.lastFeature_ = this.featuresAtPixel_(t.pixel, t.map), !this.lastCoordinate_ && this.lastFeature_) { this.startCoordinate_ = t.coordinate, this.lastCoordinate_ = t.coordinate, this.handleMoveEvent(t); const e = this.features_ || new q([this.lastFeature_]); return this.dispatchEvent(new S_(y_, e, t.coordinate, this.startCoordinate_, t)), !0 } return !1 } handleUpEvent(t) { if (this.lastCoordinate_) { this.lastCoordinate_ = null, this.handleMoveEvent(t); const e = this.features_ || new q([this.lastFeature_]); return this.dispatchEvent(new S_(v_, e, t.coordinate, this.startCoordinate_, t)), this.startCoordinate_ = null, !0 } return !1 } handleDragEvent(t) { if (this.lastCoordinate_) { const e = t.coordinate, i = e[0] - this.lastCoordinate_[0], n = e[1] - this.lastCoordinate_[1], r = this.features_ || new q([this.lastFeature_]); r.forEach((function (t) { const e = t.getGeometry(); e.translate(i, n), t.setGeometry(e) })), this.lastCoordinate_ = e, this.dispatchEvent(new S_(x_, r, e, this.startCoordinate_, t)) } } handleMoveEvent(t) { const e = t.map.getViewport(); this.featuresAtPixel_(t.pixel, t.map) ? (e.classList.remove(this.lastCoordinate_ ? "ol-grab" : "ol-grabbing"), e.classList.add(this.lastCoordinate_ ? "ol-grabbing" : "ol-grab")) : e.classList.remove("ol-grab", "ol-grabbing") } featuresAtPixel_(t, e) { return e.forEachFeatureAtPixel(t, function (t, e) { if (this.filter_(t, e) && (!this.features_ || this.features_.getArray().includes(t))) return t }.bind(this), { layerFilter: this.layerFilter_, hitTolerance: this.hitTolerance_ }) } getHitTolerance() { return this.hitTolerance_ } setHitTolerance(t) { this.hitTolerance_ = t } setMap(t) { const e = this.getMap(); super.setMap(t), this.updateState_(e) } handleActiveChanged_() { this.updateState_(null) } updateState_(t) { let e = this.getMap(); const i = this.getActive(); if ((!e || !i) && (e = e || t, e)) { e.getViewport().classList.remove("ol-grab", "ol-grabbing") } } }, _T.interaction.Translate.TranslateEvent = S_, _T.interaction.defaults = {}, _T.interaction.defaults.defaults = Ba, _T.layer = {}, _T.layer.Base = fs, _T.layer.BaseImage = Tc, _T.layer.BaseTile = Ac, _T.layer.BaseVector = Ig, _T.layer.Graticule = class extends zp { constructor(t) { t = t || {}; const e = Object.assign({ updateWhileAnimating: !0, updateWhileInteracting: !0, renderBuffer: 0 }, t); delete e.maxLines, delete e.strokeStyle, delete e.targetSize, delete e.showLabels, delete e.lonLabelFormatter, delete e.latLabelFormatter, delete e.lonLabelPosition, delete e.latLabelPosition, delete e.lonLabelStyle, delete e.latLabelStyle, delete e.intervals, super(e), this.projection_ = null, this.maxLat_ = 1 / 0, this.maxLon_ = 1 / 0, this.minLat_ = -1 / 0, this.minLon_ = -1 / 0, this.maxX_ = 1 / 0, this.maxY_ = 1 / 0, this.minX_ = -1 / 0, this.minY_ = -1 / 0, this.targetSize_ = void 0 !== t.targetSize ? t.targetSize : 100, this.maxLines_ = void 0 !== t.maxLines ? t.maxLines : 100, this.meridians_ = [], this.parallels_ = [], this.strokeStyle_ = void 0 !== t.strokeStyle ? t.strokeStyle : Zp, this.fromLonLatTransform_ = void 0, this.toLonLatTransform_ = void 0, this.projectionCenterLonLat_ = null, this.bottomLeft_ = null, this.bottomRight_ = null, this.topLeft_ = null, this.topRight_ = null, this.meridiansLabels_ = null, this.parallelsLabels_ = null, t.showLabels && (this.lonLabelFormatter_ = null == t.lonLabelFormatter ? xi.bind(this, "EW") : t.lonLabelFormatter, this.latLabelFormatter_ = null == t.latLabelFormatter ? xi.bind(this, "NS") : t.latLabelFormatter, this.lonLabelPosition_ = null == t.lonLabelPosition ? 0 : t.lonLabelPosition, this.latLabelPosition_ = null == t.latLabelPosition ? 1 : t.latLabelPosition, this.lonLabelStyleBase_ = new cg({ text: void 0 !== t.lonLabelStyle ? t.lonLabelStyle.clone() : new mg({ font: "12px Calibri,sans-serif", textBaseline: "bottom", fill: new rg({ color: "rgba(0,0,0,1)" }), stroke: new hg({ color: "rgba(255,255,255,1)", width: 3 }) }) }), this.lonLabelStyle_ = function (t) { const e = t.get("graticule_label"); return this.lonLabelStyleBase_.getText().setText(e), this.lonLabelStyleBase_ }.bind(this), this.latLabelStyleBase_ = new cg({ text: void 0 !== t.latLabelStyle ? t.latLabelStyle.clone() : new mg({ font: "12px Calibri,sans-serif", textAlign: "right", fill: new rg({ color: "rgba(0,0,0,1)" }), stroke: new hg({ color: "rgba(255,255,255,1)", width: 3 }) }) }), this.latLabelStyle_ = function (t) { const e = t.get("graticule_label"); return this.latLabelStyleBase_.getText().setText(e), this.latLabelStyleBase_ }.bind(this), this.meridiansLabels_ = [], this.parallelsLabels_ = [], this.addEventListener(ms, this.drawLabels_.bind(this))), this.intervals_ = void 0 !== t.intervals ? t.intervals : Yp, this.setSource(new zh({ loader: this.loaderFunction.bind(this), strategy: this.strategyFunction.bind(this), features: new q, overlaps: !1, useSpatialIndex: !1, wrapX: t.wrapX })), this.featurePool_ = [], this.lineStyle_ = new cg({ stroke: this.strokeStyle_ }), this.loadedExtent_ = null, this.renderedExtent_ = null, this.renderedResolution_ = null, this.setRenderOrder(null) } strategyFunction(t, e) { let i = t.slice(); return this.projection_ && this.getSource().getWrapX() && Pe(i, this.projection_), this.loadedExtent_ && (ie(this.loadedExtent_, i, e) ? i = this.loadedExtent_.slice() : this.getSource().removeLoadedExtent(this.loadedExtent_)), [i] } loaderFunction(t, e, i) { this.loadedExtent_ = t; const n = this.getSource(), r = ye(this.getExtent() || [-1 / 0, -1 / 0, 1 / 0, 1 / 0], t); if (this.renderedExtent_ && ee(this.renderedExtent_, r) && this.renderedResolution_ === e) return; if (this.renderedExtent_ = r, this.renderedResolution_ = e, Ee(r)) return; const s = ge(r), o = e * e / 4; (!this.projection_ || !Ki(this.projection_, i)) && this.updateProjectionInfo_(i), this.createGraticule_(r, s, e, o); let a, l = this.meridians_.length + this.parallels_.length; for (this.meridiansLabels_ && (l += this.meridians_.length), this.parallelsLabels_ && (l += this.parallels_.length); l > this.featurePool_.length;)a = new lt, this.featurePool_.push(a); const h = n.getFeaturesCollection(); h.clear(); let c, u, d = 0; for (c = 0, u = this.meridians_.length; c < u; ++c)a = this.featurePool_[d++], a.setGeometry(this.meridians_[c]), a.setStyle(this.lineStyle_), h.push(a); for (c = 0, u = this.parallels_.length; c < u; ++c)a = this.featurePool_[d++], a.setGeometry(this.parallels_[c]), a.setStyle(this.lineStyle_), h.push(a) } addMeridian_(t, e, i, n, r, s) { const o = this.getMeridian_(t, e, i, n, s); if (we(o.getExtent(), r)) { if (this.meridiansLabels_) { const e = this.lonLabelFormatter_(t); s in this.meridiansLabels_ ? this.meridiansLabels_[s].text = e : this.meridiansLabels_[s] = { geom: new Wn([]), text: e } } this.meridians_[s++] = o } return s } addParallel_(t, e, i, n, r, s) { const o = this.getParallel_(t, e, i, n, s); if (we(o.getExtent(), r)) { if (this.parallelsLabels_) { const e = this.latLabelFormatter_(t); s in this.parallelsLabels_ ? this.parallelsLabels_[s].text = e : this.parallelsLabels_[s] = { geom: new Wn([]), text: e } } this.parallels_[s++] = o } return s } drawLabels_(t) { const e = t.frameState.viewState.rotation, i = t.frameState.viewState.resolution, n = t.frameState.size, r = t.frameState.extent, s = ge(r); let o = r; if (e) { const t = n[0] * i, e = n[1] * i; o = [s[0] - t / 2, s[1] - e / 2, s[0] + t / 2, s[1] + e / 2] } let a = 0, l = 0, h = this.latLabelPosition_ < .5; const c = this.projection_.getExtent(), u = Se(c); if (this.getSource().getWrapX() && this.projection_.canWrapX() && !Yt(c, r)) { a = Math.floor((r[0] - c[0]) / u), l = Math.ceil((r[2] - c[2]) / u); h = h !== Math.abs(e) > Math.PI / 2 } const d = Al(t); for (let t = a; t <= l; ++t) { let i, n, c, g, f = this.meridians_.length + this.parallels_.length; if (this.meridiansLabels_) for (n = 0, c = this.meridiansLabels_.length; n < c; ++n) { const a = this.meridians_[n]; if (e || 0 !== t) { const i = a.clone(); i.translate(t * u, 0), i.rotate(-e, s), g = this.getMeridianPoint_(i, o, n), g.rotate(e, s) } else g = this.getMeridianPoint_(a, r, n); i = this.featurePool_[f++], i.setGeometry(g), i.set("graticule_label", this.meridiansLabels_[n].text), d.drawFeature(i, this.lonLabelStyle_(i)) } if (this.parallelsLabels_ && (t === a && h || t === l && !h)) for (n = 0, c = this.parallels_.length; n < c; ++n) { const a = this.parallels_[n]; if (e || 0 !== t) { const i = a.clone(); i.translate(t * u, 0), i.rotate(-e, s), g = this.getParallelPoint_(i, o, n), g.rotate(e, s) } else g = this.getParallelPoint_(a, r, n); i = this.featurePool_[f++], i.setGeometry(g), i.set("graticule_label", this.parallelsLabels_[n].text), d.drawFeature(i, this.latLabelStyle_(i)) } } } createGraticule_(t, e, i, n) { const r = this.getInterval_(i); if (-1 == r) return this.meridians_.length = 0, this.parallels_.length = 0, this.meridiansLabels_ && (this.meridiansLabels_.length = 0), void (this.parallelsLabels_ && (this.parallelsLabels_.length = 0)); let s = !1; const o = this.projection_.getExtent(), a = Se(o); this.getSource().getWrapX() && this.projection_.canWrapX() && !Yt(o, t) && (Se(t) >= a ? (t[0] = o[0], t[2] = o[2]) : s = !0); const l = [ii(e[0], this.minX_, this.maxX_), ii(e[1], this.minY_, this.maxY_)], h = this.toLonLatTransform_(l); isNaN(h[1]) && (h[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_); let c = ii(h[0], this.minLon_, this.maxLon_), u = ii(h[1], this.minLat_, this.maxLat_); const d = this.maxLines_; let g, f, p, m, _ = t; s || (_ = [ii(t[0], this.minX_, this.maxX_), ii(t[1], this.minY_, this.maxY_), ii(t[2], this.minX_, this.maxX_), ii(t[3], this.minY_, this.maxY_)]); const y = Re(_, this.toLonLatTransform_, void 0, 8); let x = y[3], v = y[2], S = y[1], w = y[0]; if (s || (Zt(_, this.bottomLeft_) && (w = this.minLon_, S = this.minLat_), Zt(_, this.bottomRight_) && (v = this.maxLon_, S = this.minLat_), Zt(_, this.topLeft_) && (w = this.minLon_, x = this.maxLat_), Zt(_, this.topRight_) && (v = this.maxLon_, x = this.maxLat_), x = ii(x, u, this.maxLat_), v = ii(v, c, this.maxLon_), S = ii(S, this.minLat_, u), w = ii(w, this.minLon_, c)), c = Math.floor(c / r) * r, m = ii(c, this.minLon_, this.maxLon_), f = this.addMeridian_(m, S, x, n, t, 0), g = 0, s) for (; (m -= r) >= w && g++ < d;)f = this.addMeridian_(m, S, x, n, t, f); else for (; m != this.minLon_ && g++ < d;)m = Math.max(m - r, this.minLon_), f = this.addMeridian_(m, S, x, n, t, f); if (m = ii(c, this.minLon_, this.maxLon_), g = 0, s) for (; (m += r) <= v && g++ < d;)f = this.addMeridian_(m, S, x, n, t, f); else for (; m != this.maxLon_ && g++ < d;)m = Math.min(m + r, this.maxLon_), f = this.addMeridian_(m, S, x, n, t, f); for (this.meridians_.length = f, this.meridiansLabels_ && (this.meridiansLabels_.length = f), u = Math.floor(u / r) * r, p = ii(u, this.minLat_, this.maxLat_), f = this.addParallel_(p, w, v, n, t, 0), g = 0; p != this.minLat_ && g++ < d;)p = Math.max(p - r, this.minLat_), f = this.addParallel_(p, w, v, n, t, f); for (p = ii(u, this.minLat_, this.maxLat_), g = 0; p != this.maxLat_ && g++ < d;)p = Math.min(p + r, this.maxLat_), f = this.addParallel_(p, w, v, n, t, f); this.parallels_.length = f, this.parallelsLabels_ && (this.parallelsLabels_.length = f) } getInterval_(t) { const e = this.projectionCenterLonLat_[0], i = this.projectionCenterLonLat_[1]; let n = -1; const r = Math.pow(this.targetSize_ * t, 2), s = [], o = []; for (let t = 0, a = this.intervals_.length; t < a; ++t) { const a = ii(this.intervals_[t] / 2, 0, 90), l = ii(i, -90 + a, 90 - a); s[0] = e - a, s[1] = l - a, o[0] = e + a, o[1] = l + a, this.fromLonLatTransform_(s, s), this.fromLonLatTransform_(o, o); if (Math.pow(o[0] - s[0], 2) + Math.pow(o[1] - s[1], 2) <= r) break; n = this.intervals_[t] } return n } getMeridian_(t, e, i, n, r) { const s = Vp(t, e, i, this.projection_, n); let o = this.meridians_[r]; return o ? (o.setFlatCoordinates("XY", s), o.changed()) : (o = new Op(s, "XY"), this.meridians_[r] = o), o } getMeridianPoint_(t, e, i) { const n = t.getFlatCoordinates(); let r = 1, s = n.length - 1; n[r] > n[s] && (r = s, s = 1); const o = Math.max(e[1], n[r]), a = Math.min(e[3], n[s]), l = ii(e[1] + Math.abs(e[1] - e[3]) * this.lonLabelPosition_, o, a), h = [n[r - 1] + (n[s - 1] - n[r - 1]) * (l - n[r]) / (n[s] - n[r]), l], c = this.meridiansLabels_[i].geom; return c.setCoordinates(h), c } getMeridians() { return this.meridians_ } getParallel_(t, e, i, n, r) { const s = Wp(t, e, i, this.projection_, n); let o = this.parallels_[r]; return o ? (o.setFlatCoordinates("XY", s), o.changed()) : o = new Op(s, "XY"), o } getParallelPoint_(t, e, i) { const n = t.getFlatCoordinates(); let r = 0, s = n.length - 2; n[r] > n[s] && (r = s, s = 0); const o = Math.max(e[0], n[r]), a = Math.min(e[2], n[s]), l = ii(e[0] + Math.abs(e[0] - e[2]) * this.latLabelPosition_, o, a), h = [l, n[r + 1] + (n[s + 1] - n[r + 1]) * (l - n[r]) / (n[s] - n[r])], c = this.parallelsLabels_[i].geom; return c.setCoordinates(h), c } getParallels() { return this.parallels_ } updateProjectionInfo_(t) { const e = Ui("EPSG:4326"), i = t.getWorldExtent(); this.maxLat_ = i[3], this.maxLon_ = i[2], this.minLat_ = i[1], this.minLon_ = i[0]; const n = Hi(t, e); if (this.minLon_ < this.maxLon_) this.toLonLatTransform_ = n; else { const t = this.minLon_ + this.maxLon_ / 2; this.maxLon_ += 360, this.toLonLatTransform_ = function (e, i, r) { const s = n(e, i, r = r || 2); for (let e = 0, i = s.length; e < i; e += r)s[e] < t && (s[e] += 360); return s } } this.fromLonLatTransform_ = Hi(e, t); const r = Re([this.minLon_, this.minLat_, this.maxLon_, this.maxLat_], this.fromLonLatTransform_, void 0, 8); this.minX_ = r[0], this.maxX_ = r[2], this.minY_ = r[1], this.maxY_ = r[3], this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]), this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]), this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]), this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]), this.projectionCenterLonLat_ = this.toLonLatTransform_(ge(t.getExtent())), isNaN(this.projectionCenterLonLat_[1]) && (this.projectionCenterLonLat_[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_), this.projection_ = t } }, _T.layer.Group = ro, _T.layer.Group.GroupEvent = io, _T.layer.Heatmap = class extends Ig { constructor(t) { t = t || {}; const e = Object.assign({}, t); delete e.gradient, delete e.radius, delete e.blur, delete e.weight, super(e), this.gradient_ = null, this.addChangeListener(qp, this.handleGradientChanged_), this.setGradient(t.gradient ? t.gradient : $p), this.setBlur(void 0 !== t.blur ? t.blur : 15), this.setRadius(void 0 !== t.radius ? t.radius : 8); const i = t.weight ? t.weight : "weight"; this.weightFunction_ = "string" == typeof i ? function (t) { return t.get(i) } : i, this.setRenderOrder(null) } getBlur() { return this.get(Kp) } getGradient() { return this.get(qp) } getRadius() { return this.get(Hp) } handleGradientChanged_() { this.gradient_ = function (t) { const e = 1, i = 256, n = Dr(e, i), r = n.createLinearGradient(0, 0, e, i), s = 1 / (t.length - 1); for (let e = 0, i = t.length; e < i; ++e)r.addColorStop(e * s, t[e]); return n.fillStyle = r, n.fillRect(0, 0, e, i), n.canvas }(this.getGradient()) } setBlur(t) { this.set(Kp, t) } setGradient(t) { this.set(qp, t) } setRadius(t) { this.set(Hp, t) } createRenderer() { return new gf(this, { className: this.getClassName(), attributes: [{ name: "weight", callback: function (t) { const e = this.weightFunction_(t); return void 0 !== e ? ii(e, 0, 1) : 1 }.bind(this) }], vertexShader: "\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_weight = a_weight;\n        }", fragmentShader: "\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          gl_FragColor = vec4(alpha, alpha, alpha, alpha);\n        }", hitVertexShader: "\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n        attribute vec4 a_hitColor;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_hitColor = a_hitColor;\n          v_weight = a_weight;\n        }", hitFragmentShader: "\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          if (alpha < 0.05) {\n            discard;\n          }\n\n          gl_FragColor = v_hitColor;\n        }", uniforms: { u_size: function () { return 2 * (this.get(Hp) + this.get(Kp)) }.bind(this), u_blurSlope: function () { return this.get(Hp) / Math.max(1, this.get(Kp)) }.bind(this) }, postProcesses: [{ fragmentShader: "\n            precision mediump float;\n\n            uniform sampler2D u_image;\n            uniform sampler2D u_gradientTexture;\n            uniform float u_opacity;\n\n            varying vec2 v_texCoord;\n\n            void main() {\n              vec4 color = texture2D(u_image, v_texCoord);\n              gl_FragColor.a = color.a * u_opacity;\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\n              gl_FragColor.rgb *= gl_FragColor.a;\n            }", uniforms: { u_gradientTexture: function () { return this.gradient_ }.bind(this), u_opacity: function () { return this.getOpacity() }.bind(this) } }] }) } renderDeclutter() { } }, _T.layer.Image = Lc, _T.layer.Layer = vs, _T.layer.Layer.inView = Ss, _T.layer.MapboxVector = class extends Pm { constructor(t) { const e = !("declutter" in t) || t.declutter, i = new Qc({ state: "loading", format: new Em }); super({ source: i, background: t.background, declutter: e, className: t.className, opacity: t.opacity, visible: t.visible, zIndex: t.zIndex, minResolution: t.minResolution, maxResolution: t.maxResolution, minZoom: t.minZoom, maxZoom: t.maxZoom, renderOrder: t.renderOrder, renderBuffer: t.renderBuffer, renderMode: t.renderMode, map: t.map, updateWhileAnimating: t.updateWhileAnimating, updateWhileInteracting: t.updateWhileInteracting, preload: t.preload, useInterimTilesOnError: t.useInterimTilesOnError, properties: t.properties }), t.accessToken && (this.accessToken = t.accessToken); const n = t.styleUrl; olms.applyStyle(this, n, t.layers || t.source, { accessToken: this.accessToken }).then((() => { i.setState("ready") })).catch((t => { this.dispatchEvent(new Im(t)); this.getSource().setState("error") })), void 0 === this.getBackground() && olms.applyBackground(this, t.styleUrl, { accessToken: this.accessToken }) } }, _T.layer.Tile = Nc, _T.layer.Vector = zp, _T.layer.VectorImage = class extends Ig { constructor(t) { t = t || {}; const e = Object.assign({}, t); delete e.imageRatio, super(e), this.imageRatio_ = void 0 !== t.imageRatio ? t.imageRatio : 1 } getImageRatio() { return this.imageRatio_ } createRenderer() { return new Tp(this) } }, _T.layer.VectorTile = Pm, _T.layer.WebGLPoints = class extends vs { constructor(t) { super(Object.assign({}, t)), this.parseResult_ = tg(t.style), this.styleVariables_ = t.style.variables || {}, this.hitDetectionDisabled_ = !!t.disableHitDetection } createRenderer() { return new gf(this, { vertexShader: this.parseResult_.builder.getSymbolVertexShader(), fragmentShader: this.parseResult_.builder.getSymbolFragmentShader(), hitVertexShader: !this.hitDetectionDisabled_ && this.parseResult_.builder.getSymbolVertexShader(!0), hitFragmentShader: !this.hitDetectionDisabled_ && this.parseResult_.builder.getSymbolFragmentShader(!0), uniforms: this.parseResult_.uniforms, attributes: this.parseResult_.attributes }) } updateStyleVariables(t) { Object.assign(this.styleVariables_, t), this.changed() } }, _T.layer.WebGLTile = Mm, _T.loadingstrategy = {}, _T.loadingstrategy.all = xl, _T.loadingstrategy.bbox = function (t, e) { return [t] }, _T.loadingstrategy.tile = function (t) { return function (e, i, n) { const r = t.getZForResolution(ln(i, n)), s = t.getTileRangeForExtentAndZ(on(e, n), r), o = [], a = [r, 0, 0]; for (a[1] = s.minX; a[1] <= s.maxX; ++a[1])for (a[2] = s.minY; a[2] <= s.maxY; ++a[2])o.push(sn(t.getTileCoordExtent(a), n)); return o } }, _T.math = {}, _T.math.ceil = gi, _T.math.clamp = ii, _T.math.floor = di, _T.math.lerp = hi, _T.math.modulo = li, _T.math.round = ui, _T.math.solveLinearSystem = si, _T.math.squaredDistance = ri, _T.math.squaredSegmentDistance = ni, _T.math.toDegrees = oi, _T.math.toFixed = ci, _T.math.toRadians = ai, _T.net = {}, _T.net.ClientError = wl, _T.net.ResponseError = Sl, _T.net.getJSON = El, _T.net.jsonp = vl, _T.net.overrideXHR = function (t) { "undefined" != typeof XMLHttpRequest && (pl = XMLHttpRequest), global.XMLHttpRequest = t }, _T.net.resolveUrl = Tl, _T.net.restoreXHR = function () { global.XMLHttpRequest = pl }, _T.obj = {}, _T.obj.clear = y, _T.obj.isEmpty = x, _T.proj = {}, _T.proj.Projection = Ae, _T.proj.Units = {}, _T.proj.Units.METERS_PER_UNIT = Fe, _T.proj.Units.fromCode = Me, _T.proj.addCommon = cn, _T.proj.addCoordinateTransforms = Yi, _T.proj.addEquivalentProjections = Xi, _T.proj.addEquivalentTransforms = Vi, _T.proj.addProjection = ji, _T.proj.addProjections = Bi, _T.proj.clearAllProjections = function () { qe(), Qe() }, _T.proj.clearUserProjection = function () { Qi = null }, _T.proj.cloneTransform = ki, _T.proj.createProjection = Wi, _T.proj.createSafeCoordinateTransform = hn, _T.proj.createTransformFromCoordinateTransform = Zi, _T.proj.disableCoordinateWarning = Di, _T.proj.epsg3857 = {}, _T.proj.epsg3857.EXTENT = De, _T.proj.epsg3857.HALF_SIZE = Ne, _T.proj.epsg3857.MAX_SAFE_Y = Ge, _T.proj.epsg3857.PROJECTIONS = Be, _T.proj.epsg3857.RADIUS = Oe, _T.proj.epsg3857.WORLD_EXTENT = ke, _T.proj.epsg3857.fromEPSG4326 = Ue, _T.proj.epsg3857.toEPSG4326 = ze, _T.proj.epsg4326 = {}, _T.proj.epsg4326.EXTENT = Ve, _T.proj.epsg4326.METERS_PER_UNIT = We, _T.proj.epsg4326.PROJECTIONS = Ye, _T.proj.epsg4326.RADIUS = Xe, _T.proj.equivalent = Ki, _T.proj.fromLonLat = function (t, e) { return Di(), $i(t, "EPSG:4326", void 0 !== e ? e : "EPSG:3857") }, _T.proj.fromUserCoordinate = rn, _T.proj.fromUserExtent = on, _T.proj.fromUserResolution = ln, _T.proj.get = Ui, _T.proj.getPointResolution = zi, _T.proj.getTransform = Hi, _T.proj.getTransformFromProjections = qi, _T.proj.getUserProjection = en, _T.proj.identityTransform = Gi, _T.proj.proj4 = {}, _T.proj.proj4.register = function (t) { const e = Object.keys(t.defs), i = e.length; let n, r; for (n = 0; n < i; ++n) { const i = e[n]; if (!Ui(i)) { const e = t.defs(i); let n = e.units; n || "longlat" !== e.projName || (n = "degrees"), ji(new Ae({ code: i, axisOrientation: e.axis, metersPerUnit: e.to_meter, units: n })) } } for (n = 0; n < i; ++n) { const s = e[n], o = Ui(s); for (r = 0; r < i; ++r) { const i = e[r], n = Ui(i); if (!ei(s, i)) if (t.defs[s] === t.defs[i]) Xi([o, n]); else { const e = t(s, i); Yi(o, n, hn(o, n, e.forward), hn(n, o, e.inverse)) } } } }, _T.proj.projections = {}, _T.proj.projections.add = $e, _T.proj.projections.clear = qe, _T.proj.projections.get = He, _T.proj.setUserProjection = tn, _T.proj.toLonLat = function (t, e) { const i = $i(t, void 0 !== e ? e : "EPSG:3857", "EPSG:4326"), n = i[0]; return (n < -180 || n > 180) && (i[0] = li(n + 180, 360) - 180), i }, _T.proj.toUserCoordinate = nn, _T.proj.toUserExtent = sn, _T.proj.toUserResolution = an, _T.proj.transform = $i, _T.proj.transformExtent = Ji, _T.proj.transformWithProjections = function (t, e, i) { return qi(e, i)(t) }, _T.proj.transforms = {}, _T.proj.transforms.add = ti, _T.proj.transforms.clear = Qe, _T.proj.transforms.get = ei, _T.proj.transforms.remove = function (t, e) { const i = t.getCode(), n = e.getCode(), r = Je[i][n]; return delete Je[i][n], x(Je[i]) && delete Je[i], r }, _T.proj.useGeographic = function () { tn("EPSG:4326") }, _T.render = {}, _T.render.Box = Ea, _T.render.Event = Ts, _T.render.Feature = Bp, _T.render.Feature.toFeature = function (t, e) { const i = t.getId(), n = Up(t), r = t.getProperties(), s = new lt; return void 0 !== e && s.setGeometryName(e), s.setGeometry(n), void 0 !== i && s.setId(i), s.setProperties(r, !0), s }, _T.render.Feature.toGeometry = Up, _T.render.VectorContext = Cl, _T.render.canvas = {}, _T.render.canvas.Builder = qf, _T.render.canvas.BuilderGroup = np, _T.render.canvas.Executor = pp, _T.render.canvas.ExecutorGroup = _p, _T.render.canvas.ExecutorGroup.getPixelIndexArray = xp, _T.render.canvas.ImageBuilder = Hf, _T.render.canvas.Immediate = bl, _T.render.canvas.Instruction = {}, _T.render.canvas.Instruction.beginPathInstruction = Yf, _T.render.canvas.Instruction.closePathInstruction = Kf, _T.render.canvas.Instruction.fillInstruction = Wf, _T.render.canvas.Instruction.strokeInstruction = Zf, _T.render.canvas.LineStringBuilder = $f, _T.render.canvas.PolygonBuilder = Jf, _T.render.canvas.TextBuilder = ep, _T.render.canvas.checkedFonts = Vs, _T.render.canvas.defaultFillStyle = Ns, _T.render.canvas.defaultFont = Os, _T.render.canvas.defaultLineCap = Ds, _T.render.canvas.defaultLineDash = ks, _T.render.canvas.defaultLineDashOffset = 0, _T.render.canvas.defaultLineJoin = Gs, _T.render.canvas.defaultLineWidth = 1, _T.render.canvas.defaultMiterLimit = js, _T.render.canvas.defaultPadding = Xs, _T.render.canvas.defaultStrokeStyle = Bs, _T.render.canvas.defaultTextAlign = Us, _T.render.canvas.defaultTextBaseline = zs, _T.render.canvas.drawImageOrLabel = to, _T.render.canvas.getTextDimensions = Qs, _T.render.canvas.hitdetect = {}, _T.render.canvas.hitdetect.HIT_DETECT_RESOLUTION = vp, _T.render.canvas.hitdetect.createHitDetectionImageData = Sp, _T.render.canvas.hitdetect.hitDetect = wp, _T.render.canvas.measureAndCacheTextWidth = Js, _T.render.canvas.measureTextHeight = qs, _T.render.canvas.measureTextWidth = $s, _T.render.canvas.registerFont = Ks, _T.render.canvas.rotateAtOffset = function (t, e, i, n) { 0 !== e && (t.translate(i, n), t.rotate(e), t.translate(-i, -n)) }, _T.render.canvas.textHeights = Ys, _T.render.getRenderPixel = function (t, e) { return bt(t.inversePixelTransform, e.slice(0)) }, _T.render.getVectorContext = Al, _T.render.toContext = function (t, e) { const i = t.canvas, n = (e = e || {}).pixelRatio || mt, r = e.size; r && (i.width = r[0] * n, i.height = r[1] * n, i.style.width = r[0] + "px", i.style.height = r[1] + "px"); const s = [0, 0, i.width, i.height], o = Pt([1, 0, 0, 1, 0, 0], n, n); return new bl(t, n, s, o, 0) }, _T.render.webgl = {}, _T.render.webgl.BatchRenderer = pf, _T.render.webgl.LineStringBatchRenderer = _f, _T.render.webgl.MixedGeometryBatch = yf, _T.render.webgl.PointBatchRenderer = vf, _T.render.webgl.PolygonBatchRenderer = wf, _T.render.webgl.utils = {}, _T.render.webgl.utils.colorDecodeId = uf, _T.render.webgl.utils.colorEncodeId = cf, _T.render.webgl.utils.getBlankImageData = function () { const t = document.createElement("canvas").getContext("2d").createImageData(1, 1); return t.data[0] = 255, t.data[1] = 255, t.data[2] = 255, t.data[3] = 255, t }, _T.render.webgl.utils.writeLineSegmentToBuffers = function (t, e, i, n, r, s, o, a, l, h) { const c = 5 + a.length, u = s.length / c, d = [t[e + 0], t[e + 1]], g = [t[i], t[i + 1]], f = bt(h, [...d]), p = bt(h, [...g]); function m(t, e, i) { const n = 1e4; return Math.round(1500 * e) + Math.round(1500 * i) * n + t * n * n } function _(t, e, i) { const n = Math.sqrt((e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1])), r = [(e[0] - t[0]) / n, (e[1] - t[1]) / n], s = [-r[1], r[0]], o = Math.sqrt((i[0] - t[0]) * (i[0] - t[0]) + (i[1] - t[1]) * (i[1] - t[1])), a = [(i[0] - t[0]) / o, (i[1] - t[1]) / o], l = 0 === n || 0 === o ? 0 : Math.acos(ii(a[0] * r[0] + a[1] * r[1], -1, 1)); return a[0] * s[0] + a[1] * s[1] > 0 ? l : 2 * Math.PI - l } const y = null !== r; let x = 0, v = 0; if (null !== n) { x = _(f, p, bt(h, [...[t[n], t[n + 1]]])) } if (y) { v = _(p, f, bt(h, [...[t[r], t[r + 1]]])) } s.push(d[0], d[1], g[0], g[1], m(0, x, v)), s.push(...a), s.push(d[0], d[1], g[0], g[1], m(1, x, v)), s.push(...a), s.push(d[0], d[1], g[0], g[1], m(2, x, v)), s.push(...a), s.push(d[0], d[1], g[0], g[1], m(3, x, v)), s.push(...a), o.push(u, u + 1, u + 2, u + 1, u + 3, u + 2) }, _T.render.webgl.utils.writePointFeatureToBuffers = function (t, e, i, n, r, s) { const o = 3 + r, a = t[e + 0], l = t[e + 1], h = af; h.length = r; for (let i = 0; i < h.length; i++)h[i] = t[e + 2 + i]; let c = s ? s.vertexPosition : 0, u = s ? s.indexPosition : 0; const d = c / o; return hf(i, c, a, l, 0), h.length && i.set(h, c + 3), c += o, hf(i, c, a, l, 1), h.length && i.set(h, c + 3), c += o, hf(i, c, a, l, 2), h.length && i.set(h, c + 3), c += o, hf(i, c, a, l, 3), h.length && i.set(h, c + 3), c += o, n[u++] = d, n[u++] = d + 1, n[u++] = d + 3, n[u++] = d + 1, n[u++] = d + 2, n[u++] = d + 3, lf.vertexPosition = c, lf.indexPosition = u, lf }, _T.render.webgl.utils.writePolygonTrianglesToBuffers = function (t, e, i, n, r) { const s = 2 + r; let o = e; const a = t.slice(o, o + r); o += r; const l = t[o++]; let h = 0; const c = new Array(l - 1); for (let e = 0; e < l; e++)h += t[o++], e < l - 1 && (c[e] = h); const u = t.slice(o, o + 2 * h), d = Ag.exports(u, c, 2); for (let t = 0; t < d.length; t++)n.push(d[t] + i.length / s); for (let t = 0; t < u.length; t += 2)i.push(u[t], u[t + 1], ...a); return o + 2 * h }, _T.renderer = {}, _T.renderer.Composite = eo, _T.renderer.Layer = Cc, _T.renderer.Map = ws, _T.renderer.canvas = {}, _T.renderer.canvas.ImageLayer = Ic, _T.renderer.canvas.Layer = Pc, _T.renderer.canvas.Layer.canvasPool = bc, _T.renderer.canvas.TileLayer = Oc, _T.renderer.canvas.VectorImageLayer = Tp, _T.renderer.canvas.VectorLayer = Ep, _T.renderer.canvas.VectorTileLayer = Rp, _T.renderer.vector = {}, _T.renderer.vector.defaultOrder = Pl, _T.renderer.vector.getSquaredTolerance = Il, _T.renderer.vector.getTolerance = Ll, _T.renderer.vector.renderFeature = Ml, _T.renderer.webgl = {}, _T.renderer.webgl.Layer = gd, _T.renderer.webgl.PointsLayer = gf, _T.renderer.webgl.TileLayer = wd, _T.renderer.webgl.TileLayer.Attributes = pd, _T.renderer.webgl.TileLayer.Uniforms = fd, _T.renderer.webgl.VectorLayer = class extends gd { constructor(t, e) { const i = e.uniforms || {}, n = [1, 0, 0, 1, 0, 0]; i[Wu] = n, super(t, { uniforms: i, postProcesses: e.postProcesses }), this.sourceRevision_ = -1, this.previousExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], this.currentTransform_ = n; const r = { color: function () { return Ef("#ddd") }, opacity: function () { return 1 }, ...e.fill && e.fill.attributes }, s = { color: function () { return Ef("#eee") }, opacity: function () { return 1 }, width: function () { return 1.5 }, ...e.stroke && e.stroke.attributes }, o = { color: function () { return Ef("#eee") }, opacity: function () { return 1 }, ...e.point && e.point.attributes }; this.fillVertexShader_ = e.fill && e.fill.vertexShader || Cf, this.fillFragmentShader_ = e.fill && e.fill.fragmentShader || bf, this.fillAttributes_ = Mf(r), this.strokeVertexShader_ = e.stroke && e.stroke.vertexShader || Rf, this.strokeFragmentShader_ = e.stroke && e.stroke.fragmentShader || Pf, this.strokeAttributes_ = Mf(s), this.pointVertexShader_ = e.point && e.point.vertexShader || If, this.pointFragmentShader_ = e.point && e.point.fragmentShader || Lf, this.pointAttributes_ = Mf(o), this.worker_ = df(), this.batch_ = new yf; const a = this.getLayer().getSource(); this.batch_.addFeatures(a.getFeatures()), this.sourceListenKeys_ = [N(a, Oh, this.handleSourceFeatureAdded_, this), N(a, Nh, this.handleSourceFeatureChanged_, this), N(a, kh, this.handleSourceFeatureDelete_, this), N(a, Dh, this.handleSourceFeatureClear_, this)] } afterHelperCreated() { this.polygonRenderer_ = new wf(this.helper, this.worker_, this.fillVertexShader_, this.fillFragmentShader_, this.fillAttributes_), this.pointRenderer_ = new vf(this.helper, this.worker_, this.pointVertexShader_, this.pointFragmentShader_, this.pointAttributes_), this.lineStringRenderer_ = new _f(this.helper, this.worker_, this.strokeVertexShader_, this.strokeFragmentShader_, this.strokeAttributes_) } handleSourceFeatureAdded_(t) { const e = t.feature; this.batch_.addFeature(e) } handleSourceFeatureChanged_(t) { const e = t.feature; this.batch_.changeFeature(e) } handleSourceFeatureDelete_(t) { const e = t.feature; this.batch_.removeFeature(e) } handleSourceFeatureClear_() { this.batch_.clear() } renderFrame(t) { const e = this.helper.getGL(); this.preRender(e, t); const i = this.getLayer().getSource(), n = t.viewState.projection, r = i.getWrapX() && n.canWrapX(), s = n.getExtent(), o = t.extent, a = r ? Se(s) : null, l = r ? Math.ceil((o[2] - s[2]) / a) + 1 : 1; let h = r ? Math.floor((o[0] - s[0]) / a) : 0; do { this.polygonRenderer_.render(this.batch_.polygonBatch, this.currentTransform_, t, h * a), this.lineStringRenderer_.render(this.batch_.lineStringBatch, this.currentTransform_, t, h * a), this.pointRenderer_.render(this.batch_.pointBatch, this.currentTransform_, t, h * a) } while (++h < l); this.helper.finalizeDraw(t); const c = this.helper.getCanvas(), u = t.layerStatesArray[t.layerIndex].opacity; return u !== parseFloat(c.style.opacity) && (c.style.opacity = String(u)), this.postRender(e, t), c } prepareFrameInternal(t) { const e = this.getLayer(), i = e.getSource(), n = t.viewState, r = !t.viewHints[Ro] && !t.viewHints[Po], s = !ee(this.previousExtent_, t.extent), o = this.sourceRevision_ < i.getRevision(); if (o && (this.sourceRevision_ = i.getRevision()), r && (s || o)) { const r = n.projection, s = n.resolution, o = e instanceof Ig ? e.getRenderBuffer() : 0, a = Xt(t.extent, o * s); i.loadFeatures(a, s, r), this.ready = !1; let l = 3; const h = () => { l--, this.ready = l <= 0, this.getLayer().changed() }; this.polygonRenderer_.rebuild(this.batch_.polygonBatch, t, "Polygon", h), this.lineStringRenderer_.rebuild(this.batch_.lineStringBatch, t, "LineString", h), this.pointRenderer_.rebuild(this.batch_.pointBatch, t, "Point", h), this.previousExtent_ = t.extent.slice() } return this.helper.makeProjectionTransform(t, this.currentTransform_), this.helper.prepareDraw(t), !0 } forEachFeatureAtCoordinate(t, e, i, n, r) { } disposeInternal() { this.worker_.terminate(), this.layer_ = null, this.sourceListenKeys_.forEach((function (t) { k(t) })), this.sourceListenKeys_ = null, super.disposeInternal() } }, _T.renderer.webgl.shaders = {}, _T.renderer.webgl.shaders.FILL_FRAGMENT_SHADER = bf, _T.renderer.webgl.shaders.FILL_VERTEX_SHADER = Cf, _T.renderer.webgl.shaders.POINT_FRAGMENT_SHADER = Lf, _T.renderer.webgl.shaders.POINT_VERTEX_SHADER = If, _T.renderer.webgl.shaders.STROKE_FRAGMENT_SHADER = Pf, _T.renderer.webgl.shaders.STROKE_VERTEX_SHADER = Rf, _T.renderer.webgl.shaders.packColor = Ef, _T.reproj = {}, _T.reproj.Image = gc, _T.reproj.Tile = zl, _T.reproj.Triangulation = Ul, _T.reproj.calculateSourceExtentResolution = jl, _T.reproj.calculateSourceResolution = Gl, _T.reproj.canvasPool = Nl, _T.reproj.common = {}, _T.reproj.common.ERROR_THRESHOLD = .5, _T.reproj.render = Bl, _T.resolutionconstraint = {}, _T.resolutionconstraint.createMinMaxResolution = ko, _T.resolutionconstraint.createSnapToPower = Do, _T.resolutionconstraint.createSnapToResolutions = No, _T.rotationconstraint = {}, _T.rotationconstraint.createSnapToN = Bo, _T.rotationconstraint.createSnapToZero = Uo, _T.rotationconstraint.disable = Go, _T.rotationconstraint.none = jo, _T.size = {}, _T.size.buffer = Ua, _T.size.hasArea = za, _T.size.scale = Xa, _T.size.toSize = Va, _T.source = {}, _T.source.BingMaps = class extends uh { constructor(t) { const e = void 0 !== t.hidpi && t.hidpi; super({ cacheSize: t.cacheSize, crossOrigin: "anonymous", interpolate: t.interpolate, opaque: !0, projection: Ui("EPSG:3857"), reprojectionErrorThreshold: t.reprojectionErrorThreshold, state: "loading", tileLoadFunction: t.tileLoadFunction, tilePixelRatio: e ? 2 : 1, wrapX: void 0 === t.wrapX || t.wrapX, transition: t.transition, zDirection: t.zDirection }), this.hidpi_ = e, this.culture_ = void 0 !== t.culture ? t.culture : "en-us", this.maxZoom_ = void 0 !== t.maxZoom ? t.maxZoom : -1, this.apiKey_ = t.key, this.imagerySet_ = t.imagerySet; vl("https://dev.virtualearth.net/REST/v1/Imagery/Metadata/" + this.imagerySet_ + "?uriScheme=https&include=ImageryProviders&key=" + this.apiKey_ + "&c=" + this.culture_, this.handleImageryMetadataResponse.bind(this), void 0, "jsonp") } getApiKey() { return this.apiKey_ } getImagerySet() { return this.imagerySet_ } handleImageryMetadataResponse(t) { if (200 != t.statusCode || "OK" != t.statusDescription || "ValidCredentials" != t.authenticationResultCode || 1 != t.resourceSets.length || 1 != t.resourceSets[0].resources.length) return void this.setState("error"); const e = t.resourceSets[0].resources[0], i = -1 == this.maxZoom_ ? e.zoomMax : this.maxZoom_, n = ih(this.getProjection()), r = this.hidpi_ ? 2 : 1, s = e.imageWidth == e.imageHeight ? e.imageWidth / r : [e.imageWidth / r, e.imageHeight / r], o = Ql({ extent: n, minZoom: e.zoomMin, maxZoom: i, tileSize: s }); this.tileGrid = o; const a = this.culture_, l = this.hidpi_; if (this.tileUrlFunction = ah(e.imageUrlSubdomains.map((function (t) { const i = [0, 0, 0], n = e.imageUrl.replace("{subdomain}", t).replace("{culture}", a); return function (t, e, r) { if (t) { el(t[0], t[1], t[2], i); let e = n; return l && (e += "&dpi=d1&device=mobile"), e.replace("{quadkey}", gh(i)) } } }))), e.imageryProviders) { const t = qi(Ui("EPSG:4326"), this.getProjection()); this.setAttributions(function (i) { const n = [], r = i.viewState, s = this.getTileGrid(), o = s.getZForResolution(r.resolution, this.zDirection), a = s.getTileCoordForCoordAndZ(r.center, o)[0]; return e.imageryProviders.map((function (e) { let r = !1; const s = e.coverageAreas; for (let e = 0, n = s.length; e < n; ++e) { const n = s[e]; if (a >= n.zoomMin && a <= n.zoomMax) { const e = n.bbox; if (we(Re([e[1], e[0], e[3], e[2]], t), i.extent)) { r = !0; break } } } r && n.push(e.attribution) })), n.push('<a class="ol-attribution-bing-tos" href="https://www.microsoft.com/maps/product/terms.html" target="_blank">Terms of Use</a>'), n }.bind(this)) } this.setState("ready") } }, _T.source.BingMaps.quadKey = gh, _T.source.CartoDB = class extends fh { constructor(t) { super({ attributions: t.attributions, cacheSize: t.cacheSize, crossOrigin: t.crossOrigin, maxZoom: void 0 !== t.maxZoom ? t.maxZoom : 18, minZoom: t.minZoom, projection: t.projection, transition: t.transition, wrapX: t.wrapX, zDirection: t.zDirection }), this.account_ = t.account, this.mapId_ = t.map || "", this.config_ = t.config || {}, this.templateCache_ = {}, this.initializeMap_() } getConfig() { return this.config_ } updateConfig(t) { Object.assign(this.config_, t), this.initializeMap_() } setConfig(t) { this.config_ = t || {}, this.initializeMap_() } initializeMap_() { const t = JSON.stringify(this.config_); if (this.templateCache_[t]) return void this.applyTemplate_(this.templateCache_[t]); let e = "https://" + this.account_ + ".carto.com/api/v1/map"; this.mapId_ && (e += "/named/" + this.mapId_); const i = new XMLHttpRequest; i.addEventListener("load", this.handleInitResponse_.bind(this, t)), i.addEventListener("error", this.handleInitError_.bind(this)), i.open("POST", e), i.setRequestHeader("Content-type", "application/json"), i.send(JSON.stringify(this.config_)) } handleInitResponse_(t, e) { const i = e.target; if (!i.status || i.status >= 200 && i.status < 300) { let e; try { e = JSON.parse(i.responseText) } catch (t) { return void this.setState("error") } this.applyTemplate_(e), this.templateCache_[t] = e, this.setState("ready") } else this.setState("error") } handleInitError_(t) { this.setState("error") } applyTemplate_(t) { const e = "https://" + t.cdn_url.https + "/" + this.account_ + "/api/v1/map/" + t.layergroupid + "/{z}/{x}/{y}.png"; this.setUrl(e) } }, _T.source.Cluster = class extends zh { constructor(t) { super({ attributions: t.attributions, wrapX: t.wrapX }), this.resolution = void 0, this.distance = void 0 !== t.distance ? t.distance : 20, this.minDistance = t.minDistance || 0, this.interpolationRatio = 0, this.features = [], this.geometryFunction = t.geometryFunction || function (t) { const e = t.getGeometry(); return at("Point" == e.getType(), 10), e }, this.createCustomCluster_ = t.createCluster, this.source = null, this.boundRefresh_ = this.refresh.bind(this), this.updateDistance(this.distance, this.minDistance), this.setSource(t.source || null) } clear(t) { this.features.length = 0, super.clear(t) } getDistance() { return this.distance } getSource() { return this.source } loadFeatures(t, e, i) { this.source.loadFeatures(t, e, i), e !== this.resolution && (this.resolution = e, this.refresh()) } setDistance(t) { this.updateDistance(t, this.minDistance) } setMinDistance(t) { this.updateDistance(this.distance, t) } getMinDistance() { return this.minDistance } setSource(t) { this.source && this.source.removeEventListener(S, this.boundRefresh_), this.source = t, t && t.addEventListener(S, this.boundRefresh_), this.refresh() } refresh() { this.clear(), this.cluster(), this.addFeatures(this.features) } updateDistance(t, e) { const i = 0 === t ? 0 : Math.min(e, t) / t, n = t !== this.distance || this.interpolationRatio !== i; this.distance = t, this.minDistance = e, this.interpolationRatio = i, n && this.refresh() } cluster() { if (void 0 === this.resolution || !this.source) return; const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0], e = this.distance * this.resolution, i = this.source.getFeatures(), n = {}; for (let r = 0, s = i.length; r < s; r++) { const s = i[r]; if (!(z(s) in n)) { const i = this.geometryFunction(s); if (i) { Qt(i.getCoordinates(), t), Xt(t, e, t); const r = this.source.getFeaturesInExtent(t).filter((function (t) { const e = z(t); return !(e in n) && (n[e] = !0, !0) })); this.features.push(this.createCluster(r, t)) } } } } createCluster(t, e) { const i = [0, 0]; for (let e = t.length - 1; e >= 0; --e) { const n = this.geometryFunction(t[e]); n ? mi(i, n.getCoordinates()) : t.splice(e, 1) } Ei(i, 1 / t.length); const n = ge(e), r = this.interpolationRatio, s = new Wn([i[0] * (1 - r) + n[0] * r, i[1] * (1 - r) + n[1] * r]); return this.createCustomCluster_ ? this.createCustomCluster_(s, t) : new lt({ geometry: s, features: t }) } }, _T.source.DataTile = Xh, _T.source.GeoTIFF = ic, _T.source.IIIF = class extends uh { constructor(t) { const e = t || {}; let i = e.url || ""; i += i.lastIndexOf("/") === i.length - 1 || "" === i ? "" : "/"; const n = e.version || sc, r = e.sizes || [], s = e.size; at(null != s && Array.isArray(s) && 2 == s.length && !isNaN(s[0]) && s[0] > 0 && !isNaN(s[1]) && s[1] > 0, 60); const o = s[0], a = s[1], l = e.tileSize, h = e.tilePixelRatio || 1, c = e.format || "jpg", u = e.quality || (e.version == rc ? "native" : "default"); let d = e.resolutions || []; const g = e.supports || [], f = e.extent || [0, -a, o, 0], p = null != r && Array.isArray(r) && r.length > 0, m = void 0 !== l && ("number" == typeof l && Number.isInteger(l) && l > 0 || Array.isArray(l) && l.length > 0), _ = null != g && Array.isArray(g) && (g.includes("regionByPx") || g.includes("regionByPct")) && (g.includes("sizeByWh") || g.includes("sizeByH") || g.includes("sizeByW") || g.includes("sizeByPct")); let y, x, v; if (d.sort((function (t, e) { return e - t })), m || _) if (null != l && ("number" == typeof l && Number.isInteger(l) && l > 0 ? (y = l, x = l) : Array.isArray(l) && l.length > 0 && ((1 == l.length || null == l[1] && Number.isInteger(l[0])) && (y = l[0], x = l[0]), 2 == l.length && (Number.isInteger(l[0]) && Number.isInteger(l[1]) ? (y = l[0], x = l[1]) : null == l[0] && Number.isInteger(l[1]) && (y = l[1], x = l[1])))), void 0 !== y && void 0 !== x || (y = Lo, x = Lo), 0 == d.length) { v = Math.max(Math.ceil(Math.log(o / y) / Math.LN2), Math.ceil(Math.log(a / x) / Math.LN2)); for (let t = v; t >= 0; t--)d.push(Math.pow(2, t)) } else { const t = Math.max(...d); v = Math.round(Math.log(t) / Math.LN2) } else if (y = o, x = a, d = [], p) { r.sort((function (t, e) { return t[0] - e[0] })), v = -1; const t = []; for (let e = 0; e < r.length; e++) { const i = o / r[e][0]; d.length > 0 && d[d.length - 1] == i ? t.push(e) : (d.push(i), v++) } if (t.length > 0) for (let e = 0; e < t.length; e++)r.splice(t[e] - e, 1) } else d.push(1), r.push([o, a]), v = 0; const S = new ql({ tileSize: [y, x], extent: f, origin: xe(f), resolutions: d }), w = nc.bind(null, Va(l || 256).map((function (t) { return t * h }))); super({ attributions: e.attributions, attributionsCollapsible: e.attributionsCollapsible, cacheSize: e.cacheSize, crossOrigin: e.crossOrigin, interpolate: e.interpolate, projection: e.projection, reprojectionErrorThreshold: e.reprojectionErrorThreshold, state: e.state, tileClass: w, tileGrid: S, tilePixelRatio: e.tilePixelRatio, tileUrlFunction: function (t, e, s) { let l, h; const f = t[0]; if (f > v) return; const S = t[1], w = t[2], E = d[f]; if (!(void 0 === S || void 0 === w || void 0 === E || S < 0 || Math.ceil(o / E / y) <= S || w < 0 || Math.ceil(a / E / x) <= w)) { if (_ || m) { const t = S * y * E, e = w * x * E; let i = y * E, r = x * E, s = y, c = x; if (t + i > o && (i = o - t), e + r > a && (r = a - e), t + y * E > o && (s = Math.floor((o - t + E - 1) / E)), e + x * E > a && (c = Math.floor((a - e + E - 1) / E)), 0 == t && i == o && 0 == e && r == a) l = "full"; else if (!_ || g.includes("regionByPx")) l = t + "," + e + "," + i + "," + r; else if (g.includes("regionByPct")) { l = "pct:" + dc(t / o * 100) + "," + dc(e / a * 100) + "," + dc(i / o * 100) + "," + dc(r / a * 100) } n != oc || _ && !g.includes("sizeByWh") ? !_ || g.includes("sizeByW") ? h = s + "," : g.includes("sizeByH") ? h = "," + c : g.includes("sizeByWh") ? h = s + "," + c : g.includes("sizeByPct") && (h = "pct:" + dc(100 / E)) : h = s + "," + c } else if (l = "full", p) { const t = r[f][0], e = r[f][1]; h = n == oc ? t == o && e == a ? "max" : t + "," + e : t == o ? "full" : t + "," } else h = n == oc ? "max" : "full"; return i + l + "/" + h + "/0/" + u + "." + c } }, transition: e.transition }), this.zDirection = e.zDirection } }, _T.source.Image = yc, _T.source.Image.ImageSourceEvent = _c, _T.source.Image.defaultImageLoadFunction = xc, _T.source.ImageArcGISRest = class extends yc { constructor(t) { super({ attributions: (t = t || {}).attributions, interpolate: t.interpolate, projection: t.projection, resolutions: t.resolutions }), this.crossOrigin_ = void 0 !== t.crossOrigin ? t.crossOrigin : null, this.hidpi_ = void 0 === t.hidpi || t.hidpi, this.url_ = t.url, this.imageLoadFunction_ = void 0 !== t.imageLoadFunction ? t.imageLoadFunction : xc, this.params_ = t.params || {}, this.image_ = null, this.imageSize_ = [0, 0], this.renderedRevision_ = 0, this.ratio_ = void 0 !== t.ratio ? t.ratio : 1.5 } getParams() { return this.params_ } getImageInternal(t, e, i, n) { if (void 0 === this.url_) return null; e = this.findNearestResolution(e), i = this.hidpi_ ? i : 1; const r = this.image_; if (r && this.renderedRevision_ == this.getRevision() && r.getResolution() == e && r.getPixelRatio() == i && Yt(r.getExtent(), t)) return r; const s = { F: "image", FORMAT: "PNG32", TRANSPARENT: !0 }; Object.assign(s, this.params_); const o = ((t = t.slice())[0] + t[2]) / 2, a = (t[1] + t[3]) / 2; if (1 != this.ratio_) { const e = this.ratio_ * Se(t) / 2, i = this.ratio_ * _e(t) / 2; t[0] = o - e, t[1] = a - i, t[2] = o + e, t[3] = a + i } const l = e / i, h = Math.ceil(Se(t) / l), c = Math.ceil(_e(t) / l); t[0] = o - l * h / 2, t[2] = o + l * h / 2, t[1] = a - l * c / 2, t[3] = a + l * c / 2, this.imageSize_[0] = h, this.imageSize_[1] = c; const u = this.getRequestUrl_(t, this.imageSize_, i, n, s); return this.image_ = new Ar(t, e, i, u, this.crossOrigin_, this.imageLoadFunction_), this.renderedRevision_ = this.getRevision(), this.image_.addEventListener(S, this.handleImageChange.bind(this)), this.image_ } getImageLoadFunction() { return this.imageLoadFunction_ } getRequestUrl_(t, e, i, n, r) { const s = n.getCode().split(/:(?=\d+$)/).pop(); r.SIZE = e[0] + "," + e[1], r.BBOX = t.join(","), r.BBOXSR = s, r.IMAGESR = s, r.DPI = Math.round(90 * i); const o = this.url_, a = o.replace(/MapServer\/?$/, "MapServer/export").replace(/ImageServer\/?$/, "ImageServer/exportImage"); return a == o && at(!1, 50), vc(a, r) } getUrl() { return this.url_ } setImageLoadFunction(t) { this.image_ = null, this.imageLoadFunction_ = t, this.changed() } setUrl(t) { t != this.url_ && (this.url_ = t, this.image_ = null, this.changed()) } updateParams(t) { Object.assign(this.params_, t), this.image_ = null, this.changed() } }, _T.source.ImageCanvas = class extends yc { constructor(t) { super({ attributions: (t = t || {}).attributions, interpolate: t.interpolate, projection: t.projection, resolutions: t.resolutions, state: t.state }), this.canvasFunction_ = t.canvasFunction, this.canvas_ = null, this.renderedRevision_ = 0, this.ratio_ = void 0 !== t.ratio ? t.ratio : 1.5 } getImageInternal(t, e, i, n) { e = this.findNearestResolution(e); let r = this.canvas_; if (r && this.renderedRevision_ == this.getRevision() && r.getResolution() == e && r.getPixelRatio() == i && Yt(r.getExtent(), t)) return r; Ce(t = t.slice(), this.ratio_); const s = [Se(t) / e * i, _e(t) / e * i], o = this.canvasFunction_.call(this, t, e, i, s, n); return o && (r = new Nr(t, e, i, o)), this.canvas_ = r, this.renderedRevision_ = this.getRevision(), r } }, _T.source.ImageMapGuide = class extends yc { constructor(t) { super({ interpolate: t.interpolate, projection: t.projection, resolutions: t.resolutions }), this.crossOrigin_ = void 0 !== t.crossOrigin ? t.crossOrigin : null, this.displayDpi_ = void 0 !== t.displayDpi ? t.displayDpi : 96, this.params_ = t.params || {}, this.url_ = t.url, this.imageLoadFunction_ = void 0 !== t.imageLoadFunction ? t.imageLoadFunction : xc, this.hidpi_ = void 0 === t.hidpi || t.hidpi, this.metersPerUnit_ = void 0 !== t.metersPerUnit ? t.metersPerUnit : 1, this.ratio_ = void 0 !== t.ratio ? t.ratio : 1, this.useOverlay_ = void 0 !== t.useOverlay && t.useOverlay, this.image_ = null, this.renderedRevision_ = 0 } getParams() { return this.params_ } getImageInternal(t, e, i, n) { e = this.findNearestResolution(e), i = this.hidpi_ ? i : 1; let r = this.image_; if (r && this.renderedRevision_ == this.getRevision() && r.getResolution() == e && r.getPixelRatio() == i && Yt(r.getExtent(), t)) return r; 1 != this.ratio_ && Ce(t = t.slice(), this.ratio_); const s = [Se(t) / e * i, _e(t) / e * i]; if (void 0 !== this.url_) { const o = this.getUrl(this.url_, this.params_, t, s, n); r = new Ar(t, e, i, o, this.crossOrigin_, this.imageLoadFunction_), r.addEventListener(S, this.handleImageChange.bind(this)) } else r = null; return this.image_ = r, this.renderedRevision_ = this.getRevision(), r } getImageLoadFunction() { return this.imageLoadFunction_ } updateParams(t) { Object.assign(this.params_, t), this.changed() } getUrl(t, e, i, n, r) { const s = function (t, e, i, n) { const r = Se(t), s = _e(t), o = e[0], a = e[1], l = .0254 / n; return a * r > o * s ? r * i / (o * l) : s * i / (a * l) }(i, n, this.metersPerUnit_, this.displayDpi_), o = ge(i), a = { OPERATION: this.useOverlay_ ? "GETDYNAMICMAPOVERLAYIMAGE" : "GETMAPIMAGE", VERSION: "2.0.0", LOCALE: "en", CLIENTAGENT: "ol/source/ImageMapGuide source", CLIP: "1", SETDISPLAYDPI: this.displayDpi_, SETDISPLAYWIDTH: Math.round(n[0]), SETDISPLAYHEIGHT: Math.round(n[1]), SETVIEWSCALE: s, SETVIEWCENTERX: o[0], SETVIEWCENTERY: o[1] }; return Object.assign(a, e), vc(t, a) } setImageLoadFunction(t) { this.image_ = null, this.imageLoadFunction_ = t, this.changed() } }, _T.source.ImageStatic = class extends yc { constructor(t) { const e = void 0 !== t.crossOrigin ? t.crossOrigin : null, i = void 0 !== t.imageLoadFunction ? t.imageLoadFunction : xc; super({ attributions: t.attributions, interpolate: t.interpolate, projection: Ui(t.projection) }), this.url_ = t.url, this.imageExtent_ = t.imageExtent, this.image_ = new Ar(this.imageExtent_, void 0, 1, this.url_, e, i), this.imageSize_ = t.imageSize ? t.imageSize : null, this.image_.addEventListener(S, this.handleImageChange.bind(this)) } getImageExtent() { return this.imageExtent_ } getImageInternal(t, e, i, n) { return we(t, this.image_.getExtent()) ? this.image_ : null } getUrl() { return this.url_ } handleImageChange(t) { if (this.image_.getState() == Lr) { const t = this.image_.getExtent(), e = this.image_.getImage(); let i, n; this.imageSize_ ? (i = this.imageSize_[0], n = this.imageSize_[1]) : (i = e.width, n = e.height); const r = Se(t), s = _e(t), o = r / i, a = s / n; let l = i, h = n; if (o > a ? l = Math.round(r / a) : h = Math.round(s / o), l !== i || h !== n) { const t = Dr(l, h); this.getInterpolate() || (t.imageSmoothingEnabled = !1); const r = t.canvas; t.drawImage(e, 0, 0, i, n, 0, 0, r.width, r.height), this.image_.setImage(r) } } super.handleImageChange(t) } }, _T.source.ImageWMS = class extends yc { constructor(t) { super({ attributions: (t = t || {}).attributions, interpolate: t.interpolate, projection: t.projection, resolutions: t.resolutions }), this.crossOrigin_ = void 0 !== t.crossOrigin ? t.crossOrigin : null, this.url_ = t.url, this.imageLoadFunction_ = void 0 !== t.imageLoadFunction ? t.imageLoadFunction : xc, this.params_ = Object.assign({}, t.params), this.v13_ = !0, this.updateV13_(), this.serverType_ = t.serverType, this.hidpi_ = void 0 === t.hidpi || t.hidpi, this.image_ = null, this.imageSize_ = [0, 0], this.renderedRevision_ = 0, this.ratio_ = void 0 !== t.ratio ? t.ratio : 1.5 } getFeatureInfoUrl(t, e, i, n) { if (void 0 === this.url_) return; const r = Ui(i), s = this.getProjection(); s && s !== r && (e = Gl(s, r, t, e), t = $i(t, r, s)); const o = pe(t, e, 0, wc), a = { SERVICE: "WMS", VERSION: Sc, REQUEST: "GetFeatureInfo", FORMAT: "image/png", TRANSPARENT: !0, QUERY_LAYERS: this.params_.LAYERS }; Object.assign(a, this.params_, n); const l = di((t[0] - o[0]) / e, 4), h = di((o[3] - t[1]) / e, 4); return a[this.v13_ ? "I" : "X"] = l, a[this.v13_ ? "J" : "Y"] = h, this.getRequestUrl_(o, wc, 1, s || r, a) } getLegendUrl(t, e) { if (void 0 === this.url_) return; const i = { SERVICE: "WMS", VERSION: Sc, REQUEST: "GetLegendGraphic", FORMAT: "image/png" }; if (void 0 === e || void 0 === e.LAYER) { const t = this.params_.LAYERS; if (!(!Array.isArray(t) || 1 === t.length)) return; i.LAYER = t } if (void 0 !== t) { const e = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, n = 28e-5; i.SCALE = t * e / n } return Object.assign(i, e), vc(this.url_, i) } getParams() { return this.params_ } getImageInternal(t, e, i, n) { if (void 0 === this.url_) return null; e = this.findNearestResolution(e), 1 == i || this.hidpi_ && void 0 !== this.serverType_ || (i = 1); const r = e / i, s = ge(t), o = pe(s, r, 0, [gi(Se(t) / r, 4), gi(_e(t) / r, 4)]), a = pe(s, r, 0, [gi(this.ratio_ * Se(t) / r, 4), gi(this.ratio_ * _e(t) / r, 4)]), l = this.image_; if (l && this.renderedRevision_ == this.getRevision() && l.getResolution() == e && l.getPixelRatio() == i && Yt(l.getExtent(), o)) return l; const h = { SERVICE: "WMS", VERSION: Sc, REQUEST: "GetMap", FORMAT: "image/png", TRANSPARENT: !0 }; Object.assign(h, this.params_), this.imageSize_[0] = ui(Se(a) / r, 4), this.imageSize_[1] = ui(_e(a) / r, 4); const c = this.getRequestUrl_(a, this.imageSize_, i, n, h); return this.image_ = new Ar(a, e, i, c, this.crossOrigin_, this.imageLoadFunction_), this.renderedRevision_ = this.getRevision(), this.image_.addEventListener(S, this.handleImageChange.bind(this)), this.image_ } getImageLoadFunction() { return this.imageLoadFunction_ } getRequestUrl_(t, e, i, n, r) { if (at(void 0 !== this.url_, 9), r[this.v13_ ? "CRS" : "SRS"] = n.getCode(), "STYLES" in this.params_ || (r.STYLES = ""), 1 != i) switch (this.serverType_) { case "geoserver": const t = 90 * i + .5 | 0; "FORMAT_OPTIONS" in r ? r.FORMAT_OPTIONS += ";dpi:" + t : r.FORMAT_OPTIONS = "dpi:" + t; break; case "mapserver": r.MAP_RESOLUTION = 90 * i; break; case "carmentaserver": case "qgis": r.DPI = 90 * i; break; default: at(!1, 8) }r.WIDTH = e[0], r.HEIGHT = e[1]; const s = n.getAxisOrientation(); let o; return o = this.v13_ && "ne" == s.substr(0, 2) ? [t[1], t[0], t[3], t[2]] : t, r.BBOX = o.join(","), vc(this.url_, r) } getUrl() { return this.url_ } setImageLoadFunction(t) { this.image_ = null, this.imageLoadFunction_ = t, this.changed() } setUrl(t) { t != this.url_ && (this.url_ = t, this.image_ = null, this.changed()) } updateParams(t) { Object.assign(this.params_, t), this.updateV13_(), this.image_ = null, this.changed() } updateV13_() { const t = this.params_.VERSION || Sc; this.v13_ = pi(t, "1.3") >= 0 } }, _T.source.OGCMapTile = class extends uh { constructor(t) { super({ attributions: t.attributions, cacheSize: t.cacheSize, crossOrigin: t.crossOrigin, interpolate: t.interpolate, projection: t.projection, reprojectionErrorThreshold: t.reprojectionErrorThreshold, state: "loading", tileLoadFunction: t.tileLoadFunction, wrapX: void 0 === t.wrapX || t.wrapX, transition: t.transition }); Rg({ url: t.url, projection: this.getProjection(), mediaType: t.mediaType, context: t.context || null }).then(this.handleTileSetInfo_.bind(this)).catch(this.handleError_.bind(this)) } handleTileSetInfo_(t) { this.tileGrid = t.grid, this.setTileUrlFunction(t.urlFunction, t.urlTemplate), this.setState("ready") } handleError_(t) { console.error(t), this.setState("error") } }, _T.source.OGCVectorTile = class extends Qc { constructor(t) { super({ attributions: t.attributions, attributionsCollapsible: t.attributionsCollapsible, cacheSize: t.cacheSize, format: t.format, overlaps: t.overlaps, projection: t.projection, tileClass: t.tileClass, transition: t.transition, wrapX: t.wrapX, zDirection: t.zDirection, state: "loading" }); Rg({ url: t.url, projection: this.getProjection(), mediaType: t.mediaType, supportedMediaTypes: t.format.supportedMediaTypes, context: t.context || null }).then(this.handleTileSetInfo_.bind(this)).catch(this.handleError_.bind(this)) } handleTileSetInfo_(t) { this.tileGrid = t.grid, this.setTileUrlFunction(t.urlFunction, t.urlTemplate), this.setState("ready") } handleError_(t) { console.error(t), this.setState("error") } }, _T.source.OSM = class extends fh { constructor(t) { let e; e = void 0 !== (t = t || {}).attributions ? t.attributions : [Ec]; const i = void 0 !== t.crossOrigin ? t.crossOrigin : "anonymous", n = void 0 !== t.url ? t.url : "https://tile.openstreetmap.org/{z}/{x}/{y}.png"; super({ attributions: e, attributionsCollapsible: !1, cacheSize: t.cacheSize, crossOrigin: i, interpolate: t.interpolate, maxZoom: void 0 !== t.maxZoom ? t.maxZoom : 19, opaque: void 0 === t.opaque || t.opaque, reprojectionErrorThreshold: t.reprojectionErrorThreshold, tileLoadFunction: t.tileLoadFunction, transition: t.transition, url: n, wrapX: t.wrapX, zDirection: t.zDirection }) } }, _T.source.OSM.ATTRIBUTION = Ec, _T.source.Raster = Wc, _T.source.Raster.Processor = Uc, _T.source.Raster.RasterSourceEvent = Vc, _T.source.Raster.newImageData = Gc, _T.source.Source = Zl, _T.source.Stamen = class extends fh { constructor(t) { const e = t.layer.indexOf("-"), i = -1 == e ? t.layer : t.layer.slice(0, e), n = $c[i], r = Hc[t.layer], s = void 0 !== t.url ? t.url : "https://stamen-tiles-{a-d}.a.ssl.fastly.net/" + t.layer + "/{z}/{x}/{y}." + r.extension; super({ attributions: qc, cacheSize: t.cacheSize, crossOrigin: "anonymous", interpolate: t.interpolate, maxZoom: null != t.maxZoom ? t.maxZoom : n.maxZoom, minZoom: null != t.minZoom ? t.minZoom : n.minZoom, opaque: r.opaque, reprojectionErrorThreshold: t.reprojectionErrorThreshold, tileLoadFunction: t.tileLoadFunction, transition: t.transition, url: s, wrapX: t.wrapX, zDirection: t.zDirection }) } }, _T.source.Tile = nh, _T.source.Tile.TileSourceEvent = rh, _T.source.TileArcGISRest = class extends uh { constructor(t) { super({ attributions: (t = t || {}).attributions, cacheSize: t.cacheSize, crossOrigin: t.crossOrigin, interpolate: t.interpolate, projection: t.projection, reprojectionErrorThreshold: t.reprojectionErrorThreshold, tileGrid: t.tileGrid, tileLoadFunction: t.tileLoadFunction, url: t.url, urls: t.urls, wrapX: void 0 === t.wrapX || t.wrapX, transition: t.transition, zDirection: t.zDirection }), this.params_ = t.params || {}, this.hidpi_ = void 0 === t.hidpi || t.hidpi, this.tmpExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], this.setKey(this.getKeyForParams_()) } getKeyForParams_() { let t = 0; const e = []; for (const i in this.params_) e[t++] = i + "-" + this.params_[i]; return e.join("/") } getParams() { return this.params_ } getRequestUrl_(t, e, i, n, r, s) { const o = this.urls; if (!o) return; const a = r.getCode().split(/:(?=\d+$)/).pop(); let l; if (s.SIZE = e[0] + "," + e[1], s.BBOX = i.join(","), s.BBOXSR = a, s.IMAGESR = a, s.DPI = Math.round(s.DPI ? s.DPI * n : 90 * n), 1 == o.length) l = o[0]; else { l = o[li(ol(t), o.length)] } return vc(l.replace(/MapServer\/?$/, "MapServer/export").replace(/ImageServer\/?$/, "ImageServer/exportImage"), s) } getTilePixelRatio(t) { return this.hidpi_ ? t : 1 } updateParams(t) { Object.assign(this.params_, t), this.setKey(this.getKeyForParams_()) } tileUrlFunction(t, e, i) { let n = this.getTileGrid(); if (n || (n = this.getTileGridForProjection(i)), n.getResolutions().length <= t[0]) return; 1 == e || this.hidpi_ || (e = 1); const r = n.getTileCoordExtent(t, this.tmpExtent_); let s = Va(n.getTileSize(t[0]), this.tmpSize); 1 != e && (s = Xa(s, e, this.tmpSize)); const o = { F: "image", FORMAT: "PNG32", TRANSPARENT: !0 }; return Object.assign(o, this.params_), this.getRequestUrl_(t, s, r, e, i, o) } }, _T.source.TileDebug = class extends fh { constructor(t) { super({ opaque: !1, projection: (t = t || {}).projection, tileGrid: t.tileGrid, wrapX: void 0 === t.wrapX || t.wrapX, zDirection: t.zDirection, url: t.template || "z:{z} x:{x} y:{y}", tileLoadFunction: (t, e) => { const i = t.getTileCoord()[0], n = Va(this.tileGrid.getTileSize(i)), r = Dr(n[0], n[1]); r.strokeStyle = "grey", r.strokeRect(.5, .5, n[0] + .5, n[1] + .5), r.fillStyle = "grey", r.strokeStyle = "white", r.textAlign = "center", r.textBaseline = "middle", r.font = "24px sans-serif", r.lineWidth = 4, r.strokeText(e, n[0] / 2, n[1] / 2, n[0]), r.fillText(e, n[0] / 2, n[1] / 2, n[0]), t.setImage(r.canvas) } }) } }, _T.source.TileImage = uh, _T.source.TileJSON = class extends uh { constructor(t) { if (super({ attributions: t.attributions, cacheSize: t.cacheSize, crossOrigin: t.crossOrigin, interpolate: t.interpolate, projection: Ui("EPSG:3857"), reprojectionErrorThreshold: t.reprojectionErrorThreshold, state: "loading", tileLoadFunction: t.tileLoadFunction, wrapX: void 0 === t.wrapX || t.wrapX, transition: t.transition, zDirection: t.zDirection }), this.tileJSON_ = null, this.tileSize_ = t.tileSize, t.url) if (t.jsonp) vl(t.url, this.handleTileJSONResponse.bind(this), this.handleTileJSONError.bind(this)); else { const e = new XMLHttpRequest; e.addEventListener("load", this.onXHRLoad_.bind(this)), e.addEventListener("error", this.onXHRError_.bind(this)), e.open("GET", t.url), e.send() } else t.tileJSON ? this.handleTileJSONResponse(t.tileJSON) : at(!1, 51) } onXHRLoad_(t) { const e = t.target; if (!e.status || e.status >= 200 && e.status < 300) { let t; try { t = JSON.parse(e.responseText) } catch (t) { return void this.handleTileJSONError() } this.handleTileJSONResponse(t) } else this.handleTileJSONError() } onXHRError_(t) { this.handleTileJSONError() } getTileJSON() { return this.tileJSON_ } handleTileJSONResponse(t) { const e = Ui("EPSG:4326"), i = this.getProjection(); let n; if (void 0 !== t.bounds) { const r = qi(e, i); n = Re(t.bounds, r) } const r = ih(i), s = t.minzoom || 0, o = Ql({ extent: r, maxZoom: t.maxzoom || 22, minZoom: s, tileSize: this.tileSize_ }); if (this.tileGrid = o, this.tileUrlFunction = oh(t.tiles, o), t.attribution && !this.getAttributions()) { const e = void 0 !== n ? n : r; this.setAttributions((function (i) { return we(e, i.extent) ? [t.attribution] : null })) } this.tileJSON_ = t, this.setState("ready") } handleTileJSONError() { this.setState("error") } }, _T.source.TileWMS = class extends uh { constructor(t) { t = t || {}; const e = Object.assign({}, t.params), i = !("TRANSPARENT" in e) || e.TRANSPARENT; super({ attributions: t.attributions, attributionsCollapsible: t.attributionsCollapsible, cacheSize: t.cacheSize, crossOrigin: t.crossOrigin, interpolate: t.interpolate, opaque: !i, projection: t.projection, reprojectionErrorThreshold: t.reprojectionErrorThreshold, tileClass: t.tileClass, tileGrid: t.tileGrid, tileLoadFunction: t.tileLoadFunction, url: t.url, urls: t.urls, wrapX: void 0 === t.wrapX || t.wrapX, transition: t.transition, zDirection: t.zDirection }), this.gutter_ = void 0 !== t.gutter ? t.gutter : 0, this.params_ = e, this.v13_ = !0, this.serverType_ = t.serverType, this.hidpi_ = void 0 === t.hidpi || t.hidpi, this.tmpExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], this.updateV13_(), this.setKey(this.getKeyForParams_()) } getFeatureInfoUrl(t, e, i, n) { const r = Ui(i), s = this.getProjection(); let o = this.getTileGrid(); o || (o = this.getTileGridForProjection(r)); const a = o.getZForResolution(e, this.zDirection), l = o.getTileCoordForCoordAndZ(t, a); if (o.getResolutions().length <= l[0]) return; let h = o.getResolution(l[0]), c = o.getTileCoordExtent(l, this.tmpExtent_), u = Va(o.getTileSize(l[0]), this.tmpSize); const d = this.gutter_; 0 !== d && (u = Ua(u, d, this.tmpSize), c = Xt(c, h * d, c)), s && s !== r && (h = Gl(s, r, t, h), c = Ji(c, r, s), t = $i(t, r, s)); const g = { SERVICE: "WMS", VERSION: Sc, REQUEST: "GetFeatureInfo", FORMAT: "image/png", TRANSPARENT: !0, QUERY_LAYERS: this.params_.LAYERS }; Object.assign(g, this.params_, n); const f = Math.floor((t[0] - c[0]) / h), p = Math.floor((c[3] - t[1]) / h); return g[this.v13_ ? "I" : "X"] = f, g[this.v13_ ? "J" : "Y"] = p, this.getRequestUrl_(l, u, c, 1, s || r, g) } getLegendUrl(t, e) { if (void 0 === this.urls[0]) return; const i = { SERVICE: "WMS", VERSION: Sc, REQUEST: "GetLegendGraphic", FORMAT: "image/png" }; if (void 0 === e || void 0 === e.LAYER) { const t = this.params_.LAYERS; if (!(!Array.isArray(t) || 1 === t.length)) return; i.LAYER = t } if (void 0 !== t) { const e = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, n = 28e-5; i.SCALE = t * e / n } return Object.assign(i, e), vc(this.urls[0], i) } getGutter() { return this.gutter_ } getParams() { return this.params_ } getRequestUrl_(t, e, i, n, r, s) { const o = this.urls; if (!o) return; if (s.WIDTH = e[0], s.HEIGHT = e[1], s[this.v13_ ? "CRS" : "SRS"] = r.getCode(), "STYLES" in this.params_ || (s.STYLES = ""), 1 != n) switch (this.serverType_) { case "geoserver": const t = 90 * n + .5 | 0; "FORMAT_OPTIONS" in s ? s.FORMAT_OPTIONS += ";dpi:" + t : s.FORMAT_OPTIONS = "dpi:" + t; break; case "mapserver": s.MAP_RESOLUTION = 90 * n; break; case "carmentaserver": case "qgis": s.DPI = 90 * n; break; default: at(!1, 52) }const a = r.getAxisOrientation(), l = i; if (this.v13_ && "ne" == a.substr(0, 2)) { let t; t = i[0], l[0] = i[1], l[1] = t, t = i[2], l[2] = i[3], l[3] = t } let h; if (s.BBOX = l.join(","), 1 == o.length) h = o[0]; else { h = o[li(ol(t), o.length)] } return vc(h, s) } getTilePixelRatio(t) { return this.hidpi_ && void 0 !== this.serverType_ ? t : 1 } getKeyForParams_() { let t = 0; const e = []; for (const i in this.params_) e[t++] = i + "-" + this.params_[i]; return e.join("/") } updateParams(t) { Object.assign(this.params_, t), this.updateV13_(), this.setKey(this.getKeyForParams_()) } updateV13_() { const t = this.params_.VERSION || Sc; this.v13_ = pi(t, "1.3") >= 0 } tileUrlFunction(t, e, i) { let n = this.getTileGrid(); if (n || (n = this.getTileGridForProjection(i)), n.getResolutions().length <= t[0]) return; 1 == e || this.hidpi_ && void 0 !== this.serverType_ || (e = 1); const r = n.getResolution(t[0]); let s = n.getTileCoordExtent(t, this.tmpExtent_), o = Va(n.getTileSize(t[0]), this.tmpSize); const a = this.gutter_; 0 !== a && (o = Ua(o, a, this.tmpSize), s = Xt(s, r * a, s)), 1 != e && (o = Xa(o, e, this.tmpSize)); const l = { SERVICE: "WMS", VERSION: Sc, REQUEST: "GetMap", FORMAT: "image/png", TRANSPARENT: !0 }; return Object.assign(l, this.params_), this.getRequestUrl_(t, o, s, e, i, l) } }, _T.source.UTFGrid = class extends nh { constructor(t) { if (super({ projection: Ui("EPSG:3857"), state: "loading", zDirection: t.zDirection }), this.preemptive_ = void 0 === t.preemptive || t.preemptive, this.tileUrlFunction_ = lh, this.template_ = void 0, this.jsonp_ = t.jsonp || !1, t.url) if (this.jsonp_) vl(t.url, this.handleTileJSONResponse.bind(this), this.handleTileJSONError.bind(this)); else { const e = new XMLHttpRequest; e.addEventListener("load", this.onXHRLoad_.bind(this)), e.addEventListener("error", this.onXHRError_.bind(this)), e.open("GET", t.url), e.send() } else t.tileJSON ? this.handleTileJSONResponse(t.tileJSON) : at(!1, 51) } onXHRLoad_(t) { const e = t.target; if (!e.status || e.status >= 200 && e.status < 300) { let t; try { t = JSON.parse(e.responseText) } catch (t) { return void this.handleTileJSONError() } this.handleTileJSONResponse(t) } else this.handleTileJSONError() } onXHRError_(t) { this.handleTileJSONError() } getTemplate() { return this.template_ } forDataAtCoordinateAndResolution(t, e, i, n) { if (this.tileGrid) { const r = this.tileGrid.getZForResolution(e, this.zDirection), s = this.tileGrid.getTileCoordForCoordAndZ(t, r); this.getTile(s[0], s[1], s[2], 1, this.getProjection()).forDataAtCoordinate(t, i, n) } else !0 === n ? setTimeout((function () { i(null) }), 0) : i(null) } handleTileJSONError() { this.setState("error") } handleTileJSONResponse(t) { const e = Ui("EPSG:4326"), i = this.getProjection(); let n; if (void 0 !== t.bounds) { const r = qi(e, i); n = Re(t.bounds, r) } const r = ih(i), s = t.minzoom || 0, o = Ql({ extent: r, maxZoom: t.maxzoom || 22, minZoom: s }); this.tileGrid = o, this.template_ = t.template; const a = t.grids; if (a) { if (this.tileUrlFunction_ = oh(a, o), void 0 !== t.attribution) { const e = void 0 !== n ? n : r; this.setAttributions((function (i) { return we(e, i.extent) ? [t.attribution] : null })) } this.setState("ready") } else this.setState("error") } getTile(t, e, i, n, r) { const s = il(t, e, i); if (this.tileCache.containsKey(s)) return this.tileCache.get(s); { const o = [t, e, i], a = this.getTileCoordForTileUrlFunction(o, r), l = this.tileUrlFunction_(a, n, r), h = new Jc(o, void 0 !== l ? H : tt, void 0 !== l ? l : "", this.tileGrid.getTileCoordExtent(o), this.preemptive_, this.jsonp_); return this.tileCache.set(s, h), h } } useTile(t, e, i) { const n = il(t, e, i); this.tileCache.containsKey(n) && this.tileCache.get(n) } }, _T.source.UTFGrid.CustomTile = Jc, _T.source.UrlTile = ch, _T.source.Vector = zh, _T.source.Vector.VectorSourceEvent = Uh, _T.source.VectorTile = Qc, _T.source.VectorTile.defaultLoadFunction = tu, _T.source.WMTS = class extends uh { constructor(t) { const e = void 0 !== t.requestEncoding ? t.requestEncoding : "KVP", i = t.tileGrid; let n = t.urls; void 0 === n && void 0 !== t.url && (n = hh(t.url)), super({ attributions: t.attributions, attributionsCollapsible: t.attributionsCollapsible, cacheSize: t.cacheSize, crossOrigin: t.crossOrigin, interpolate: t.interpolate, projection: t.projection, reprojectionErrorThreshold: t.reprojectionErrorThreshold, tileClass: t.tileClass, tileGrid: i, tileLoadFunction: t.tileLoadFunction, tilePixelRatio: t.tilePixelRatio, urls: n, wrapX: void 0 !== t.wrapX && t.wrapX, transition: t.transition, zDirection: t.zDirection }), this.version_ = void 0 !== t.version ? t.version : "1.0.0", this.format_ = void 0 !== t.format ? t.format : "image/jpeg", this.dimensions_ = void 0 !== t.dimensions ? t.dimensions : {}, this.layer_ = t.layer, this.matrixSet_ = t.matrixSet, this.style_ = t.style, this.requestEncoding_ = e, this.setKey(this.getKeyForDimensions_()), n && n.length > 0 && (this.tileUrlFunction = ah(n.map(this.createFromWMTSTemplate.bind(this)))) } setUrls(t) { this.urls = t; const e = t.join("\n"); this.setTileUrlFunction(ah(t.map(this.createFromWMTSTemplate.bind(this))), e) } getDimensions() { return this.dimensions_ } getFormat() { return this.format_ } getLayer() { return this.layer_ } getMatrixSet() { return this.matrixSet_ } getRequestEncoding() { return this.requestEncoding_ } getStyle() { return this.style_ } getVersion() { return this.version_ } getKeyForDimensions_() { let t = 0; const e = []; for (const i in this.dimensions_) e[t++] = i + "-" + this.dimensions_[i]; return e.join("/") } updateDimensions(t) { Object.assign(this.dimensions_, t), this.setKey(this.getKeyForDimensions_()) } createFromWMTSTemplate(t) { const e = this.requestEncoding_, i = { layer: this.layer_, style: this.style_, tilematrixset: this.matrixSet_ }; "KVP" == e && Object.assign(i, { Service: "WMTS", Request: "GetTile", Version: this.version_, Format: this.format_ }), t = "KVP" == e ? vc(t, i) : t.replace(/\{(\w+?)\}/g, (function (t, e) { return e.toLowerCase() in i ? i[e.toLowerCase()] : t })); const n = this.tileGrid, r = this.dimensions_; return function (i, s, o) { if (i) { const s = { TileMatrix: n.getMatrixId(i[0]), TileCol: i[1], TileRow: i[2] }; Object.assign(s, r); let o = t; return o = "KVP" == e ? vc(o, s) : o.replace(/\{(\w+?)\}/g, (function (t, e) { return s[e] })), o } } } }, _T.source.WMTS.optionsFromCapabilities = function (t, e) { const i = t.Contents.Layer.find((function (t) { return t.Identifier == e.layer })); if (!i) return null; const n = t.Contents.TileMatrixSet; let r; r = i.TileMatrixSetLink.length > 1 ? "projection" in e ? i.TileMatrixSetLink.findIndex((function (t) { const i = n.find((function (e) { return e.Identifier == t.TileMatrixSet })).SupportedCRS, r = Ui(i), s = Ui(e.projection); return r && s ? Ki(r, s) : i == e.projection })) : i.TileMatrixSetLink.findIndex((function (t) { return t.TileMatrixSet == e.matrixSet })) : 0, r < 0 && (r = 0); const s = i.TileMatrixSetLink[r].TileMatrixSet, o = i.TileMatrixSetLink[r].TileMatrixSetLimits; let a = i.Format[0]; "format" in e && (a = e.format), r = i.Style.findIndex((function (t) { return "style" in e ? t.Title == e.style : t.isDefault })), r < 0 && (r = 0); const l = i.Style[r].Identifier, h = {}; "Dimension" in i && i.Dimension.forEach((function (t, e, i) { const n = t.Identifier; let r = t.Default; void 0 === r && (r = t.Value[0]), h[n] = r })); const c = t.Contents.TileMatrixSet.find((function (t) { return t.Identifier == s })); let u; const d = c.SupportedCRS; if (d && (u = Ui(d)), "projection" in e) { const t = Ui(e.projection); t && (u && !Ki(t, u) || (u = t)) } let g = !1; const f = "ne" == u.getAxisOrientation().substr(0, 2); let p = c.TileMatrix[0], m = { MinTileCol: 0, MinTileRow: 0, MaxTileCol: p.MatrixWidth - 1, MaxTileRow: p.MatrixHeight - 1 }; if (o) { m = o[o.length - 1]; const t = c.TileMatrix.find((t => t.Identifier === m.TileMatrix || c.Identifier + ":" + t.Identifier === m.TileMatrix)); t && (p = t) } const _ = 28e-5 * p.ScaleDenominator / u.getMetersPerUnit(), y = f ? [p.TopLeftCorner[1], p.TopLeftCorner[0]] : p.TopLeftCorner, x = p.TileWidth * _, v = p.TileHeight * _; let S = c.BoundingBox; S && f && (S = [S[1], S[0], S[3], S[2]]); let w = [y[0] + x * m.MinTileCol, y[1] - v * (1 + m.MaxTileRow), y[0] + x * (1 + m.MaxTileCol), y[1] - v * m.MinTileRow]; if (void 0 !== S && !Yt(S, w)) { const t = i.WGS84BoundingBox, e = Ui("EPSG:4326").getExtent(); if (w = S, t) g = t[0] === e[0] && t[2] === e[2]; else { const t = Ji(S, c.SupportedCRS, "EPSG:4326"); g = t[0] - 1e-10 <= e[0] && t[2] + 1e-10 >= e[2] } } const E = iu(c, w, o), T = []; let C = e.requestEncoding; if (C = void 0 !== C ? C : "", "OperationsMetadata" in t && "GetTile" in t.OperationsMetadata) { const e = t.OperationsMetadata.GetTile.DCP.HTTP.Get; for (let t = 0, i = e.length; t < i; ++t)if (e[t].Constraint) { const i = e[t].Constraint.find((function (t) { return "GetEncoding" == t.name })).AllowedValues.Value; if ("" === C && (C = i[0]), "KVP" !== C) break; i.includes("KVP") && T.push(e[t].href) } else e[t].href && (C = "KVP", T.push(e[t].href)) } return 0 === T.length && (C = "REST", i.ResourceURL.forEach((function (t) { "tile" === t.resourceType && (a = t.format, T.push(t.template)) }))), { urls: T, layer: e.layer, matrixSet: s, format: a, projection: u, requestEncoding: C, tileGrid: E, style: l, dimensions: h, wrapX: g, crossOrigin: e.crossOrigin } }, _T.source.XYZ = fh, _T.source.Zoomify = class extends uh { constructor(t) { const e = t.size, i = void 0 !== t.tierSizeCalculation ? t.tierSizeCalculation : "default", n = t.tilePixelRatio || 1, r = e[0], s = e[1], o = [], a = t.tileSize || Lo; let l = a * n; switch (i) { case "default": for (; r > l || s > l;)o.push([Math.ceil(r / l), Math.ceil(s / l)]), l += l; break; case "truncated": let t = r, e = s; for (; t > l || e > l;)o.push([Math.ceil(t / l), Math.ceil(e / l)]), t >>= 1, e >>= 1; break; default: at(!1, 53) }o.push([1, 1]), o.reverse(); const h = [n], c = [0]; for (let t = 1, e = o.length; t < e; t++)h.push(n << t), c.push(o[t - 1][0] * o[t - 1][1] + c[t - 1]); h.reverse(); const u = new ql({ tileSize: a, extent: t.extent || [0, -s, r, 0], resolutions: h }); let d = t.url; !d || d.includes("{TileGroup}") || d.includes("{tileIndex}") || (d += "{TileGroup}/{z}-{x}-{y}.jpg"); const g = hh(d); let f = a * n; const p = ah(g.map((function (t) { return function (e, i, n) { if (e) { const i = e[0], n = e[1], r = e[2], s = n + r * o[i][0], a = { z: i, x: n, y: r, tileIndex: s, TileGroup: "TileGroup" + ((s + c[i]) / f | 0) }; return t.replace(/\{(\w+?)\}/g, (function (t, e) { return a[e] })) } } }))), m = nc.bind(null, Va(a * n)); super({ attributions: t.attributions, cacheSize: t.cacheSize, crossOrigin: t.crossOrigin, interpolate: t.interpolate, projection: t.projection, tilePixelRatio: n, reprojectionErrorThreshold: t.reprojectionErrorThreshold, tileClass: m, tileGrid: u, tileUrlFunction: p, transition: t.transition }), this.zDirection = t.zDirection; const _ = p(u.getTileCoordForCoordAndResolution(ge(u.getExtent()), h[h.length - 1]), 1, null), y = new Image; y.addEventListener("error", function () { f = a, this.changed() }.bind(this)), y.src = _ } }, _T.source.Zoomify.CustomTile = nc, _T.source.common = {}, _T.source.common.DEFAULT_WMS_VERSION = "1.3.0", _T.source.ogcTileUtil = {}, _T.source.ogcTileUtil.getMapTileUrlTemplate = Tg, _T.source.ogcTileUtil.getTileSetInfo = Rg, _T.source.ogcTileUtil.getVectorTileUrlTemplate = Cg, _T.source.sourcesFromTileGrid = function (t, e) { const i = new tl(32), n = t.getExtent(); return function (r, s) { i.expireCache(), n && (r = ye(n, r)); const o = t.getZForResolution(s), a = []; return t.forEachTileCoord(r, o, (t => { const n = t.toString(); if (!i.containsKey(n)) { const r = e(t); i.set(n, r) } a.push(i.get(n)) })), a } }, _T.source.wms = {}, _T.source.wms.DEFAULT_VERSION = Sc, _T.sphere = {}, _T.sphere.DEFAULT_RADIUS = Li, _T.sphere.getArea = function t(e, i) { const n = (i = i || {}).radius || Li, r = i.projection || "EPSG:3857", s = e.getType(); "GeometryCollection" !== s && (e = e.clone().transform(r, "EPSG:4326")); let o, a, l, h, c, u, d = 0; switch (s) { case "Point": case "MultiPoint": case "LineString": case "MultiLineString": case "LinearRing": break; case "Polygon": for (o = e.getCoordinates(), d = Math.abs(Ai(o[0], n)), l = 1, h = o.length; l < h; ++l)d -= Math.abs(Ai(o[l], n)); break; case "MultiPolygon": for (o = e.getCoordinates(), l = 0, h = o.length; l < h; ++l)for (a = o[l], d += Math.abs(Ai(a[0], n)), c = 1, u = a.length; c < u; ++c)d -= Math.abs(Ai(a[c], n)); break; case "GeometryCollection": { const n = e.getGeometries(); for (l = 0, h = n.length; l < h; ++l)d += t(n[l], i); break } default: throw new Error("Unsupported geometry type: " + s) }return d }, _T.sphere.getDistance = Mi, _T.sphere.getLength = function t(e, i) { const n = (i = i || {}).radius || Li, r = i.projection || "EPSG:3857", s = e.getType(); "GeometryCollection" !== s && (e = e.clone().transform(r, "EPSG:4326")); let o, a, l, h, c, u, d = 0; switch (s) { case "Point": case "MultiPoint": break; case "LineString": case "LinearRing": o = e.getCoordinates(), d = Fi(o, n); break; case "MultiLineString": case "Polygon": for (o = e.getCoordinates(), l = 0, h = o.length; l < h; ++l)d += Fi(o[l], n); break; case "MultiPolygon": for (o = e.getCoordinates(), l = 0, h = o.length; l < h; ++l)for (a = o[l], c = 0, u = a.length; c < u; ++c)d += Fi(a[c], n); break; case "GeometryCollection": { const n = e.getGeometries(); for (l = 0, h = n.length; l < h; ++l)d += t(n[l], i); break } default: throw new Error("Unsupported geometry type: " + s) }return d }, _T.sphere.offset = Oi, _T.string = {}, _T.string.compareVersions = pi, _T.string.padNumber = fi, _T.structs = {}, _T.structs.LRUCache = tl, _T.structs.LinkedList = class { constructor(t) { this.first_, this.last_, this.head_, this.circular_ = void 0 === t || t, this.length_ = 0 } insertItem(t) { const e = { prev: void 0, next: void 0, data: t }, i = this.head_; if (i) { const t = i.next; e.prev = i, e.next = t, i.next = e, t && (t.prev = e), i === this.last_ && (this.last_ = e) } else this.first_ = e, this.last_ = e, this.circular_ && (e.next = e, e.prev = e); this.head_ = e, this.length_++ } removeItem() { const t = this.head_; if (t) { const e = t.next, i = t.prev; e && (e.prev = i), i && (i.next = e), this.head_ = e || i, this.first_ === this.last_ ? (this.head_ = void 0, this.first_ = void 0, this.last_ = void 0) : this.first_ === t ? this.first_ = this.head_ : this.last_ === t && (this.last_ = i ? this.head_.prev : this.head_), this.length_-- } } firstItem() { if (this.head_ = this.first_, this.head_) return this.head_.data } lastItem() { if (this.head_ = this.last_, this.head_) return this.head_.data } nextItem() { if (this.head_ && this.head_.next) return this.head_ = this.head_.next, this.head_.data } getNextItem() { if (this.head_ && this.head_.next) return this.head_.next.data } prevItem() { if (this.head_ && this.head_.prev) return this.head_ = this.head_.prev, this.head_.data } getPrevItem() { if (this.head_ && this.head_.prev) return this.head_.prev.data } getCurrItem() { if (this.head_) return this.head_.data } setFirstItem() { this.circular_ && this.head_ && (this.first_ = this.head_, this.last_ = this.head_.prev) } concat(t) { if (t.head_) { if (this.head_) { const e = this.head_.next; this.head_.next = t.first_, t.first_.prev = this.head_, e.prev = t.last_, t.last_.next = e, this.length_ += t.length_ } else this.head_ = t.head_, this.first_ = t.first_, this.last_ = t.last_, this.length_ = t.length_; t.head_ = void 0, t.first_ = void 0, t.last_ = void 0, t.length_ = 0 } } getLength() { return this.length_ } }, _T.structs.PriorityQueue = To, _T.structs.PriorityQueue.DROP = Eo, _T.structs.RBush = Ah, _T.style = {}, _T.style.Circle = ng, _T.style.Fill = rg, _T.style.Icon = lg, _T.style.IconImage = og, _T.style.IconImage.get = ag, _T.style.IconImageCache = es, _T.style.IconImageCache.shared = ns, _T.style.Image = eg, _T.style.RegularShape = ig, _T.style.Stroke = hg, _T.style.Style = cg, _T.style.Style.createDefaultStyle = gg, _T.style.Style.createEditingStyle = fg, _T.style.Style.toFunction = ug, _T.style.Text = mg, _T.style.expressions = {}, _T.style.expressions.Operators = Ld, _T.style.expressions.PALETTE_TEXTURE_ARRAY = qd, _T.style.expressions.arrayToGlsl = Od, _T.style.expressions.colorToGlsl = Nd, _T.style.expressions.expressionToGlsl = Gd, _T.style.expressions.getStringNumberEquivalent = Dd, _T.style.expressions.getValueType = Md, _T.style.expressions.isTypeUnique = Fd, _T.style.expressions.numberToGlsl = Ad, _T.style.expressions.stringToGlsl = kd, _T.style.expressions.uniformNameForVariable = Kd, _T.style.flat = {}, _T.style.flat.toStyle = _g, _T.tilecoord = {}, _T.tilecoord.createOrUpdate = el, _T.tilecoord.fromKey = sl, _T.tilecoord.getCacheKeyForTileKey = rl, _T.tilecoord.getKey = nl, _T.tilecoord.getKeyZXY = il, _T.tilecoord.hash = ol, _T.tilecoord.withinExtentAndZ = al, _T.tilegrid = {}, _T.tilegrid.TileGrid = ql, _T.tilegrid.WMTS = eu, _T.tilegrid.WMTS.createFromCapabilitiesMatrixSet = iu, _T.tilegrid.common = {}, _T.tilegrid.common.DEFAULT_MAX_ZOOM = 42, _T.tilegrid.common.DEFAULT_TILE_SIZE = Lo, _T.tilegrid.createForExtent = Jl, _T.tilegrid.createForProjection = eh, _T.tilegrid.createXYZ = Ql, _T.tilegrid.extentFromProjection = ih, _T.tilegrid.getForProjection = Hl, _T.tilegrid.wrapX = $l, _T.tileurlfunction = {}, _T.tileurlfunction.createFromTemplate = sh, _T.tileurlfunction.createFromTemplates = oh, _T.tileurlfunction.createFromTileUrlFunctions = ah, _T.tileurlfunction.expandUrl = hh, _T.tileurlfunction.nullTileUrlFunction = lh, _T.transform = {}, _T.transform.apply = bt, _T.transform.compose = Mt, _T.transform.composeCssTransform = function (t, e, i, n, r, s, o) { return Nt(Mt([1, 0, 0, 1, 0, 0], t, e, i, n, r, s, o)) }, _T.transform.create = St, _T.transform.determinant = At, _T.transform.invert = function (t) { return Ft(t, t) }, _T.transform.makeInverse = Ft, _T.transform.makeScale = It, _T.transform.multiply = Et, _T.transform.reset = wt, _T.transform.rotate = Rt, _T.transform.scale = Pt, _T.transform.set = Tt, _T.transform.setFromArray = Ct, _T.transform.toString = Nt, _T.transform.translate = Lt, _T.uri = {}, _T.uri.appendParams = vc, _T.util = {}, _T.util.VERSION = "latest", _T.util.abstract = B, _T.util.getUid = z, _T.vec = {}, _T.vec.mat4 = {}, _T.vec.mat4.create = Xu, _T.vec.mat4.fromTransform = Vu, _T.webgl = {}, _T.webgl.ARRAY_BUFFER = nu, _T.webgl.Buffer = Gu, _T.webgl.Buffer.getArrayClassForType = ju, _T.webgl.DYNAMIC_DRAW = ou, _T.webgl.ELEMENT_ARRAY_BUFFER = ru, _T.webgl.FLOAT = au, _T.webgl.Helper = nd, _T.webgl.Helper.computeAttributesStride = rd, _T.webgl.PaletteTexture = od, _T.webgl.PostProcessingPass = zu, _T.webgl.RenderTarget = ld, _T.webgl.STATIC_DRAW = su, _T.webgl.STREAM_DRAW = 35040, _T.webgl.ShaderBuilder = {}, _T.webgl.ShaderBuilder.ShaderBuilder = Qd, _T.webgl.ShaderBuilder.parseLiteralStyle = tg, _T.webgl.TileTexture = dd, _T.webgl.UNSIGNED_BYTE = 5121, _T.webgl.UNSIGNED_INT = 5125, _T.webgl.UNSIGNED_SHORT = 5123, _T.webgl.getContext = hu, _T.webgl.getSupportedExtensions = function () { if (!cu) { const t = hu(document.createElement("canvas")); t && (cu = t.getSupportedExtensions()) } return cu }, _T.xml = {}, _T.xml.OBJECT_PROPERTY_NODE_FACTORY = bu, _T.xml.XML_SCHEMA_INSTANCE_URI = uu, _T.xml.createElementNS = du, _T.xml.getAllTextContent = gu, _T.xml.getAllTextContent_ = fu, _T.xml.getAttributeNS = mu, _T.xml.getDocument = Du, _T.xml.getXMLSerializer = Nu, _T.xml.isDocument = pu, _T.xml.makeArrayExtender = yu, _T.xml.makeArrayPusher = xu, _T.xml.makeArraySerializer = Tu, _T.xml.makeChildAppender = Eu, _T.xml.makeObjectPropertyPusher = Su, _T.xml.makeObjectPropertySetter = wu, _T.xml.makeReplacer = vu, _T.xml.makeSequence = Ru, _T.xml.makeSimpleNodeFactory = Cu, _T.xml.makeStructureNS = Pu, _T.xml.parse = _u, _T.xml.parseNode = Iu, _T.xml.pushParseAndPop = Lu, _T.xml.pushSerializeAndPop = Fu, _T.xml.registerDocument = function (t) { Ou = t }, _T.xml.registerXMLSerializer = function (t) { Au = t }, _T.xml.serialize = Mu, _T
}();
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('ol/style'), require('ol/render'), require('ol/geom'), require('ol/extent'), require('ol/has')) :
        typeof define === 'function' && define.amd ? define(['exports', 'ol/style', 'ol/render', 'ol/geom', 'ol/extent', 'ol/has'], factory) :
            (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.SLDReader = {}, global.ol.style, global.ol.render, global.ol.geom, global.ol.extent, global.ol.has));
})(this, (function (exports, style, render, geom, extent, has) {
    'use strict';

    /**
     * Bron: https://github.com/NieuwlandGeo/SLDReader
     */

    /**
     * Factory methods for filterelements
     * @see http://schemas.opengis.net/filter/1.0.0/filter.xsd
     *
     * @module
     */

    var TYPE_COMPARISON = 'comparison';

    /**
     * @var string[] element names of binary comparison
     * @private
     */
    var BINARY_COMPARISON_NAMES = [
        'PropertyIsEqualTo',
        'PropertyIsNotEqualTo',
        'PropertyIsLessThan',
        'PropertyIsLessThanOrEqualTo',
        'PropertyIsGreaterThan',
        'PropertyIsGreaterThanOrEqualTo'];

    var COMPARISON_NAMES = BINARY_COMPARISON_NAMES.concat([
        'PropertyIsLike',
        'PropertyIsNull',
        'PropertyIsBetween']);

    /**
     * @private
     * @param {string} localName
     *
     * @return null|string
     */
    function getChildTextContent(node, localName) {
        var propertyNameElement = node
            .getElementsByTagNameNS(node.namespaceURI, localName)
            .item(0);
        if (!propertyNameElement) {
            return null;
        }
        if (propertyNameElement.parentNode !== node) {
            throw new Error('Expected direct descant');
        }
        return propertyNameElement ? propertyNameElement.textContent.trim() : null;
    }

    function isComparison(element) {
        return COMPARISON_NAMES.includes(element.localName);
    }

    function isBinary(element) {
        return ['or', 'and'].includes(element.localName.toLowerCase());
    }

    /**
     * factory for comparisonOps
     * @private
     * @param {Element} element
     *
     * @return {object}
     */
    function createComparison(element) {
        if (BINARY_COMPARISON_NAMES.includes(element.localName)) {
            return createBinaryFilterComparison(element);
        }
        if (element.localName === 'PropertyIsBetween') {
            return createIsBetweenComparison(element);
        }
        if (element.localName === 'PropertyIsNull') {
            return createIsNullComparison(element);
        }
        if (element.localName === 'PropertyIsLike') {
            return createIsLikeComparison(element);
        }
        throw new Error(("Unknown comparison element " + (element.localName)));
    }

    /**
     * factory for element type BinaryComparisonOpType
     * @private
     * @param {Element} element
     *
     * @return {object}
     */
    function createBinaryFilterComparison(element) {
        var propertyname = getChildTextContent(element, 'PropertyName');
        var literal = getChildTextContent(element, 'Literal');

        return {
            type: TYPE_COMPARISON,
            operator: element.localName.toLowerCase(),
            propertyname: propertyname,
            literal: literal,
            // Match case attribute is true by default, so only make it false if the attribute value equals 'false'.
            matchcase: element.getAttribute('matchCase') !== 'false',
        };
    }

    /**
     * factory for element type PropertyIsLikeType
     * @private
     * @param {Element} element
     *
     * @return {object}
     */
    function createIsLikeComparison(element) {
        var propertyname = getChildTextContent(element, 'PropertyName');
        var literal = getChildTextContent(element, 'Literal');

        return {
            type: TYPE_COMPARISON,
            operator: element.localName.toLowerCase(),
            propertyname: propertyname,
            literal: literal,
            wildcard: element.getAttribute('wildCard'),
            singlechar: element.getAttribute('singleChar'),
            escapechar: element.getAttribute('escapeChar'),
            // Match case attribute is true by default, so only make it false if the attribute value equals 'false'.
            matchcase: element.getAttribute('matchCase') !== 'false',
        };
    }
    /**
     * factory for element type PropertyIsNullType
     * @private
     * @param {Element} element
     *
     * @return {object}
     */
    function createIsNullComparison(element) {
        var propertyname = getChildTextContent(element, 'PropertyName');

        return {
            type: TYPE_COMPARISON,
            operator: element.localName.toLowerCase(),
            propertyname: propertyname,
        };
    }
    /**
     * factory for element type PropertyIsBetweenType
     * @private
     * @param {Element} element
     *
     * @return {object}
     */
    function createIsBetweenComparison(element) {
        var propertyname = getChildTextContent(element, 'PropertyName');
        var lowerboundary = getChildTextContent(element, 'LowerBoundary');
        var upperboundary = getChildTextContent(element, 'UpperBoundary');
        return {
            type: TYPE_COMPARISON,
            operator: element.localName.toLowerCase(),
            lowerboundary: lowerboundary,
            upperboundary: upperboundary,
            propertyname: propertyname,
            // Match case attribute is true by default, so only make it false if the attribute value equals 'false'.
            matchcase: element.getAttribute('matchCase') !== 'false',
        };
    }

    /**
     * Factory for and/or filter
     * @private
     * @param {Element} element
     *
     * @return {object}
     */
    function createBinaryLogic(element) {
        var predicates = [];
        for (var n = element.firstElementChild; n; n = n.nextElementSibling) {
            if (isComparison(n)) {
                predicates.push(createComparison(n));
            }
        }
        return {
            type: element.localName.toLowerCase(),
            predicates: predicates,
        };
    }

    /**
     * Factory for not filter
     * @private
     * @param {Element} element
     *
     * @return {object}
     */
    function createUnaryLogic(element) {
        var predicate = null;
        var childElement = element.firstElementChild;
        if (childElement && isComparison(childElement)) {
            predicate = createComparison(childElement);
        }
        if (childElement && isBinary(childElement)) {
            predicate = createBinaryLogic(childElement);
        }
        return {
            type: element.localName.toLowerCase(),
            predicate: predicate,
        };
    }

    /**
     * Factory root filter element
     * @param {Element} element
     *
     * @return {Filter}
     */
    function createFilter(element) {
        var filter = {};
        for (var n = element.firstElementChild; n; n = n.nextElementSibling) {
            if (isComparison(n)) {
                filter = createComparison(n);
            }
            if (isBinary(n)) {
                filter = createBinaryLogic(n);
            }
            if (n.localName.toLowerCase() === 'not') {
                filter = createUnaryLogic(n);
            }
            if (n.localName.toLowerCase() === 'featureid') {
                filter.type = 'featureid';
                filter.fids = filter.fids || [];
                filter.fids.push(n.getAttribute('fid'));
            }
        }
        return filter;
    }

    /**
     * A filter predicate.
     * @typedef Filter
     * @name Filter
     * @description [filter operators](http://schemas.opengis.net/filter/1.1.0/filter.xsd), see also
     * [geoserver](http://docs.geoserver.org/stable/en/user/styling/sld/reference/filters.html)
     * @property {string} type Can be 'comparison', 'and', 'or', 'not', or 'featureid'.
     * @property {Array<string>} [fids] An array of feature id's. Required for type='featureid'.
     * @property {string} [operator] Required for type='comparison'. Can be one of
     * 'propertyisequalto',
     * 'propertyisnotequalto',
     * 'propertyislessthan',
     * 'propertyislessthanorequalto',
     * 'propertyisgreaterthan',
     * 'propertyisgreaterthanorequalto',
     * 'propertyislike',
     * 'propertyisbetween'
     * @property {Filter[]} [predicates] Required for type='and' or type='or'.
     * An array of filter predicates that must all evaluate to true for 'and', or
     * for which at least one must evaluate to true for 'or'.
     * @property {Filter} [predicate] Required for type='not'. A single predicate to negate.
     * @property {string} [propertyname] Required for type='comparison'.
     * @property {string} [literal] A literal value to use in a comparison,
     * required for type='comparison'.
     * @property {string} [lowerboundary] Lower boundary, required for operator='propertyisbetween'.
     * @property {string} [upperboundary] Upper boundary, required for operator='propertyisbetween'.
     * @property {string} [wildcard] Required wildcard character for operator='propertyislike'.
     * @property {string} [singlechar] Required single char match character,
     * required for operator='propertyislike'.
     * @property {string} [escapechar] Required escape character for operator='propertyislike'.
     */

    /**
     * @module
     */

    /**
     * Generic parser for elements with maxOccurs > 1
     * it pushes result of readNode(node) to array on obj[prop]
     * @private
     * @param {Element} node the xml element to parse
     * @param {object} obj  the object to modify
     * @param {string} prop key on obj to hold array
     */
    function addPropArray(node, obj, prop) {
        var property = prop.toLowerCase();
        obj[property] = obj[property] || [];
        var item = {};
        readNode(node, item);
        obj[property].push(item);
    }

    /**
     * Generic parser for elements that can be arrays
     * @private
     * @param {Element} node the xml element to parse
     * @param {object|Array} obj  the object or array to modify
     * @param {string} prop key on obj to hold array
     */
    function addPropOrArray(node, obj, prop) {
        var property = prop.toLowerCase();
        var item = {};
        readNode(node, item);
        if (!(property in obj)) {
            obj[property] = item;
        } else if (Array.isArray(obj[property])) {
            obj[property].push(item);
        } else {
            obj[property] = [obj[property], item];
        }
    }

    /**
     * Generic parser for maxOccurs = 1 (the xsd default)
     * it sets result of readNode(node) to array on obj[prop]
     * @private
     * @param {Element} node the xml element to parse
     * @param {object} obj  the object to modify
     * @param {string} prop key on obj to hold empty object
     */
    function addProp(node, obj, prop) {
        var property = prop.toLowerCase();
        obj[property] = {};
        readNode(node, obj[property]);
    }

    /**
     * Assigns textcontent to obj.prop
     * @private
     * @param {Element} node [description]
     * @param {object} obj  [description]
     * @param {string} prop [description]
     * @param {bool} [trimText] Trim whitespace from text content (default false).
     */
    function addPropWithTextContent(node, obj, prop, trimText) {
        if (trimText === void 0) trimText = false;

        var property = prop.toLowerCase();
        if (trimText) {
            obj[property] = node.textContent.trim();
        } else {
            obj[property] = node.textContent;
        }
    }

    /**
     * Assigns numeric value of text content to obj.prop.
     * Assigns NaN if the text value is not a valid text representation of a floating point number.
     * @private
     * @param {Element} node The XML node element.
     * @param {object} obj  The object to add the element value to.
     * @param {string} prop The property name.
     */
    function addNumericProp(node, obj, prop) {
        var property = prop.toLowerCase();
        var value = parseFloat(node.textContent.trim());
        obj[property] = value;
    }

    /**
     * This function parses SLD XML nodes that can contain an SLD filter expression.
     * If the SLD node contains only text elements, the result will be concatenated into a string.
     * If the SLD node contains one or more non-literal nodes (for now, only PropertyName), the result
     * will be an object with type:"expression" and an array of child nodes of which one or more have
     * the type "propertyname".
     *
     * Functions and arithmetic operators (Add,Sub,Mul,Div) are not supported (yet).
     * Note: for now, only these contents will be parsed:
     * * Plain text nodes.
     * * CDATA sections.
     * * ogc:PropertyName elements (property name will be parsed as trimmed text).
     * * ogc:Literal elements (contents will be parsed as trimmed text).
     * See also:
     * * http://schemas.opengis.net/filter/1.1.0/expr.xsd
     * * https://docs.geoserver.org/stable/en/user/styling/sld/reference/filters.html#sld-filter-expression
     * @private
     * @param {Element} node XML Node.
     * @param {object} obj Object to add XML node contents to.
     * @param {string} prop Property name on obj that will hold the parsed node contents.
     * @param {bool} [skipEmptyNodes] Default true. If true, emtpy (whitespace-only) text nodes will me omitted in the result.
     */
    function addFilterExpressionProp(node, obj, prop, skipEmptyNodes) {
        if (skipEmptyNodes === void 0) skipEmptyNodes = true;

        var childExpressions = [];

        for (var k = 0; k < node.childNodes.length; k += 1) {
            var childNode = node.childNodes[k];
            var childExpression = {};
            if (
                childNode.namespaceURI === 'http://www.opengis.net/ogc' &&
                childNode.localName === 'PropertyName'
            ) {
                // Add ogc:PropertyName elements as type:propertyname.
                childExpression.type = 'propertyname';
                childExpression.value = childNode.textContent.trim();
            } else if (childNode.nodeName === '#cdata-section') {
                // Add CDATA section text content untrimmed.
                childExpression.type = 'literal';
                childExpression.value = childNode.textContent;
            } else {
                // Add ogc:Literal elements and plain text nodes as type:literal.
                childExpression.type = 'literal';
                childExpression.value = childNode.textContent.trim();
            }

            if (childExpression.type === 'literal' && skipEmptyNodes) {
                if (childExpression.value.trim()) {
                    childExpressions.push(childExpression);
                }
            } else {
                childExpressions.push(childExpression);
            }
        }

        var property = prop.toLowerCase();

        // If expression children are all literals, concatenate them into a string.
        var allLiteral = childExpressions.every(
            function (childExpression) { return childExpression.type === 'literal'; }
        );

        if (allLiteral) {
            obj[property] = childExpressions
                .map(function (expression) { return expression.value; })
                .join('');
        } else {
            obj[property] = {
                type: 'expression',
                children: childExpressions,
            };
        }
    }

    /**
     * recieves boolean of element with tagName
     * @private
     * @param  {Element} element [description]
     * @param  {string} tagName [description]
     * @return {boolean}
     */
    function getBool(element, tagName) {
        var collection = element.getElementsByTagNameNS(
            'http://www.opengis.net/sld',
            tagName
        );
        if (collection.length) {
            return Boolean(collection.item(0).textContent);
        }
        return false;
    }

    /**
     * css and svg params
     * @private
     * @param  {Element} element
     * @param  {object} obj
     * @param  {String} prop
     */
    function parameters(element, obj, prop) {
        var propnames = {
            CssParameter: 'styling',
            SvgParameter: 'styling',
            VendorOption: 'vendoroption',
        };
        var propname = propnames[prop] || 'styling';
        obj[propname] = obj[propname] || {};
        var name = element
            .getAttribute('name')
            .toLowerCase()
            .replace(/-(.)/g, function (match, group1) { return group1.toUpperCase(); });
        obj[propname][name] = element.textContent.trim();
    }

    var FilterParsers = {
        Filter: function (element, obj) {
            obj.filter = createFilter(element);
        },
        ElseFilter: function (element, obj) {
            obj.elsefilter = true;
        },
    };

    var SymbParsers = {
        PolygonSymbolizer: addPropOrArray,
        LineSymbolizer: addPropOrArray,
        PointSymbolizer: addPropOrArray,
        TextSymbolizer: addPropOrArray,
        Fill: addProp,
        Stroke: addProp,
        GraphicStroke: addProp,
        GraphicFill: addProp,
        Graphic: addProp,
        ExternalGraphic: addProp,
        Gap: addNumericProp,
        InitialGap: addNumericProp,
        Mark: addProp,
        Label: function (node, obj, prop) { return addFilterExpressionProp(node, obj, prop, false); },
        Halo: addProp,
        Font: addProp,
        Radius: addPropWithTextContent,
        LabelPlacement: addProp,
        PointPlacement: addProp,
        LinePlacement: addProp,
        PerpendicularOffset: addPropWithTextContent,
        AnchorPoint: addProp,
        AnchorPointX: addPropWithTextContent,
        AnchorPointY: addPropWithTextContent,
        Opacity: addFilterExpressionProp,
        Rotation: addFilterExpressionProp,
        Displacement: addProp,
        DisplacementX: addPropWithTextContent,
        DisplacementY: addPropWithTextContent,
        Size: addFilterExpressionProp,
        WellKnownName: addPropWithTextContent,
        VendorOption: parameters,
        OnlineResource: function (element, obj) {
            obj.onlineresource = element.getAttribute('xlink:href');
        },
        CssParameter: parameters,
        SvgParameter: parameters,
    };

    /**
     * Each propname is a tag in the sld that should be converted to plain object
     * @private
     * @type {Object}
     */
    var parsers = Object.assign({}, {
        NamedLayer: function (element, obj) {
            addPropArray(element, obj, 'layers');
        },
        UserLayer: function (element, obj) {
            addPropArray(element, obj, 'layers');
        },
        UserStyle: function (element, obj) {
            obj.styles = obj.styles || [];
            var style = {
                default: getBool(element, 'IsDefault'),
                featuretypestyles: [],
            };
            readNode(element, style);
            obj.styles.push(style);
        },
        FeatureTypeStyle: function (element, obj) {
            obj.featuretypestyle = obj.featuretypestyle || [];
            var featuretypestyle = {
                rules: [],
            };
            readNode(element, featuretypestyle);
            obj.featuretypestyles.push(featuretypestyle);
        },
        Rule: function (element, obj) {
            var rule = {};
            readNode(element, rule);
            obj.rules.push(rule);
        },
        Name: addPropWithTextContent,
        Title: addPropWithTextContent,
        Abstract: addPropWithTextContent,
        MaxScaleDenominator: addPropWithTextContent,
        MinScaleDenominator: addPropWithTextContent
    },
        FilterParsers,
        SymbParsers);

    /**
     * walks over xml nodes
     * @private
     * @param  {Element} node derived from xml
     * @param  {object} obj recieves results
     * @return {void}
     */
    function readNode(node, obj) {
        for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
            if (parsers[n.localName]) {
                parsers[n.localName](n, obj, n.localName);
            }
        }
    }

    /**
     * Creates a object from an sld xml string,
     * @param  {string} sld xml string
     * @return {StyledLayerDescriptor}  object representing sld style
     */
    function Reader(sld) {
        var result = {};
        var parser = new DOMParser();
        var doc = parser.parseFromString(sld, 'application/xml');

        for (var n = doc.firstChild; n; n = n.nextSibling) {
            result.version = n.getAttribute('version');
            readNode(n, result);
        }
        return result;
    }

    /**
     * @typedef StyledLayerDescriptor
     * @name StyledLayerDescriptor
     * @description a typedef for StyledLayerDescriptor {@link http://schemas.opengis.net/sld/1.1/StyledLayerDescriptor.xsd xsd}
     * @property {string} version sld version
     * @property {Layer[]} layers info extracted from NamedLayer element
     */

    /**
     * @typedef Layer
     * @name Layer
     * @description a typedef for Layer, the actual style object for a single layer
     * @property {string} name layer name
     * @property {Object[]} styles See explanation at [Geoserver docs](http://docs.geoserver.org/stable/en/user/styling/sld/reference/styles.html)
     * @property {Boolean} styles[].default
     * @property {String} [styles[].name]
     * @property {FeatureTypeStyle[]} styles[].featuretypestyles Geoserver will draw multiple,
     * libraries as openlayers can only use one definition!
     */

    /**
     * @typedef FeatureTypeStyle
     * @name FeatureTypeStyle
     * @description a typedef for FeatureTypeStyle: {@link http://schemas.opengis.net/se/1.1.0/FeatureStyle.xsd xsd}
     * @property {Rule[]} rules
     */

    /**
     * @typedef Rule
     * @name Rule
     * @description a typedef for Rule to match a feature: {@link http://schemas.opengis.net/se/1.1.0/FeatureStyle.xsd xsd}
     * @property {string} name rule name
     * @property {Filter[]} [filter]
     * @property {boolean} [elsefilter]
     * @property {integer} [minscaledenominator]
     * @property {integer} [maxscaledenominator]
     * @property {PolygonSymbolizer} [polygonsymbolizer]
     * @property {LineSymbolizer}  [linesymbolizer]
     * @property {PointSymbolizer} [pointsymbolizer]
     * */

    /**
     * @typedef PolygonSymbolizer
     * @name PolygonSymbolizer
     * @description a typedef for [PolygonSymbolizer](http://schemas.opengis.net/se/1.1.0/Symbolizer.xsd), see also
     * [geoserver docs](http://docs.geoserver.org/stable/en/user/styling/sld/reference/polygonsymbolizer.html)
     * @property {Object} fill
     * @property {array} fill.css one object per CssParameter with props name (camelcased) & value
     * @property {Object} stroke
     * @property {Object[]} stroke.css with camelcased name & value
     * */

    /**
     * @typedef LineSymbolizer
     * @name LineSymbolizer
     * @description a typedef for [LineSymbolizer](http://schemas.opengis.net/se/1.1.0/Symbolizer.xsd), see also
     * [geoserver docs](http://docs.geoserver.org/stable/en/user/styling/sld/reference/linesymbolizer.html#sld-reference-linesymbolizer)
     * @property {Object} stroke
     * @property {Object[]} stroke.css one object per CssParameter with props name (camelcased) & value
     * @property {Object} graphicstroke
     * @property {Object} graphicstroke.graphic
     * @property {Object} graphicstroke.graphic.mark
     * @property {string} graphicstroke.graphic.mark.wellknownname
     * @property {Object} graphicstroke.graphic.mark.fill
     * @property {Object} graphicstroke.graphic.mark.stroke
     * @property {Number} graphicstroke.graphic.opacity
     * @property {Number} graphicstroke.graphic.size
     * @property {Number} graphicstroke.graphic.rotation
     * */

    /**
     * @typedef PointSymbolizer
     * @name PointSymbolizer
     * @description a typedef for PointSymbolizer [xsd](http://schemas.opengis.net/se/1.1.0/Symbolizer.xsd)
     * & [geoserver docs](http://docs.geoserver.org/latest/en/user/styling/sld/reference/pointsymbolizer.html)
     * @property {Object} graphic
     * @property {Object} graphic.externalgraphic
     * @property {string} graphic.externalgraphic.onlineresource
     * @property {Object} graphic.mark
     * @property {string} graphic.mark.wellknownname
     * @property {Object} graphic.mark.fill
     * @property {Object} graphic.mark.stroke
     * @property {Number} graphic.opacity
     * @property {Number} graphic.size
     * @property {Number} graphic.rotation
     * */

    function isNullOrUndefined(value) {
        /* eslint-disable-next-line eqeqeq */
        return value == null;
    }

    function compareNumbers(a, b) {
        if (a < b) {
            return -1;
        }
        if (a === b) {
            return 0;
        }
        return 1;
    }

    function toNumber(text) {
        if (text === '') {
            return NaN;
        }
        return Number(text);
    }

    function compare(a, b, matchcase) {
        var aNumber = toNumber(a);
        var bNumber = toNumber(b);
        if (!(Number.isNaN(aNumber) || Number.isNaN(bNumber))) {
            return compareNumbers(aNumber, bNumber);
        }

        // If a and/or b is non-numeric, compare both values as strings.
        var aString = a.toString();
        var bString = b.toString();

        // Note: using locale compare with sensitivity option fails the CI test, while it works on my PC.
        // So, case insensitive comparison is done in a more brute-force way by using lower case comparison.
        // Original method:
        // const caseSensitiveCollator = new Intl.Collator(undefined, { sensitivity: 'case' });
        // caseSensitiveCollator.compare(string1, string2);
        if (matchcase) {
            return aString.localeCompare(bString);
        }

        return aString.toLowerCase().localeCompare(bString.toLowerCase());
    }

    function propertyIsLessThan(comparison, value) {
        if (isNullOrUndefined(value)) {
            return false;
        }

        if (isNullOrUndefined(comparison.literal)) {
            return false;
        }

        return compare(value, comparison.literal) < 0;
    }

    function propertyIsGreaterThan(comparison, value) {
        if (isNullOrUndefined(value)) {
            return false;
        }

        if (isNullOrUndefined(comparison.literal)) {
            return false;
        }

        return compare(value, comparison.literal) > 0;
    }

    function propertyIsBetween(comparison, value) {
        if (isNullOrUndefined(value)) {
            return false;
        }

        var lowerBoundary = comparison.lowerboundary;
        if (isNullOrUndefined(lowerBoundary)) {
            return false;
        }

        var upperBoundary = comparison.upperboundary;
        if (isNullOrUndefined(upperBoundary)) {
            return false;
        }

        return (
            compare(lowerBoundary, value) <= 0 && compare(upperBoundary, value) >= 0
        );
    }

    function propertyIsEqualTo(comparison, value) {
        if (isNullOrUndefined(value)) {
            return false;
        }

        if (isNullOrUndefined(comparison.literal)) {
            return false;
        }

        if (!comparison.matchcase) {
            return compare(comparison.literal, value, false) === 0;
        }

        /* eslint-disable-next-line eqeqeq */
        return value == comparison.literal;
    }

    // Watch out! Null-ish values should not pass propertyIsNotEqualTo,
    // just like in databases.
    // This means that PropertyIsNotEqualTo is not the same as NOT(PropertyIsEqualTo).
    function propertyIsNotEqualTo(comparison, value) {
        if (isNullOrUndefined(value)) {
            return false;
        }

        return !propertyIsEqualTo(comparison, value);
    }

    /**
     * A very basic implementation of a PropertyIsLike by converting match pattern to a regex.
     * @private
     * @param {object} comparison filter object for operator 'propertyislike'
     * @param {string|number} value Feature property value.
     * @param {object} getProperty A function with parameters (feature, propertyName) to extract
     * the value of a property from a feature.
     */
    function propertyIsLike(comparison, value) {
        var pattern = comparison.literal;

        if (isNullOrUndefined(value)) {
            return false;
        }

        // Create regex string from match pattern.
        var wildcard = comparison.wildcard;
        var singlechar = comparison.singlechar;
        var escapechar = comparison.escapechar;
        var matchcase = comparison.matchcase;

        // Replace wildcard by '.*'
        var patternAsRegex = pattern.replace(new RegExp(("[" + wildcard + "]"), 'g'), '.*');

        // Replace single char match by '.'
        patternAsRegex = patternAsRegex.replace(
            new RegExp(("[" + singlechar + "]"), 'g'),
            '.'
        );

        // Replace escape char by '\' if escape char is not already '\'.
        if (escapechar !== '\\') {
            patternAsRegex = patternAsRegex.replace(
                new RegExp(("[" + escapechar + "]"), 'g'),
                '\\'
            );
        }

        // Bookend the regular expression.
        patternAsRegex = "^" + patternAsRegex + "$";

        var rex =
            matchcase === false
                ? new RegExp(patternAsRegex, 'i')
                : new RegExp(patternAsRegex);
        return rex.test(value);
    }

    /**
     * Test feature properties against a comparison filter.
     * @private
     * @param  {Filter} comparison A comparison filter object.
     * @param  {object} feature A feature object.
     * @param  {Function} getProperty A function with parameters (feature, propertyName)
     * to extract a single property value from a feature.
     * @return {bool}  does feature fullfill comparison
     */
    function doComparison(comparison, feature, getProperty) {
        var value = getProperty(feature, comparison.propertyname);

        switch (comparison.operator) {
            case 'propertyislessthan':
                return propertyIsLessThan(comparison, value);
            case 'propertyisequalto':
                return propertyIsEqualTo(comparison, value);
            case 'propertyislessthanorequalto':
                return (
                    propertyIsEqualTo(comparison, value) ||
                    propertyIsLessThan(comparison, value)
                );
            case 'propertyisnotequalto':
                return propertyIsNotEqualTo(comparison, value);
            case 'propertyisgreaterthan':
                return propertyIsGreaterThan(comparison, value);
            case 'propertyisgreaterthanorequalto':
                return (
                    propertyIsEqualTo(comparison, value) ||
                    propertyIsGreaterThan(comparison, value)
                );
            case 'propertyisbetween':
                return propertyIsBetween(comparison, value);
            case 'propertyisnull':
                return isNullOrUndefined(value);
            case 'propertyislike':
                return propertyIsLike(comparison, value);
            default:
                throw new Error(("Unkown comparison operator " + (comparison.operator)));
        }
    }

    function doFIDFilter(fids, featureId) {
        for (var i = 0; i < fids.length; i += 1) {
            if (fids[i] === featureId) {
                return true;
            }
        }

        return false;
    }

    /**
     * @private
     * Get feature properties from a GeoJSON feature.
     * @param {object} feature GeoJSON feature.
     * @returns {object} Feature properties.
     *
     */
    function getGeoJSONProperty(feature, propertyName) {
        return feature.properties[propertyName];
    }

    /**
     * @private
     * Gets feature id from a GeoJSON feature.
     * @param {object} feature GeoJSON feature.
     * @returns {number|string} Feature ID.
     */
    function getGeoJSONFeatureId(feature) {
        return feature.id;
    }

    /**
     * Calls functions from Filter object to test if feature passes filter.
     * Functions are called with filter part they match and feature.
     * @private
     * @param  {Filter} filter
     * @param  {object} feature feature
     * @param  {object} options Custom filter options.
     * @param  {Function} options.getProperty An optional function with parameters (feature, propertyName)
     * that can be used to extract properties from a feature.
     * When not given, properties are read from feature.properties directly.
     * @param  {Function} options.getFeatureId An optional function to extract the feature id from a feature.
     * When not given, feature id is read from feature.id.
     * @return {boolean} True if the feature passes the conditions described by the filter object.
     */
    function filterSelector(filter, feature, options) {
        if (options === void 0) options = {};

        var getProperty =
            typeof options.getProperty === 'function'
                ? options.getProperty
                : getGeoJSONProperty;

        var getFeatureId =
            typeof options.getFeatureId === 'function'
                ? options.getFeatureId
                : getGeoJSONFeatureId;

        var type = filter.type;
        switch (type) {
            case 'featureid':
                return doFIDFilter(filter.fids, getFeatureId(feature));

            case 'comparison':
                return doComparison(filter, feature, getProperty);

            case 'and': {
                if (!filter.predicates) {
                    throw new Error('And filter must have predicates array.');
                }

                // And without predicates should return false.
                if (filter.predicates.length === 0) {
                    return false;
                }

                return filter.predicates.every(function (predicate) { return filterSelector(predicate, feature, options); }
                );
            }

            case 'or': {
                if (!filter.predicates) {
                    throw new Error('Or filter must have predicates array.');
                }

                return filter.predicates.some(function (predicate) { return filterSelector(predicate, feature, options); }
                );
            }

            case 'not': {
                if (!filter.predicate) {
                    throw new Error('Not filter must have predicate.');
                }

                return !filterSelector(filter.predicate, feature, options);
            }

            default:
                throw new Error(("Unknown filter type: " + type));
        }
    }

    /**
     * [scaleSelector description]
     * The "standardized rendering pixel size" is defined to be 0.28mm × 0.28mm
     * @private
     * @param  {Rule} rule
     * @param  {number} resolution  m/px
     * @return {boolean}
     */
    function scaleSelector(rule, resolution) {
        if (
            rule.maxscaledenominator !== undefined &&
            rule.minscaledenominator !== undefined
        ) {
            if (
                resolution / 0.00028 < rule.maxscaledenominator &&
                resolution / 0.00028 > rule.minscaledenominator
            ) {
                return true;
            }
            return false;
        }
        if (rule.maxscaledenominator !== undefined) {
            return resolution / 0.00028 < rule.maxscaledenominator;
        }
        if (rule.minscaledenominator !== undefined) {
            return resolution / 0.00028 > rule.minscaledenominator;
        }
        return true;
    }

    /**
     * get all layer names in sld
     * @param {StyledLayerDescriptor} sld
     * @return {string[]} registered layernames
     */
    function getLayerNames(sld) {
        return sld.layers.map(function (l) { return l.name; });
    }

    /**
     * Get layer definition from sld
     * @param  {StyledLayerDescriptor} sld       [description]
     * @param  {string} [layername] optional layername
     * @return {Layer}           [description]
     */
    function getLayer(sld, layername) {
        if (!layername) {
            return sld.layers['0'];
        }
        return sld.layers.find(function (l) { return l.name === layername; });
    }

    /**
     * getStyleNames, notice name is not required for userstyle, you might get undefined
     * @param  {Layer} layer [description]
     * @return {string[]}       [description]
     */
    function getStyleNames(layer) {
        return layer.styles.map(function (s) { return s.name; });
    }

    /**
     * get style from array layer.styles, if name is undefined it returns default style.
     * null is no style found
     * @param  {Layer} layer [description]
     * @param {string} [name] of style
     * @return {object} the style from layer.styles matching the name
     */
    function getStyle(layer, name) {
        if (name) {
            return layer.styles.find(function (s) { return s.name === name; });
        }
        return layer.styles.find(function (s) { return s.default; });
    }

    /**
     * get rules for specific feature after applying filters
     * @example
     * const style = getStyle(sldLayer, stylename);
     * getRules(style.featuretypestyles['0'], geojson, resolution);
     * @param  {FeatureTypeStyle} featureTypeStyle
     * @param  {object} feature geojson
     * @param  {number} resolution m/px
     * @param  {Function} options.getProperty An optional function with parameters (feature, propertyName)
     * that can be used to extract a property value from a feature.
     * When not given, properties are read from feature.properties directly.Error
     * @param  {Function} options.getFeatureId An optional function to extract the feature id from a feature.Error
     * When not given, feature id is read from feature.id.
     * @return {Rule[]}
     */
    function getRules(featureTypeStyle, feature, resolution, options) {
        if (options === void 0) options = {};

        var validRules = [];
        var elseFilterCount = 0;
        for (var j = 0; j < featureTypeStyle.rules.length; j += 1) {
            var rule = featureTypeStyle.rules[j];
            // Only keep rules that pass the rule's min/max scale denominator checks.
            if (scaleSelector(rule, resolution)) {
                if (rule.elsefilter) {
                    // In the first rule selection step, keep all rules with an ElseFilter.
                    validRules.push(rule);
                    elseFilterCount += 1;
                } else if (!rule.filter) {
                    // Rules without filter always apply.
                    validRules.push(rule);
                } else if (filterSelector(rule.filter, feature, options)) {
                    // If a rule has a filter, only keep it if the feature passes the filter.
                    validRules.push(rule);
                }
            }
        }

        // When eligible rules contain only rules with ElseFilter, return them all.
        // Note: the spec does not forbid more than one ElseFilter remaining at a given scale,
        // but leaves handling this case up to the implementor.
        // The SLDLibrary chooses to keep them all.
        if (elseFilterCount === validRules.length) {
            return validRules;
        }

        // If a mix of rules with and without ElseFilter remains, only keep rules without ElseFilter.
        return validRules.filter(function (rule) { return !rule.elsefilter; });
    }

    /**
     * Get all symbolizers inside a given rule.
     * Note: this will be a mix of Point/Line/Polygon/Text symbolizers.
     * @param {object} rule SLD rule object.
     * @returns {Array<object>} Array of all symbolizers in a rule.
     */
    function getRuleSymbolizers(rule) {
        // Helper for adding a symbolizer to a list when the symbolizer can be an array of symbolizers.
        // Todo: refactor style reader, so symbolizer is always an array.
        function addSymbolizer(list, symbolizer) {
            if (!symbolizer) {
                return;
            }
            if (Array.isArray(symbolizer)) {
                Array.prototype.push.apply(list, symbolizer);
                return;
            }
            list.push(symbolizer);
        }

        var allSymbolizers = [];
        addSymbolizer(allSymbolizers, rule.pointsymbolizer);
        addSymbolizer(allSymbolizers, rule.linesymbolizer);
        addSymbolizer(allSymbolizers, rule.polygonsymbolizer);
        addSymbolizer(allSymbolizers, rule.textsymbolizer);

        return allSymbolizers;
    }

    /**
     * Gets a nested property from an object according to a property path.
     * Note: path fragments may not contain a ".".
     * Note: returns undefined if input obj is falsy.
     * @private
     * @example
     * getByPath({ a: { b: { c: 42 } } }, "a.b.c") // returns 42.
     * getByPath({ a: { b: { c: 42 } } }, "a.d.c") // returns undefined, because obj.a has no property .d.
     * @param {object} obj Object.
     * @param {string} path Property path.
     * @returns {any} Value of property at given path inside object, or undefined if any property
     * in the path does not exist on the object.
     */
    function getByPath(obj, path) {
        if (!obj) {
            return undefined;
        }

        // Start from the given object.
        var value = obj;

        // Walk the object property path.
        var fragments = (path || '').split('.');
        for (var k = 0; k < fragments.length; k += 1) {
            var fragment = fragments[k];
            // Return undefined if any partial path does not exist in the object.
            if (!(fragment in value)) {
                return undefined;
            }
            value = value[fragment];
        }

        return value;
    }

    /**
     * Get styling from rules per geometry type
     * @param  {Rule[]} rules [description]
     * @return {GeometryStyles}
     */
    function getGeometryStyles(rules) {
        var result = {
            polygon: [],
            line: [],
            point: [],
            text: [],
        };
        for (var i = 0; i < rules.length; i += 1) {
            if (rules[i].polygonsymbolizer) {
                result.polygon.push(rules[i].polygonsymbolizer);
            }
            if (rules[i].linesymbolizer && rules[i].linesymbolizer) {
                result.line.push(rules[i].linesymbolizer);
            }
            if (rules[i].pointsymbolizer) {
                var ref = rules[i];
                var pointsymbolizer = ref.pointsymbolizer;
                result.point.push(pointsymbolizer);
            }
            if (rules[i].textsymbolizer) {
                var ref$1 = rules[i];
                var textsymbolizer = ref$1.textsymbolizer;
                result.text.push(textsymbolizer);
            }
        }
        return result;
    }

    /**
     * @typedef GeometryStyles
     * @name GeometryStyles
     * @description contains for each geometry type the symbolizer from an array of rules
     * @property {PolygonSymbolizer[]} polygon polygonsymbolizers
     * @property {LineSymbolizer[]} line linesymbolizers
     * @property {PointSymbolizer[]} point pointsymbolizers, same as graphic prop from PointSymbolizer
     */

    var IMAGE_LOADING = 'IMAGE_LOADING';
    var IMAGE_LOADED = 'IMAGE_LOADED';
    var IMAGE_ERROR = 'IMAGE_ERROR';

    // SLD Spec: Default size for Marks without Size should be 6 pixels.
    var DEFAULT_MARK_SIZE = 6; // pixels
    // SLD Spec: Default size for ExternalGraphic with an unknown native size,
    // like SVG without dimensions, should be 16 pixels.
    var DEFAULT_EXTERNALGRAPHIC_SIZE = 16; // pixels

    // QGIS Graphic stroke placement options
    var PLACEMENT_DEFAULT = 'PLACEMENT_DEFAULT';
    var PLACEMENT_FIRSTPOINT = 'PLACEMENT_FIRSTPOINT';
    var PLACEMENT_LASTPOINT = 'PLACEMENT_LASTPOINT';

    /* eslint-disable no-continue */

    // These are possible locations for an external graphic inside a symbolizer.
    var externalGraphicPaths = [
        'graphic.externalgraphic',
        'stroke.graphicstroke.graphic.externalgraphic',
        'fill.graphicfill.graphic.externalgraphic'];

    /**
     * @private
     * Global image cache. A map of image Url -> {
     *   url: image url,
     *   image: an Image instance containing image data,
     *   width: image width in pixels,
     *   height: image height in pixels
     * }
     */
    var imageCache = {};
    function setCachedImage(url, imageData) {
        imageCache[url] = imageData;
    }
    function getCachedImage(url) {
        return imageCache[url];
    }

    /**
     * @private
     * Global image loading state cache.
     * A map of image Url -> one of 'IMAGE_LOADING', 'IMAGE_LOADED', 'IMAGE_ERROR'
     */
    var imageLoadingStateCache = {};
    function setImageLoadingState(url, loadingState) {
        imageLoadingStateCache[url] = loadingState;
    }
    function getImageLoadingState(url) {
        return imageLoadingStateCache[url];
    }

    /**
     * @private
     * A cache of image loading promises.
     * A map of image Url -> Promise
     * This used to prevent duplicate loading when a style references an image that's already being loaded.
     */
    var _imageLoaderCache = {};
    function getImageLoader(url) {
        return _imageLoaderCache[url];
    }
    function setImageLoader(url, loaderPromise) {
        _imageLoaderCache[url] = loaderPromise;
    }

    function invalidateExternalGraphicSymbolizers(symbolizer, imageUrl) {
        // Look at all possible paths where an externalgraphic may be present within a symbolizer.
        // When such an externalgraphic has been found, and its url equals imageUrl, invalidate the symbolizer.
        for (var k = 0; k < externalGraphicPaths.length; k += 1) {
            // Note: this process assumes that each symbolizer has at most one external graphic element.
            var path = externalGraphicPaths[k];
            var externalgraphic = getByPath(symbolizer, path);
            if (externalgraphic && externalgraphic.onlineresource === imageUrl) {
                symbolizer.__invalidated = true;
                // If the symbolizer contains a graphic stroke symbolizer,
                // also update the nested graphicstroke symbolizer object.
                if (path.indexOf('graphicstroke') > -1) {
                    symbolizer.stroke.graphicstroke.__invalidated = true;
                }
            }
        }
    }

    function updateSymbolizerInvalidatedState(ruleSymbolizer, imageUrl) {
        if (!ruleSymbolizer) {
            return;
        }

        // Watch out! A symbolizer inside a rule may be a symbolizer, or an array of symbolizers.
        // Todo: refactor so rule.symbolizers property is always an array with 0..n symbolizer objects.
        if (!Array.isArray(ruleSymbolizer)) {
            invalidateExternalGraphicSymbolizers(ruleSymbolizer, imageUrl);
        } else {
            for (var k = 0; k < ruleSymbolizer.length; k += 1) {
                invalidateExternalGraphicSymbolizers(ruleSymbolizer[k], imageUrl);
            }
        }
    }

    /**
     * @private
     * Invalidate all symbolizers inside a featureTypeStyle's rules having an ExternalGraphic matching the image url
     * @param {object} featureTypeStyle A feature type style object.
     * @param {string} imageUrl The image url.
     */
    function invalidateExternalGraphics(featureTypeStyle, imageUrl) {
        if (!featureTypeStyle.rules) {
            return;
        }

        featureTypeStyle.rules.forEach(function (rule) {
            updateSymbolizerInvalidatedState(rule.pointsymbolizer, imageUrl);
            updateSymbolizerInvalidatedState(rule.linesymbolizer, imageUrl);
            updateSymbolizerInvalidatedState(rule.polygonsymbolizer, imageUrl);
        });
    }

    /**
     * @private
     * Creates a promise that loads an image and store it in the image cache.
     * Calling this method with the same image url twice will return the loader promise
     * that was created when this method was called the first time for that specific image url.
     * @param {string} imageUrl Image url.
     * @returns {Promise} A promise that resolves when the image is loaded and fails when the
     * image didn't load correctly.
     */
    function getCachingImageLoader(imageUrl) {
        // Check of a load is already in progress for an image.
        // If so, return the loader.
        var loader = getImageLoader(imageUrl);
        if (loader) {
            return loader;
        }

        // If no load is in progress, create a new loader and store it in the image loader cache before returning it.
        loader = new Promise(function (resolve, reject) {
            var image = new Image();

            image.onload = function () {
                setCachedImage(imageUrl, {
                    url: imageUrl,
                    image: image,
                    width: image.naturalWidth,
                    height: image.naturalHeight,
                });
                setImageLoadingState(imageUrl, IMAGE_LOADED);
                resolve(imageUrl);
            };

            image.onerror = function () {
                setImageLoadingState(imageUrl, IMAGE_ERROR);
                reject();
            };

            image.src = imageUrl;
        });

        // Cache the new image loader and return it.
        setImageLoadingState(imageUrl, IMAGE_LOADING);
        setImageLoader(imageUrl, loader);
        return loader;
    }

    /**
     * @private
     * Load and cache an image that's used as externalGraphic inside a symbolizer.
     * When the image is loaded, all symbolizers within the feature type style referencing this image are invalidated,
     * and the imageLoadedCallback is called with the loaded image url.
     * @param {url} imageUrl Image url.
     * @param {object} featureTypeStyle Feature type style object.
     * @param {Function} imageLoadedCallback Will be called with the image url when image
     * has loaded. Will be called with undefined if the loading the image resulted in an error.
     */
    function loadExternalGraphic(
        imageUrl,
        featureTypeStyle,
        imageLoadedCallback
    ) {
        invalidateExternalGraphics(featureTypeStyle, imageUrl);
        getCachingImageLoader(imageUrl)
            .then(function () {
                invalidateExternalGraphics(featureTypeStyle, imageUrl);
                if (typeof imageLoadedCallback === 'function') {
                    imageLoadedCallback(imageUrl);
                }
            })
            .catch(function () {
                invalidateExternalGraphics(featureTypeStyle, imageUrl);
                if (typeof imageLoadedCallback === 'function') {
                    imageLoadedCallback();
                }
            });
    }

    /**
     * @private
     * Start loading images used in rules that have a pointsymbolizer with an externalgraphic.
     * @param {Array<object>} rules Array of SLD rule objects that pass the filter for a single feature.
     * @param {FeatureTypeStyle} featureTypeStyle The feature type style object for a layer.
     * @param {Function} imageLoadedCallback Function to call when an image has loaded.
     */
    function processExternalGraphicSymbolizers(
        rules,
        featureTypeStyle,
        imageLoadedCallback,
        callbackRef
    ) {
        // Walk over all symbolizers inside all given rules.
        // Dive into the symbolizers to find ExternalGraphic elements and for each ExternalGraphic,
        // check if the image url has been encountered before.
        // If not -> start loading the image into the global image cache.
        rules.forEach(function (rule) {
            var allSymbolizers = getRuleSymbolizers(rule);
            allSymbolizers.forEach(function (symbolizer) {
                externalGraphicPaths.forEach(function (path) {
                    var exgraphic = getByPath(symbolizer, path);
                    if (!exgraphic) {
                        return;
                    }
                    var imageUrl = exgraphic.onlineresource;
                    var imageLoadingState = getImageLoadingState(imageUrl);
                    if (!imageLoadingState || imageLoadingState === IMAGE_LOADING) {
                        // Prevent adding imageLoadedCallback more than once per image per created style function
                        // by inspecting the callbackRef object passed by the style function creator function.
                        // Each style function has its own callbackRef dictionary.
                        if (!callbackRef[imageUrl]) {
                            callbackRef[imageUrl] = true;
                            // Load image and when loaded, invalidate all symbolizers referencing the image
                            // and invoke the imageLoadedCallback.
                            loadExternalGraphic(
                                imageUrl,
                                featureTypeStyle,
                                imageLoadedCallback
                            );
                        }
                    }
                });
            });
        });
    }

    /**
     * @private
     * Create an OL Icon style for an external graphic.
     * The Graphic must be already loaded and present in the global imageCache.
     * @param {string} imageUrl Url of the external graphic.
     * @param {number} size Requested size in pixels.
     * @param {number} [rotationDegrees] Image rotation in degrees (clockwise). Default 0.
     */
    function createCachedImageStyle(imageUrl, size, rotationDegrees) {
        if (rotationDegrees === void 0) rotationDegrees = 0.0;

        var ref = getCachedImage(imageUrl);
        var image = ref.image;
        var width = ref.width;
        var height = ref.height;
        return new style.Style({
            image: new style.Icon({
                img: image,
                imgSize: [width, height],
                // According to SLD spec, if size is given, image height should equal the given size.
                scale: size / height || 1,
                rotation: (Math.PI * rotationDegrees) / 180.0,
            }),
        });
    }

    var emptyStyle = new style.Style({});

    var defaultPointStyle = new style.Style({
        image: new style.Circle({
            radius: 8,
            fill: new style.Fill({
                color: 'blue',
                fillOpacity: 0.7,
            }),
        }),
    });

    var imageLoadingPointStyle = new style.Style({
        image: new style.Circle({
            radius: 5,
            fill: new style.Fill({
                color: '#DDDDDD',
            }),
            stroke: new style.Stroke({
                width: 1,
                color: '#888888',
            }),
        }),
    });

    var imageLoadingPolygonStyle = new style.Style({
        fill: new style.Fill({
            color: '#DDDDDD',
        }),
        stroke: new style.Stroke({
            color: '#888888',
            width: 1,
        }),
    });

    var imageErrorPointStyle = new style.Style({
        image: new style.RegularShape({
            angle: Math.PI / 4,
            fill: new style.Fill({
                color: 'red',
            }),
            points: 4,
            radius1: 8,
            radius2: 0,
            stroke: new style.Stroke({
                color: 'red',
                width: 4,
            }),
        }),
    });

    var imageErrorPolygonStyle = new style.Style({
        fill: new style.Fill({
            color: 'red',
        }),
        stroke: new style.Stroke({
            color: 'red',
            width: 1,
        }),
    });

    /**
     * @private
     * Function to memoize style conversion functions that convert sld symbolizers to OpenLayers style instances.
     * The memoized version of the style converter returns the same OL style instance if the symbolizer is the same object.
     * Uses a WeakMap internally.
     * Note: This only works for constant symbolizers.
     * @param {Function} styleFunction Function that accepts a single symbolizer object and returns the corresponding OpenLayers style object.
     * @returns {Function} The memoized function of the style conversion function.
     */
    function memoizeStyleFunction(styleFunction) {
        var styleCache = new WeakMap();

        return function (symbolizer) {
            var olStyle = styleCache.get(symbolizer);

            // Create a new style if no style has been created yet, or when symbolizer has been invalidated.
            if (!olStyle || symbolizer.__invalidated) {
                olStyle = styleFunction(symbolizer);
                // Clear invalidated flag after creating a new style instance.
                symbolizer.__invalidated = false;
                styleCache.set(symbolizer, olStyle);
            }

            return olStyle;
        };
    }

    /**
     * @private
     * Convert a hex color (like #AABBCC) to an rgba-string.
     * @param  {string} hex   eg #AA00FF
     * @param  {Number} alpha eg 0.5
     * @return {string}       rgba(0,0,0,0)
     */
    function hexToRGB(hex, alpha) {
        var r = parseInt(hex.slice(1, 3), 16);
        var g = parseInt(hex.slice(3, 5), 16);
        var b = parseInt(hex.slice(5, 7), 16);
        if (alpha) {
            return ("rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")");
        }
        return ("rgb(" + r + ", " + g + ", " + b + ")");
    }

    /**
     * @private
     * Calculate the center-to-center distance for graphics placed along a line within a GraphicSymbolizer.
     * @param {object} lineSymbolizer SLD line symbolizer object.
     * @param {number} graphicWidth Width of the symbolizer graphic in pixels. This size may be dependent on feature properties,
     * so it has to be supplied separately from the line symbolizer object.
     * @returns {number} Center-to-center distance for graphics along a line.
     */
    function calculateGraphicSpacing(lineSymbolizer, graphicWidth) {
        var ref = lineSymbolizer.stroke;
        var graphicstroke = ref.graphicstroke;
        var styling = ref.styling;
        if ('gap' in graphicstroke) {
            // Note: gap should be a numeric property after parsing (check reader.test).
            return graphicstroke.gap + graphicWidth;
        }

        // If gap is not given, use strokeDasharray to space graphics.
        // First digit represents size of graphic, second the relative space, e.g.
        // size = 20, dash = [2 6] -> 2 ~ 20 then 6 ~ 60, total segment length should be 20 + 60 = 80
        var multiplier = 1; // default, i.e. a segment is the size of the graphic (without stroke/outline).
        if (styling && styling.strokeDasharray) {
            var dash = styling.strokeDasharray.split(' ');
            if (dash.length >= 2 && dash[0] !== 0) {
                multiplier = dash[1] / dash[0] + 1;
            }
        }
        return multiplier * graphicWidth;
    }

    /**
     * @private
     * Create an OL point style corresponding to a well known symbol identifier.
     * @param {string} wellKnownName SLD Well Known Name for symbolizer.
     * Can be 'circle', 'square', 'triangle', 'star', 'cross', 'x', 'hexagon', 'octagon'.
     * @param {number} size Symbol size in pixels.
     * @param {ol/style/stroke} stroke OpenLayers Stroke instance.
     * @param {ol/style/fill} fill OpenLayers Fill instance.
     * @param {number} rotationDegrees Symbol rotation in degrees (clockwise). Default 0.
     */
    function getWellKnownSymbol(
        wellKnownName,
        size,
        stroke,
        fill,
        rotationDegrees
    ) {
        if (rotationDegrees === void 0) rotationDegrees = 0.0;

        var radius = 0.5 * parseFloat(size);
        var rotationRadians = (Math.PI * rotationDegrees) / 180.0;

        var fillColor;
        if (fill && fill.getColor()) {
            fillColor = fill.getColor();
        }

        switch (wellKnownName) {
            case 'circle':
                return new style.Circle({
                    fill: fill,
                    radius: radius,
                    stroke: stroke,
                });

            case 'triangle':
                return new style.RegularShape({
                    fill: fill,
                    points: 3,
                    radius: radius,
                    stroke: stroke,
                    rotation: rotationRadians,
                });

            case 'star':
                return new style.RegularShape({
                    fill: fill,
                    points: 5,
                    radius1: radius,
                    radius2: radius / 2.5,
                    stroke: stroke,
                    rotation: rotationRadians,
                });

            case 'cross':
                return new style.RegularShape({
                    fill: fill,
                    points: 4,
                    radius1: radius,
                    radius2: 0,
                    stroke:
                        stroke ||
                        new style.Stroke({
                            color: fillColor,
                            width: radius / 2,
                        }),
                    rotation: rotationRadians,
                });

            case 'hexagon':
                return new style.RegularShape({
                    fill: fill,
                    points: 6,
                    radius: radius,
                    stroke:
                        stroke ||
                        new style.Stroke({
                            color: fillColor,
                            width: radius / 2,
                        }),
                    rotation: rotationRadians,
                });

            case 'octagon':
                return new style.RegularShape({
                    angle: Math.PI / 8,
                    fill: fill,
                    points: 8,
                    radius: radius / Math.cos(Math.PI / 8),
                    stroke:
                        stroke ||
                        new style.Stroke({
                            color: fillColor,
                            width: radius / 2,
                        }),
                    rotation: rotationRadians,
                });

            case 'cross2': // cross2 is used by QGIS for the x symbol.
            case 'x':
                return new style.RegularShape({
                    angle: Math.PI / 4,
                    fill: fill,
                    points: 4,
                    radius1: radius,
                    radius2: 0,
                    stroke:
                        stroke ||
                        new style.Stroke({
                            color: fillColor,
                            width: radius / 2,
                        }),
                    rotation: rotationRadians,
                });

            case 'diamond':
                return new style.RegularShape({
                    fill: fill,
                    points: 4,
                    radius1: radius,
                    stroke: stroke,
                    rotation: rotationRadians,
                });

            default:
                // Default is `square`
                return new style.RegularShape({
                    angle: Math.PI / 4,
                    fill: fill,
                    points: 4,
                    // For square, scale radius so the height of the square equals the given size.
                    radius1: radius * Math.sqrt(2.0),
                    stroke: stroke,
                    rotation: rotationRadians,
                });
        }
    }

    // This module contains an evaluate function that takes an SLD expression and a feature and outputs the value for that feature.
    // Constant expressions are returned as-is.

    /**
     * @private
     * Evaluate the value of a sub-expression.
     * @param {object} childExpression SLD object expression child.
     * @param {ol/feature} feature OpenLayers feature instance.feature.
     * @param {function} getProperty A function to get a specific property value from a feature.
     * Signature (feature, propertyName) => property value.
     */
    function evaluateChildExpression(childExpression, feature, getProperty) {
        // For now, the only valid child types are 'propertyname' and 'literal'.
        // Todo: add,sub,mul,div. Maybe a few functions as well.
        if (childExpression.type === 'literal') {
            return childExpression.value;
        }

        if (childExpression.type === 'propertyname') {
            return getProperty(feature, childExpression.value);
        }

        return null;
    }

    /**
     * @private
     * This function takes an SLD expression and an OL feature and outputs the expression value for that feature.
     * Constant expressions are returned as-is.
     * @param {object|string} expression SLD object expression.
     * @param {ol/feature} feature OpenLayers feature instance.
     * @param {function} getProperty A function to get a specific property value from a feature.
     * Signature (feature, propertyName) => property value.
     */
    function evaluate(expression, feature, getProperty) {
        // The only compound expressions have type: 'expression'.
        // If it does not have this type, it's probably a plain string (or number).
        if (expression.type !== 'expression') {
            return expression;
        }

        // Evaluate the child expression when there is only one child.
        if (expression.children.length === 1) {
            return evaluateChildExpression(expression.children[0], feature, getProperty);
        }

        // In case of multiple child expressions, concatenate the evaluated child results.
        var childValues = [];
        for (var k = 0; k < expression.children.length; k += 1) {
            childValues.push(evaluateChildExpression(expression.children[k], feature, getProperty));
        }
        return childValues.join('');
    }

    /**
     * @private
     * Utility function for evaluating dynamic expressions without a feature.
     * If the expression is static, the expression value will be returned.
     * If the expression is dynamic, defaultValue will be returned.
     * If the expression is falsy, defaultValue will be returned.
     * @param {object|string} expression SLD object expression (or string).
     * @param {any} defaultValue Default value.
     * @returns {any} The value of a static expression or default value if the expression is dynamic.
     */
    function expressionOrDefault(expression, defaultValue) {
        if (!expression) {
            return defaultValue;
        }

        if (expression.type === 'expression') {
            return defaultValue;
        }

        return expression;
    }

    /* eslint-disable import/prefer-default-export */

    /**
     * Get an OL style/Stroke instance from the css/svg properties of the .stroke property
     * of an SLD symbolizer object.
     * @private
     * @param  {object} stroke SLD symbolizer.stroke object.
     * @return {object} OpenLayers style/Stroke instance. Returns undefined when input is null or undefined.
     */
    function getSimpleStroke(stroke) {
        // According to SLD spec, if no Stroke element is present inside a symbolizer element,
        // no stroke is to be rendered.
        if (!stroke) {
            return undefined;
        }

        var styleParams = stroke.styling || {};
        return new style.Stroke({
            color:
                styleParams.strokeOpacity &&
                    styleParams.stroke &&
                    styleParams.stroke.slice(0, 1) === '#'
                    ? hexToRGB(styleParams.stroke, styleParams.strokeOpacity)
                    : styleParams.stroke || 'black',
            width: parseFloat(styleParams.strokeWidth) || 1,
            lineCap: styleParams.strokeLinecap,
            lineDash:
                styleParams.strokeDasharray && styleParams.strokeDasharray.split(' '),
            lineDashOffset: parseFloat(styleParams.strokeDashoffset),
            lineJoin: styleParams.strokeLinejoin,
        });
    }

    /**
     * Get an OL style/Fill instance from the css/svg properties of the .fill property
     * of an SLD symbolizer object.
     * @private
     * @param  {object} fill SLD symbolizer.fill object.
     * @return {object} OpenLayers style/Fill instance. Returns undefined when input is null or undefined.
     */
    function getSimpleFill(fill) {
        // According to SLD spec, if no Fill element is present inside a symbolizer element,
        // no fill is to be rendered.
        if (!fill) {
            return undefined;
        }

        var styleParams = fill.styling || {};

        return new style.Fill({
            color:
                styleParams.fillOpacity &&
                    styleParams.fill &&
                    styleParams.fill.slice(0, 1) === '#'
                    ? hexToRGB(styleParams.fill, styleParams.fillOpacity)
                    : styleParams.fill || 'black',
        });
    }

    var defaultMarkFill = getSimpleFill({ styling: { fill: '#888888' } });
    var defaultMarkStroke = getSimpleStroke({ styling: { stroke: {} } });

    /**
     * @private
     * @param  {PointSymbolizer} pointsymbolizer [description]
     * @return {object} openlayers style
     */
    function pointStyle(pointsymbolizer) {
        var style$1 = pointsymbolizer.graphic;

        // If the point size is a dynamic expression, use the default point size and update in-place later.
        var pointSizeValue = expressionOrDefault(style$1.size, DEFAULT_MARK_SIZE);

        // If the point rotation is a dynamic expression, use 0 as default rotation and update in-place later.
        var rotationDegrees = expressionOrDefault(style$1.rotation, 0.0);

        if (style$1.externalgraphic && style$1.externalgraphic.onlineresource) {
            // For external graphics: the default size is the native image size.
            // In that case, set pointSizeValue to null, so no scaling is calculated for the image.
            if (!style$1.size) {
                pointSizeValue = null;
            }

            var imageUrl = style$1.externalgraphic.onlineresource;

            // Use fallback point styles when image hasn't been loaded yet.
            switch (getImageLoadingState(imageUrl)) {
                case IMAGE_LOADED:
                    return createCachedImageStyle(
                        imageUrl,
                        pointSizeValue,
                        rotationDegrees
                    );
                case IMAGE_LOADING:
                    return imageLoadingPointStyle;
                case IMAGE_ERROR:
                    return imageErrorPointStyle;
                default:
                    // A symbolizer should have loading state metadata, but return IMAGE_LOADING just in case.
                    return imageLoadingPointStyle;
            }
        }

        if (style$1.mark) {
            var ref = style$1.mark;
            var wellknownname = ref.wellknownname;
            var olFill = getSimpleFill(style$1.mark.fill);
            var olStroke = getSimpleStroke(style$1.mark.stroke);

            return new style.Style({
                // Note: size will be set dynamically later.
                image: getWellKnownSymbol(
                    wellknownname,
                    pointSizeValue,
                    olStroke,
                    olFill,
                    rotationDegrees
                ),
            });
        }

        // SLD spec: when no ExternalGraphic or Mark is specified,
        // use a square of 6 pixels with 50% gray fill and a black outline.
        return new style.Style({
            image: getWellKnownSymbol(
                'square',
                pointSizeValue,
                defaultMarkStroke,
                defaultMarkFill,
                rotationDegrees
            ),
        });
    }

    var cachedPointStyle = memoizeStyleFunction(pointStyle);

    /**
     * @private
     * Get an OL point style instance for a feature according to a symbolizer.
     * @param {object} symbolizer SLD symbolizer object.
     * @param {ol/Feature} feature OpenLayers Feature.
     * @param {Function} getProperty A property getter: (feature, propertyName) => property value.
     * @returns {ol/Style} OpenLayers style instance.
     */
    function getPointStyle(symbolizer, feature, getProperty) {
        // According to SLD spec, when a point symbolizer has no Graphic, nothing will be rendered.
        if (!(symbolizer && symbolizer.graphic)) {
            return emptyStyle;
        }

        var olStyle = cachedPointStyle(symbolizer);

        // Reset previous calculated point geometry left by evaluating point style for a line or polygon feature.
        olStyle.setGeometry(null);

        var olImage = olStyle.getImage();

        // Apply dynamic values to the cached OL style instance before returning it.

        // --- Update dynamic size ---
        var graphic = symbolizer.graphic;
        var size = graphic.size;
        if (size && size.type === 'expression') {
            var sizeValue =
                Number(evaluate(size, feature, getProperty)) || DEFAULT_MARK_SIZE;

            if (graphic.externalgraphic && graphic.externalgraphic.onlineresource) {
                var height = olImage.getSize()[1];
                var scale = sizeValue / height || 1;
                olImage.setScale(scale);
            } else if (graphic.mark && graphic.mark.wellknownname === 'circle') {
                // Note: only ol/style/Circle has a setter for radius. RegularShape does not.
                olImage.setRadius(sizeValue * 0.5);
            } else {
                // For a non-Circle RegularShape, create a new olImage in order to update the size.
                olImage = getWellKnownSymbol(
                    (graphic.mark && graphic.mark.wellknownname) || 'square',
                    sizeValue,
                    // Note: re-use stroke and fill instances for a (small?) performance gain.
                    olImage.getStroke(),
                    olImage.getFill()
                );
                olStyle.setImage(olImage);
            }
        }

        // --- Update dynamic rotation ---
        var rotation = graphic.rotation;
        if (rotation && rotation.type === 'expression') {
            var rotationDegrees =
                Number(evaluate(rotation, feature, getProperty)) || 0.0;
            // Note: OL angles are in radians.
            var rotationRadians = (Math.PI * rotationDegrees) / 180.0;
            olImage.setRotation(rotationRadians);
        }

        return olStyle;
    }

    // eslint-disable-next-line import/prefer-default-export
    function splitLineString(geometry, graphicSpacing, options) {
        function calculatePointsDistance(coord1, coord2) {
            var dx = coord1[0] - coord2[0];
            var dy = coord1[1] - coord2[1];
            return Math.sqrt(dx * dx + dy * dy);
        }

        function calculateSplitPointCoords(
            startNode,
            nextNode,
            distanceBetweenNodes,
            distanceToSplitPoint
        ) {
            var d = distanceToSplitPoint / distanceBetweenNodes;
            var x = nextNode[0] + (startNode[0] - nextNode[0]) * d;
            var y = nextNode[1] + (startNode[1] - nextNode[1]) * d;
            return [x, y];
        }

        /**
         * Calculate the angle of a vector in radians clockwise from the positive x-axis.
         * Example: (0,0) -> (1,1) --> -pi/4 radians.
         * @param {Array<number>} p1 Start of the line segment as [x,y].
         * @param {Array<number>} p2 End of the line segment as [x,y].
         * @param {boolean} invertY If true, calculate with Y-axis pointing downwards.
         * @returns {number} Angle in radians, clockwise from the positive x-axis.
         */
        function calculateAngle(p1, p2, invertY) {
            var dX = p2[0] - p1[0];
            var dY = p2[1] - p1[1];
            var angle = -Math.atan2(invertY ? -dY : dY, dX);
            return angle;
        }

        var coords = geometry.getCoordinates();

        // Handle first point placement case.
        if (options.placement === PLACEMENT_FIRSTPOINT) {
            var p1 = coords[0];
            var p2 = coords[1];
            return [[p1[0], p1[1], calculateAngle(p1, p2, options.invertY)]];
        }

        // Handle last point placement case.
        if (options.placement === PLACEMENT_LASTPOINT) {
            var p1$1 = coords[coords.length - 2];
            var p2$1 = coords[coords.length - 1];
            return [[p2$1[0], p2$1[1], calculateAngle(p1$1, p2$1, options.invertY)]];
        }

        // Without placement vendor options, draw regularly spaced GraphicStroke markers.
        var splitPoints = [];
        var coordIndex = 0;
        var startPoint = coords[coordIndex];
        var nextPoint = coords[coordIndex + 1];
        var angle = calculateAngle(startPoint, nextPoint, options.invertY);

        var n = Math.ceil(geometry.getLength() / graphicSpacing);
        var segmentLength = geometry.getLength() / n;
        var currentSegmentLength = options.midPoints
            ? segmentLength / 2
            : segmentLength;

        for (var i = 0; i <= n; i += 1) {
            var distanceBetweenPoints = calculatePointsDistance(
                startPoint,
                nextPoint
            );
            currentSegmentLength += distanceBetweenPoints;

            if (currentSegmentLength < segmentLength) {
                coordIndex += 1;
                if (coordIndex < coords.length - 1) {
                    startPoint = coords[coordIndex];
                    nextPoint = coords[coordIndex + 1];
                    angle = calculateAngle(startPoint, nextPoint, options.invertY);
                    i -= 1;
                    // continue;
                } else {
                    if (!options.midPoints) {
                        var splitPointCoords = nextPoint;
                        if (
                            !options.extent ||
                            extent.containsCoordinate(options.extent, splitPointCoords)
                        ) {
                            splitPointCoords.push(angle);
                            splitPoints.push(splitPointCoords);
                        }
                    }
                    break;
                }
            } else {
                var distanceToSplitPoint = currentSegmentLength - segmentLength;
                var splitPointCoords$1 = calculateSplitPointCoords(
                    startPoint,
                    nextPoint,
                    distanceBetweenPoints,
                    distanceToSplitPoint
                );
                startPoint = splitPointCoords$1.slice();
                if (
                    !options.extent ||
                    extent.containsCoordinate(options.extent, splitPointCoords$1)
                ) {
                    splitPointCoords$1.push(angle);
                    splitPoints.push(splitPointCoords$1);
                }
                currentSegmentLength = 0;
            }
        }

        return splitPoints;
    }

    // A flag to prevent multiple renderer patches.
    var rendererPatched = false;
    function patchRenderer(renderer) {
        if (rendererPatched) {
            return;
        }

        // Add setImageStyle2 function that does the same as setImageStyle, except that it sets rotation
        // to a given value instead of taking it from imageStyle.getRotation().
        // This fixes a problem with re-use of the (cached) image style instance when drawing
        // many points inside a single line feature that are aligned according to line segment direction.
        var rendererProto = Object.getPrototypeOf(renderer);
        // eslint-disable-next-line
        rendererProto.setImageStyle2 = function (imageStyle, rotation) {
            // First call the original setImageStyle method.
            rendererProto.setImageStyle.call(this, imageStyle);

            // Then set rotation according to the given parameter.
            // This overrides the following line in setImageStyle:
            // this.imageRotation_ = imageStyle.getRotation()
            if (this.image_) {
                this.imageRotation_ = rotation;
            }
        };

        rendererPatched = true;
    }

    /**
     * Directly render graphic stroke marks for a line onto canvas.
     * @private
     * @param {ol/render/canvas/Immediate} render Instance of CanvasImmediateRenderer used to paint stroke marks directly to the canvas.
     * @param {Array<Array<number>>} pixelCoords A line as array of [x,y] point coordinate arrays in pixel space.
     * @param {number} graphicSpacing The center-to-center distance in pixels for stroke marks distributed along the line.
     * @param {ol/style/Style} pointStyle OpenLayers style instance used for rendering stroke marks.
     * @param {number} pixelRatio Ratio of device pixels to css pixels.
     * @returns {void}
     */
    function renderStrokeMarks(
        render,
        pixelCoords,
        graphicSpacing,
        pointStyle,
        pixelRatio,
        options
    ) {
        if (!pixelCoords) {
            return;
        }

        // The first element of the first pixelCoords entry should be a number (x-coordinate of first point).
        // If it's an array instead, then we're dealing with a multiline or (multi)polygon.
        // In that case, recursively call renderStrokeMarks for each child coordinate array.
        if (Array.isArray(pixelCoords[0][0])) {
            pixelCoords.forEach(function (pixelCoordsChildArray) {
                renderStrokeMarks(
                    render,
                    pixelCoordsChildArray,
                    graphicSpacing,
                    pointStyle,
                    pixelRatio,
                    options
                );
            });
            return;
        }

        // Line should be a proper line with at least two coordinates.
        if (pixelCoords.length < 2) {
            return;
        }

        // Don't render anything when the pointStyle has no image.
        var image = pointStyle.getImage();
        if (!image) {
            return;
        }

        var splitPoints = splitLineString(
            new geom.LineString(pixelCoords),
            graphicSpacing * pixelRatio,
            {
                invertY: true, // Pixel y-coordinates increase downwards in screen space.
                midPoints: false,
                extent: render.extent_,
                placement: options.placement,
            }
        );

        splitPoints.forEach(function (point) {
            var splitPointAngle = image.getRotation() + point[2];
            render.setImageStyle2(image, splitPointAngle);
            render.drawPoint(new geom.Point([point[0] / pixelRatio, point[1] / pixelRatio]));
        });
    }

    /**
     * Create a renderer function for renderining GraphicStroke marks
     * to be used inside an OpenLayers Style.renderer function.
     * @private
     * @param {LineSymbolizer} linesymbolizer SLD line symbolizer object.
     * @param {Function} getProperty A property getter: (feature, propertyName) => property value.
     * @returns {ol/style/Style~RenderFunction} A style renderer function (pixelCoords, renderState) => void.
     */
    function getGraphicStrokeRenderer(linesymbolizer, getProperty) {
        if (!(linesymbolizer.stroke && linesymbolizer.stroke.graphicstroke)) {
            throw new Error(
                'getGraphicStrokeRenderer error: symbolizer.stroke.graphicstroke null or undefined.'
            );
        }

        var ref = linesymbolizer.stroke;
        var graphicstroke = ref.graphicstroke;

        var options = {
            placement: PLACEMENT_DEFAULT,
        };

        // QGIS vendor options to override graphicstroke symbol placement.
        if (linesymbolizer.vendoroption) {
            if (linesymbolizer.vendoroption.placement === 'firstPoint') {
                options.placement = PLACEMENT_FIRSTPOINT;
            } else if (linesymbolizer.vendoroption.placement === 'lastPoint') {
                options.placement = PLACEMENT_LASTPOINT;
            }
        }

        return function (pixelCoords, renderState) {
            // Abort when feature geometry is (Multi)Point.
            var geometryType = renderState.feature.getGeometry().getType();
            if (geometryType === 'Point' || geometryType === 'MultiPoint') {
                return;
            }

            var pixelRatio = renderState.pixelRatio || 1.0;

            // TODO: Error handling, alternatives, etc.
            var render$1 = render.toContext(renderState.context);
            patchRenderer(render$1);

            var defaultGraphicSize = DEFAULT_MARK_SIZE;
            if (graphicstroke.graphic && graphicstroke.graphic.externalgraphic) {
                defaultGraphicSize = DEFAULT_EXTERNALGRAPHIC_SIZE;
            }

            var pointStyle = getPointStyle(
                graphicstroke,
                renderState.feature,
                getProperty
            );

            // Calculate graphic spacing.
            // Graphic spacing equals the center-to-center distance of graphics along the line.
            // If there's no gap, segment length will be equal to graphic size.
            var graphicSizeExpression =
                (graphicstroke.graphic && graphicstroke.graphic.size) ||
                defaultGraphicSize;
            var graphicSize = Number(
                evaluate(graphicSizeExpression, renderState.feature, getProperty)
            );

            var graphicSpacing = calculateGraphicSpacing(linesymbolizer, graphicSize);

            renderStrokeMarks(
                render$1,
                pixelCoords,
                graphicSpacing,
                pointStyle,
                pixelRatio,
                options
            );
        };
    }

    /**
     * Create an OpenLayers style for rendering line symbolizers with a GraphicStroke.
     * @private
     * @param {LineSymbolizer} linesymbolizer SLD line symbolizer object.
     * @param {Function} getProperty A property getter: (feature, propertyName) => property value.
     * @returns {ol/style/Style} An OpenLayers style instance.
     */
    function getGraphicStrokeStyle(linesymbolizer, getProperty) {
        if (!(linesymbolizer.stroke && linesymbolizer.stroke.graphicstroke)) {
            throw new Error(
                'getGraphicStrokeStyle error: linesymbolizer.stroke.graphicstroke null or undefined.'
            );
        }

        return new style.Style({
            renderer: getGraphicStrokeRenderer(linesymbolizer, getProperty),
        });
    }

    /**
     * @private
     * @param  {object} symbolizer SLD symbolizer object.
     * @return {object} OpenLayers style instance corresponding to the stroke of the given symbolizer.
     */
    function lineStyle(symbolizer) {
        if (symbolizer.stroke && symbolizer.stroke.graphicstroke) {
            return getGraphicStrokeStyle(symbolizer);
        }

        return new style.Style({
            stroke: getSimpleStroke(symbolizer.stroke),
        });
    }

    var cachedLineStyle = memoizeStyleFunction(lineStyle);

    /**
     * @private
     * Get an OL line style instance for a feature according to a symbolizer.
     * @param {object} symbolizer SLD symbolizer object.
     * @returns {ol/Style} OpenLayers style instance.
     */
    function getLineStyle(symbolizer) {
        return cachedLineStyle(symbolizer);
    }

    /* eslint-disable function-call-argument-newline */

    function createPattern(graphic) {
        var ref = getCachedImage(
            graphic.externalgraphic.onlineresource
        );
        var image = ref.image;
        var width = ref.width;
        var height = ref.height;
        var cnv = document.createElement('canvas');
        var ctx = cnv.getContext('2d');

        // Calculate image scale factor.
        var imageRatio = has.DEVICE_PIXEL_RATIO;
        if (graphic.size && height !== graphic.size) {
            imageRatio *= graphic.size / height;
        }

        // Draw image to canvas directly if no scaling necessary.
        if (imageRatio === 1) {
            return ctx.createPattern(image, 'repeat');
        }

        // Scale the image by drawing onto a temp canvas.
        var tempCanvas = document.createElement('canvas');
        var tCtx = tempCanvas.getContext('2d');
        tempCanvas.width = width * imageRatio;
        tempCanvas.height = height * imageRatio;
        // prettier-ignore
        tCtx.drawImage(
            image,
            0, 0, width, height,
            0, 0, width * imageRatio, height * imageRatio
        );

        return ctx.createPattern(tempCanvas, 'repeat');
    }

    function getExternalGraphicFill(symbolizer) {
        var ref = symbolizer.fill.graphicfill;
        var graphic = ref.graphic;
        var fillImageUrl = graphic.externalgraphic.onlineresource;

        // Use fallback style when graphicfill image hasn't been loaded yet.
        switch (getImageLoadingState(fillImageUrl)) {
            case IMAGE_LOADED:
                return new style.Fill({
                    color: createPattern(symbolizer.fill.graphicfill.graphic),
                });
            case IMAGE_LOADING:
                return imageLoadingPolygonStyle.getFill();
            case IMAGE_ERROR:
                return imageErrorPolygonStyle.getFill();
            default:
                // Load state of an image should be known at this time, but return 'loading' style as fallback.
                return imageLoadingPolygonStyle.getFill();
        }
    }

    function polygonStyle(symbolizer) {
        var fillImageUrl =
            symbolizer.fill &&
            symbolizer.fill.graphicfill &&
            symbolizer.fill.graphicfill.graphic &&
            symbolizer.fill.graphicfill.graphic.externalgraphic &&
            symbolizer.fill.graphicfill.graphic.externalgraphic.onlineresource;

        var polygonFill = fillImageUrl
            ? getExternalGraphicFill(symbolizer)
            : getSimpleFill(symbolizer.fill);

        // When a polygon has a GraphicStroke, use a custom renderer to combine
        // GraphicStroke with fill. This is needed because a custom renderer
        // ignores any stroke, fill and image present in the style.
        if (symbolizer.stroke && symbolizer.stroke.graphicstroke) {
            var renderGraphicStroke = getGraphicStrokeRenderer(symbolizer);
            return new style.Style({
                renderer: function (pixelCoords, renderState) {
                    // First render the fill (if any).
                    if (polygonFill) {
                        var feature = renderState.feature;
                        var context = renderState.context;
                        var render$1 = render.toContext(context);
                        render$1.setFillStrokeStyle(polygonFill, undefined);
                        var geometryType = feature.getGeometry().getType();
                        if (geometryType === 'Polygon') {
                            render$1.drawPolygon(new geom.Polygon(pixelCoords));
                        } else if (geometryType === 'MultiPolygon') {
                            render$1.drawMultiPolygon(new geom.MultiPolygon(pixelCoords));
                        }
                    }

                    // Then, render the graphic stroke.
                    renderGraphicStroke(pixelCoords, renderState);
                },
            });
        }

        var polygonStroke = getSimpleStroke(symbolizer.stroke);

        return new style.Style({
            fill: polygonFill,
            stroke: polygonStroke,
        });
    }

    var cachedPolygonStyle = memoizeStyleFunction(polygonStyle);

    /**
     * @private
     * Get an OL line style instance for a feature according to a symbolizer.
     * @param {object} symbolizer SLD symbolizer object.
     * @returns {ol/Style} OpenLayers style instance.
     */
    function getPolygonStyle(symbolizer) {
        return cachedPolygonStyle(symbolizer);
    }

    /**
     * @private
     * Get the static OL style instance for a text symbolizer.
     * The text and placement properties will be set on the style object at runtime.
     * @param {object} textsymbolizer SLD text symbolizer object.
     * @return {object} openlayers style
     */
    function textStyle(textsymbolizer) {
        if (!(textsymbolizer && textsymbolizer.label)) {
            return emptyStyle;
        }

        // If the label is dynamic, set text to empty string.
        // In that case, text will be set at runtime.
        var labelText = expressionOrDefault(textsymbolizer.label, '');

        var fill = textsymbolizer.fill ? textsymbolizer.fill.styling : {};
        var halo =
            textsymbolizer.halo && textsymbolizer.halo.fill
                ? textsymbolizer.halo.fill.styling
                : {};
        var haloRadius =
            textsymbolizer.halo && textsymbolizer.halo.radius
                ? parseFloat(textsymbolizer.halo.radius)
                : 1;
        var ref = textsymbolizer.font && textsymbolizer.font.styling
            ? textsymbolizer.font.styling
            : {};
        var fontFamily = ref.fontFamily; if (fontFamily === void 0) fontFamily = 'sans-serif';
        var fontSize = ref.fontSize; if (fontSize === void 0) fontSize = 10;
        var fontStyle = ref.fontStyle; if (fontStyle === void 0) fontStyle = '';
        var fontWeight = ref.fontWeight; if (fontWeight === void 0) fontWeight = '';

        var pointplacement =
            textsymbolizer &&
                textsymbolizer.labelplacement &&
                textsymbolizer.labelplacement.pointplacement
                ? textsymbolizer.labelplacement.pointplacement
                : {};

        // If rotation is dynamic, default to 0. Rotation will be set at runtime.
        var labelRotationDegrees = expressionOrDefault(
            pointplacement.rotation,
            0.0
        );

        var displacement =
            pointplacement && pointplacement.displacement
                ? pointplacement.displacement
                : {};
        var offsetX = displacement.displacementx ? displacement.displacementx : 0;
        var offsetY = displacement.displacementy ? displacement.displacementy : 0;

        // OpenLayers does not support fractional alignment, so snap the anchor to the most suitable option.
        var anchorpoint = (pointplacement && pointplacement.anchorpoint) || {};

        var textAlign = 'center';
        var anchorpointx = Number(
            anchorpoint.anchorpointx === '' ? NaN : anchorpoint.anchorpointx
        );
        if (anchorpointx < 0.25) {
            textAlign = 'left';
        } else if (anchorpointx > 0.75) {
            textAlign = 'right';
        }

        var textBaseline = 'middle';
        var anchorpointy = Number(
            anchorpoint.anchorpointy === '' ? NaN : anchorpoint.anchorpointy
        );
        if (anchorpointy < 0.25) {
            textBaseline = 'bottom';
        } else if (anchorpointy > 0.75) {
            textBaseline = 'top';
        }

        // Assemble text style options.
        var textStyleOptions = {
            text: labelText,
            font: (fontStyle + " " + fontWeight + " " + fontSize + "px " + fontFamily),
            offsetX: Number(offsetX),
            offsetY: Number(offsetY),
            rotation: (Math.PI * labelRotationDegrees) / 180.0,
            textAlign: textAlign,
            textBaseline: textBaseline,
            fill: new style.Fill({
                color:
                    fill.fillOpacity && fill.fill && fill.fill.slice(0, 1) === '#'
                        ? hexToRGB(fill.fill, fill.fillOpacity)
                        : fill.fill,
            }),
        };

        // Convert SLD halo to text symbol stroke.
        if (textsymbolizer.halo) {
            textStyleOptions.stroke = new style.Stroke({
                color:
                    halo.fillOpacity && halo.fill && halo.fill.slice(0, 1) === '#'
                        ? hexToRGB(halo.fill, halo.fillOpacity)
                        : halo.fill,
                // wrong position width radius equal to 2 or 4
                width:
                    (haloRadius === 2 || haloRadius === 4
                        ? haloRadius - 0.00001
                        : haloRadius) * 2,
            });
        }

        return new style.Style({
            text: new style.Text(textStyleOptions),
        });
    }

    var cachedTextStyle = memoizeStyleFunction(textStyle);

    /**
     * @private
     * Get an OL text style instance for a feature according to a symbolizer.
     * @param {object} symbolizer SLD symbolizer object.
     * @param {ol/Feature} feature OpenLayers Feature.
     * @param {Function} getProperty A property getter: (feature, propertyName) => property value.
     * @returns {ol/Style} OpenLayers style instance.
     */
    function getTextStyle(symbolizer, feature, getProperty) {
        var olStyle = cachedTextStyle(symbolizer);
        var olText = olStyle.getText();
        if (!olText) {
            return olStyle;
        }

        // Read text from feature and set it on the text style instance.
        var label = symbolizer.label;
        var labelplacement = symbolizer.labelplacement;

        // Set text only if the label expression is dynamic.
        if (label && label.type === 'expression') {
            var labelText = evaluate(label, feature, getProperty);
            // Important! OpenLayers expects the text property to always be a string.
            olText.setText(labelText.toString());
        }

        // Set rotation if expression is dynamic.
        if (labelplacement) {
            var pointPlacementRotation =
                (labelplacement.pointplacement &&
                    labelplacement.pointplacement.rotation) ||
                0.0;
            if (pointPlacementRotation.type === 'expression') {
                var labelRotationDegrees = evaluate(
                    pointPlacementRotation,
                    feature,
                    getProperty
                );
                olText.setRotation((Math.PI * labelRotationDegrees) / 180.0); // OL rotation is in radians.
            }
        }

        // Set line or point placement according to geometry type.
        var geometry = feature.getGeometry
            ? feature.getGeometry()
            : feature.geometry;
        var geometryType = geometry.getType ? geometry.getType() : geometry.type;
        var lineplacement =
            symbolizer &&
                symbolizer.labelplacement &&
                symbolizer.labelplacement.lineplacement
                ? symbolizer.labelplacement.lineplacement
                : null;
        var placement =
            geometryType !== 'point' && lineplacement ? 'line' : 'point';
        olText.setPlacement(placement);

        return olStyle;
    }

    /**
     * @private
     * Get the point located at the middle along a line string.
     * @param {ol/geom/LineString} geometry An OpenLayers LineString geometry.
     * @returns {Array<number>} An [x, y] coordinate array.
     */
    function getLineMidpoint(geometry) {
        // Use the splitpoints routine to distribute points over the line with
        // a point-to-point distance along the line equal to half line length.
        // This results in three points. Take the middle point.
        var splitPoints = splitLineString(geometry, geometry.getLength() / 2, {
            midPoints: false,
        });
        var ref = splitPoints[1];
        var x = ref[0];
        var y = ref[1];
        return [x, y];
    }

    /**
     * @private
     * Get an OL point style instance for a line feature according to a symbolizer.
     * The style will render a point on the middle of the line.
     * @param {object} symbolizer SLD symbolizer object.
     * @param {ol/Feature} feature OpenLayers Feature.
     * @returns {ol/Style} OpenLayers style instance.
     */
    function getLinePointStyle(symbolizer, feature) {
        var geom$1 = feature.getGeometry();
        if (!geom$1) {
            return null;
        }

        var pointStyle = null;
        var geomType = geom$1.getType();
        if (geomType === 'LineString') {
            pointStyle = getPointStyle(symbolizer, feature);
            pointStyle.setGeometry(new geom.Point(getLineMidpoint(geom$1)));
        } else if (geomType === 'MultiLineString') {
            var lineStrings = geom$1.getLineStrings();
            var multiPointCoords = lineStrings.map(getLineMidpoint);
            pointStyle = getPointStyle(symbolizer, feature);
            pointStyle.setGeometry(new geom.MultiPoint(multiPointCoords));
        }

        return pointStyle;
    }

    /**
     * @private
     * Get the point located at the centroid of a polygon.
     * @param {ol/geom/Polygon} geometry An OpenLayers Polygon geometry.
     * @returns {Array<number>} An [x, y] coordinate array.
     */
    function getInteriorPoint(geometry) {
        // Use OpenLayers getInteriorPoint method to get a 'good' interior point.
        var ref = geometry.getInteriorPoint().getCoordinates();
        var x = ref[0];
        var y = ref[1];
        return [x, y];
    }

    /**
     * @private
     * Get an OL point style instance for a line feature according to a symbolizer.
     * The style will render a point on the middle of the line.
     * @param {object} symbolizer SLD symbolizer object.
     * @param {ol/Feature} feature OpenLayers Feature.
     * @returns {ol/Style} OpenLayers style instance.
     */
    function getPolygonPointStyle(symbolizer, feature) {
        var geom$1 = feature.getGeometry();
        if (!geom$1) {
            return null;
        }

        var pointStyle = null;
        var geomType = geom$1.getType();
        if (geomType === 'Polygon') {
            pointStyle = getPointStyle(symbolizer, feature);
            pointStyle.setGeometry(new geom.Point(getInteriorPoint(geom$1)));
        } else if (geomType === 'MultiPolygon') {
            var polygons = geom$1.getPolygons();
            var multiPointCoords = polygons.map(getInteriorPoint);
            pointStyle = getPointStyle(symbolizer, feature);
            pointStyle.setGeometry(new geom.MultiPoint(multiPointCoords));
        }

        return pointStyle;
    }

    var defaultStyles = [defaultPointStyle];

    /**
     * @private
     * Convert symbolizers together with the feature to OL style objects and append them to the styles array.
     * @example appendStyle(styles, point[j], feature, getPointStyle);
     * @param {Array<ol/style>} styles Array of OL styles.
     * @param {object|Array<object>} symbolizers Feature symbolizer object, or array of feature symbolizers.
     * @param {ol/feature} feature OpenLayers feature.
     * @param {Function} styleFunction Function for getting the OL style object. Signature (symbolizer, feature) => OL style.
     * @param {Function} getProperty A property getter: (feature, propertyName) => property value.
     */
    function appendStyle(styles, symbolizers, feature, styleFunction, getProperty) {
        if (Array.isArray(symbolizers)) {
            for (var k = 0; k < symbolizers.length; k += 1) {
                styles.push(styleFunction(symbolizers[k], feature, getProperty));
            }
        } else {
            styles.push(styleFunction(symbolizers, feature, getProperty));
        }
    }

    /**
     * Create openlayers style
     * @example OlStyler(getGeometryStyles(rules), geojson.geometry.type);
     * @param {GeometryStyles} GeometryStyles rulesconverter
     * @param {object|Feature} feature {@link http://geojson.org|geojson}
     *  or {@link https://openlayers.org/en/latest/apidoc/module-ol_Feature-Feature.html|ol/Feature} Changed in 0.0.04 & 0.0.5!
     * @param {Function} getProperty A property getter: (feature, propertyName) => property value.
     * @return ol.style.Style or array of it
     */
    function OlStyler(GeometryStyles, feature, getProperty) {
        var polygon = GeometryStyles.polygon;
        var line = GeometryStyles.line;
        var point = GeometryStyles.point;
        var text = GeometryStyles.text;

        var geometry = feature.getGeometry
            ? feature.getGeometry()
            : feature.geometry;
        var geometryType = geometry.getType ? geometry.getType() : geometry.type;

        var styles = [];
        switch (geometryType) {
            case 'Point':
            case 'MultiPoint':
                for (var j = 0; j < point.length; j += 1) {
                    appendStyle(styles, point[j], feature, getPointStyle, getProperty);
                }
                for (var j$1 = 0; j$1 < text.length; j$1 += 1) {
                    styles.push(getTextStyle(text[j$1], feature, getProperty));
                }
                break;

            case 'LineString':
            case 'MultiLineString':
                for (var j$2 = 0; j$2 < line.length; j$2 += 1) {
                    appendStyle(styles, line[j$2], feature, getLineStyle, getProperty);
                }
                for (var j$3 = 0; j$3 < point.length; j$3 += 1) {
                    appendStyle(styles, point[j$3], feature, getLinePointStyle, getProperty);
                }
                for (var j$4 = 0; j$4 < text.length; j$4 += 1) {
                    styles.push(getTextStyle(text[j$4], feature, getProperty));
                }
                break;

            case 'Polygon':
            case 'MultiPolygon':
                for (var j$5 = 0; j$5 < polygon.length; j$5 += 1) {
                    appendStyle(styles, polygon[j$5], feature, getPolygonStyle, getProperty);
                }
                for (var j$6 = 0; j$6 < line.length; j$6 += 1) {
                    appendStyle(styles, line[j$6], feature, getLineStyle, getProperty);
                }
                for (var j$7 = 0; j$7 < point.length; j$7 += 1) {
                    appendStyle(
                        styles,
                        point[j$7],
                        feature,
                        getPolygonPointStyle,
                        getProperty
                    );
                }
                for (var j$8 = 0; j$8 < text.length; j$8 += 1) {
                    styles.push(getTextStyle(text[j$8], feature, getProperty));
                }
                break;

            default:
                styles = defaultStyles;
        }

        return styles;
    }

    /**
     * @private
     * Extract feature id from an OpenLayers Feature.
     * @param {Feature} feature {@link https://openlayers.org/en/latest/apidoc/module-ol_Feature-Feature.html|ol/Feature}
     * @returns {string} Feature id.
     */
    function getOlFeatureId(feature) {
        return feature.getId();
    }

    /**
     * @private
     * Extract a property value from an OpenLayers Feature.
     * @param {Feature} feature {@link https://openlayers.org/en/latest/apidoc/module-ol_Feature-Feature.html|ol/Feature}
     * @param {string} propertyName The name of the feature property to read.
     * @returns {object} Property value.
     */
    function getOlFeatureProperty(feature, propertyName) {
        return feature.get(propertyName);
    }

    /**
     * Create an OpenLayers style function from a FeatureTypeStyle object extracted from an SLD document.
     *
     * **Important!** When using externalGraphics for point styling, make sure to call .changed() on the layer
     * inside options.imageLoadedCallback to immediately see the loaded image. If you do not do this, the
     * image icon will only become visible the next time OpenLayers draws the layer (after pan or zoom).
     * @param {FeatureTypeStyle} featureTypeStyle Feature Type Style object.
     * @param {object} options Options
     * @param {function} options.convertResolution An optional function to convert the resolution in map units/pixel to resolution in meters/pixel.
     * When not given, the map resolution is used as-is.
     * @param {function} options.imageLoadedCallback Optional callback that will be called with the url of an externalGraphic when
     * an image has been loaded (successfully or not). Call .changed() inside the callback on the layer to see the loaded image.
     * @param {function} options.getProperty Optional custom property getter: (feature, propertyName) => property value.
     * @returns {Function} A function that can be set as style function on an OpenLayers vector style layer.
     * @example
     * myOlVectorLayer.setStyle(SLDReader.createOlStyleFunction(featureTypeStyle, {
     *   imageLoadedCallback: () => { myOlVectorLayer.changed(); }
     * }));
     */
    function createOlStyleFunction(featureTypeStyle, options) {
        if (options === void 0) options = {};

        var imageLoadedCallback = options.imageLoadedCallback || (function () { });

        // Keep track of whether a callback has been registered per image url.
        var callbackRef = {};

        return function (feature, mapResolution) {
            // Determine resolution in meters/pixel.
            var resolution =
                typeof options.convertResolution === 'function'
                    ? options.convertResolution(mapResolution)
                    : mapResolution;

            var getProperty =
                typeof options.getProperty === 'function'
                    ? options.getProperty
                    : getOlFeatureProperty;

            // Determine applicable style rules for the feature, taking feature properties and current resolution into account.
            var rules = getRules(featureTypeStyle, feature, resolution, {
                getProperty: getProperty,
                getFeatureId: getOlFeatureId,
            });

            // Start loading images for external graphic symbolizers and when loaded:
            // * update symbolizers to use the cached image.
            // * call imageLoadedCallback with the image url.
            processExternalGraphicSymbolizers(
                rules,
                featureTypeStyle,
                imageLoadedCallback,
                callbackRef
            );

            // Convert style rules to style rule lookup categorized by geometry type.
            var geometryStyles = getGeometryStyles(rules);

            // Determine style rule array.
            var olStyles = OlStyler(geometryStyles, feature, getProperty);

            return olStyles;
        };
    }

    exports.OlStyler = OlStyler;
    exports.Reader = Reader;
    exports.createOlStyleFunction = createOlStyleFunction;
    exports.getByPath = getByPath;
    exports.getGeometryStyles = getGeometryStyles;
    exports.getLayer = getLayer;
    exports.getLayerNames = getLayerNames;
    exports.getRuleSymbolizers = getRuleSymbolizers;
    exports.getRules = getRules;
    exports.getStyle = getStyle;
    exports.getStyleNames = getStyleNames;

    Object.defineProperty(exports, '__esModule', { value: true });

}));

class Kaartgegevens {

    constructor() {
        this._GeoJSON = {};
        this._Symbolisaties = {};
    }

    VoegDataToe(naam, geoJSON) {
        this._GeoJSON[naam] = geoJSON;
        return this;
    }

    VoegSymbolisatieToe(naam, symbolisatie) {
        this._Symbolisaties[naam] = SLDReader.createOlStyleFunction(
            SLDReader.getStyle(
                SLDReader.getLayer(
                    SLDReader.Reader(`<?xml version="1.0" encoding="UTF-8"?>
<StyledLayerDescriptor xmlns="http://www.opengis.net/sld" version="1.1.0">
    <NamedLayer>
        <Name>Symbolisatie</Name>
        <UserStyle>
            <Name>Symbolisatie</Name>
` + symbolisatie + `
        </UserStyle>
    </NamedLayer>
</StyledLayerDescriptor>`)
                ), 'Symbolisatie'
            ).featuretypestyles[0]
        );
        return this;
    }

    static Instantie = new Kaartgegevens();
}


class Kaart {
    constructor() {
        this._Toplagen = [];
        this._Lagen = [];
        this._ToonSlider = false;
        this._LagenMetProperties = 0;
    }
    static EPSG28992 = new ol.proj.Projection('urn:ogc:def:crs:EPSG::28992');

    VoegLaagToe(naam, dataNaam, symbolisatieNaam) {
        var geoJson = Kaartgegevens.Instantie._GeoJSON[dataNaam];
        var layer = new ol.layer.Vector({
            source: new ol.source.Vector({
                features: (new ol.format.GeoJSON()).readFeatures(geoJson),
                projection: Kaart.EPSG28992
            }),
            style: Kaartgegevens.Instantie._Symbolisaties[symbolisatieNaam]
        });
        this._Lagen.push(layer);

        layer._Naam = naam;
        if (geoJson.properties !== undefined) {
            this._LagenMetProperties++;
            layer._PopupNaam = naam;
            layer._PopupProperties = geoJson.properties;
            layer._ToonInPopup = true;
        } else {
            layer._ToonInPopup = false;
        }
        layer._AanUit = false;
        return this;
    }
    AlsAanUitLaag(toonInitieel = true) {
        var layer = this._Lagen[this._Lagen.length - 1];
        layer._AanUit = layer._Naam;
        layer.setVisible(toonInitieel);
        return this;
    }
    AlsOudLaag() {
        var layer = this._Lagen[this._Lagen.length - 1];
        if (layer._PopupNaam) {
            layer._PopupNaam += ' (origineel)'
        }
        var self = this;
        layer.on('prerender', function (event) {
            var ctx = event.context;
            ctx.save();
            ctx.beginPath();
            ctx.rect(0, 0, self._SliderPositie, ctx.canvas.height);
            ctx.clip();
        });

        layer.on('postrender', function (event) {
            var ctx = event.context;
            ctx.restore();
        });
        this._ToonSlider = true;
        return this;
    }
    AlsNieuwLaag() {
        var layer = this._Lagen[this._Lagen.length - 1];
        if (layer._PopupNaam) {
            layer._PopupNaam += ' (nieuw)'
        }
        var self = this;
        layer.on('prerender', function (event) {
            var ctx = event.context;
            ctx.save();
            ctx.beginPath();
            ctx.rect(self._SliderPositie, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.clip();
        });

        layer.on('postrender', function (event) {
            var ctx = event.context;
            ctx.restore();
        });
        this._ToonSlider = true;
        return this;
    }
    LimiteerZoomLevel(minZoom, maxZoom) {
        var layer = this._Lagen[this._Lagen.length - 1];
        layer.setMinZoom(minZoom);
        layer.setMaxZoom(maxZoom);
    }

    Toon(opties) {
        var self = this;
        // Bepaal eerst welk deel van Nederland getoond moet worden
        var kaartElement = document.getElementById(opties['kaartelementId']);
        kaartElement.style.width = opties['kaartelementWidth'] + "px"
        kaartElement.style.height = opties['kaartelementHeight'] + "px"
        var legeRuimteOmGeometrie = 0.25;
        if (!('bbox' in opties)) {
            opties['bbox'] = Kaart._BRT_BBox;
            legeRuimteOmGeometrie = 0;
        }
        var zoomLevel = 6;
        var zoomLevelX = Math.max(Math.floor(Math.log2((opties['kaartelementWidth'] * (1 - legeRuimteOmGeometrie) * Kaart._BRT_Resolutions[0]) / (opties['bbox'][2] - opties['bbox'][0]))), 0);
        var zoomLevelY = Math.max(Math.floor(Math.log2((opties['kaartelementHeight'] * (1 - legeRuimteOmGeometrie) * Kaart._BRT_Resolutions[0]) / (opties['bbox'][3] - opties['bbox'][1]))), 0);
        zoomLevel += (zoomLevelX < zoomLevelY ? zoomLevelX : zoomLevelY);
        this._SliderPositie = opties['kaartelementWidth'] / 2;

        // Achtergrondkaart
        var matrixIds = [];
        for (var z = 0; z < Kaart._BRT_Resolutions.length; z++) {
            matrixIds.push('urn:ogc:def:crs:EPSG::28992:' + z);
        }
        self._Lagen.splice(0, 0, new ol.layer.Tile({
            extent: Kaart._BRT_BBox,
            source: new ol.source.WMTS({
                url: 'https://service.pdok.nl/brt/achtergrondkaart/wmts/v2_0',
                layer: 'pastel',
                matrixSet: 'EPSG:28992',
                format: 'image/png',
                projection: Kaart.EPSG28992,
                tileGrid: new ol.tilegrid.WMTS({
                    origin: ol.extent.getTopLeft(Kaart._BRT_BBox),
                    resolutions: Kaart._BRT_Resolutions,
                    matrixIds: matrixIds
                })
            })
        }));

        // Tot slot de overlays / popup
        var mapOverlays = []
        const popup_content = document.getElementById(opties['kaartelementId'] + '_popup-content');
        const popup_closer = document.getElementById(opties['kaartelementId'] + '_popup-closer');
        var popup_overlay = false;
        if (this._LagenMetProperties > 0) {
            // Popup wordt als overlay op de kaart getoond
            popup_overlay = new ol.Overlay({
                element: document.getElementById(opties['kaartelementId'] + '_popup'),
                autoPan: true,
                autoPanAnimation: {
                    duration: 250
                }
            });
            mapOverlays.push(popup_overlay);

            popup_closer.onclick = function () {
                popup_overlay.setPosition(undefined);
                popup_closer.blur();
                return false;
            };
        } else {
            var popup = document.getElementById(opties['kaartelementId'] + '_popup');
            if (popup) {
                popup.remove();
            }
        }

        // Maak het kaartbeeld
        var view = new ol.View({
            center: ol.extent.getCenter(opties['bbox']),
            zoom: zoomLevel,
            maxZoom: ('maxZoom' in opties ? opties['maxZoom'] : 24)
        });
        var map = new ol.Map({
            layers: self._Lagen,
            overlays: mapOverlays,
            target: opties['kaartelementId'],
            view: view
        });
        map.addControl(new ol.control.ScaleLine({ units: 'metric' }));
        map.render();

        if (this._LagenMetProperties > 0) {
            // Vulling van de popup
            const toonNamen = (this._LagenMetProperties > 1);
            map.on('click', function (e) {
                var content = false;
                map.forEachFeatureAtPixel(e.pixel, function (feature, layer) {
                    if (layer._ToonInPopup) {
                        var attr = feature.getProperties();
                        if (content === false) {
                            content = '';
                        }
                        if (toonNamen) {
                            content += '<div><b>' + layer._PopupNaam + '</b></div>';
                        }
                        for (var prop in layer._PopupProperties) {
                            var info = layer._PopupProperties[prop]
                            content += '<div>' + info[0] + ': ' + attr[prop] + (info[1] ? ' ' + info[1] : '') + '</div>';
                        }
                    }
                });
                if (content !== false) {
                    popup_content.innerHTML = content;
                    popup_overlay.setPosition(e.coordinate);
                }
            });
        }
        if (this._ToonSlider) {
            new Slider(kaartElement, function (positie) {
                self._SliderPositie = positie;
                map.render();
            })
        }

        var aanUitLagen = [];
        for (var i = self._Lagen.length - 1; i >= 0; i--) {
            if (self._Lagen[i]._AanUit) {
                aanUitLagen.push(self._Lagen[i]);
            }
        }
        var aanUitLagenElt = null;
        if (aanUitLagen.length > 0 || 'juridische-nauwkeurigheid' in opties) {
            var elt = document.createElement('p');
            kaartElement.insertAdjacentElement('afterend', elt); var parent = elt;
            elt = document.createElement('table'); parent.appendChild(elt); parent = elt;
            elt = document.createElement('tr'); parent.appendChild(elt); parent = elt;
            elt = document.createElement('td'); parent.appendChild(elt);
            if (aanUitLagen.length > 0) {
                aanUitLagenElt = elt
                aanUitLagenElt.innerHTML = 'Gegevens in de kaart die wel/niet zichtbaar gemaakt kunnen worden:</br>';
            }
            if ('juridische-nauwkeurigheid' in opties) {
                elt.width = '100%';
                elt = document.createElement('td'); parent.appendChild(elt);
                new TekenNauwkeurigheidSchaal(opties['juridische-nauwkeurigheid'], elt, opties['kaartelementId'], view);
            }
        }

        this._AanUitLagen = {};
        for (var i = 0; i < aanUitLagen.length; i++) {
            if (aanUitLagen[i]._AanUit) {
                if (i > 0) {
                    aanUitLagenElt.append(document.createElement('br'));
                }
                var ctrl = document.createElement('input');
                ctrl.type = 'checkbox';
                ctrl.id = opties['kaartelementId'] + '_laag_' + i;
                ctrl.checked = aanUitLagen[i].getVisible();
                aanUitLagenElt.append(ctrl);
                var label = document.createElement('label');
                label.htmlFor = ctrl.id;
                label.innerText = aanUitLagen[i]._AanUit
                aanUitLagenElt.append(label);
                this._AanUitLagen[ctrl.id] = [];
                for (var j = aanUitLagen.length - 1; j >= i; j--) {
                    if (aanUitLagen[j]._AanUit == aanUitLagen[i]._AanUit) {
                        this._AanUitLagen[ctrl.id].push(aanUitLagen[j]);
                        aanUitLagen[j]._AanUit = false;
                    }
                }
                ctrl.addEventListener('click', (e) => {
                    var layers = self._AanUitLagen[e.srcElement.id];
                    for (var k = 0; k < layers.length; k++) {
                        layers[k].setVisible(e.srcElement.checked);
                    }
                });
            }
        }
    }

    static _BRT_BBox = [-285401.92, 22598.08, 595401.9199999999, 903401.9199999999];
    static _BRT_Resolutions = [3440.64, 1720.32, 860.16, 430.08, 215.04, 107.52, 53.76, 26.88, 13.44, 6.72, 3.36, 1.68, 0.84, 0.42, 0.21];
}

class TekenNauwkeurigheidSchaal {
    constructor(juridischeNauwkeurigheid, inElement, kaartElementId, view) {
        inElement.style.textAlign = 'center';
        inElement.style.whiteSpace = 'nowrap';
        inElement.innerHTML = 'Juridische&nbsp;nauwkeurigheid<br><div id="' + kaartElementId + '_tn" class="juridische_nauwkeurigheid"></div></br>' + juridischeNauwkeurigheid + '&nbsp;decimeter</br>';
        this._JuridischeNauwkeurigheid = juridischeNauwkeurigheid / 10;
        this._View = view;
        this._SchaalElement = document.getElementById(kaartElementId + '_tn');
        this._Schaal();
        var self = this;
        view.on('change:resolution', function () {
            self._Schaal();
        });
    }
    _Schaal() {
        var resolution = this._View.getResolution();
        if (resolution) {
            var pixels = this._JuridischeNauwkeurigheid / resolution;
            if (pixels < 1) {
                this._SchaalElement.style.display = 'none';
            } else {
                this._SchaalElement.style.width = pixels + 'px';
                this._SchaalElement.style.height = pixels + 'px';
                this._SchaalElement.style.display = 'inline-block';
            }
        } else {
            this._SchaalElement.style.display = 'none';
        }
    }
}

class Slider {
    // Inspiratie: https://www.w3schools.com/howto/howto_js_image_comparison.asp
    constructor(kaartElement, onSlide) {
        this._Kaartelement = kaartElement;
        var kaartRect = this._Kaartelement.getBoundingClientRect();
        this._Width = kaartRect.right - kaartRect.left;
        this._OnSlide = onSlide;
        this._Clicked = false;

        this._Sliders = [document.createElement("DIV"), document.createElement("DIV")];
        this._Sliders[0].setAttribute("class", "kaart-slider knop");
        this._Sliders[1].setAttribute("class", "kaart-slider lijn");
        this._Sliders[1].style.height = (kaartRect.bottom - kaartRect.top) + "px";
        var self = this;
        var centerY = - (kaartRect.bottom - kaartRect.top) / 2;
        for (var i = 0; i < this._Sliders.length; i++) {
            var slider = this._Sliders[i];
            this._Kaartelement.appendChild(slider);
            slider.style.top = (centerY - slider.offsetHeight / 2) + "px";
            slider.style.left = (this._Width / 2 - slider.offsetWidth / 2) + "px";
            slider.addEventListener("mousedown", (e) => self._SlideReady(e));
            window.addEventListener("mouseup", (e) => self._SlideFinish(e));
            slider.addEventListener("touchstart", (e) => self._SlideReady(e));
            var sliderRect = slider.getBoundingClientRect();
            centerY -= sliderRect.bottom - sliderRect.top;
        }
    }
    _SlideReady(e) {
        e.preventDefault();
        this._Clicked = true;
        var self = this;
        window.addEventListener("mousemove", (e) => self._SlideMove(e));
        window.addEventListener("touchmove", (e) => self._SlideMove(e));
    }
    _SlideFinish() {
        this._Clicked = false;
    }
    _SlideMove(e) {
        if (!this._Clicked) return false;
        var pos = this._GetCursorPos(e)
        if (pos < 0) pos = 0;
        if (pos > this._Width) pos = this._Width;
        for (var i = 0; i < this._Sliders.length; i++) {
            var slider = this._Sliders[i]
            slider.style.left = (pos - (slider.offsetWidth / 2)) + "px";
        }
        this._OnSlide(pos)
    }
    _GetCursorPos(e) {
        e = (e.changedTouches) ? e.changedTouches[0] : e;
        var a = this._Kaartelement.getBoundingClientRect();
        var x = e.pageX - a.left;
        x = x - window.pageXOffset;
        return x;
    }
}


    </script>
</head>
<body>
<h1>GIO-wijziging</h1><p>Inhoudsopgave? <span id="accordion-sluiten" class="aslink">Verberg</span> alle teksten.</p>
<table><tr><td><button data-accordion="13" class="accordion_t active">?</button></td>
<td data-accordion-titel="13" class="accordion_t_titel" style="display: none">&#8678;Beschrijving van dit scenario</td>
<td data-accordion-paneel="13" class="accordion_t_paneel" style="display: block">
Uitleg van nut en noodzaak van de juridische nauwkeurigheid bij het opstellen van een GIO-wijziging.</p><p>STOP moet iets zeggen over de nauwkeurigheid van geometrie om geautomatiseerd te kunnen bepalen of en hoe een geometrie is gewijzigd. Een jurist die een gebied intekent of overneemt zal dat niet met een oneindige precisie doen maar eerder met een "dikke pen". Kleine veranderingen zullen niet gezien worden als een echte wijziging ("als ik een wijziging bedoeld had zou ik het wel duidelijk ingetekend hebben"), maar als de veranderingen groot genoeg zijn moeten ze wel gedetecteerd worden.</p><p>De "dikte van de pen" wordt <b>juridische nauwkeurigheid</b> genoemd. Dit voorbeeld laat zien hoe dat eruit ziet.
</td></tr></table>

<div class="sectie_toon_geo"><h2>Geo-informatieobjecten</h2>
<button data-accordion="14" class="accordion_h active"><h3>1. Voorbeeld noodmaatregel</h3></button>
<div data-accordion-paneel="14" class="accordion_h_paneel" style="display: block">
<p>Er zijn allerlei voorbeelden te vinden waar het tekenen met de "dikke pen" terug te zien is. Bijvoorbeeld de aanwijzing van een park als onderdeel van een noodverordening (barbecueverbod in verband met SARS-CoV-2). In de noodverordening is een vrij grove manier gebruikt. Als een  meer gedetailleerde vorm al voorhanden is omdat het park al als geometrie bekend was zal die gebruikt worden, maar er is juridisch geen reden voor het bevoegd gezag om de gedetailleerde vorm te gaan samenstellen als het gebied voor het eerst getekend moet worden.</p><p style="text-align: center"><img src="data:image/png;base64,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"/></p><p>Het zal een bewuste keuze zijn geweest om de grenzen globaal aan te geven. Als de noodverordening in STOP was gemaakt, dan had die er als in onderstaande kaart uitgezien. Maar bij inzoomen tot maximaal zoomniveau geeft het een verkeerde indruk: het lijkt net alsof de lijn zeer precies is ingetekend. Als het bevoegd gezag dat detailniveau een correct uitziende geometrie had willen hebben, dan had zij bijvoorbeeld de geometrie moeten uitlijnen ten opzichte van het stratenplan, maar dat is veel meer werk en zou het doel voorbij schieten. Om toch een grovere geometrie te kunnen gebruiken kent STOP de juridische nauwkeurigheid waarmee de "dikte van de pen" aangegeven kan worden. De juridische nauwkeurigheid zegt niet waar precies de juridische regels gelden: er kan best in de tekst staan hoe ver van de rand de regels gelden, dat hoeft niet visueel weergegeven te worden.</p><p>De "dikte van de pen" kan in onderstaande kaart weergegeven worden door de <i>juridische nauwkeurigheid</i> aan te zetten.</p>
Bestand: 1. Voorbeeld noodmaatregel.gml
<div id="kaart_5" class="kaart">
</div>
<div id="kaart_5_popup" class="ol-popup">
    <a href="#" id="kaart_5_popup-closer" class="ol-popup-closer"></a>
    <div id="kaart_5_popup-content" class="ol-popup-content"></div>
</div>

<p>De GIO-versie is met een juridische nauwkeurigheid van 100 decimeter opgesteld.
                Een GIO-viewer zou dat kunnen laten zien en/of gebruiken om het maximale zoom-niveau in te perken. Een viewer kan ook andere schaal-afhankelijke vereenvoudigingen doorvoeren,
                bijvoorbeeld vereenvoudiging van geometrieën en/of het clusteren van vrijwel onzichtbare geometrieën, zoals in deze kaart gedaan is:.</p>
<div id="kaart_6" class="kaart">
</div>
<div id="kaart_6_popup" class="ol-popup">
    <a href="#" id="kaart_6_popup-closer" class="ol-popup-closer"></a>
    <div id="kaart_6_popup-content" class="ol-popup-content"></div>
</div>

</div>

</div><div class="sectie_toon_geo_alt1">
<button data-accordion="15" class="accordion_h active"><h3>2. Gebruik bestaande geometrie</h3></button>
<div data-accordion-paneel="15" class="accordion_h_paneel" style="display: block">
<p>Het is niet verplicht om de geometrie altijd te tekenen met een pen van voldoende dikte. Soms heeft het meerwaarde om een bestaande (gedetailleerde) geometrie over te nemen, of voor de herkenbaarheid een bestaande geometrie te gebruiken. In onderstaande kaart is de juridische nauwkeurigheid in de orde van kilometers, en een van de gebieden is het ambtsgebied van een gemeente. Het zou vreemd zijn om dat gebied voor gebruik in dit GIO opzettelijk minder gedetailleerd te gaan tekenen. In het GIO zal de bestaande geometrie gebruikt worden. Maar de exacte ligging van de verschillende enclaves is niet zo van belang, voor de juridische regels geldt nog steeds dat het gebied met een "dikke pen" aangegeven kan worden.</p>
Bestand: 2. Gebruik bestaande geometrie.gml
<div id="kaart_14" class="kaart">
</div>
<div id="kaart_14_popup" class="ol-popup">
    <a href="#" id="kaart_14_popup-closer" class="ol-popup-closer"></a>
    <div id="kaart_14_popup-content" class="ol-popup-content"></div>
</div>

</div>

</div><div class="sectie_toon_geo_alt2">
<button data-accordion="16" class="accordion_h active"><h3>3. Twee gebieden initieel</h3></button>
<div data-accordion-paneel="16" class="accordion_h_paneel" style="display: block">
<p>De juridische nauwkeurigheid is voor STOP van belang om te kunnen detecteren wanneer een geometrie wijzigt. Als een GIO initieel wordt opgesteld kan het nog lijken dat alle geometrie heel gedetailleerd is ingetekend. Maar de hoekigheid van de verstroking van de cirkel laat al zien wat de orde van grootte van de juridische nauwkeurigheid is.</p>
Bestand: 3. Twee gebieden initieel.gml
<div id="kaart_18" class="kaart">
</div>
<div id="kaart_18_popup" class="ol-popup">
    <a href="#" id="kaart_18_popup-closer" class="ol-popup-closer"></a>
    <div id="kaart_18_popup-content" class="ol-popup-content"></div>
</div>

</div>

</div><div class="sectie_toon_geo_alt1">
<button data-accordion="17" class="accordion_h active"><h3>4. Twee gebieden na wijziging</h3></button>
<div data-accordion-paneel="17" class="accordion_h_paneel" style="display: block">
<p>Als de gebieden gewijzigd worden en een van de twee opnieuw verstrookt wordt, passen de twee geometrieën niet meer zo netjes op elkaar. Maar de overlap is klein ten opzichte van de "dikte van de pen", en is juridisch niet relevant.</p>
Bestand: 4. Twee gebieden na wijziging.gml
<div id="kaart_22" class="kaart">
</div>
<div id="kaart_22_popup" class="ol-popup">
    <a href="#" id="kaart_22_popup-closer" class="ol-popup-closer"></a>
    <div id="kaart_22_popup-content" class="ol-popup-content"></div>
</div>

</div>

</div>
<div class="sectie_maak_gio_wijziging"><h2>Maak GIO-wijziging</h2>
<button data-accordion="18" class="accordion_h active"><h3>3. Twee gebieden initieel &rarr; 4. Twee gebieden na wijziging</h3></button>
<div data-accordion-paneel="18" class="accordion_h_paneel" style="display: block">
<p>Als de GIO-wijziging berekend wordt voor de verandering van de eerdere naar de latere versie van het GIO, dan zouden alleen de rechthoekige stukken aangemerkt moeten worden als de plaatsen waar de geometrie daadwerkelijk gewijzigd is. Dat wordt in onderstaande kaart weergegeven. De wijzigmarkeringen zijn iets kleiner dan het gebied daadwerkelijk wijzigt (dat is het </p><p>Sla de beschrijving van de berekening over - dat wordt in een later voorbeeld toegelicht. Selecteer in de kaart alleen de <i>Originelen</i> en <i>Wijzigmarkeringen</i>. Beweeg de blauwe lijn en bal heen en weer om de originele en de nieuwe versie te zien.</p>
<table><tr><td><button data-accordion="19" class="accordion_t">?</button></td>
<td data-accordion-titel="19" class="accordion_t_titel" style="display: block">&#8678;Bepaling GIO-Wijziging</td>
<td data-accordion-paneel="19" class="accordion_t_paneel" style="display: none">
<p>Bij de bepaling van de GIO-wijziging wordt ervan uitgegaan dat de beide GIO-versies aan de kwaliteitseisen voldoen. 
            Deze kunnen gecontroleerd worden als onderdeel van het <a href="https://github.com/STOPwerk/Geo-tools//toon_geo" target="_blank">tonen van een GIO-versie</a>.
            De bepaling bestaat uit de volgende stappen:</p>
            <p><ol><li>Bepaal de te verwijderen en toe te voegen locaties waarvan de geometrie is gewijzigd.
            Dit zijn alle locaties met een basisgeometrie-id die alleen in de originele en nieuwe versie terugkomt.
 Het gaat om 2 locaties uit de originele versie en 2 locaties uit de nieuwe versie</li>
<li>De locaties met een manifest ongewijzigde geometrie die in beide versies een verschillende waarde voor het label hebben 
            moet als revisie toegevoegd worden. Het betreft 0 locaties.</li>
<li>Bepaal de wijzigmarkeringen. Hierbij wordt bedoeld met:<ul>
            <li>De "buitenrand" van een geometrie: de buitenste rand van de geometrie van een locatie getekend met een "dikke pen":<br/>
            <code>buitenrand = locatie.geometrie.<a href="https://shapely.readthedocs.io/en/stable/reference/shapely.buffer.html#shapely.buffer" target="_blank">buffer</a> (juridische nauwkeurigheid / 2)</code></li>
            <li>De "buitenrand" van meerdere geometrieën: de "buitenrand" van de <a href="https://shapely.readthedocs.io/en/stable/reference/shapely.union.html#shapely.union" target="_blank">union</a> (geometrieën)
            <li>Het "binnengebied": de binnenste rand van de geometrie getekend met een "dikke pen":<br/>
            <code>binnengebied = locatie.geometrie</code> voor een punt of lijn,<br/>
            <code>binnengebied = locatie.geometrie.<a href="https://shapely.readthedocs.io/en/stable/reference/shapely.buffer.html#shapely.buffer" target="_blank">buffer</a> (- juridische nauwkeurigheid / 2)</code> voor vlakken.</li></ul>
            <li>Het "binnengebied" van meerdere geometrieën:<br/>
            <code>binnengebied = <a href="https://shapely.readthedocs.io/en/stable/reference/shapely.union.html#shapely.union" target="_blank">union</a> (binnengebieden van de geometrieën)</code> voor punten of lijnen,<br/>
            <code>binnengebied = (buitenrand van de geometrieën).<a href="https://shapely.readthedocs.io/en/stable/reference/shapely.buffer.html#shapely.buffer" target="_blank">buffer</a> (- juridische nauwkeurigheid)</code> voor vlakken.<br/>
            De manier van samenvoegen van vlakken zorgt ervoor dat vlakken die net niet op elkaar aansluiten toch als aansluitend gezien worden.</li></ul>
            De wijzigmarkeringen worden opgesplitst in enkelvoudige geometrieën (punt, lijn, vlak) om bij weergave clustering te vereenvoudigen. Ze worden in meerdere stappen bepaald:
            <ol>
<li>De delen van de locaties uit de originele versie waar geen enkele juridische regel meer geldt.
            Oftewel: het deel van de binnengebieden van locaties uit de originele versie dat niet binnen de buitenranden ligt van de locaties uit de nieuwe versie:<br/>
            <code>was_geometrie = binnengebied van alle geometrieën uit originele versie</code><br/>
            <code>wordt_geometrie = de buitenrand van alle geometrieën uit de nieuwe versie</code><br/>
            <code>wijzigmarkering = was_geometrie.<a href="https://shapely.readthedocs.io/en/stable/reference/shapely.difference.html#shapely.difference" target="_blank">difference</a> (wordt_geometrie)</code><br/>
            
Dit levert 1 markering op.</li>
<li>De delen van de locaties uit de nieuwe versie waar de juridische regel voor het eerst gaan gelden.
                Oftewel: het deel van de binnengebieden van locaties uit de nieuwe versie dat niet binnen de buitenranden ligt van de locaties uit de originele versie:<br/>
                <code>wordt_geometrie = binnenebied van alle geometrieën uit nieuwe versie</code><br/>
                <code>was_geometrie = buitenrand van alle geometrieën uit originele versie</code><br/>
                <code>wijzigmarkering = wordt_geometrie.<a href="https://shapely.readthedocs.io/en/stable/reference/shapely.difference.html#shapely.difference" target="_blank">difference</a> (was_geometrie)</code><br/>
                
Dit levert 1 markering op.</li>
</ol></li></ol>
</td></tr></table>

<div id="kaart_24" class="kaart">
</div>
<div id="kaart_24_popup" class="ol-popup">
    <a href="#" id="kaart_24_popup-closer" class="ol-popup-closer"></a>
    <div id="kaart_24_popup-content" class="ol-popup-content"></div>
</div>

<table><tr><td><button data-accordion="20" class="accordion_t">?</button></td>
<td data-accordion-titel="20" class="accordion_t_titel" style="display: block">&#8678;GML voor GIO-Wijziging</td>
<td data-accordion-paneel="20" class="accordion_t_paneel" style="display: none">

<p>De GIO-wijziging is een GML bestand waarin de vaststellingscontext nog aangepast moet worden:</p>
<textarea id="resultaat_44" class="resultaat"
 name="wijziging"
>
&lt;geo:GeoInformatieObjectVaststelling schemaversie="2.0.0-rc" xmlns:basisgeo="http://www.geostandaarden.nl/basisgeometrie/1.0" xmlns:geo="https://standaarden.overheid.nl/stop/imop/geo/" xmlns:gio="https://standaarden.overheid.nl/stop/imop/gio/" xmlns:gml="http://www.opengis.net/gml/3.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="https://standaarden.overheid.nl/stop/imop/geo/
  https://standaarden.overheid.nl/stop/2.0.0-rc/imop-geo.xsd"&gt;

    &lt;geo:vastgesteldeVersie&gt;
        &lt;geo:GeoInformatieObjectMutatie&gt;
            &lt;geo:FRBRWork&gt;/join/id/regdata/mnre9999/2022/uitleg2&lt;/geo:FRBRWork&gt;
            &lt;geo:FRBRExpression&gt;/join/id/regdata/mnre9999/2022/uitleg2/nld@2022;4&lt;/geo:FRBRExpression&gt;
            &lt;geo:juridischeNauwkeurigheid&gt;50&lt;/geo:juridischeNauwkeurigheid&gt;
            &lt;geo:locatieMutaties&gt;
                &lt;geo:LocatieMutatie&gt;
                    &lt;geo:naam&gt;Binnengebied&lt;/geo:naam&gt;
                    &lt;geo:geometrie&gt;
                        &lt;basisgeo:Geometrie&gt;
                            &lt;basisgeo:id&gt;37b0a09f-36a0-4e69-80c2-000000000002&lt;/basisgeo:id&gt;
                            &lt;basisgeo:geometrie&gt;
                                &lt;gml:Polygon srsName="urn:ogc:def:crs:EPSG::28992"&gt;&lt;gml:exterior&gt;&lt;gml:LinearRing&gt;&lt;gml:posList&gt;85853.0 447597.0 85861.81678 447594.1353 85867.26585 447586.6353 85867.26585 447577.3647 85861.81678 447569.8647 85853.0 447567.0 85844.18322 447569.8647 85838.73415 447577.3647 85838.73415 447586.6353 85844.18322 447594.1353 85853.0 447597.0&lt;/gml:posList&gt;&lt;/gml:LinearRing&gt;&lt;/gml:exterior&gt;&lt;/gml:Polygon&gt;
                            &lt;/basisgeo:geometrie&gt;
                        &lt;/basisgeo:Geometrie&gt;
                    &lt;/geo:geometrie&gt;
                    &lt;geo:wijzigactie&gt;verwijder&lt;/geo:wijzigactie&gt;
                &lt;/geo:LocatieMutatie&gt;
                &lt;geo:LocatieMutatie&gt;
                    &lt;geo:naam&gt;Buitengebied&lt;/geo:naam&gt;
                    &lt;geo:geometrie&gt;
                        &lt;basisgeo:Geometrie&gt;
                            &lt;basisgeo:id&gt;37b0a09f-36a0-4e69-80c2-000000000003&lt;/basisgeo:id&gt;
                            &lt;basisgeo:geometrie&gt;
                                &lt;gml:Polygon srsName="urn:ogc:def:crs:EPSG::28992"&gt;&lt;gml:exterior&gt;&lt;gml:LinearRing&gt;&lt;gml:posList&gt;85853.0 447597.0 85861.81678 447594.1353 85867.26585 447586.6353 85867.26585 447577.3647 85861.81678 447569.8647 85853.0 447567.0 85853.0 447537.0 85866.90576 447539.2025 85879.45034 447545.5942 85889.40576 447555.5497 85895.79754 447568.0942 85945.79754 447568.0942 85945.79754 447595.9058 85895.79754 447595.9058 85889.40576 447608.4503 85879.45034 447618.4058 85866.90576 447624.7975 85853.0 447627.0 85853.0 447597.0&lt;/gml:posList&gt;&lt;/gml:LinearRing&gt;&lt;/gml:exterior&gt;&lt;/gml:Polygon&gt;
                            &lt;/basisgeo:geometrie&gt;
                        &lt;/basisgeo:Geometrie&gt;
                    &lt;/geo:geometrie&gt;
                    &lt;geo:wijzigactie&gt;verwijder&lt;/geo:wijzigactie&gt;
                &lt;/geo:LocatieMutatie&gt;
                &lt;geo:LocatieMutatie&gt;
                    &lt;geo:naam&gt;Binnengebied&lt;/geo:naam&gt;
                    &lt;geo:geometrie&gt;
                        &lt;basisgeo:Geometrie&gt;
                            &lt;basisgeo:id&gt;37b0a09f-36a0-4e69-80c2-100000000001&lt;/basisgeo:id&gt;
                            &lt;basisgeo:geometrie&gt;
                                &lt;gml:Polygon srsName="urn:ogc:def:crs:EPSG::28992"&gt;&lt;gml:exterior&gt;&lt;gml:LinearRing&gt;&lt;gml:posList&gt;85857.63525 447596.2658 85865.13525 447590.8168 85868.0 447582.0 85865.13525 447573.1832 85857.63525 447567.7342 85848.36475 447567.7342 85781.71948 447545.6808 85773.98493 447569.4852 85840.86475 447590.8168 85846.19014 447595.3651 85857.63525 447596.2658&lt;/gml:posList&gt;&lt;/gml:LinearRing&gt;&lt;/gml:exterior&gt;&lt;/gml:Polygon&gt;
                            &lt;/basisgeo:geometrie&gt;
                        &lt;/basisgeo:Geometrie&gt;
                    &lt;/geo:geometrie&gt;
                    &lt;geo:wijzigactie&gt;voegtoe&lt;/geo:wijzigactie&gt;
                &lt;/geo:LocatieMutatie&gt;
                &lt;geo:LocatieMutatie&gt;
                    &lt;geo:naam&gt;Buitengebied&lt;/geo:naam&gt;
                    &lt;geo:geometrie&gt;
                        &lt;basisgeo:Geometrie&gt;
                            &lt;basisgeo:id&gt;37b0a09f-36a0-4e69-80c2-100000000002&lt;/basisgeo:id&gt;
                            &lt;basisgeo:geometrie&gt;
                                &lt;gml:Polygon srsName="urn:ogc:def:crs:EPSG::28992"&gt;&lt;gml:exterior&gt;&lt;gml:LinearRing&gt;&lt;gml:posList&gt;85853.0 447597.0 85861.81678 447594.1353 85867.26585 447586.6353 85867.26585 447577.3647 85861.81678 447569.8647 85853.0 447567.0 85853.0 447537.0 85866.90576 447539.2025 85879.45034 447545.5942 85889.40576 447555.5497 85895.79754 447568.0942 85895.79754 447595.9058 85889.40576 447608.4503 85879.45034 447618.4058 85866.90576 447624.7975 85853.0 447627.0 85853.0 447597.0&lt;/gml:posList&gt;&lt;/gml:LinearRing&gt;&lt;/gml:exterior&gt;&lt;/gml:Polygon&gt;
                            &lt;/basisgeo:geometrie&gt;
                        &lt;/basisgeo:Geometrie&gt;
                    &lt;/geo:geometrie&gt;
                    &lt;geo:wijzigactie&gt;voegtoe&lt;/geo:wijzigactie&gt;
                &lt;/geo:LocatieMutatie&gt;
            &lt;/geo:locatieMutaties&gt;
                &lt;geo:wijzigmarkeringen&gt;
                    &lt;geo:Vlak&gt;
                        &lt;geo:geometrie&gt;
                            &lt;basisgeo:Geometrie&gt;
                                &lt;basisgeo:id&gt;4e4783ef-62f9-4628-bfb7-d9ae197bfeb5&lt;/basisgeo:id&gt;
                                &lt;basisgeo:geometrie&gt;
                                    &lt;gml:Polygon srsName="urn:ogc:def:crs:EPSG::28992"&gt;&lt;gml:exterior&gt;&lt;gml:LinearRing&gt;&lt;gml:posList&gt;85943.29754 447593.4058 85943.29754 447570.5942 85898.29754 447570.5942 85898.29754 447593.4058 85943.29754 447593.4058&lt;/gml:posList&gt;&lt;/gml:LinearRing&gt;&lt;/gml:exterior&gt;&lt;/gml:Polygon&gt;
                                &lt;/basisgeo:geometrie&gt;
                            &lt;/basisgeo:Geometrie&gt;
                        &lt;/geo:geometrie&gt;
                    &lt;/geo:Vlak&gt;
                    &lt;geo:Vlak&gt;
                        &lt;geo:geometrie&gt;
                            &lt;basisgeo:Geometrie&gt;
                                &lt;basisgeo:id&gt;f753988f-bee7-4612-924b-a83d0c7dfd3f&lt;/basisgeo:id&gt;
                                &lt;basisgeo:geometrie&gt;
                                    &lt;gml:Polygon srsName="urn:ogc:def:crs:EPSG::28992"&gt;&lt;gml:exterior&gt;&lt;gml:LinearRing&gt;&lt;gml:posList&gt;85836.23843869919 447586.7171332435 85836.23415 447586.6353 85836.23415 447577.3647 85836.24784526553 447577.1033788042 85836.2887810139 447576.84492069896 85836.35650874433 447576.59215740615 85836.45028641741 447576.3478582541 85836.56908658508 447576.11469983624 85836.71160764743 447575.8952366857 85842.16067764744 447568.3952366857 85842.21220984512 447568.33159978274 85783.32038810207 447548.84387167194 85777.13930376922 447567.86721548554 85836.23843869919 447586.7171332435&lt;/gml:posList&gt;&lt;/gml:LinearRing&gt;&lt;/gml:exterior&gt;&lt;/gml:Polygon&gt;
                                &lt;/basisgeo:geometrie&gt;
                            &lt;/basisgeo:Geometrie&gt;
                        &lt;/geo:geometrie&gt;
                    &lt;/geo:Vlak&gt;
            &lt;/geo:wijzigmarkeringen&gt;
        &lt;/geo:GeoInformatieObjectMutatie&gt;
    &lt;/geo:vastgesteldeVersie&gt;
    &lt;geo:wasID&gt;/join/id/regdata/mnre9999/2022/uitleg2/nld@2022;3&lt;/geo:wasID&gt;
&lt;/geo:GeoInformatieObjectVaststelling&gt;
</textarea>

<div><a data-copy="resultaat_44" href="#">Kopieer</a> of <a data-download_xml="resultaat_44" data-filenaam="GIO-wijziging.gml" href="#">download</a></div>

</td></tr></table>

</div>

</div>
<p>&nbsp;</p>
<button data-accordion="21" class="accordion_h"><h3>Verslag van de verwerking</h3></button>
<div data-accordion-paneel="21" class="accordion_h_paneel">
<p>&nbsp;</p>
<p><b>Fouten: 0, waarschuwingen: 0</b></p>
<!-- checkboxElement id moet overeenkomen "toon_" plus log-level waarde. -->
<input id="toon_fout" checked="checked" type="checkbox" class="meldingen_checkbox" /><label for="toon_fout">Toon FOUT meldingen </label>
<input id="toon_letop" checked="checked" type="checkbox" class="meldingen_checkbox" /><label for="toon_letop">Toon LeT OP meldingen </label>
<input id="toon_info" checked="checked" type="checkbox" class="meldingen_checkbox" /><label for="toon_info">Toon INFO meldingen </label>
<input id="toon_detail" type="checkbox" class="meldingen_checkbox" /><label for="toon_detail">Toon alle (detail)meldingen in gedetailleerd overzicht</label>
<div id="log_detail">

<table id="meldingen_tabel">
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Geo-tools (https://github.com/STOPwerk/Geo-tools/) versie 2023-04-17 15:18:43.</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Toon GIO: '1. Voorbeeld noodmaatregel.gml'</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Lees het GIO, gebiedsmarkering of effectgebied</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Lees het GIO, gebiedsmarkering of effectgebied</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Bestand "1. Voorbeeld noodmaatregel.gml" voor "geometrie" ingelezen</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">GIO-versie ingelezen uit '1. Voorbeeld noodmaatregel.gml'</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Lees de symbolisatie (indien aanwezig)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Bestand "symbolisatie.xml" voor "symbolisatie" ingelezen</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Symbolisatie voor vlakken ingelezen uit 'symbolisatie.xml'</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Bereken randen via buffers om locaties</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Randen zijn bepaald</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">VoegGeoDataToe: data3_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">GeoData toegevoegd: data3_2</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Maak de kaartweergave</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">VoegGeoDataToe: data4_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">GeoData toegevoegd: data4_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Prepareer kaart kaart_5</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg laag toe: 'Juridische nauwkeurigheid' (data3_2)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg laag toe: 'GIO-versie' (data4_2)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Toon kaart kaart_5</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Toon GIO met schaalafhankelijkheid</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Prepareer kaart kaart_6</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Maak schaalafhankelijke geometrie met juridische nauwkeurigheid 100 decimeter</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg laag toe: 'GIO-versie' (data4_2)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">VoegGeoDataToe: data7_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">GeoData toegevoegd: data7_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg laag toe: 'GIO-versie' (data7_2)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">VoegGeoDataToe: data8_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">GeoData toegevoegd: data8_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg laag toe: 'GIO-versie' (data8_2)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">VoegGeoDataToe: data10_0</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">GeoData toegevoegd: data10_0</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg laag toe: 'GIO-versie' (data10_0)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Toon kaart kaart_6</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Maak de pagina af</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Toon GIO: '2. Gebruik bestaande geometrie.gml'</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Lees het GIO, gebiedsmarkering of effectgebied</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Lees het GIO, gebiedsmarkering of effectgebied</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Bestand "2. Gebruik bestaande geometrie.gml" voor "geometrie" ingelezen</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">GIO-versie ingelezen uit '2. Gebruik bestaande geometrie.gml'</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Lees de symbolisatie (indien aanwezig)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Bestand "symbolisatie.xml" voor "symbolisatie" ingelezen</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Symbolisatie voor vlakken ingelezen uit 'symbolisatie.xml'</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Bereken randen via buffers om locaties</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Randen zijn bepaald</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">VoegGeoDataToe: data12_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">GeoData toegevoegd: data12_2</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Maak de kaartweergave</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">VoegGeoDataToe: data13_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">GeoData toegevoegd: data13_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Prepareer kaart kaart_14</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg laag toe: 'Juridische nauwkeurigheid' (data12_2)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg laag toe: 'GIO-versie' (data13_2)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Toon kaart kaart_14</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Maak de pagina af</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Toon GIO: '3. Twee gebieden initieel.gml'</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Lees het GIO, gebiedsmarkering of effectgebied</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Lees het GIO, gebiedsmarkering of effectgebied</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Bestand "3. Twee gebieden initieel.gml" voor "geometrie" ingelezen</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">GIO-versie ingelezen uit '3. Twee gebieden initieel.gml'</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Lees de symbolisatie (indien aanwezig)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Bestand "symbolisatie.xml" voor "symbolisatie" ingelezen</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Symbolisatie voor vlakken ingelezen uit 'symbolisatie.xml'</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Bereken randen via buffers om locaties</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Randen zijn bepaald</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">VoegGeoDataToe: data16_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">GeoData toegevoegd: data16_2</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Maak de kaartweergave</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">VoegGeoDataToe: data17_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">GeoData toegevoegd: data17_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Prepareer kaart kaart_18</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg laag toe: 'Juridische nauwkeurigheid' (data16_2)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg laag toe: 'GIO-versie' (data17_2)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Toon kaart kaart_18</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Maak de pagina af</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Toon GIO: '4. Twee gebieden na wijziging.gml'</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Lees het GIO, gebiedsmarkering of effectgebied</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Lees het GIO, gebiedsmarkering of effectgebied</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Bestand "4. Twee gebieden na wijziging.gml" voor "geometrie" ingelezen</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">GIO-versie ingelezen uit '4. Twee gebieden na wijziging.gml'</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Lees de symbolisatie (indien aanwezig)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Bestand "symbolisatie.xml" voor "symbolisatie" ingelezen</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Symbolisatie voor vlakken ingelezen uit 'symbolisatie.xml'</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Bereken randen via buffers om locaties</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Randen zijn bepaald</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">VoegGeoDataToe: data20_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">GeoData toegevoegd: data20_2</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Maak de kaartweergave</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">VoegGeoDataToe: data21_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">GeoData toegevoegd: data21_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Prepareer kaart kaart_22</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg laag toe: 'Juridische nauwkeurigheid' (data20_2)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg laag toe: 'GIO-versie' (data21_2)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Toon kaart kaart_22</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Maak de pagina af</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Maak GIO-wijziging: '3. Twee gebieden initieel &rarr; 4. Twee gebieden na wijziging'</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Lees de symbolisatie (indien aanwezig)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Bestand "symbolisatie.xml" voor "symbolisatie" ingelezen</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">Symbolisatie voor vlakken ingelezen uit 'symbolisatie.xml'</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Maak GIO-wijziging aan</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg de locaties aan de was, wordt en wordt-revisies toe; locaties met dezelfde basisgeo-id moeten gelijke geometrie hebben.</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Bepaal de wijzigmarkering voor de verwijderde gebieden</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Bepaal de wijzigmarkering voor de toegevoegde gebieden</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Toon de onderdelen van de GIO-wijziging in een kaart</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Prepareer kaart kaart_24</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">VoegGeoDataToe: data25_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">GeoData toegevoegd: data25_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">VoegGeoDataToe: data26_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">GeoData toegevoegd: data26_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg laag toe: 'Juridische nauwkeurigheid' (data25_2)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg laag toe: 'Juridische nauwkeurigheid' (data26_2)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg laag toe: 'GIO-versies' (data17_2)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg laag toe: 'GIO-versies' (data21_2)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">VoegGeoDataToe: data28_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">GeoData toegevoegd: data28_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">VoegGeoDataToe: data29_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">GeoData toegevoegd: data29_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg laag toe: 'LocatieMutaties (geen revisie)' (data28_2)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg laag toe: 'LocatieMutaties (geen revisie)' (data29_2)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">VoegGeoDataToe: data40_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">GeoData toegevoegd: data40_2</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Voeg laag toe: 'Wijzigmarkeringen' (data40_2)</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Toon kaart kaart_24</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Maak en presenteer de GIO-wijziging als GML</td></tr>
<tr style="display: none" class="entry_DETAIL"><td class="level_DETAIL">DETAIL</td><td class="message_DETAIL main">Neem GIO-wijziging op in resultaatpagina</td></tr>
<tr class="entry_INFO"><td class="level_INFO">INFO</td><td class="message_INFO main">De verwerking is voltooid.</td></tr>
</table>
</div>
<script type="text/javascript">
    function Meldingen_Aanpassen(e) {
        var show = e.srcElement.checked;
        var container = document.querySelector("#meldingen_tabel");
        var matches = container.querySelectorAll("tr.entry" + e.srcElement.id.slice(4));

        for (var i = 0; i < matches.length; i++) {
            matches[i].style.display = show ? '' : 'none';
        }
    }

    document.querySelectorAll(".meldingen_checkbox").forEach((checkbox) => {
        checkbox.addEventListener('change', Meldingen_Aanpassen);
    });
</script>

</div>

<script type="text/javascript">
    window.addEventListener('load', function () {

        function TogglePaneel() {
            this.classList.toggle("active");
            var panel = document.querySelector('[data-accordion-paneel="' + this.dataset.accordion + '"]');
            var titel = document.querySelector('[data-accordion-titel="' + this.dataset.accordion + '"]');
            if (panel.style.display === "block") {
                panel.style.display = "none";
                if (titel) {
                    titel.style.display = "block";
                }
            } else {
                panel.style.display = "block";
                if (titel) {
                    titel.style.display = "none";
                }
            }
        }

        function VerbergPanelen() {
            document.querySelectorAll("[data-accordion]").forEach((elt) => {
                elt.classList.remove("active");
            });
            document.querySelectorAll("[data-accordion-paneel]").forEach((elt) => {
                elt.style.display = "none";
            });
            document.querySelectorAll("[data-accordion-titel]").forEach((elt) => {
                elt.style.display = "block";
            });
        }

        // Event handlers voor de accordion panelen (op te klikken stukjes van de pagina)
        document.querySelectorAll("[data-accordion]").forEach((elt) => {
            elt.addEventListener("click", TogglePaneel);
        });
        // Event handler voor het sluiten van alle accordion panelen
        document.querySelectorAll("#accordion-sluiten").forEach((elt) => {
            elt.addEventListener("click", VerbergPanelen);
        });
    });
    window.addEventListener('load', function () {

    function MaakLink(downloadLink, key, mimeType) {
        var tekst = document.getElementById(downloadLink.dataset[key]).value
        var textFileAsBlob = new Blob([tekst], { type: mimeType });
        downloadLink.download = downloadLink.dataset['filenaam'];
        if (window.webkitURL !== null) {
            downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
        }
        else {
            downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
        }
    }

    document.querySelectorAll('[data-download_xml]').forEach(downloadLink => {
        MaakLink(downloadLink, 'download_xml', 'text/xml');
    });
    document.querySelectorAll('[data-download_json]').forEach(downloadLink => {
        MaakLink(downloadLink, 'download_json', 'application/json');
    });

    document.querySelectorAll('[data-copy]').forEach(copyLink => {
        copyLink.addEventListener('click', e => {
            e.preventDefault();
            e.stopPropagation();
            var area = document.getElementById(e.srcElement.dataset['copy']);
            area.select();
            document.execCommand('copy');
            area.selectionStart = 0;
            area.selectionEnd = 0;
        });
    });

});


Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym1",`<FeatureTypeStyle version="1.1.0" xmlns="http://www.opengis.net/se" xmlns:ogc="http://www.opengis.net/ogc">
	<FeatureTypeName>geo:Locatie</FeatureTypeName>
	<SemanticTypeIdentifier>geo:groepID</SemanticTypeIdentifier>
	<Rule>
		<Name>Vlak</Name>
		<PolygonSymbolizer>
			<Name>10</Name>
			<Fill>
				<SvgParameter name="fill">#DAE8FC</SvgParameter>
				<SvgParameter name="fill-opacity">0.7</SvgParameter>
			</Fill>
			<Stroke>
				<SvgParameter name="stroke">#6C8EBF</SvgParameter>
				<SvgParameter name="stroke-opacity">1</SvgParameter>
				<SvgParameter name="stroke-width">1</SvgParameter>
				<SvgParameter name="stroke-linejoin">round</SvgParameter>
			</Stroke>
		</PolygonSymbolizer>
	</Rule>
</FeatureTypeStyle>
`);


Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym2",`<FeatureTypeStyle version="1.1.0"
    xmlns="http://www.opengis.net/se"
    xmlns:ogc="http://www.opengis.net/ogc">
    <FeatureTypeName>geo:Locatie</FeatureTypeName>
    <SemanticTypeIdentifier>geo:geometrie</SemanticTypeIdentifier>
    <Rule>
        <Name>Vlak</Name>
        <PolygonSymbolizer>
            <Fill>
                <SvgParameter name="fill">#cccccc</SvgParameter>
                <SvgParameter name="fill-opacity">0.5</SvgParameter>
            </Fill>
            <Stroke>
                <SvgParameter name="stroke">#000000</SvgParameter>
                <SvgParameter name="stroke-opacity">1</SvgParameter>
                <SvgParameter name="stroke-width">3</SvgParameter>
                <SvgParameter name="stroke-linejoin">round</SvgParameter>
            </Stroke>
        </PolygonSymbolizer>
    </Rule>
</FeatureTypeStyle>`);


Kaartgegevens.Instantie.VoegDataToe ("data3_2",
{"type": "FeatureCollection", "crs": {"type": "name", "properties": {"name": "urn:ogc:def:crs:EPSG::28992"}}, "features": [{"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[79574.77678275575, 457927.98164066306], [79574.41452382453, 457928.2961814654], [79574.08407841883, 457928.6439936036], [79573.78848884974, 457929.0218748762], [79573.5304765211, 457929.4263462447], [79573.31241687456, 457929.8536838631], [79573.13631751937, 457930.2999533632], [79573.00379974913, 457930.7610460764], [79572.91608361494, 457931.2327168614], [79572.87397669273, 457931.71062318765], [79572.87786664824, 457932.19036511605], [79572.92771766782, 457932.6675258075], [79573.02307078819, 457933.1377121876], [79573.16304812195, 457933.5965953924], [79573.34636094006, 457934.03995062277], [79573.57132153682, 457934.463696041], [79573.8358587679, 457934.86393035116], [79574.13753711894, 457935.2369687166], [79883.12753711894, 458281.88696871663], [79883.48258287038, 458282.2468758499], [79883.87215806873, 458282.5690897463], [79884.29227984317, 458282.8503162117], [79884.73865302613, 458283.0876800921], [79885.20671406547, 458283.2787546682], [79885.69167768059, 458283.42158646515], [79886.1885857852, 458283.5147152241], [79886.69235817713, 458283.5571888317], [79887.1978444762, 458283.5485730535], [79887.69987677998, 458283.48895597405], [79888.19332249834, 458283.3789470961], [79888.6731368272, 458283.21967110917], [79889.13441432468, 458283.01275639125], [79889.57243906254, 458282.7603183608], [79889.98273284003, 458282.46493784967], [80146.58273284003, 458077.26493784966], [80146.95096088503, 458076.9395519411], [80147.2854707327, 458076.5795921594], [80147.58303144768, 458076.1885352537], [80147.84076897569, 458075.77015833126], [80148.05619390335, 458075.3285023756], [80148.22722550263, 458074.8678332159], [80148.35221182798, 458074.3926003245], [80220.65221182797, 457731.85260032455], [80220.73185929308, 457731.34973122407], [80220.75995433456, 457730.84136942425], [80220.73620563935, 457730.33278604824], [80220.66085945394, 457729.8292545167], [80220.534697031, 457729.3359958686], [80220.3590265288, 457728.8581246249], [80220.13566944699, 457728.40059575706], [80134.98566944699, 457574.40059575706], [80134.73282721233, 457573.99116706447], [80134.44179752975, 457573.60794027284], [80134.1152760448, 457573.2544649981], [80133.7562871438, 457572.9340152845], [80133.36815594063, 457572.64955927903], [80132.95447747801, 457572.4037317388], [80132.51908342875, 457572.19880962715], [80132.06600660496, 457572.0366910233], [80131.59944360444, 457571.91887754144], [80131.12371593993, 457571.8464604221], [80130.64323001131, 457571.8201104246], [80130.16243629165, 457571.8400716143], [80129.68578810488, 457571.9061591018], [80129.21770037716, 457572.0177607556], [80128.76250874397, 457572.1738428719], [80128.32442939137, 457572.37295974913], [80127.90752000395, 457572.6132670787], [79575.16752000395, 457927.7032670787], [79574.77678275575, 457927.98164066306]], [[80128.81877822896, 457583.91356680426], [80210.48317588244, 457731.6096001412], [80138.93784395949, 458070.5741644135], [79887.4387963477, 458271.6949928233], [79585.4975075067, 457932.9528077146], [80128.81877822896, 457583.91356680426]]]}, "_shape": null}], "bbox": [79572.87397669273, 457571.8201104246, 80220.75995433456, 458283.5571888317]}
);


Kaartgegevens.Instantie.VoegDataToe ("data4_2",
{"type": "FeatureCollection", "crs": {"type": "name", "properties": {"name": "urn:ogc:def:crs:EPSG::28992"}}, "features": [{"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[79577.87, 457931.91], [79886.86, 458278.56], [80143.46, 458073.36], [80215.76, 457730.82], [80130.61, 457576.82], [79577.87, 457931.91]]]}, "properties": {"id": "37b0a09f-36a0-4e69-80c2-000000000001", "naam": "Gebied uit noodverordening"}, "_shape": null}], "properties": {"id": ["ID", ""], "naam": ["Naam", ""]}, "bbox": [79577.87, 457576.82, 80215.76, 458278.56]}
);


window.addEventListener("load", function () {
var kaart = new Kaart ();
kaart.VoegLaagToe ("Juridische nauwkeurigheid", "data3_2", "sym2").AlsAanUitLaag (false);
kaart.VoegLaagToe ("GIO-versie", "data4_2", "sym1");
kaart.Toon ({"kaartelementId": "kaart_5", "kaartelementWidth": 900, "kaartelementHeight": 600, "juridische-nauwkeurigheid": 100, "maxZoom": 20, "bbox": [79572.87397669273, 457571.8201104246, 80220.75995433456, 458283.5571888317]});
});

Kaartgegevens.Instantie.VoegDataToe ("data7_2",
{"type": "FeatureCollection", "crs": {"type": "name", "properties": {"name": "urn:ogc:def:crs:EPSG::28992"}}, "features": [{"type": "Feature", "properties": {"id": "37b0a09f-36a0-4e69-80c2-000000000001", "naam": "Gebied uit noodverordening"}, "geometry": {"type": "Polygon", "coordinates": [[[79577.87, 457931.91], [79886.86, 458278.56], [80215.76, 457730.82], [80130.61, 457576.82], [79577.87, 457931.91]]]}, "_shape": null}], "properties": {"id": ["ID", ""], "naam": ["Naam", ""]}, "bbox": [79577.87, 457576.82, 80215.76, 458278.56]}
);


Kaartgegevens.Instantie.VoegDataToe ("data8_2",
{"type": "FeatureCollection", "crs": {"type": "name", "properties": {"name": "urn:ogc:def:crs:EPSG::28992"}}, "features": [], "properties": {"id": ["ID", ""], "naam": ["Naam", ""]}}
);


Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym9",`<FeatureTypeStyle version="1.1.0"
    xmlns="http://www.opengis.net/se"
    xmlns:ogc="http://www.opengis.net/ogc">
    <FeatureTypeName>geo:Locatie</FeatureTypeName>
    <SemanticTypeIdentifier>geo:geometrie</SemanticTypeIdentifier>
    <Rule>
        <Name>Punt</Name>
        <PointSymbolizer>
            <Graphic>
                <Mark>
                    <WellKnownName>star</WellKnownName>
                    <Fill>
                        <SvgParameter name="fill">#007bc7</SvgParameter>
                        <SvgParameter name="fill-opacity">1</SvgParameter>
                    </Fill>
                </Mark>
                <Size>35</Size>
                <Rotation>0</Rotation>
            </Graphic>
        </PointSymbolizer>
        <PointSymbolizer>
            <Graphic>
                <Mark>
                    <WellKnownName>star</WellKnownName>
                    <Fill>
                        <SvgParameter name="fill">#b2d7ee</SvgParameter>
                        <SvgParameter name="fill-opacity">1</SvgParameter>
                    </Fill>
                </Mark>
                <Size>29</Size>
                <Rotation>0</Rotation>
            </Graphic>
        </PointSymbolizer>
        <PointSymbolizer>
            <Graphic>
                <Mark>
                    <WellKnownName>circle</WellKnownName>
                    <Fill>
                        <SvgParameter name="fill">#007bc7</SvgParameter>
                        <SvgParameter name="fill-opacity">1</SvgParameter>
                    </Fill>
                </Mark>
                <Size>11</Size>
                <Rotation>0</Rotation>
            </Graphic>
        </PointSymbolizer>
        <PointSymbolizer>
            <Graphic>
                <Mark>
                    <WellKnownName>circle</WellKnownName>
                    <Fill>
                        <SvgParameter name="fill">#b2d7ee</SvgParameter>
                        <SvgParameter name="fill-opacity">1</SvgParameter>
                    </Fill>
                </Mark>
                <Size>7</Size>
                <Rotation>0</Rotation>
            </Graphic>
        </PointSymbolizer>
    </Rule>
</FeatureTypeStyle>`);


Kaartgegevens.Instantie.VoegDataToe ("data10_0",
{"type": "FeatureCollection", "crs": {"type": "name", "properties": {"name": "urn:ogc:def:crs:EPSG::28992"}}, "features": [{"type": "Feature", "properties": {"n": 1}, "geometry": {"type": "Point", "coordinates": [80066.95, 458018.31]}, "_shape": null}], "properties": {"n": ["Aantal niet-getoonde locaties", ""]}, "bbox": [80066.95, 458018.31, 80066.95, 458018.31]}
);


window.addEventListener("load", function () {
var kaart = new Kaart ();
kaart.VoegLaagToe ("GIO-versie", "data4_2", "sym1").LimiteerZoomLevel (11, 100);
kaart.VoegLaagToe ("GIO-versie", "data7_2", "sym1").LimiteerZoomLevel (10, 11);
kaart.VoegLaagToe ("GIO-versie", "data8_2", "sym1").LimiteerZoomLevel (0, 10);
kaart.VoegLaagToe ("GIO-versie", "data10_0", "sym9").LimiteerZoomLevel (0, 10);
kaart.Toon ({"kaartelementId": "kaart_6", "kaartelementWidth": 900, "kaartelementHeight": 600, "juridische-nauwkeurigheid": 100, "maxZoom": 16, "bbox": [79577.87, 457576.82, 80215.76, 458278.56]});
});

Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym11",`<FeatureTypeStyle version="1.1.0" xmlns="http://www.opengis.net/se" xmlns:ogc="http://www.opengis.net/ogc">
	<FeatureTypeName>geo:Locatie</FeatureTypeName>
	<SemanticTypeIdentifier>geo:groepID</SemanticTypeIdentifier>
	<Rule>
		<Name>Vlak</Name>
		<PolygonSymbolizer>
			<Name>10</Name>
			<Fill>
				<SvgParameter name="fill">#DAE8FC</SvgParameter>
				<SvgParameter name="fill-opacity">0.7</SvgParameter>
			</Fill>
			<Stroke>
				<SvgParameter name="stroke">#6C8EBF</SvgParameter>
				<SvgParameter name="stroke-opacity">1</SvgParameter>
				<SvgParameter name="stroke-width">1</SvgParameter>
				<SvgParameter name="stroke-linejoin">round</SvgParameter>
			</Stroke>
		</PolygonSymbolizer>
	</Rule>
</FeatureTypeStyle>
`);


Kaartgegevens.Instantie.VoegDataToe ("data12_2",
{"type": "FeatureCollection", "crs": {"type": "name", "properties": {"name": "urn:ogc:def:crs:EPSG::28992"}}, "features": [{"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[89353.55339059327, 384353.55339059327], [89386.50522668137, 384317.19664208184], [89415.73480615127, 384277.7851165098], [89440.96063217417, 384235.698368413], [89461.93976625564, 384191.34171618253], [89478.47016786611, 384145.14233862725], [89490.39264020162, 384097.5451610081], [89497.5923633361, 384049.0085701648], [89500.0, 384000.0], [89497.5923633361, 383950.9914298352], [89490.39264020162, 383902.4548389919], [89478.47016786611, 383854.85766137275], [89461.93976625564, 383808.65828381747], [89440.96063217417, 383764.301631587], [89415.73480615127, 383722.2148834902], [89386.50522668137, 383682.80335791816], [89353.55339059327, 383646.44660940673], [79353.55339059327, 373646.44660940673], [79317.19664208182, 373613.49477331864], [79277.7851165098, 373584.26519384875], [79235.698368413, 373559.03936782584], [79191.34171618255, 373538.0602337444], [79145.14233862724, 373521.5298321339], [79097.54516100806, 373509.6073597984], [79049.00857016478, 373502.4076366639], [79000.0, 373500.0], [78950.99142983522, 373502.4076366639], [78902.45483899194, 373509.6073597984], [78854.85766137276, 373521.5298321339], [78808.65828381745, 373538.0602337444], [78764.301631587, 373559.03936782584], [78722.2148834902, 373584.26519384875], [78682.80335791818, 373613.49477331864], [78646.44660940673, 373646.44660940673], [68646.44660940673, 383646.44660940673], [68613.49477331863, 383682.80335791816], [68584.26519384873, 383722.2148834902], [68559.03936782583, 383764.301631587], [68538.06023374436, 383808.65828381747], [68521.52983213389, 383854.85766137275], [68509.60735979838, 383902.4548389919], [68502.4076366639, 383950.9914298352], [68500.0, 384000.0], [68502.4076366639, 384049.0085701648], [68509.60735979838, 384097.5451610081], [68521.52983213389, 384145.14233862725], [68538.06023374436, 384191.34171618253], [68559.03936782583, 384235.698368413], [68584.26519384873, 384277.7851165098], [68613.49477331863, 384317.19664208184], [68646.44660940673, 384353.55339059327], [78646.44660940673, 394353.55339059327], [78682.80335791818, 394386.50522668136], [78722.2148834902, 394415.73480615125], [78764.301631587, 394440.96063217416], [78808.65828381745, 394461.9397662556], [78854.85766137276, 394478.4701678661], [78902.45483899194, 394490.3926402016], [78950.99142983522, 394497.5923633361], [79000.0, 394500.0], [79049.00857016478, 394497.5923633361], [79097.54516100806, 394490.3926402016], [79145.14233862724, 394478.4701678661], [79191.34171618255, 394461.9397662556], [79235.698368413, 394440.96063217416], [79277.7851165098, 394415.73480615125], [79317.19664208182, 394386.50522668136], [79353.55339059327, 394353.55339059327], [89353.55339059327, 384353.55339059327]], [[69707.10678118654, 384000.0], [79000.0, 374707.10678118654], [88292.89321881346, 384000.0], [79000.0, 393292.89321881346], [69707.10678118654, 384000.0]]]}, "_shape": null}, {"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[89353.55339059327, 365353.55339059327], [89386.50522668137, 365317.19664208184], [89415.73480615127, 365277.7851165098], [89440.96063217417, 365235.698368413], [89461.93976625564, 365191.34171618253], [89478.47016786611, 365145.14233862725], [89490.39264020162, 365097.5451610081], [89497.5923633361, 365049.0085701648], [89500.0, 365000.0], [89497.5923633361, 364950.9914298352], [89490.39264020162, 364902.4548389919], [89478.47016786611, 364854.85766137275], [89461.93976625564, 364808.65828381747], [89440.96063217417, 364764.301631587], [89415.73480615127, 364722.2148834902], [89386.50522668137, 364682.80335791816], [89353.55339059327, 364646.44660940673], [79353.55339059327, 354646.44660940673], [79317.19664208182, 354613.49477331864], [79277.7851165098, 354584.26519384875], [79235.698368413, 354559.03936782584], [79191.34171618255, 354538.0602337444], [79145.14233862724, 354521.5298321339], [79097.54516100806, 354509.6073597984], [79049.00857016478, 354502.4076366639], [79000.0, 354500.0], [78950.99142983522, 354502.4076366639], [78902.45483899194, 354509.6073597984], [78854.85766137276, 354521.5298321339], [78808.65828381745, 354538.0602337444], [78764.301631587, 354559.03936782584], [78722.2148834902, 354584.26519384875], [78682.80335791818, 354613.49477331864], [78646.44660940673, 354646.44660940673], [68646.44660940673, 364646.44660940673], [68613.49477331863, 364682.80335791816], [68584.26519384873, 364722.2148834902], [68559.03936782583, 364764.301631587], [68538.06023374436, 364808.65828381747], [68521.52983213389, 364854.85766137275], [68509.60735979838, 364902.4548389919], [68502.4076366639, 364950.9914298352], [68500.0, 365000.0], [68502.4076366639, 365049.0085701648], [68509.60735979838, 365097.5451610081], [68521.52983213389, 365145.14233862725], [68538.06023374436, 365191.34171618253], [68559.03936782583, 365235.698368413], [68584.26519384873, 365277.7851165098], [68613.49477331863, 365317.19664208184], [68646.44660940673, 365353.55339059327], [78646.44660940673, 375353.55339059327], [78682.80335791818, 375386.50522668136], [78722.2148834902, 375415.73480615125], [78764.301631587, 375440.96063217416], [78808.65828381745, 375461.9397662556], [78854.85766137276, 375478.4701678661], [78902.45483899194, 375490.3926402016], [78950.99142983522, 375497.5923633361], [79000.0, 375500.0], [79049.00857016478, 375497.5923633361], [79097.54516100806, 375490.3926402016], [79145.14233862724, 375478.4701678661], [79191.34171618255, 375461.9397662556], [79235.698368413, 375440.96063217416], [79277.7851165098, 375415.73480615125], [79317.19664208182, 375386.50522668136], [79353.55339059327, 375353.55339059327], [89353.55339059327, 365353.55339059327]], [[69707.10678118654, 365000.0], [79000.0, 355707.10678118654], [88292.89321881346, 365000.0], [79000.0, 374292.89321881346], [69707.10678118654, 365000.0]]]}, "_shape": null}, {"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[111353.55339059327, 382353.55339059327], [111386.50522668137, 382317.19664208184], [111415.73480615127, 382277.7851165098], [111440.96063217417, 382235.698368413], [111461.93976625564, 382191.34171618253], [111478.47016786611, 382145.14233862725], [111490.39264020162, 382097.5451610081], [111497.5923633361, 382049.0085701648], [111500.0, 382000.0], [111497.5923633361, 381950.9914298352], [111490.39264020162, 381902.4548389919], [111478.47016786611, 381854.85766137275], [111461.93976625564, 381808.65828381747], [111440.96063217417, 381764.301631587], [111415.73480615127, 381722.2148834902], [111386.50522668137, 381682.80335791816], [111353.55339059327, 381646.44660940673], [101353.55339059327, 371646.44660940673], [101317.19664208182, 371613.49477331864], [101277.7851165098, 371584.26519384875], [101235.698368413, 371559.03936782584], [101191.34171618255, 371538.0602337444], [101145.14233862724, 371521.5298321339], [101097.54516100806, 371509.6073597984], [101049.00857016478, 371502.4076366639], [101000.0, 371500.0], [100950.99142983522, 371502.4076366639], [100902.45483899194, 371509.6073597984], [100854.85766137276, 371521.5298321339], [100808.65828381745, 371538.0602337444], [100764.301631587, 371559.03936782584], [100722.2148834902, 371584.26519384875], [100682.80335791818, 371613.49477331864], [100646.44660940673, 371646.44660940673], [90646.44660940673, 381646.44660940673], [90613.49477331863, 381682.80335791816], [90584.26519384873, 381722.2148834902], [90559.03936782583, 381764.301631587], [90538.06023374436, 381808.65828381747], [90521.52983213389, 381854.85766137275], [90509.60735979838, 381902.4548389919], [90502.4076366639, 381950.9914298352], [90500.0, 382000.0], [90502.4076366639, 382049.0085701648], [90509.60735979838, 382097.5451610081], [90521.52983213389, 382145.14233862725], [90538.06023374436, 382191.34171618253], [90559.03936782583, 382235.698368413], [90584.26519384873, 382277.7851165098], [90613.49477331863, 382317.19664208184], [90646.44660940673, 382353.55339059327], [100646.44660940673, 392353.55339059327], [100682.80335791818, 392386.50522668136], [100722.2148834902, 392415.73480615125], [100764.301631587, 392440.96063217416], [100808.65828381745, 392461.9397662556], [100854.85766137276, 392478.4701678661], [100902.45483899194, 392490.3926402016], [100950.99142983522, 392497.5923633361], [101000.0, 392500.0], [101049.00857016478, 392497.5923633361], [101097.54516100806, 392490.3926402016], [101145.14233862724, 392478.4701678661], [101191.34171618255, 392461.9397662556], [101235.698368413, 392440.96063217416], [101277.7851165098, 392415.73480615125], [101317.19664208182, 392386.50522668136], [101353.55339059327, 392353.55339059327], [111353.55339059327, 382353.55339059327]], [[91707.10678118654, 382000.0], [101000.0, 372707.10678118654], [110292.89321881346, 382000.0], [101000.0, 391292.89321881346], [91707.10678118654, 382000.0]]]}, "_shape": null}, {"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[112865.00724514923, 379865.2968213677], [112822.10162416042, 379889.7293229864], [112800.40844667393, 379905.1000043289], [112764.91655601028, 379916.5419991993], [112719.10999024495, 379936.5533770689], [112675.5304529873, 379961.0384877254], [112634.61351242308, 379989.752607707], [112628.44551242307, 379994.55860770703], [112598.32169261605, 380020.0016198327], [112595.91163541778, 380022.20575680485], [112577.15794474591, 380038.0067103166], [112574.24800901055, 380041.0906086277], [112567.20112301125, 380044.37711298425], [112508.37242489288, 380076.7914840406], [112506.19842489288, 380078.1874840406], [112459.97085863054, 380111.7501182468], [112457.47085863054, 380113.79311824683], [112424.09951456163, 380143.65392252535], [112400.75083190572, 380168.6533723783], [112392.59566567025, 380168.1614339506], [112378.3311604744, 380165.0903285825], [112330.59231423053, 380159.5324680276], [112282.54039220436, 380158.5837614158], [112234.61937248491, 380162.2529743683], [112187.27202368288, 380170.5062050122], [112140.93581394842, 380183.2671972185], [112134.23481394842, 380185.46419721853], [112088.38561884293, 380203.0334792392], [112044.48072191422, 380225.0150257776], [112002.94351184533, 380251.1968618904], [111964.17454497282, 380281.3265079252], [111928.54768259637, 380315.1134142611], [111896.40648571713, 380352.23176316987], [111884.02688903843, 380369.7414009302], [111867.98509045095, 380391.075948613], [111849.16085908143, 380422.0055053389], [111833.86971752318, 380433.1478558171], [111798.77386496332, 380464.1406666009], [111766.73098199717, 380498.28047969943], [111738.02205563741, 380535.26791992516], [111712.89883712199, 380574.77864098427], [111691.58163428423, 380616.4661696992], [111674.25737965295, 380659.9649442642], [111661.07799122382, 380704.8935198906], [111659.07999122381, 380713.1115198906], [111649.564673364, 380763.2906321448], [111645.21793546753, 380814.17865087464], [111645.54199637249, 380833.26140558464], [111633.92316803259, 380850.0413071291], [111608.94573513404, 380895.5776067881], [111588.9345894695, 380943.20243003214], [111576.11527945203, 380960.2729839426], [111550.19406860365, 381003.13723999186], [111528.69190361425, 381048.3800352114], [111511.82460202505, 381095.54726701067], [111499.76146118624, 381144.1655172014], [111492.62355901703, 381193.7468037028], [111492.02655901703, 381200.15680370276], [111491.80858467767, 381204.9117828221], [111487.90410174496, 381216.7307828511], [111477.54908539304, 381261.55640157603], [111471.35804090496, 381307.1440471158], [111469.38338321011, 381353.1077630742], [111469.43438321011, 381369.6257630742], [111471.96471595485, 381418.3443249039], [111479.23073994929, 381466.5844093344], [111491.16328552665, 381513.8867898939], [111492.4680310125, 381517.52069060144], [111491.6710734034, 381548.0245057111], [111491.95007340341, 381558.0095057111], [111496.56294052674, 381613.21642394643], [111507.25494851645, 381667.57415871613], [111523.8948387599, 381720.4153965596], [111526.87783875989, 381728.3283965596], [111539.12858023371, 381757.9182988409], [111542.34858023371, 381765.0412988409], [111542.52955823025, 381765.39330124645], [111541.08839631414, 381799.8934214242], [111541.26239631414, 381818.2764214242], [111547.2295610554, 381890.7041335778], [111547.88735926432, 381894.9156242383], [111547.86163890056, 381895.03079968324], [111542.00286312801, 381940.7001686929], [111540.37003616497, 381986.7148445627], [111540.51753128311, 381989.3156883702], [111537.30089369003, 381994.7476898937], [111531.14089369003, 382006.3916898937], [111511.04772024298, 382049.14523328125], [111495.07905691506, 382093.6042355517], [111483.37744645229, 382139.3718376732], [111476.0473421614, 382186.0394995222], [111476.00829068192, 382186.67593782046], [111470.19195108612, 382208.9293407683], [111448.88612342888, 382236.5974727633], [111422.2271081367, 382279.5974392852], [111403.18810813672, 382314.0894392852], [111378.53416932221, 382365.4756229971], [111359.88832366261, 382419.3336680339], [111358.96832366262, 382422.5786680339], [111347.9738912952, 382470.06988917856], [111341.65633850383, 382518.4060263393], [111340.07571473028, 382567.12763609696], [111343.24704407934, 382615.77161104814], [111351.14018251214, 382663.87558172183], [111363.68010437039, 382710.9823114818], [111380.7476155084, 382756.6440426409], [111402.18048625426, 382800.4267524758], [111427.77499343117, 382841.91427868867], [111457.28785678177, 382880.7122751027], [111490.43855138945, 382916.451959991], [111526.91197411668, 382948.7936214118], [111566.36143871522, 382977.429846229], [111608.41197113953, 383002.08844212827], [111611.30497113953, 383003.60044212826], [111612.41413391686, 383004.0968815923], [111615.04109176401, 383006.06954953703], [111653.10795266967, 383029.6456772543], [111693.13135894979, 383049.721698949], [111734.79033574197, 383066.13661137584], [111777.75079143362, 383078.75877220975], [111795.52079143362, 383083.1257722097], [111848.82477880009, 383093.1950317452], [111902.90589009246, 383097.43041344447], [111957.12754627205, 383095.7820633909], [111958.10554627204, 383095.6990633909], [112004.5719580076, 383089.5507685535], [112050.2584779107, 383079.07838352775], [112053.52081075017, 383078.000512716], [112097.2287648391, 383102.1603653869], [112099.27302977585, 383103.0197664028], [112129.93597359183, 383121.3781924625], [112172.56722522297, 383141.708086229], [112216.92652182603, 383157.92477519676], [112262.61804926621, 383169.8835592645], [112309.23410602917, 383177.4777312449], [112356.35874110601, 383180.63952900376], [112412.86974110601, 383181.75552900374], [112435.53137742738, 383181.6894050617], [112454.79853293828, 383181.19641391246], [112472.15107448971, 383183.5809519071], [112473.3426250591, 383183.74323175446], [112510.43535922476, 383188.7495454532], [112527.62688799914, 383191.06949932885], [112577.69863181372, 383204.40452500613], [112588.3168548272, 383207.2721210193], [112590.27007238758, 383207.79935179366], [112619.50917713961, 383215.6955856701], [112663.22605660452, 383228.05538035976], [112664.53233120262, 383228.424631234], [112702.95660696414, 383239.2878820126], [112749.21384422579, 383250.0223085206], [112796.28079389752, 383256.3200986199], [112843.73291964066, 383258.1244472536], [112891.14221089018, 383255.4190794864], [112918.89556683731, 383251.1674705024], [112942.08922937422, 383253.20561066247], [112950.86985247416, 383253.89932725905], [113036.26743780047, 383259.88981865055], [113041.95526957052, 383260.3134870968], [113057.76007059832, 383261.4895320271], [113104.42960214733, 383277.0210408945], [113152.57481994644, 383287.9139022054], [113201.55949284452, 383294.00637670525], [113250.90619340746, 383295.2390843001], [113300.1339657109, 383291.6000104479], [113348.76301296074, 383283.12462325697], [113396.319373816, 383269.89552779787], [113442.33954183692, 383252.0416609957], [113486.37498303446, 383229.7370349508], [113527.99650749151, 383203.19904093596], [113566.79845244763, 383172.68633059936], [113602.40263607733, 383138.49629502575], [113612.9057038517, 383126.19963918405], [113632.44486246926, 383111.615273286], [113668.68958530716, 383078.56397086475], [113701.52135205436, 383042.1202660916], [113730.62418078847, 383002.6349031705], [113755.7179779086, 382960.4879000573], [113770.45732499231, 382929.08822989487], [113797.29068269324, 382916.73299735493], [113836.62798343222, 382894.0889391062], [113866.58140289455, 382873.0143660855], [113870.46619366987, 382873.86007653526], [113919.41163559169, 382881.9958833928], [113968.92243948838, 382885.2405614429], [114018.5110531374, 382883.5621590736], [114067.68915809318, 382876.9772041685], [114075.48726900853, 382875.131714182], [114111.2126074978, 382881.8434477328], [114155.26130726498, 382886.13682390755], [114199.51710411673, 382886.5182359857], [114243.63325901308, 382882.9846956477], [114247.54225901308, 382882.4966956477], [114294.99630589105, 382874.2343644602], [114341.43511608092, 382861.4441498452], [114347.94551996858, 382858.9554063892], [114395.54632514634, 382847.2163763031], [114399.98432514635, 382845.8743763031], [114446.95773196599, 382829.06996913877], [114462.67429978949, 382821.60601094883], [114496.92812840028, 382826.5056679708], [114542.30291281657, 382828.8298026646], [114554.70191281657, 382828.9008026646], [114604.55605974651, 382826.69594268117], [114653.94211982575, 382819.5325326338], [114702.36814915147, 382807.48192860733], [114749.35176686906, 382790.66416895203], [114794.42496025932, 382769.24677855865], [114837.13874670173, 382743.4431001114], [114837.16884980239, 382743.42053314723], [114862.21947047314, 382731.2897308958], [114903.99552807114, 382705.73684196087], [114911.60230886261, 382699.9908574259], [114913.95182089088, 382698.346894128], [114918.44293966604, 382694.8236046966], [114943.07149784279, 382676.2197671099], [114948.2828784823, 382671.4141278315], [114956.96069077542, 382664.60637104063], [114978.10312704464, 382643.91558805946], [114979.07253352563, 382643.021656454], [114979.45412947523, 382642.59344629006], [114996.02923500266, 382626.37242488127], [115030.69047729833, 382584.10205618787], [115037.61536357854, 382573.47289143706], [115066.19881061053, 382571.89265669096], [115117.09287905003, 382563.7654225589], [115124.38106466332, 382562.21265634487], [115143.21585249675, 382558.9641614706], [115181.401912401, 382550.83126712235], [115218.83698347927, 382539.7436796997], [115224.70998347928, 382537.7516796997], [115271.22361728287, 382519.3323841262], [115315.6637746694, 382496.3571585452], [115319.9213633129, 382493.58444604516], [115349.44389750992, 382491.5308231495], [115399.63494824813, 382482.844498943], [115448.68178365658, 382469.09670861723], [115496.07537727454, 382450.4301318984], [115507.77302288359, 382444.38292259997], [115501.92248280007, 382473.69502282934], [115501.3855608988, 382476.42462198285], [115488.7052511842, 382541.84923138155], [115476.89887861625, 382602.5959142961], [115475.36032239915, 382610.4480867515], [115474.38681834856, 382615.5571381553], [115474.09302116661, 382617.143901863], [115468.62087899141, 382646.7279268762], [115451.81820540407, 382731.9903448274], [115451.63770398754, 382732.91082028823], [115451.162710271, 382735.3451643616], [115429.62542585295, 382845.7421106597], [115427.45160468765, 382856.1868111449], [115426.12304787675, 382862.7930629629], [115419.53150174674, 382896.75185270066], [115413.5542622598, 382925.9268901964], [115408.27825496648, 382956.46408444515], [115407.10925496648, 382964.7540844451], [115405.96009990104, 382976.9066423384], [115405.0748362878, 382982.2948002478], [115399.77056678866, 383027.1789790017], [115398.5410383352, 383072.35876471514], [115401.39629728034, 383117.46499791724], [115404.9876727911, 383140.6560075674], [115405.80926617196, 383153.3788953596], [115414.14527633034, 383217.52905646444], [115416.22227633033, 383228.10305646446], [115428.25458686217, 383276.47073734045], [115445.04259181002, 383323.4001730917], [115446.39439964386, 383326.24740617647], [115443.03070056216, 383354.36164984043], [115442.91044768547, 383355.3755138492], [115429.99852124421, 383465.19576019264], [115426.54385820153, 383494.3713373626], [115425.89859833031, 383499.8174226119], [115418.22548025106, 383564.62057029357], [115412.4413476235, 383611.0748093376], [115411.84636474887, 383616.05707497685], [115406.43676973764, 383663.3710815348], [115405.29882604687, 383673.07728036755], [115401.58031469196, 383704.21543251956], [115396.83347553705, 383743.5394737634], [115395.03284765655, 383756.01731140097], [115389.39908008653, 383804.7514118904], [115383.57990683767, 383853.4639348201], [115383.52043707733, 383853.9638955941], [115377.63843707733, 383903.6268955941], [115377.52229066001, 383904.61597722914], [115371.75778692856, 383954.131100583], [115367.38923017956, 383991.4476440498], [115365.92629065999, 384003.9489772293], [115360.27531193265, 384052.48895947065], [115354.2297433261, 384102.43285571405], [115354.19035515444, 384102.7603515422], [115354.07290245543, 384103.73871598876], [115334.10151055323, 384270.9679976511], [115310.33188346733, 384470.0127531668], [115309.41955655442, 384477.6451266082], [115308.59855655441, 384484.5161266082], [115305.13860938732, 384535.37606999435], [115306.87532800481, 384586.32397362235], [115313.79065952892, 384636.8302431891], [115325.81272033113, 384686.36987509846], [115342.81654324975, 384734.42791377875], [115364.62537660106, 384780.5048045538], [115391.01252148137, 384824.12158642395], [115421.70368826136, 384864.82487077947], [115456.37984777747, 384902.19155429373], [115460.48368697091, 384906.1846945442], [115469.33552634834, 384914.79883362015], [115477.30428981353, 384922.38470717147], [115495.57328981353, 384939.39670717146], [115535.30770234102, 384972.72229520936], [115564.35370234102, 384994.6212952094], [115567.03403254408, 384996.6280680891], [115586.58503254407, 385011.16406808904], [115589.77115423883, 385013.5133947519], [115625.07415423884, 385039.32939475187], [115626.07061742371, 385040.056193174], [115653.94708465993, 385060.33605261805], [115687.99522842263, 385085.8983456659], [115718.85991432908, 385107.16254276567], [115734.26428953063, 385131.5203448227], [115764.29666839645, 385170.08048348705], [115783.33594726544, 385190.1324527175], [115789.17453157407, 385206.6602145526], [115809.73636229402, 385250.6992182007], [115834.47681985762, 385292.5338029891], [115863.16213438057, 385331.7686784903], [115895.52126145553, 385368.03311864624], [115897.41822306169, 385369.9615487704], [115910.17173200392, 385382.93136461906], [115931.75313131747, 385448.345740555], [115949.11637238479, 385493.50365559844], [115970.76278009854, 385536.7720327868], [115996.4896817901, 385577.7457555952], [116013.58590184424, 385599.8892901384], [116015.31488489524, 385603.69804459426], [116020.78103843401, 385615.2221474671], [116022.95406853264, 385627.410587853], [116036.23053863269, 385674.5651492337], [116054.05774834329, 385720.194174111], [116076.2645694781, 385763.8596571887], [116102.63783278145, 385805.14244173694], [116132.92437419735, 385843.64624319057], [116166.83346505955, 385879.0014531917], [116174.88849233961, 385885.9006224484], [116189.5588522181, 385904.28379543044], [116202.69775685726, 385920.746937059], [116201.71521603884, 385937.99261053297], [116203.77895357263, 385987.30019009317], [116221.7105102159, 386183.3710631375], [116221.9105102159, 386185.5560631375], [116222.85428267502, 386194.89930753165], [116223.16631134941, 386197.7228740363], [116223.64815852493, 386202.07809338946], [116232.72948107023, 386309.4744107613], [116239.46826060752, 386389.02261183143], [116241.10427817689, 386408.3308094342], [116261.62231940315, 386651.16505680286], [116260.0963446307, 386665.2379689781], [116259.63306152407, 386714.52150789194], [116264.02407439961, 386763.6112302892], [116273.22671873876, 386812.03016435716], [116282.04200803353, 386848.5059306349], [116294.12070235962, 386903.7954590801], [116309.20418721762, 386958.00459814555], [116311.1781872176, 386963.8115981455], [116315.4395040814, 386975.8412443732], [116317.27250408141, 386980.8132443732], [116338.04232174817, 387029.1496637806], [116340.79632174816, 387034.7296637806], [116354.537354542, 387059.94930834166], [116381.52620208796, 387147.4184453476], [116382.8813055766, 387151.7406590334], [116388.42338351553, 387169.1410680792], [116394.03935574327, 387196.9009699242], [116408.83690759352, 387244.763189117], [116428.3497163333, 387290.9043839641], [116435.4427163333, 387305.58038396406], [116444.02672027457, 387322.51316177595], [116469.57993517294, 387370.6318588574], [116477.67087070164, 387475.42483648984], [116478.47059386793, 387485.83773679455], [116480.83210669021, 387516.9376093999], [116487.893524338, 387609.9424376924], [116487.96897884771, 387610.9325754289], [116491.0611460612, 387651.348786636], [116491.54431190781, 387657.7875377521], [116495.19357673064, 387706.4717074415], [116495.6851275248, 387713.0397368296], [116500.4539397565, 387776.65083473275], [116500.4619397565, 387776.7568347328], [116500.72966095565, 387780.15018305747], [116500.89596439323, 387782.1701517606], [116504.96922452147, 387831.49851341493], [116505.37935145939, 387836.4619474518], [116510.96647882166, 387904.11338116444], [116518.78638177809, 387960.0466636358], [116532.86423371147, 388014.74124339665], [116553.02041908352, 388067.49928696844], [116629.18441908351, 388237.3922869684], [116629.56563714435, 388238.2405257831], [116662.98363714435, 388312.4135257831], [116684.60677020319, 388354.8789410734], [116710.17436351739, 388395.09298776323], [116739.45417422339, 388432.6903821421], [116772.1802395847, 388467.3296088226], [116808.05529286063, 388498.69602289086], [116846.75346352436, 388526.5047079791], [116887.92323730316, 388550.50306429906], [116931.19064915318, 388570.47310312866], [116976.16268016558, 388586.2334269095], [117022.43082754801, 388597.6408769687], [117069.57481525387, 388604.5918338989], [117106.27586751126, 388606.46679058415], [117114.16423798022, 388608.3717328596], [117118.46223798022, 388609.13473285956], [117170.79881262542, 388615.60133885377], [117223.52537642077, 388616.51976632053], [117232.71737642078, 388616.1947663205], [117253.27424091432, 388615.0437663538], [117266.18624091432, 388614.0537663538], [117274.96841235438, 388613.21323942905], [117288.75911321251, 388616.7003786519], [117336.69921082533, 388623.97786128236], [117385.118803779, 388626.5774248545], [117433.56251263618, 388624.4746208398], [117481.57473115291, 388617.68922581326], [117528.70391119094, 388606.2850554573], [117574.50680946428, 388590.36936438445], [117618.55265617973, 388570.0918374228], [117660.15967152923, 388545.7993833398], [117663.33677134196, 388545.19474813296], [117664.91477134195, 388544.893748133], [117731.13851399747, 388527.4886617881], [117751.08251399748, 388520.7566617881], [117763.19025825121, 388516.49586735957], [117782.93925825121, 388509.2598673596], [117786.56371965048, 388507.91595661046], [117803.48604470423, 388501.5668273506], [117811.45120862202, 388498.702285708], [117826.5971181397, 388493.9918690936], [117838.43751086091, 388490.4588029191], [117845.05553672161, 388488.4340590796], [117859.54164215388, 388483.89225002145], [117875.45322777641, 388478.91500350315], [117891.96426821167, 388473.830925736], [117896.90656021539, 388472.2810242102], [117919.01756021539, 388465.2210242102], [117927.25983159874, 388462.17621441203], [117936.82253478191, 388459.28224687127], [117946.25913713788, 388456.3242617863], [117962.04915995144, 388451.2027040843], [117970.0427054243, 388448.6315318143], [117994.0273535861, 388441.25375539315], [118028.92235358611, 388430.51975539315], [118074.52956079115, 388414.0298973565], [118118.32471141616, 388393.19920968555], [118159.89579246192, 388368.22366188775], [118198.85171437773, 388339.33821720013], [118234.82599032669, 388306.8146221181], [118237.3645117272, 388304.02721153037], [118273.69419556588, 388297.7626552171], [118281.55916131935, 388296.4071081709], [118286.06294035794, 388295.60964186466], [118318.90007660845, 388289.64027255395], [118379.10002304071, 388279.2807338626], [118386.49070542368, 388278.0085644466], [118411.23875194493, 388273.73911277234], [118458.43613211613, 388265.67171317275], [118478.18294262269, 388273.8901818136], [118484.99835216947, 388276.6680319191], [118485.26139409606, 388276.7729926879], [118512.43295600745, 388287.6352487351], [118544.21913488634, 388300.34119966504], [118564.35931146717, 388308.9525901437], [118627.06250445591, 388330.96001804346], [118677.2733825428, 388344.9127087804], [118681.18391606704, 388345.9989128825], [118707.97745018128, 388353.4441144717], [118720.5199175711, 388356.7546793693], [118766.78591757109, 388368.32667936926], [118784.98156557663, 388372.5183623124], [118805.94268712163, 388376.9366526024], [118836.95234179724, 388383.47261791053], [118894.27907609625, 388395.7274928693], [118899.08527249581, 388396.7549324454], [118925.53533127847, 388414.32919418055], [118967.91461516026, 388436.95218474383], [118968.83683540959, 388437.388918729], [118977.35583540959, 388441.42291872896], [119040.14503312975, 388466.11852028675], [119044.22703312975, 388467.41352028673], [119091.0991021844, 388479.81721029937], [119138.95217680477, 388487.62269764947], [119187.33627684688, 388490.75658445497], [119235.79642873847, 388489.1894016203], [119283.87694376368, 388482.93588594464], [119331.12570307234, 388472.05484154687], [119377.09840912068, 388456.6485869083], [119421.36276356525, 388436.8619927345], [119463.50253232407, 388412.8811196823], [119488.42911138717, 388395.29636331205], [119505.70934374357, 388392.3947873036], [119529.92784543558, 388388.3286955827], [119575.28327930326, 388380.71279064537], [119607.89305965822, 388375.23716335406], [119691.75107902272, 388361.15683172987], [119765.43649571128, 388348.78526546026], [119796.35268527939, 388343.5945620279], [119996.4416852794, 388309.99856202793], [120042.92940845407, 388299.8982230025], [120088.24681154717, 388285.4255511244], [120131.98365872107, 388266.71156027046], [120171.4835942666, 388245.15902663145], [120352.16713087687, 388275.86251144094], [120373.8552279662, 388279.5480377229], [120465.8782279662, 388295.18503772287], [120513.89580003383, 388300.9717156002], [120562.24781955249, 388302.09201761073], [120610.48187159344, 388298.53546143416], [120658.14664501329, 388290.3353246694], [120704.79615523302, 388277.5683334661], [120749.99391717819, 388260.353944622], [120793.31702933501, 388238.85322786245], [120832.97705839082, 388216.7181184953], [120855.58442750694, 388204.10140965425], [120880.52743444224, 388190.2162207932], [120988.38508963132, 388131.6387907231], [121067.2114973353, 388090.34876764007], [121070.779884326, 388088.4612160079], [121150.49123941651, 388045.88399886107], [121205.15108920667, 388016.93895135535], [121221.54178296262, 388007.86205487215], [121227.29284474211, 388004.53491176484], [121232.42190715947, 388001.56776813813], [121267.8481021382, 387979.0375283449], [121316.57315535897, 387945.0949743405], [121349.9687193384, 387921.8323534612], [121512.57838667625, 387809.1490679532], [121515.33195612584, 387807.22721422755], [121630.28340652364, 387726.4214691761], [121643.35549464363, 387717.7101517533], [121700.63623649144, 387677.8137245716], [121747.93398295932, 387644.87129413534], [121753.1058934945, 387641.22026593116], [121771.10483889168, 387628.3426940333], [121853.90301988272, 387570.34473667067], [121912.31866292775, 387529.42668716866], [121913.18270460553, 387528.820096418], [122099.75163944354, 387397.54721686733], [122115.18546469409, 387386.6873398283], [122123.36594922423, 387380.9312207355], [122231.91458703508, 387304.55632816674], [122238.92257954991, 387299.6250371005], [122246.42952270752, 387294.34270637296], [122343.34861033579, 387226.14968079503], [122411.17674511892, 387178.4266967239], [122449.33067639406, 387148.72336978477], [122455.84732192059, 387142.55135013646], [122457.7310135793, 387142.1525212309], [122502.3407705183, 387128.24880374136], [122545.45781225656, 387110.2414584087], [122586.70558149548, 387088.28775013424], [122625.72384599442, 387062.57940888713], [122662.17184461385, 387033.34095525456], [122695.73126331034, 387000.82773961936], [122767.51826331034, 386924.45973961934], [122798.0274225794, 386888.7866702725], [122825.05682940729, 386850.4097521776], [122848.36825993573, 386809.66722055955], [122867.75625871548, 386766.9181599939], [122868.67928391435, 386764.2397503076], [122959.4853650583, 386685.35185715306], [122960.9390827306, 386684.08400944923], [122968.2913098616, 386677.646814934], [123017.7049110031, 386634.38666597806], [123083.5004391505, 386576.7835810238], [123109.41192983773, 386554.09951345227], [123189.66109845765, 386485.2910816482], [123224.60009845765, 386455.3330816482], [123228.25934493856, 386452.1646450128], [123230.41189023243, 386450.28251017083], [123238.6693443341, 386443.0664464797], [123281.789698785, 386405.3810106634], [123304.3756970365, 386385.6419023191], [123310.903858766, 386379.9361155211], [123321.0739083342, 386371.0492056326], [123331.88651903895, 386361.59929380816], [123342.979778387, 386351.9043514605], [123430.03561224979, 386277.6179023638], [123434.6325305469, 386273.6467511836], [123439.57100588208, 386269.32787329133], [123482.33601619033, 386232.1114032162], [123493.34566289233, 386222.53097008576], [123548.4655810315, 386174.56407935405], [123552.67069354568, 386170.9045179883], [123615.29358603818, 386118.52230466163], [123639.81773252947, 386111.9248276812], [123648.43172550954, 386109.6082562262], [123677.5970204075, 386101.76241048484], [123692.89455175179, 386097.64668893284], [123843.76308463424, 386057.06196664844], [123900.86552096174, 386037.9459806645], [123918.60628576053, 386030.79225279187], [123978.781838939, 386006.52623948164], [124039.7498729157, 385981.9414029783], [124046.30564468303, 385979.2976884823], [124084.36963986415, 385963.94763546705], [124089.7828884633, 385969.14245240897], [124129.14030776454, 385999.9890995241], [124171.3820262105, 386026.7502526202], [124216.08553840044, 386049.15824427904], [124262.80371585501, 386066.9889477879], [124311.06927923489, 386080.06401887466], [124372.31732831108, 386093.4084729249], [124485.13197232258, 386118.6317011422], [124489.37582456939, 386119.5612062646], [124537.96882456938, 386129.9832062646], [124548.6523850969, 386132.1530172334], [124560.44211326947, 386134.4139470797], [124575.20586128575, 386137.3057434325], [124607.02234501146, 386143.702361918], [124609.18885207035, 386144.13295554067], [124628.76585207036, 386147.9789555407], [124629.38536230403, 386148.10025531455], [124643.71836230403, 386150.8972553145], [124662.02344320917, 386154.11742186605], [124670.93844320918, 386155.5154218661], [124723.67568249957, 386160.94038349704], [124734.50923664031, 386161.4767223618], [124762.8496966848, 386163.65699759754], [124764.26104059722, 386163.7724565103], [124770.39433313777, 386165.2155841669], [124792.97858343695, 386169.98220708716], [124817.27558343695, 386174.5272070872], [124822.038819648, 386175.3943717015], [124835.61922341558, 386177.79886392993], [124847.11026028129, 386179.98781919206], [124847.6754369368, 386180.09514415875], [124912.1792584193, 386192.3057409725], [124949.06726641675, 386206.9121312328], [124991.27099477567, 386219.4574500724], [124994.06799477566, 386220.1564500724], [125039.53750313827, 386229.3024796784], [125040.08550313827, 386229.3864796784], [125084.69391906934, 386234.18779151124], [125129.55314283575, 386234.9709966381], [125174.30197454101, 386231.7297888062], [125218.58010314933, 386224.4902657459], [125222.71910314934, 386223.6212657459], [125272.79898771663, 386210.3645406606], [125321.2383907241, 386191.99718280655], [125367.51731797091, 386168.71636471216], [125379.14703540056, 386161.2662794306], [125403.01364716802, 386160.0962402759], [125409.38196179218, 386159.7433105393], [125470.49671943608, 386155.96521372726], [125478.3839268166, 386157.30358160526], [125558.39596668037, 386170.90962398954], [125652.91659321956, 386186.9833904248], [125703.07090182621, 386192.9250363465], [125753.56874749882, 386193.77674668166], [125803.89489913678, 386189.5298314032], [125853.5358774391, 386180.22762192064], [125859.59738582339, 386178.44322467863], [125896.52844663076, 386185.7126114495], [125945.63023323193, 386190.4239398277], [125994.95730102391, 386190.2741214089], [126013.668772775, 386188.3639740831], [126024.21036442224, 386197.82663518423], [126067.65553555882, 386229.1299344793], [126092.49000134903, 386243.25771197455], [126092.33848723858, 386243.5174504496], [126111.74248723857, 386254.83645044954], [126118.54578063513, 386258.7338688123], [126131.48078063513, 386266.00986881234], [126148.87250197065, 386275.3457533584], [126181.49776583194, 386292.0379888913], [126196.34565355336, 386299.8157037706], [126196.37917662282, 386299.7517072396], [126213.43556570016, 386309.26141051174], [126259.22955146903, 386329.0976896569], [126265.69755146903, 386331.52368965687], [126321.68283837895, 386348.854148702], [126339.32089281428, 386352.1169516995], [126339.2866682558, 386352.27095162997], [126346.56266825579, 386353.88795162993], [126390.90655336644, 386361.6664894752], [126435.77036262794, 386365.42473590985], [126480.79036076898, 386365.1322207888], [126525.60154621021, 386360.7913156909], [126535.35728726539, 386358.9490424033], [126563.1897527118, 386355.77058766526], [126612.31723174715, 386345.078152942], [126660.12251805415, 386329.50599966163], [126706.1222356785, 386309.2115833073], [126709.1606593085, 386307.48760786327], [126746.08951559677, 386304.5851267946], [126792.1201918959, 386296.5932048281], [126809.30504701872, 386292.77479273285], [126828.5350746493, 386288.50150212325], [126936.18314868845, 386275.6990736509], [126940.65975491893, 386275.1461883347], [127155.55250536684, 386247.6211169116], [127169.13316591398, 386245.8820076019], [127279.96101933817, 386231.6860263768], [127364.44542111478, 386220.8644126852], [127376.68766294338, 386219.29579115], [127441.30156084879, 386211.01939211774], [127441.66863786915, 386210.972088378], [127447.31878769776, 386210.24895262456], [127448.71245945303, 386210.070457622], [127451.6681579873, 386209.6918323436], [127453.42215628251, 386209.4669607673], [127487.01710594994, 386205.16542415146], [127528.25008129903, 386199.88481151155], [127628.88910671673, 386186.9974485333], [127702.99560295018, 386177.5083111396], [127717.090476893, 386175.70273640443], [127755.57156209585, 386170.7750060513], [127794.8879313179, 386165.7402148861], [127865.2520864286, 386156.7299633342], [127884.77588928731, 386154.23024463974], [127899.7303649973, 386152.31549444795], [127904.9561017006, 386151.6461685845], [127993.19633186853, 386140.3460355361], [128099.13310447504, 386126.7803207646], [128335.2277877046, 386096.5479526237], [128339.4212812547, 386096.0108675639], [128342.5410593538, 386095.6109975283], [128367.59178954059, 386092.40348914405], [128374.14115800435, 386091.56483234145], [128374.7137775795, 386091.4914195754], [128382.4037360425, 386090.50695188745], [128382.65574849387, 386090.4744702826], [128431.36363532006, 386084.23610021884], [128500.09578377097, 386075.43367227254], [128518.1320336151, 386073.12330551323], [128531.94036636397, 386071.3552381036], [128555.0915615593, 386068.3898782286], [128568.89892159661, 386066.62206354993], [128639.01005419547, 386057.64268693497], [128658.30038908093, 386055.1724913632], [128673.78893338764, 386053.1886778122], [128708.33231286156, 386048.76447640016], [128722.07937912013, 386047.0034927035], [128781.75601944794, 386039.36092294304], [128850.32311460564, 386030.5791422632], [128869.16380695354, 386028.16587152245], [128878.377539575, 386026.9864662102], [128880.324539575, 386026.7364662102], [128930.4500232746, 386017.68441582494], [128979.39444712168, 386003.57955472753], [129026.64986515482, 385984.5682633771], [129071.72585994018, 385960.84784123907], [129114.15463213096, 385932.6644592085], [129153.49585529591, 385900.3106048448], [129189.34124563372, 385864.12204693176], [129221.3187991483, 385824.4743508635], [129249.09665231187, 385781.7789810218], [129272.38652614961, 385736.47903059225], [129290.94671800314, 385689.0446231367], [129304.5846099243, 385639.9680336439], [129310.73860992432, 385612.4600336439], [129318.58311994038, 385568.1004473919], [129322.40324091127, 385523.21486055595], [129322.86324091126, 385511.67486055597], [129322.5190808173, 385464.55025502766], [129321.23527849349, 385451.95662903227], [129322.54469615621, 385448.79129324784], [129337.42645448781, 385398.38360326004], [129346.93460674824, 385346.6922405237], [129347.96460674824, 385338.77224052366], [129351.59090215557, 385297.7164025403], [129351.84090215557, 385292.3864025403], [129352.37894392274, 385265.6349503729], [129352.10894392274, 385225.0349503729], [129346.47370490576, 385153.4306035928], [129338.99370490576, 385104.0806035928], [129337.92078742856, 385097.31505062216], [129330.83078742857, 385054.50505062216], [129321.13888049708, 385009.1496373103], [129315.36579905308, 384987.175689866], [129307.77791306042, 384950.19117295113], [129290.89781477713, 384888.35704886116], [129278.76781477714, 384853.0170488612], [129263.24314293037, 384813.3709112753], [129252.86414293037, 384789.8659112753], [129225.83451300405, 384737.30160990194], [129221.41351300405, 384729.8266099019], [129198.7170319434, 384694.8645923223], [129187.28912099412, 384678.771823959], [129166.9387239217, 384647.49192791834], [129163.19924447175, 384641.8285595428], [129156.65924447174, 384632.0685595428], [129123.00156282105, 384587.4506497782], [129116.35156282106, 384579.59064977814], [129084.74200175832, 384545.568588869], [129050.11222979038, 384514.6259989236], [129045.13222979038, 384510.5759989236], [129013.16006710037, 384487.22955391835], [129008.76881461946, 384481.5161525687], [128996.80630232, 384467.462035358], [128995.39585580102, 384465.7121765751], [128971.1426277889, 384437.80128106195], [128969.4886277889, 384436.03428106196], [128948.08878674652, 384415.4941340592], [128936.9906612668, 384342.9115833396], [128936.7590228853, 384341.4118865802], [128933.59902288529, 384321.15688658017], [128933.14019042464, 384318.27124312444], [128927.65819042464, 384284.43224312447], [128926.87832095534, 384279.75869262905], [128919.46664638148, 384236.6030166567], [128914.62264107709, 384207.06398789294], [128911.79258302014, 384189.86603293364], [128910.2918843987, 384162.3413040552], [128910.27305297181, 384158.3195433797], [128922.17560472451, 384118.892788902], [128931.87181031189, 384068.7430984221], [128936.40097174032, 384017.8658485478], [128935.7158225388, 383966.79199585784], [128929.82351294592, 383916.0545486844], [128918.7855352898, 383866.18300462083], [128902.7170822522, 383817.69782466866], [128881.7858447141, 383771.10500168975], [128879.29884471411, 383766.2490016897], [128842.9006321354, 383706.43358214526], [128824.41565961321, 383674.7920502742], [128798.3222594091, 383638.1435455594], [128793.41925940911, 383631.8745455594], [128756.09379716092, 383589.34718442895], [128716.51179558056, 383553.4064676177], [128699.64988214642, 383536.16599791945], [128661.85978133795, 383504.47634009336], [128655.45978133795, 383499.6263400933], [128610.77488420036, 383469.41414601094], [128591.63888420037, 383457.92914601095], [128571.17022828493, 383446.2909188804], [128566.39922828492, 383443.7249188804], [128516.22901749598, 383420.2267020128], [128496.56353962788, 383413.5529726724], [128489.9137280169, 383409.2291905011], [128459.49443901127, 383392.6998808271], [128449.38863042141, 383379.760787078], [128426.59112990802, 383349.15564931754], [128413.65608384095, 383332.53325258376], [128399.42771414295, 383315.0226517032], [128363.59669710258, 383267.8216541172], [128348.02517295314, 383248.3378082923], [128326.83317295313, 383223.1368082923], [128293.40198316508, 383187.13200418366], [128256.59846830525, 383154.58217064326], [128255.01972894208, 383153.31855957286], [128222.54012761435, 383127.33607834816], [128209.57792607283, 383116.96631711494], [128143.23995172566, 383063.7433999242], [128138.4236121768, 383059.87865233823], [128132.93261217681, 383055.4736523382], [128131.39547993471, 383054.245494183], [128131.11147993471, 383054.019494183], [128099.86692938818, 383031.07620132307], [128059.97578466444, 383004.09954389266], [128024.70545643005, 382971.3445973853], [127995.88335475112, 382946.5506427155], [127966.12219238299, 382922.856668017], [127746.22621955247, 382746.1450494778], [127743.29686456284, 382743.79115713027], [127741.25233201149, 382742.14828693715], [127698.46137204552, 382707.35859560414], [127694.14571687827, 382703.84873764793], [127633.03105862156, 382654.1600154992], [127582.25329667027, 382612.8754612193], [127576.83478586565, 382608.4697937375], [127501.55078586565, 382547.26079373754], [127499.07676740944, 382545.26235033997], [127382.05569322422, 382451.3494338966], [127343.7062105528, 382420.59093113715], [127266.84114186694, 382358.9144543795], [127183.89925934117, 382290.7493781062], [126991.80358761868, 382132.8766478992], [126990.73013981336, 382131.99693417735], [126990.25716213966, 382131.6105920675], [126984.49020366969, 382126.9049384121], [126980.62445006236, 382123.75153261673], [126910.56169365237, 382066.5841300147], [126898.02644450625, 382056.6853160977], [126859.12624925259, 382026.9630253503], [126796.87138473032, 381973.8587413424], [126789.08606655145, 381967.3530517579], [126723.40184975993, 381913.5872790596], [126652.37933004416, 381854.4667802803], [126612.89778118579, 381821.5572004159], [126579.35890023343, 381793.5765183309], [126574.85765076948, 381789.82182726986], [126569.66622912051, 381785.4904819498], [126505.03846956177, 381731.57411531644], [126393.60846956178, 381638.6581153164], [126393.41470254587, 381638.49671059934], [126256.38656187292, 381524.1573165529], [126226.31904271488, 381499.02266430657], [126225.8130958993, 381498.60028911807], [126153.89031482638, 381438.63801273005], [126149.86341733646, 381435.27681861835], [126027.84986416288, 381332.17524236534], [126020.83361740096, 381326.2461041884], [126018.89366091219, 381324.6067386152], [125918.29943014862, 381239.62118058547], [125866.99365886803, 381196.3112536807], [125736.22917303561, 381038.02657834435], [125714.54838769382, 381011.7560047814], [125668.49622984082, 380955.9981319633], [125662.14215428966, 380948.30383708683], [125658.60738360108, 380944.02311497234], [125572.68248396607, 380839.9698285304], [125485.451575682, 380734.13866058056], [125484.50236518787, 380732.9871593254], [125359.52385230437, 380581.20337429113], [125274.08198373768, 380477.5636864952], [125130.91963152104, 380303.43722032843], [125088.36820954281, 380251.67014861933], [125045.28905476256, 380199.3352232564], [124881.2639177295, 379999.8515338555], [124828.506665481, 379935.7444424732], [124793.59017214544, 379893.3158430051], [124760.46585803245, 379853.06532185624], [124755.97578702886, 379847.60902046866], [124754.49876345412, 379845.8142069773], [124737.23202084753, 379824.83216526674], [124708.9087121484, 379790.41349918285], [124665.4857121484, 379737.64849918283], [124664.97586187544, 379737.0299711535], [124570.14118566245, 379622.16840756556], [124566.28103476047, 379617.4934912378], [124470.83388300479, 379501.8915744063], [124470.33090868023, 379501.28336960805], [124459.02296549876, 379487.63157303695], [124443.44820701116, 379468.8296299553], [124369.95648697398, 379379.7054815413], [124366.5661239322, 379375.63802646054], [124341.03660589027, 379345.33766418305], [124272.9932888024, 379264.5810889259], [124136.37419782043, 379102.5851608369], [124057.2918697082, 379006.54343412345], [124036.19375047096, 378980.915074094], [124034.65945390308, 378979.04396053415], [123937.18653184382, 378860.1535576152], [123894.04975081161, 378807.5024084298], [123848.56566202115, 378751.89246363443], [123847.46813707131, 378750.5553297649], [123831.88028326278, 378731.63122320484], [123753.44412556427, 378636.4110255093], [123647.82982543037, 378507.77401788125], [123646.07582543037, 378505.63801788125], [123643.05249639928, 378501.99159939034], [123572.19110097045, 378417.34535208106], [123493.53469796576, 378323.35011082777], [123459.6791195637, 378286.76409990835], [123422.3489044919, 378253.7309131619], [123418.72654306208, 378250.83423750877], [123405.65754306207, 378240.38523750874], [123405.48662570055, 378240.5990109797], [123388.7466988725, 378227.6747657249], [123377.73267739052, 378216.0260993014], [123341.47754979339, 378184.4102685841], [123302.35203585759, 378156.4247511101], [123260.71828056216, 378132.3285802726], [123216.96164511824, 378112.3447897498], [123028.48707648825, 378037.00190614903], [122992.45943350399, 378022.55922968703], [122985.71276847179, 378019.85497967707], [122975.55213036624, 378015.78133231495], [122903.97513036623, 377987.08633231494], [122901.96050089938, 377986.2837402654], [122891.52321833429, 377982.1519198542], [122890.34292358143, 377981.68474042485], [122811.5996550696, 377950.5111408127], [122734.56266302223, 377919.9727672055], [122688.36781797164, 377904.2229378878], [122640.85750841459, 377893.05193441565], [122592.48441653959, 377886.56619504094], [122543.70944519703, 377884.82751642895], [122494.99732637833, 377887.8524648543], [122446.81219321083, 377895.61221835646], [122399.61315765868, 377908.03284135734], [122398.453807202, 377908.3992920988], [122328.17846914005, 377930.58078202425], [122325.8201797396, 377931.33156826533], [122324.31832662984, 377931.81379710604], [122286.76493296554, 377943.8745293811], [122243.15412434476, 377957.8812196918], [122186.0724301923, 377976.2125157685], [122142.97727422926, 377990.05237134686], [122140.97469965626, 377990.69623340026], [122130.07027075985, 377994.2056714028], [122124.985082756, 377995.8426498791], [122084.14526405215, 378008.9853658367], [121965.32184204155, 378047.28444800974], [121907.82500892431, 378065.1824854084], [121861.1468462631, 378082.301722145], [121816.39962969883, 378103.9721108268], [121774.02580523508, 378129.97938165994], [121734.44435154209, 378160.06638316263], [121698.04663723108, 378193.93562479573], [121665.19255112806, 378231.2522184534], [121636.20694380958, 378271.64718972764], [121611.3764155852, 378314.72112620866], [121590.94648268641, 378360.048126745], [121575.11914968154, 378407.18001261674], [121564.05091211986, 378455.6507589814], [121557.8512091543, 378504.9811027772], [121556.58134144245, 378554.68328152085], [121560.25386502549, 378604.2658561454], [121568.83246717813, 378653.23857019085], [121582.23232545711, 378701.11719730124], [121600.32094639802, 378747.42832909833], [121622.91947556788, 378791.71405609057], [121649.80446601991, 378833.53649533394], [121669.27271682772, 378858.0693521417], [121652.68409695421, 378864.17758510815], [121604.94790039079, 378884.62895426713], [121588.43267731808, 378892.7441276402], [121584.48367731807, 378894.68512764026], [121542.34916837276, 378917.97765977035], [121502.65018055253, 378945.2145697115], [121465.7547804659, 378976.1433322076], [121432.00504143826, 379010.4771932293], [121401.71387200113, 379047.8978285957], [121375.16211478085, 379088.0582952963], [121352.59594268425, 379130.58624815085], [121334.22457652239, 379175.0873919838], [121320.21834523333, 379221.14913730643], [121310.70710668826, 379268.344425614], [121310.00456634938, 379275.17176214064], [121291.03360904807, 379299.61363528186], [121264.64058718078, 379341.64193931106], [121242.54402340825, 379386.0796689145], [121224.96161042014, 379432.4890289227], [121215.93333980202, 379466.0421387549], [121211.55522471512, 379480.1511551391], [121201.48371413971, 379530.1188180085], [121196.55187749775, 379580.8522354494], [121196.81097043354, 379631.8241446617], [121200.16761069848, 379663.0535264975], [121175.11374685226, 379684.14383773215], [121141.1642679662, 379718.88333587383], [121110.74585492576, 379756.7531126869], [121100.16044001584, 379772.92660894094], [121043.8256807423, 379781.305358281], [121033.10381746439, 379782.9003627046], [121023.20995377388, 379784.37136886554], [120975.54441811498, 379793.84594782564], [120929.0238367147, 379807.9032036852], [120884.08769340135, 379826.4103363709], [120841.16050368399, 379849.19250745024], [120800.64780431877, 379876.03449184535], [120762.93232216933, 379906.68271108164], [120742.77485698531, 379926.6086084759], [120728.40779010898, 379931.23376346356], [120682.11425589088, 379951.4954568566], [120676.10025589088, 379954.49845685664], [120632.01030210337, 379979.37881936954], [120590.66228831012, 380008.5900880703], [120552.48010714799, 380041.8327941193], [120517.85519568899, 380078.7661390831], [120511.49993305988, 380087.0939640518], [120467.56294163612, 380110.76761102775], [120461.83794163613, 380114.31061102776], [120421.56687856128, 380142.0447091839], [120414.29787856128, 380147.5937091839], [120384.60180907125, 380172.1298867586], [120373.6232763156, 380181.9363976828], [120355.15778541139, 380198.4139554642], [120337.53737957847, 380214.9186169836], [120288.51489676669, 380263.1109824934], [120275.02954390606, 380266.8449882953], [120242.63581519513, 380279.4381269578], [120242.31240434416, 380279.41088147886], [120194.91147050931, 380277.6754589442], [120147.55938140521, 380280.4394917351], [120100.6822793583, 380287.67810510186], [120054.70203207701, 380299.32615557144], [120016.82309669371, 380312.85369764105], [120011.03302605759, 380312.11013975914], [120008.70694717787, 380310.1128016901], [119969.74655289929, 380282.642521687], [119928.34713954336, 380259.00743802794], [119884.8850325145, 380239.42239632766], [119880.05003251451, 380237.51539632765], [119840.53984039082, 380223.8119095825], [119814.50366784504, 380215.9850601705], [119751.0444924303, 380196.9072099628], [119704.38026539118, 380185.2931316596], [119656.81615570252, 380178.21553535055], [119635.95553595327, 380177.14016637893], [119614.47250290783, 380136.08834508184], [119587.68369225433, 380095.1944210657], [119557.02933567819, 380057.1120915601], [119522.80248311399, 380022.20541653625], [119485.33033689208, 379990.80809730047], [119444.97112374514, 379963.22028637194], [119402.11067022754, 379939.7057180804], [119357.15871428534, 379920.48918731546], [119310.54498823785, 379905.75440052914], [119301.06680048729, 379903.75052440015], [119290.01590753639, 379887.4189003394], [119256.51322922534, 379847.5671727122], [119253.92022922535, 379844.7901727122], [119253.46226269148, 379844.30036758416], [119253.45547252716, 379844.2931151108], [119198.03735659637, 379784.94316721195], [119163.40462575047, 379751.27196117415], [119125.68446237854, 379721.0996984635], [119085.22889762459, 379694.7079678964], [119042.41549132581, 379672.34307569946], [118997.64380835815, 379654.213746806], [118951.3316896153, 379640.489176888], [118903.9113524231, 379631.29745330295], [118855.82535678287, 379626.7243596923], [118807.52247508957, 379626.81257538794], [118759.45350387169, 379631.56127709895], [118712.06705664031, 379640.92614659475], [118665.80537711176, 379654.8197843143], [118621.10021187754, 379673.1125250402], [118578.36878104102, 379695.6336480262], [118538.00988442537, 379722.172970283], [118500.40017969259, 379752.4828081546], [118492.97985338992, 379759.7500314906], [118488.24118112717, 379760.51205831335], [118459.2788058881, 379763.66815972276], [118410.05426394966, 379769.03925751586], [118404.03726394965, 379769.69625751587], [118392.38917557578, 379771.2705561652], [118367.71680534547, 379773.61800283036], [118362.2673967211, 379774.5657917051], [118319.66952057902, 379780.03359567607], [118301.40498049487, 379781.18267727626], [118253.67726319145, 379788.86299302743], [118206.9143090614, 379801.1164974267], [118161.55324365647, 379817.82864852593], [118118.01808810858, 379838.8432263341], [118107.15208810859, 379844.7522263341], [118067.28965697631, 379868.90233067324], [118029.8491037105, 379896.65923839936], [117995.15574792394, 379927.7817707454], [117963.51103892994, 379961.9995051539], [117956.47003892994, 379970.3635051539], [117924.432840647, 380012.8121348037], [117898.1913703565, 380056.5788675824], [117875.79180674267, 380061.77161537256], [117831.46860938807, 380076.52185648703], [117788.71540385729, 380095.34415319894], [117774.6614696511, 380103.1718047583], [117737.86424603908, 380084.3161047033], [117691.83835844418, 380066.2211496297], [117644.25002538881, 380052.76156995475], [117595.56481490475, 380044.06904396194], [117546.25902603759, 380040.2286127099], [117496.81502909958, 380041.277848055], [117447.71654652557, 380047.20648507733], [117410.26394532705, 380055.5469649264], [117380.38180739646, 380053.37502615794], [117331.94520642413, 380054.55634017766], [117283.85035253679, 380060.42019949725], [117236.5488563771, 380070.911542482], [117190.48487895935, 380085.93185542885], [117189.28241744448, 380086.3895160054], [117170.54395702653, 380093.51917911496], [117157.07357736176, 380098.8691936787], [117136.99088864645, 380107.1843903592], [117093.63063313463, 380124.47003013757], [117091.20865495574, 380125.44288967707], [117045.25766179092, 380144.0399049772], [116999.2749177199, 380162.56253705], [116997.27755016556, 380163.37211828545], [116926.08955016555, 380192.40511828545], [116921.7653219839, 380194.1923362728], [116876.72277972198, 380213.0558059499], [116832.009871498, 380231.5397743103], [116810.42344823312, 380240.4181102565], [116791.56540895175, 380238.20795691205], [116787.94443433695, 380237.7969516676], [116745.65494367083, 380233.1528413765], [116693.84293371483, 380227.2363673645], [116690.83363797294, 380226.9019596317], [116644.69933236398, 380221.91665322706], [116563.65403878455, 380212.9490816131], [116458.56921242442, 380201.1973212129], [116377.53205157295, 380191.92572538834], [116376.44039991856, 380191.802042589], [116285.89488083046, 380181.644086939], [116249.25712138804, 380177.5345589322], [116150.35143208242, 380166.4990233962], [116051.88062801694, 380155.236936853], [115980.85886283535, 380144.9239081464], [115953.30537672018, 380140.8191472002], [115910.08457738976, 380134.3797730489], [115742.62651410971, 380109.4299126125], [115741.51172779758, 380109.2651026405], [115673.47067375388, 380099.2842539883], [115653.04414656821, 380095.41796535376], [115645.35403666677, 380094.3266460864], [115621.0644588335, 380090.87777121883], [115582.51569448528, 380084.76328952174], [115550.1260498557, 380079.62513907417], [115542.97880150267, 380078.49130651884], [115470.75880150267, 380067.03530651884], [115469.03238701318, 380066.7645435717], [115350.70813623053, 380048.4189117526], [115195.8345729249, 380024.0238824574], [115112.77710275189, 380010.7217511055], [115068.11008339594, 380003.18042952736], [115060.1852773614, 380001.90778494574], [115026.74865891486, 379996.81314781593], [114957.00555703521, 379986.18591273675], [114933.05224776208, 379982.2925926575], [114928.57337384354, 379981.58543619065], [114874.5187266828, 379973.3019399446], [114801.44302120124, 379961.71123103163], [114800.11950185438, 379961.5031219781], [114664.37606624207, 379940.34526377637], [114620.04125941142, 379933.20578413317], [114573.12787476993, 379925.6509364975], [114485.17423187394, 379910.86192673433], [114345.64761644912, 379881.6247794974], [114172.3064643711, 379845.3011189987], [114120.1758313705, 379834.3776149821], [114044.73119624755, 379818.5681105446], [114043.23941751359, 379818.25787877996], [114002.18405033537, 379809.78520514205], [113971.57132587742, 379793.7039631061], [113960.71830048061, 379788.1703746034], [113927.44241145627, 379771.71180984145], [113926.41241145627, 379771.20280984143], [113863.69458310971, 379745.3427987511], [113834.78458310971, 379735.65979875106], [113768.98796169856, 379718.4983099099], [113756.66396169856, 379716.1653099099], [113708.36934950804, 379709.44266836694], [113659.64956858258, 379707.4561078912], [113630.81057423152, 379709.09611633694], [113608.21465533339, 379697.53729821346], [113560.7434583247, 379679.07437936735], [113511.64019598906, 379665.5368926821], [113461.41444114709, 379657.06532445], [113410.58741537028, 379653.7475890116], [113359.68657996475, 379655.61811641743], [113309.24016220166, 379662.6574951278], [113259.77167359866, 379674.7926734574], [113126.69467359866, 379714.72467345744], [113078.06587391588, 379732.1007199608], [113031.48863267025, 379754.3997726003], [113020.04963267026, 379760.62177260034], [112980.45777363857, 379784.5955762965], [112943.2524011573, 379812.12771794543], [112908.75232933793, 379842.9822736821], [112904.25627499219, 379847.82281188644], [112865.00724514923, 379865.2968213677]], [[112541.28900580003, 381414.9720763106], [112559.45092856753, 381368.7510699446], [112560.50392856753, 381365.6230699446], [112563.9627764247, 381353.63830507785], [112575.20601630925, 381340.1256245116], [112588.037582522, 381321.5490696371], [112597.24460844148, 381309.8049159413], [112602.14560844148, 381302.9759159413], [112631.139741919, 381257.6031671865], [112655.08659231236, 381209.3756391354], [112659.68959342517, 381196.887221372], [112662.83170963096, 381196.22789256845], [112671.30555089073, 381193.98371502757], [112691.41287570215, 381191.26663530746], [112741.74768775533, 381179.0581742312], [112790.54948180394, 381161.70811014157], [112793.87448180394, 381160.32811014156], [112856.62248802652, 381128.9568140553], [112858.65948802652, 381127.7528140553], [112899.09686605033, 381101.1288278728], [112936.76969153441, 381070.7186913763], [112946.06247506996, 381062.4431623654], [112954.46559851256, 381054.9898906155], [112992.38040701316, 381017.13622243894], [113023.35964478225, 380988.2144259422], [113053.46671512129, 380954.5274910433], [113080.4100209217, 380918.2603772923], [113080.74024150126, 380917.7200278104], [113101.5347408577, 380892.37644598796], [113113.87388307418, 380884.2501356852], [113118.88962858959, 380880.71070194815], [113150.98544197844, 380862.0737307195], [113172.35644197844, 380847.7857307195], [113190.69136244389, 380834.2679698127], [113208.59955257579, 380834.1996886306], [113258.21931873054, 380829.0391530425], [113307.07785201746, 380818.9596666539], [113354.68876528413, 380804.06157084525], [113400.57809144698, 380784.4931762988], [113404.36275542497, 380782.4113609681], [113418.26821101045, 380788.8204188534], [113464.23973516916, 380804.7986475371], [113511.54692531111, 380816.2316955217], [113559.74155814265, 380823.011237658], [113608.36700208197, 380825.0730395516], [113656.96254372432, 380822.3975661673], [113705.06775298144, 380815.0101669177], [113752.22684553658, 380802.98083548486], [113793.9535617682, 380787.8849358709], [113840.32619849182, 380797.45494446397], [113915.0839362293, 380813.1203363134], [113967.21739349137, 380824.04443213576], [114140.55324820505, 380860.3669825907], [114289.86450875207, 380891.6544562832], [114309.5011157555, 380895.3612056767], [114409.0161157555, 380912.0942056767], [114412.43007885633, 380912.65610930265], [114461.05207885633, 380920.48610930267], [114506.50192685905, 380927.805150207], [114507.25550085738, 380927.9269141412], [114509.99289676257, 380928.3614460362], [114512.84089676257, 380928.80544603616], [114645.45991580967, 380949.4711878601], [114719.15897879876, 380961.16076896834], [114720.06173709345, 380961.3033785675], [114722.23951985588, 380961.6420953629], [114725.74951985588, 380962.1800953629], [114774.86896595443, 380969.7049897689], [114799.01975223792, 380973.6304073425], [114803.91695640428, 380974.4014888139], [114876.11295640428, 380985.4024888139], [114905.58921211389, 380989.8936973915], [114948.38191660406, 380997.11857047264], [114952.55077511029, 380997.804314226], [115038.01274780465, 381011.49154048035], [115041.3967160212, 381012.08839060745], [115195.89771602121, 381036.36339060747], [115196.89761298682, 381036.5194564283], [115314.95416915936, 381054.8235834272], [115386.3081560605, 381066.1422108703], [115393.44712064517, 381067.2747293349], [115425.84378000292, 381072.41399257095], [115468.42083150684, 381079.1674283766], [115476.46007360687, 381080.37567176315], [115500.81830001157, 381083.8342940349], [115521.43307928348, 381087.77316495316], [115596.10706964855, 381098.63807234366], [115665.97963521328, 381109.04850421555], [115665.34741467387, 381109.5631950253], [115629.93610529495, 381144.82387576066], [115628.30998078942, 381146.8040258421], [115609.43003661296, 381147.8711489524], [115565.00871885197, 381154.4164609039], [115553.86571885196, 381156.5734609039], [115507.69128863983, 381167.8119550654], [115462.79237176926, 381183.38337183726], [115419.5745638192, 381203.1470464052], [115378.42827402578, 381226.9244430808], [115339.72519850983, 381254.5007681086], [115333.00519850983, 381259.7877681086], [115322.78646746438, 381268.6561543528], [115296.7619978086, 381287.5238807727], [115268.22275391614, 381311.66402731434], [115260.75775391613, 381318.47302731435], [115227.00164860672, 381352.3592298297], [115196.63786702865, 381389.3158278177], [115169.9442680702, 381429.00463154394], [115166.93837389766, 381434.5545043566], [115140.11748804676, 381449.15886719024], [115139.81994055666, 381449.1979872834], [115094.99016837856, 381459.34936452645], [115051.28205004423, 381473.5746703278], [115009.06496442358, 381491.7536861199], [115008.74242063613, 381491.92929542536], [114999.75482836396, 381495.35901055404], [114954.00153320367, 381518.4321850139], [114933.50663408192, 381531.5574029116], [114916.64821997604, 381532.88535059546], [114907.65021997604, 381534.0243505954], [114869.78189425742, 381540.7773339947], [114823.16430350648, 381539.47099348425], [114819.14330350648, 381539.56199348427], [114776.14130912117, 381542.39284038165], [114733.54280449935, 381548.91607725114], [114729.75180449933, 381549.66507725115], [114681.26703606067, 381561.7904498048], [114634.2349662647, 381578.69553308823], [114589.12550144369, 381600.21142520726], [114550.75601235157, 381623.47556128557], [114517.9300994886, 381637.7318053303], [114469.30451688266, 381665.70027318504], [114424.11781118368, 381698.93946851196], [114398.66481118368, 381719.96146851196], [114364.45000193077, 381750.98669567157], [114362.08867453669, 381753.5632295172], [114329.58361918574, 381760.3474977142], [114282.19185907893, 381775.27672559855], [114236.5158697208, 381794.8359885551], [114224.71760709384, 381801.3429599457], [114217.88372535825, 381801.8091354413], [114213.65672535825, 381802.29713544133], [114167.04090050141, 381809.92489132256], [114121.35289721219, 381821.9175616804], [114105.0653805832, 381827.8852432549], [114103.6333332774, 381827.7233481245], [114074.92856244369, 381827.3738028825], [114054.39092711941, 381820.0929228138], [114004.60113309968, 381808.00488073326], [113953.83568703383, 381801.07567907625], [113902.6276554175, 381799.3780784611], [113851.51475215015, 381802.92990467447], [113804.09075215015, 381808.6789046745], [113789.3969675987, 381810.6816951396], [113783.8039675987, 381811.5286951396], [113732.78829106393, 381822.1969784824], [113699.84801225759, 381824.6779158464], [113695.08001225759, 381825.2669158464], [113668.33468065523, 381829.96816348546], [113626.7636690778, 381832.03494409984], [113614.76966907781, 381833.2709440998], [113565.5650216476, 381840.83296401374], [113517.35623671717, 381853.25047300063], [113470.62121404077, 381870.4003747306], [113425.82324378195, 381892.1126600686], [113383.40641385973, 381918.17209239665], [113343.79120764926, 381948.3203412813], [113336.52324655243, 381955.09287359234], [113311.38276216747, 381960.123613366], [113266.08837996535, 381973.74509619846], [113222.28375910857, 381991.58552907495], [113180.36088539641, 382013.48526682094], [113140.69490580747, 382039.2483395584], [113131.11734677236, 382046.8464296163], [113118.5634245959, 382054.8725269338], [113081.144732195, 382084.14748241944], [113046.67351503631, 382116.84177469317], [113015.46100430266, 382152.6602159404], [112987.78900920869, 382191.2794112608], [112963.90737262258, 382232.35067851236], [112955.50888951885, 382250.58482730546], [112911.0683070753, 382248.71839184436], [112889.3493070753, 382248.7983918443], [112876.58502944179, 382249.2969959066], [112850.95870872204, 382242.37642075523], [112837.56976069955, 382238.7608144876], [112835.89121231982, 382238.3106607713], [112753.39221231981, 382216.33966077137], [112681.26166890426, 382202.7064743851], [112679.77933415068, 382202.5377587922], [112644.17550740813, 382197.73311128677], [112607.69324780458, 382192.8091917194], [112581.05540556223, 382189.1486935305], [112584.84049458278, 382147.4791237398], [112585.07549458278, 382141.3111237398], [112583.6903781723, 382080.50697819324], [112576.3110740268, 382029.791853138], [112582.72539825461, 381982.68279731413], [112583.03373495977, 381979.1089945618], [112602.86117510969, 381935.14917473175], [112605.1841751097, 381929.20417473174], [112619.83623365288, 381885.9844871113], [112630.48664444253, 381841.6088973397], [112637.04668426489, 381796.44707612874], [112639.46170472875, 381750.8752438886], [112637.7115875137, 381705.2730366252], [112631.81091196572, 381660.0203433833], [112621.808833644, 381615.49414158246], [112619.277833644, 381606.22714158247], [112603.45910748144, 381558.062988075], [112582.84457283451, 381511.74820920493], [112569.48412308033, 381488.42466221185], [112567.0134163367, 381482.1022438338], [112545.89036271619, 381440.15582441405], [112540.16636271619, 381430.0058244141], [112536.53084576823, 381424.2524451966], [112541.28900580003, 381414.9720763106]], [[117484.8700266642, 381325.87831467035], [117502.92411067376, 381281.18321996595], [117516.5903604617, 381234.9573067052], [117522.68581463512, 381203.434235468], [117527.87366374921, 381204.62178683694], [117575.41673034507, 381210.79450853803], [117623.33243262663, 381212.385467181], [117671.18024403926, 381209.3800358377], [117685.61167161603, 381207.0710723148], [117690.05449778833, 381207.2006930734], [117696.63549778833, 381207.0636930734], [117745.97014680113, 381203.59016584296], [117794.72029488935, 381195.2597369216], [117822.67586707052, 381187.57697292295], [117841.28068545845, 381185.3603794553], [117890.98199944975, 381174.22036998963], [117939.29208317654, 381158.0817134883], [117985.42794751632, 381137.23913035553], [118028.4988486261, 381131.27934525034], [118032.3778486261, 381130.53834525036], [118076.66530785381, 381119.9675656441], [118119.80753134273, 381105.41184584866], [118161.44676299386, 381086.99188890425], [118169.82599354477, 381082.33141939685], [118174.17830801038, 381082.27886479866], [118175.66478953004, 381082.72343232716], [118218.2067983539, 381091.5110836612], [118224.92579835391, 381092.5970836612], [118274.69360560834, 381098.10144337855], [118324.76239307408, 381098.6005791543], [118374.63004439097, 381094.0894853902], [118386.87904439097, 381092.3594853902], [118409.57904272579, 381088.02402104926], [118436.70512697226, 381109.33291325666], [118477.55193961195, 381135.4490917552], [118520.73608800292, 381157.4864738578], [118565.85155186582, 381175.23786260973], [118612.47415256285, 381188.5363582553], [118660.16554125387, 381197.25692744035], [118665.49854125387, 381197.9669274404], [118718.17872689551, 381204.97447323863], [118745.14894955557, 381208.56270459713], [118794.40026853453, 381212.65137523186], [118843.81464015815, 381211.8579486324], [118880.26199805964, 381207.6502545281], [118894.79506395095, 381224.5249928894], [118930.3061021072, 381258.3876143686], [118968.9653080436, 381288.6064290499], [118999.8620329387, 381308.20550503035], [119008.8391730921, 381314.33018033864], [119014.22235358837, 381317.95190867817], [119021.45819841773, 381322.75218151364], [119047.5960434165, 381340.0944532652], [119052.28645290837, 381343.1687616599], [119067.7810002222, 381353.2008211074], [119085.78354846338, 381364.8568811412], [119127.80788934657, 381389.25331216614], [119172.00193817346, 381409.4552210291], [119217.94828549866, 381425.27180223033], [119265.2129715501, 381436.5536693577], [119313.34958494628, 381443.19426603033], [119361.9034790179, 381445.13087231544], [119410.4160659113, 381442.34519711323], [119458.42914791597, 381434.8635509151], [119505.48924510728, 381422.75659730297], [119551.15187843, 381406.13868553715], [119594.98576776935, 381385.16677053616], [119636.57690535902, 381360.0389304496], [119644.82352140617, 381353.8900061465], [119656.89960997188, 381362.285991561], [119700.75011237903, 381386.6511152229], [119746.82138728781, 381406.4996275273], [119794.64967648813, 381421.6317313001], [119843.75353548265, 381431.89510522224], [119893.63867975678, 381437.18643711216], [119897.2210710308, 381437.3854250942], [119897.90717327838, 381437.47901826707], [119947.11116618132, 381444.33322735335], [119951.44902995374, 381444.91686824604], [119937.21594738908, 381467.7944159898], [119915.55999685042, 381511.649475599], [119898.29247891426, 381557.41058650543], [119885.81829383527, 381603.7495467484], [119870.10643173195, 381632.71457694337], [119850.99321991742, 381678.11627878115], [119836.44039000451, 381725.1784136367], [119826.58919929265, 381773.44417207054], [119821.53526853767, 381822.44506164984], [119821.32765380734, 381871.7054543783], [119825.96837031767, 381920.7472033877], [119835.41237287226, 381969.09428407915], [119849.56799309427, 382016.2774146638], [119868.29782920712, 382061.838611255], [119891.42007972726, 382105.3356332969], [119918.71030812348, 382146.34627618047], [119949.90362131399, 382184.47246937925], [119984.69724085588, 382219.34414032876], [120022.7534418693, 382250.62280654174], [120063.70283116997, 382278.00486109464], [120114.67382504967, 382308.5663299548], [120168.76646927075, 382341.39174723683], [120211.80256363143, 382364.70541540807], [120256.91190965268, 382383.69961038855], [120303.66224566549, 382398.1923197318], [120351.60558516478, 382408.0446666135], [120400.28250965354, 382413.16224062233], [120449.2265710345, 382413.49600245105], [120497.96876136302, 382409.04275381676], [120546.04200712996, 382399.845168109], [120592.98564500757, 382385.9913814701], [120638.34983616983, 382367.61414822855], [120681.69987688647, 382344.8895687762], [120715.75446949809, 382322.541161674], [120729.864640535, 382317.07527277776], [120772.3728616684, 382295.76462907577], [120812.66446281929, 382270.5123167932], [120815.71446281929, 382268.3923167932], [120854.68381920511, 382238.3573800181], [120890.5126086663, 382204.63786030095], [120922.85390703018, 382167.5602581084], [120951.3945589168, 382127.4835896579], [120985.8045589168, 382073.75358965783], [120986.36466027975, 382072.8770046659], [121000.71466027976, 382050.36700466595], [121024.98873729182, 382007.8271188738], [121044.98429303094, 381963.11637689074], [121060.50946032615, 381916.66380022967], [121071.41526757764, 381868.9151241623], [121077.59706821234, 381820.3285206701], [121078.99554481918, 381771.3702020595], [121075.59727832874, 381722.509947426], [121067.43487677586, 381674.2165948929], [121054.58666240949, 381626.95354287984], [121037.17592015225, 381581.17430356715], [121015.36971462116, 381537.3181512242], [120989.3772870606, 381495.80590715684], [120969.54164000554, 381470.11102959776], [120946.69203858144, 381427.22480229667], [120918.55442156078, 381385.25813484035], [120886.32503064042, 381346.3455015461], [120850.33298290682, 381310.8842668111], [120810.94581859409, 381279.2365503627], [120768.56574787099, 381251.7255293985], [120723.62554358867, 381228.6321383947], [120709.24781015988, 381222.9961583324], [120734.7105273947, 381208.9540266957], [120775.43798899432, 381180.9166602048], [120813.19707732984, 381148.99376409303], [120822.35859848576, 381139.54618125723], [120855.11175694675, 381160.8205330168], [120898.33425911405, 381183.2469788291], [120943.53327602251, 381201.36269123247], [120990.2801166624, 381214.99585137836], [121038.13140965777, 381224.0171552777], [121086.63330843157, 381228.3410401872], [121135.32579572272, 381227.92649613123], [121183.74704662948, 381222.7774548613], [121231.43780879714, 381212.9427525658], [121277.94575820658, 381198.51566668187], [121322.8297892507, 381179.6330312036], [121365.66419840966, 381156.47393887735], [121406.04272184482, 381129.2580425928], [121418.6318049208, 381118.8571776325], [121425.27958692992, 381115.2294486092], [121455.87633694516, 381094.4005498084], [121492.6142303488, 381074.6135143375], [121531.41321261713, 381059.62879100215], [121576.23666372416, 381036.91001473257], [121618.5532783421, 381009.80671803997], [121657.93561049609, 380978.5926750714], [121693.98585380414, 380943.58318319044], [121726.33985977442, 380905.13187811495], [121754.67081611941, 380863.6271617937], [121778.69254793214, 380819.4882791045], [121798.16240837835, 380773.161083004], [121799.01091546498, 380770.39171960624], [121804.81466672802, 380764.90412253555], [121836.00021077669, 380729.2480778724], [121863.67155827334, 380690.80086462677], [121887.58034319244, 380649.9075683262], [121907.5119706399, 380606.93522947986], [121923.28754296381, 380562.26954918186], [121934.76546546233, 380516.31142722553], [121941.84271727633, 380469.4733638007], [121944.21698531845, 380426.4979830591], [121955.42351375779, 380404.8462894383], [121955.4564597635, 380404.76313345414], [121958.78972679663, 380401.6783902613], [122000.05271610402, 380374.5412443165], [122006.7375742984, 380369.6507565622], [122021.68643240162, 380358.8258316372], [122028.6165565488, 380355.362723452], [122069.19931262804, 380329.96405664127], [122107.16687993165, 380300.8004457572], [122142.1711638496, 380268.1392688933], [122173.89123777472, 380232.2799705603], [122202.03628542493, 380193.5513163167], [122226.34826710791, 380152.3083785771], [122246.60428548306, 380108.92928123364], [122262.61862913094, 380063.81173293723], [122274.2444751945, 380017.36938082136], [122281.3752354818, 379970.0280180983], [122281.6512354818, 379967.32101809833], [122284.22908346524, 379915.64764222124], [122281.45337511261, 379863.98451690056], [122273.35383030048, 379812.884806054], [122260.0171719267, 379762.89564104617], [122255.68216932449, 379749.47720873705], [122249.05126139487, 379728.23537267395], [122244.28071084578, 379711.3240259631], [122249.79870050718, 379709.23495569726], [122355.3715418972, 379670.69672506064], [122507.77772059178, 379615.09471229167], [122553.0250565235, 379596.0206341832], [122588.72038169658, 379576.6501226985], [122588.20288072816, 379579.25241851923], [122583.39600328555, 379627.74777488044], [122583.33299036665, 379676.48073794163], [122587.4016440251, 379718.6387696063], [122565.0440163392, 379753.7613706581], [122542.97287895062, 379797.2966555018], [122525.25179312851, 379842.776532913], [122512.04963771123, 379889.76758764026], [122503.49222692328, 379937.8220031778], [122499.6611113879, 379986.48182937765], [122500.59280096389, 380035.2833466346], [122506.27841681307, 380083.76148505247], [122516.66377601407, 380131.4542564787], [122531.64990791603, 380177.9071571703], [122551.09399731157, 380222.67749913485], [122574.81074544066, 380265.33862886945], [122602.57413585522, 380305.4839932934], [122634.11958831632, 380342.73101412825], [122669.14648019732, 380376.7247338012], [122707.32101136484, 380407.14119812875], [122748.27938523541, 380433.69054354297], [122791.63127569307, 380456.1197594409], [122836.9635468288, 380474.2150993305], [122883.84419005323, 380487.8041177981], [122931.82644106263, 380496.757313882], [122980.45303742444, 380500.9893651947], [123029.26057620792, 380500.4599410296], [123077.78393013279, 380495.1740867063], [123089.87347280708, 380492.6457096816], [123109.72173445007, 380490.409956639], [123127.74229938036, 380503.21520568064], [123171.5854940543, 380528.1375626973], [123217.7162231979, 380548.51660652086], [123265.66518052538, 380564.14501301956], [123314.94456219126, 380574.86378818797], [123339.90557811024, 380578.9873480178], [123367.39301856626, 380583.53273626603], [123368.5468239526, 380583.73249958665], [123462.37112826825, 380599.972495263], [123502.79205987467, 380606.969636431], [123508.24716405368, 380607.9144975126], [123556.46746321708, 380613.87075730314], [123605.03820482497, 380615.11869230046], [123653.50075007508, 380611.6465186325], [123701.39748183051, 380603.48702298343], [123748.27612575988, 380590.7172529995], [123793.69402102676, 380573.457789751], [123837.22230020193, 380551.871609122], [123878.44993892864, 380526.1625428784], [123916.98763710106, 380496.5733539461], [123952.47149490732, 380463.38344407454], [123960.31045605236, 380454.4741439962], [123965.07083398051, 380460.25887348736], [123982.33105030973, 380481.23298466415], [123985.08283873044, 380484.5773587202], [123988.31970031286, 380488.51029282593], [124021.40649037302, 380528.71521717607], [124022.18716249867, 380529.6642695641], [124056.35816190587, 380571.1865629121], [124109.04910153909, 380635.2130756306], [124272.95815508156, 380834.55565682333], [124316.18110401512, 380887.0653834062], [124358.4195112784, 380938.45183835464], [124359.69157535647, 380939.99929822667], [124501.85046477344, 381112.90500624053], [124502.27414769563, 381113.4196257089], [124587.83199062652, 381217.19998864573], [124712.60990416094, 381368.74029353616], [124801.16875004178, 381476.1825370016], [124887.49771589223, 381580.7254651495], [124888.42682247395, 381581.85103906045], [124888.96790875458, 381582.50638453977], [124897.44664241122, 381592.7732368309], [124943.46654930685, 381648.4920628969], [124965.04451467586, 381674.6381071677], [125105.98340880586, 381845.2385575276], [125124.02803085672, 381867.14508812834], [125154.2804703439, 381900.6654002625], [125187.43356985139, 381931.3198194145], [125273.10349276244, 382003.63835213723], [125273.17850869116, 382003.70177469513], [125373.5137596389, 382088.4684958194], [125382.4015286406, 382095.97917416797], [125383.87918686983, 382097.2278853509], [125505.58969006992, 382200.073295968], [125506.1687710401, 382200.5623755787], [125508.60165490599, 382202.60383570916], [125513.42465490599, 382206.62483570917], [125585.2077915213, 382266.4706900313], [125615.19395728513, 382291.5373356934], [125752.92304707205, 382406.46187784994], [125864.57338711653, 382499.5614081344], [125929.05418603533, 382553.3551903144], [125934.24360024596, 382557.68486128177], [125938.79217592579, 382561.47903303406], [125972.36925316109, 382589.4915833294], [126012.22721435304, 382622.714979958], [126085.2171960531, 382683.4733748731], [126088.39793344855, 382686.0989482421], [126151.7522702827, 382737.957599225], [126220.38261526969, 382796.5002586576], [126241.30755549375, 382813.39868390234], [126284.55086670665, 382846.43939900334], [126348.44969094812, 382898.57736785273], [126350.89408492239, 382900.5718733655], [126357.38060704044, 382905.8638689014], [126548.96925303574, 383063.3190429864], [126634.17406831267, 383133.3438911733], [126638.72127898636, 383137.03656329773], [126717.91127898636, 383200.57856329775], [126756.32626321449, 383231.38961592637], [126871.93904548317, 383324.1723620862], [126945.9047066781, 383384.3094982118], [126946.06722909898, 383384.4417532992], [126951.40250503152, 383388.77962973155], [127002.18458158227, 383430.0676919707], [127063.2526419141, 383479.71852809755], [127064.58801020085, 383480.8047821269], [127067.55093144251, 383483.21426450857], [127111.53035847818, 383518.97020178684], [127113.71854795779, 383520.7390293118], [127115.38954795779, 383522.0820293118], [127119.84438488234, 383525.6614367026], [127340.59921685254, 383703.0632474521], [127342.37964524888, 383704.4873572845], [127358.14993119286, 383717.04267187614], [127407.71554356995, 383763.0734026147], [127436.87262468145, 383788.1338127606], [127467.86907061182, 383810.87979867694], [127522.79910174871, 383848.0266051394], [127584.06297817746, 383897.17857832817], [127584.60947622279, 383897.6164047215], [127588.64225785069, 383900.84263002384], [127607.92130289743, 383926.2393458828], [127618.12591615906, 383939.2307474162], [127630.92130152608, 383954.97780003224], [127650.83787009199, 383981.71535068244], [127657.76458452803, 383990.7959607221], [127684.29301758435, 384024.7619595118], [127718.42541391573, 384077.69300605427], [127743.48147258518, 384113.07978559105], [127771.50912606163, 384146.16272504075], [127802.29760300054, 384176.69303669676], [127806.79660300053, 384180.7830366968], [127840.79635110054, 384209.0498023328], [127877.16036322113, 384234.202367468], [127913.86153347518, 384255.05391250644], [127914.75550476344, 384271.45048739697], [127920.6493589229, 384325.41701210703], [127927.8706748845, 384369.3001636732], [127932.95206788361, 384400.28730260296], [127933.57667904465, 384404.00830737094], [127940.90667214332, 384446.6883797208], [127941.51728261272, 384450.4575237693], [127940.48294486116, 384454.809020421], [127933.8750509269, 384503.2838395198], [127933.7440509269, 384504.7938395198], [127931.88541870668, 384544.4850033418], [127933.18439405624, 384584.1984225136], [127934.51139405623, 384602.4844225136], [127935.25605442295, 384611.5920977344], [127936.17174088377, 384621.65809648525], [127936.22605487474, 384623.3318331331], [127937.47297804429, 384645.94408717175], [127938.21397804428, 384655.4570871718], [127942.8409998541, 384694.7262527775], [127950.55659483523, 384733.5069991896], [127952.85259483523, 384743.0569991896], [127968.9779597745, 384794.0950737419], [127969.90305124954, 384798.9565174275], [127980.33750192255, 384842.88522375753], [127986.27750192254, 384863.6692237575], [128004.22286646598, 384915.50857881946], [128027.73922252456, 384965.0700138225], [128056.54349385838, 385011.7569369891], [128090.28895137385, 385055.0073582461], [128100.64995137385, 385066.8813582461], [128110.4420435761, 385077.7769721983], [128143.03643029742, 385112.99297008227], [127972.16502973517, 385134.8735155189], [127970.59385786286, 385135.0744003722], [127968.60204660386, 385135.32928346924], [127866.17484055385, 385148.4460704448], [127777.92716195656, 385159.74715734617], [127772.69637271774, 385160.4171302378], [127757.77512073984, 385162.32762603776], [127738.2501389521, 385164.8274956716], [127667.87169206316, 385173.83957723714], [127628.55103847611, 385178.87491704046], [127590.06065117463, 385183.8038385808], [127575.94562455642, 385185.6119943967], [127501.9110883599, 385195.09191678494], [127499.36532460156, 385195.4175377307], [127401.2270324285, 385207.98504587344], [127359.99336967131, 385213.2657465306], [127326.37784631431, 385217.5699172537], [127314.46937954951, 385219.094873364], [127249.62368662874, 385227.40126747143], [127237.36277882627, 385228.9722803771], [127152.90898066183, 385239.78997362324], [127042.08878810341, 385253.98497356504], [127028.52474514412, 385255.7219546042], [126815.84730126079, 385282.96327277087], [126685.51985131155, 385298.46292634914], [126636.10395298128, 385306.8702072671], [126620.96728898595, 385310.2338719147], [126562.28217601485, 385312.0947542295], [126557.52366309718, 385308.63382298563], [126509.10714896128, 385277.5157980124], [126478.9963033034, 385262.7447067397], [126478.39981731198, 385262.3902236245], [126476.28284739798, 385261.4136014861], [126457.43538236506, 385252.1678423526], [126443.77635134044, 385246.4173733964], [126431.21653523472, 385240.62315101223], [126427.17353523472, 385239.00715101225], [126384.01479767832, 385224.0048080899], [126366.99333440678, 385219.7829123308], [126362.2518890406, 385216.9879003885], [126351.74188904061, 385211.32790038845], [126343.5912964706, 385207.2869414017], [126326.13828778439, 385197.8641496184], [126305.1172877844, 385187.3541496184], [126280.32165713828, 385175.79372728564], [126261.4611449465, 385167.62089051085], [126245.59787024009, 385160.2992049562], [126244.0767025966, 385159.39849144034], [126200.80750857395, 385139.0828085016], [126155.79604457281, 385122.9918721364], [126109.45370639427, 385111.2727502929], [126062.20405376394, 385104.03255340684], [126014.4789390805, 385101.3374554332], [125966.71456037089, 385103.2120890299], [125919.34747452749, 385109.63932041975], [125872.81060726507, 385120.5604059902], [125860.0945484413, 385124.86125336646], [125850.52681399924, 385125.205859037], [125771.04681399923, 385132.18185903697], [125700.1021343606, 385138.4090942375], [125651.96898694831, 385145.0033856508], [125604.70303652967, 385156.23790789605], [125588.6963927882, 385161.7306165788], [125580.84596125862, 385160.39903796185], [125536.16684809145, 385155.4382196697], [125507.25179709817, 385140.0613102549], [125460.63920593355, 385121.00956046657], [125400.15691617464, 385099.77599086653], [125396.10362515661, 385098.3524250277], [125349.2948723515, 385084.4400232634], [125301.35222714391, 385075.16009694256], [125252.73298839592, 385070.60116224375], [125233.28003080064, 385070.6830428903], [125239.36043791949, 385060.2088489734], [125246.60043791948, 385046.10884897335], [125267.01640175754, 385000.9766608988], [125282.8664094597, 384954.045826305], [125293.99489472322, 384905.7769668242], [125300.29263253449, 384856.6438366747], [125301.69781120199, 384807.12867280794], [125298.19663903207, 384757.7174618], [125289.82347969324, 384708.8951699395], [125276.66051493987, 384661.14098332997], [125275.382771095, 384657.8277330627], [125275.24548711213, 384625.5643957275], [125269.97840539891, 384575.5389305931], [125259.7115893566, 384526.2958417376], [125244.54895104475, 384478.3335262065], [125224.64395391002, 384432.1374181372], [125200.19805955843, 384388.17507560377], [125171.4586887307, 384346.8914483878], [125138.71671711818, 384308.7043745721], [125102.30353136412, 384274.00035153556], [125063.14205536485, 384243.56152432313], [125065.35334302581, 384235.25541333074], [125065.5371223313, 384234.77046187967], [125078.32677327591, 384187.5075109281], [125079.35677327591, 384182.79751092807], [125087.48312089471, 384134.3341261819], [125090.81299760031, 384085.3071019218], [125089.31424028428, 384036.18998766225], [125087.55956738161, 384022.64472407603], [125094.00832885537, 383978.0302868437], [125096.20253378323, 383928.42757231893], [125093.4663246883, 383878.85180219606], [125085.82668326085, 383829.79184191936], [125073.35894381626, 383781.7314705451], [125056.18605042517, 383735.14461020805], [125034.477344565, 383690.490652787], [125008.44689524795, 383648.20992985275], [124978.3513880916, 383608.7193705696], [124944.48759414848, 383572.4083903671], [124907.18944345403, 383539.6350509239], [124866.82473215075, 383510.72252933047], [124823.79149565955, 383485.9559312479], [124778.51408366227, 383465.57947948814], [124731.43897560005, 383449.79410573846], [124683.03037795037, 383438.7554691795], [124633.76564669874, 383432.5724215335], [124610.49791775539, 383431.9787223987], [124599.55233047134, 383391.56217230146], [124582.18011518123, 383345.7558329998], [124560.40857605175, 383301.8694493685], [124560.08980997597, 383301.2989333919], [124560.10690640312, 383294.7542425202], [124555.64774663032, 383247.06131884875], [124550.7793523388, 383221.6189970408], [124556.31742676691, 383200.6787557997], [124556.81608845292, 383198.79459684103], [124564.99801896267, 383167.86026704597], [124569.50827267411, 383144.6706252571], [124576.38397940448, 383120.3989326075], [124576.34060872433, 383120.38664652256], [124587.13546976945, 383074.2754877806], [124593.55669500915, 383026.3870324436], [124595.32568719631, 382978.10238731926], [124592.42592722514, 382929.8724414323], [124584.88449347514, 382882.14757301833], [124572.77180894933, 382835.37344382575], [124556.200983654, 382789.98683746246], [124535.32675836106, 382746.4115806467], [124510.34405961623, 382705.0545854516], [124481.4861794867, 382666.3020495014], [124449.02259704591, 382630.51584960177], [124413.25646193889, 382598.03016248194], [124406.66126830346, 382593.112577167], [124406.64706321423, 382569.6429543965], [124402.0787407395, 382522.1928238542], [124393.01247191329, 382475.39338765806], [124379.53066492912, 382429.6700310539], [124371.04519756995, 382408.5543853554], [124369.36833157997, 382397.8148263305], [124357.13043210546, 382350.4390200689], [124340.3204049999, 382304.48625963833], [124319.09923876343, 382260.3966315377], [124293.67016707925, 382218.59237917315], [124264.2767224583, 382179.47385906056], [124231.20040394473, 382143.41570663877], [124194.7579812186, 382110.7632484107], [124155.29846091375, 382081.829194775], [124113.19974420487, 382056.8906452192], [124068.86500767324, 382036.18643455673], [124035.93072943433, 382022.72755822074], [124000.36928047672, 381998.2405698222], [123895.61928047672, 381933.3605698222], [123850.85299906081, 381908.7055629928], [123803.80379057642, 381888.74907796766], [123754.96320432295, 381873.69961126667], [123704.84150512161, 381863.71439305483], [123653.9623422945, 381858.8977444712], [123602.8572788083, 381859.2999877275], [123590.8372788083, 381860.0099877275], [123540.6569291506, 381865.5269986084], [123491.28866639879, 381876.0759101019], [123443.23575159116, 381891.54918639746], [123396.98803708324, 381911.78909261327], [123362.17759687953, 381931.42260045814], [123322.2636003511, 381923.2772368477], [123274.05881764115, 381918.2295097376], [123225.5917835165, 381917.87281904096], [123177.31792924726, 381922.2105164813], [123129.690870846, 381931.2018419195], [123083.15814656403, 381944.7623063655], [123038.15701149864, 381962.7644858979], [122995.1103288282, 381985.03921903134], [122966.70115856506, 382003.42903908895], [122958.84669304363, 382005.719423704], [122912.49099671001, 382024.4369358958], [122868.23611444, 382047.6899193709], [122826.5244527052, 382075.2459190905], [122787.7729939524, 382106.82946369454], [122766.9829939524, 382125.57946369454], [122765.30685287445, 382127.098023529], [122748.39685287444, 382142.488023529], [122716.13159302475, 382174.66022682335], [122686.92906225495, 382209.6360735554], [122674.45906225494, 382226.03607355535], [122652.71902499381, 382256.9916626572], [122644.16902499381, 382270.2016626572], [122620.9329132017, 382310.0127083654], [122612.6629132017, 382325.8127083654], [122607.41981054973, 382336.1184320472], [122602.939425906, 382336.68676411733], [122556.22878620136, 382347.229470559], [122510.74089429122, 382362.1922313437], [122466.89297103732, 382381.4378060831], [122425.08719529565, 382404.7896718623], [122385.70701507953, 382432.03364233056], [122376.01068919791, 382440.21770527837], [122350.70164278896, 382437.40156395594], [122303.21668368763, 382436.65139083547], [122255.8747458565, 382440.4097179846], [122209.10292631108, 382448.6426395181], [122163.32317872401, 382461.2758818347], [122118.94850675459, 382478.1954736788], [122031.27850675458, 382516.4854736788], [121990.03041109107, 382536.80791364575], [121950.82372958443, 382560.8337973406], [121913.99005775605, 382588.35992278013], [121906.7573688775, 382594.8819104867], [121890.75669631464, 382605.79184523097], [121884.73859504031, 382609.89473318105], [121844.9423290802, 382640.0429839008], [121808.35110187599, 382674.009760279], [121775.3297513529, 382711.4563918426], [121746.20752148364, 382752.0095117383], [121721.27477951565, 382795.2647794382], [121700.78012082391, 382840.7909122735], [121684.92789025625, 382888.1339855986], [121673.87614468456, 382936.8219587095], [121667.7350770767, 382986.3693813919], [121666.56591780225, 383036.2822341698], [121670.38032412651, 383086.0628539954], [121679.14026398021, 383135.21489626827], [121692.7583951634, 383183.2482837077], [121711.0989362032, 383229.684092737], [121733.97902018172, 383274.0593286571], [121761.1705180362, 383315.9315420003], [121792.40231315162, 383354.88324003393], [121827.36300456656, 383390.52604942967], [121865.70401183995, 383422.50458859414], [121907.04305062078, 383450.5000110505], [121913.32305062078, 383454.3100110505], [121959.82037281775, 383479.2623553951], [121973.19037281774, 383485.5523553951], [121977.1645659942, 383487.2515952062], [121969.553095268, 383518.59937660623], [121962.69121762045, 383567.51750396844], [121960.68974943366, 383616.87398960674], [121963.56822558593, 383666.187100688], [121963.96563279936, 383668.69525796385], [121953.3146872229, 383686.6000966542], [121932.0239319102, 383732.333986246], [121915.44992807669, 383779.9804689694], [121903.76139145199, 383829.054525563], [121897.07730595843, 383879.05660472077], [121892.24230595843, 383937.5866047208], [121890.58488104978, 383985.0650185498], [121893.44098977759, 384032.4864217342], [121900.7848477996, 384079.42270393035], [121908.22383558773, 384108.525000067], [121907.60559647197, 384111.7397862486], [121903.10856903176, 384160.8825529502], [121903.47773906708, 384210.2292700483], [121908.7095105151, 384259.29925417714], [121918.75292100877, 384307.6145176095], [121933.51013829811, 384354.70442430675], [121953.70013829811, 384409.49442430673], [121974.53535302459, 384457.9807544243], [122000.36495880052, 384504.0009874357], [122030.90121067865, 384547.0424523527], [122040.1349427513, 384557.5144370078], [122050.42318447288, 384573.36095701647], [122080.81830129598, 384615.25718098384], [122115.38188266449, 384653.78659250797], [122153.74352357473, 384688.53628626326], [122195.49211663617, 384719.13386274903], [122207.53211663618, 384727.033862749], [122248.87042092188, 384751.40364639414], [122292.35450820853, 384771.6983725311], [122337.58384800203, 384787.7311071067], [122384.14183434499, 384799.3541731315], [122431.59962316048, 384806.4605109276], [122479.52008232067, 384808.98466425185], [122516.3082656012, 384807.38758923556], [122521.45139831412, 384810.10414028075], [122567.38197762783, 384828.808145756], [122614.9395181004, 384842.87009018456], [122663.65615665031, 384852.15163452306], [122695.09563681773, 384854.9583712466], [122701.73251456826, 384861.45391959173], [122739.78350073745, 384892.0337956628], [122756.9168093731, 384904.4769475664], [122763.12225699886, 384908.99290828], [122763.67608277538, 384909.39537051355], [122778.65463597591, 384920.26454307366], [122795.8192135769, 384932.7306820561], [122836.68231053163, 384959.4615572311], [122840.225852436, 384961.31354792387], [122847.77385819238, 384968.1056645859], [122849.14815414023, 384969.70606823225], [122854.5755269439, 384976.02562701254], [122859.057219517, 384981.24374825176], [122864.8806399211, 384988.0241155213], [122868.95162259584, 384992.7651327619], [122872.74784722149, 384997.18552026583], [122874.42133155373, 384999.1342618541], [122878.90935412458, 385004.3594126889], [122888.64913095953, 385015.7008505903], [122890.97793088487, 385018.41261761374], [122924.00234785388, 385053.3231893028], [122960.22566878931, 385084.90215623035], [122999.3132829183, 385112.8578095674], [123040.90412073, 385136.931910629], [123084.61398933364, 385156.9020763382], [123130.03912141755, 385172.583833477], [123176.75990502564, 385183.83232274646], [123221.90837946408, 385190.20001257997], [123184.07930346632, 385204.6853426764], [123139.76308913252, 385226.91221894766], [123126.62408913253, 385234.3392189477], [123088.06628602014, 385258.5136365884], [123051.86624491645, 385286.0937684447], [122907.31724491646, 385407.0047684447], [122900.02964254092, 385413.22023891535], [122899.04064254092, 385414.08023891534], [122891.97962436576, 385420.2258333527], [122836.88690678003, 385468.1690532579], [122825.88347654825, 385477.74407671264], [122782.63749023511, 385515.3791181056], [122782.72743729348, 385515.4824752179], [122780.99365972214, 385517.00962082273], [122780.92238775022, 385516.92609763617], [122691.61938775022, 385593.1300976362], [122687.14787017704, 385596.9916181391], [122673.82787017703, 385608.6326181391], [122663.02303578376, 385618.0757336367], [122652.87698143875, 385626.9416736553], [122646.29412210833, 385632.6952635406], [122623.73094081713, 385652.4144303542], [122580.64512216512, 385690.0696832832], [122580.04859482363, 385690.59082012344], [122579.4059673237, 385691.1523265773], [122577.10595053386, 385693.16219602426], [122573.98430346661, 385695.8903625769], [122538.84840636411, 385726.0525210684], [122538.75419900396, 385726.133110777], [122538.31719146289, 385726.5073846443], [122456.5381914629, 385796.6283846443], [122452.65303240997, 385799.9945043739], [122424.80203240998, 385824.3765043739], [122358.99477443419, 385881.98985844466], [122309.57846364737, 385925.2523795884], [122302.92855332077, 385931.0746646384], [122080.41886599471, 386124.3802254389], [122073.76518799631, 386129.95073131484], [122039.71375881719, 386161.24856284383], [122008.6999510741, 386195.55887932196], [121980.98912561598, 386232.5881142585], [121973.69725737692, 386244.48381847417], [121956.92700431815, 386254.9901877298], [121921.6145988846, 386281.74016354047], [121832.1045988846, 386356.0101635404], [121798.40572927558, 386386.6684365853], [121797.79213133256, 386387.28002930625], [121767.91625488107, 386408.3003032761], [121670.98152744971, 386476.5043330814], [121663.45242758605, 386481.80225421884], [121656.45044704534, 386486.7293148516], [121547.92348220307, 386563.08895770874], [121539.7266203271, 386568.8566003474], [121524.29583025149, 386579.7143417119], [121338.16899603426, 386710.6761521236], [121280.18433707226, 386751.2923128314], [121195.3376159687, 386810.7252188797], [121194.35488848026, 386811.4138805531], [121190.17859723746, 386814.3725230041], [121173.71489802537, 386826.1630446562], [121129.10601704067, 386857.23270586465], [121078.6605301927, 386892.36833131034], [121062.70104387416, 386903.05378577247], [120941.62160186152, 386988.16723574104], [120779.89161332374, 387100.2409320468], [120778.8917936689, 387100.9355782747], [120744.9917936689, 387124.5495782747], [120718.00311668252, 387143.3502682849], [120681.71791079333, 387162.56504864467], [120680.137115674, 387163.40578399214], [120601.41649924843, 387205.453805578], [120521.0525026647, 387247.54923236], [120514.42785049391, 387251.08292678435], [120461.10996688508, 387280.03983849456], [120200.71102880349, 387235.79034576385], [120168.41417456076, 387230.3021481451], [120163.30923953695, 387229.43394164374], [120061.86243774563, 387212.195245326], [120013.64191078191, 387206.39389847504], [119965.08601870539, 387205.2983663672], [119916.65291060587, 387208.91898589494], [119868.79957704498, 387217.221594705], [119821.97753812201, 387230.1278535371], [119776.62858315639, 387247.51598539395], [119733.18060218476, 387269.2219245681], [119725.8660453227, 387273.331675587], [119660.30348298854, 387310.16842968157], [119618.78344112268, 387336.25466714334], [119580.61610242377, 387365.8193097201], [119526.16924849435, 387374.96077748685], [119442.30258714645, 387389.04256013624], [119409.6873010192, 387394.51911191054], [119364.33592984908, 387402.13433465443], [119340.12970642518, 387406.19836481375], [119321.26460363044, 387409.3660610981], [119219.11350730938, 387426.5187414415], [119176.70498474076, 387433.63927223743], [119173.79926436424, 387433.0023183293], [119157.77749484319, 387429.71968059917], [119153.97930302582, 387428.8083886358], [119141.8512878379, 387426.0575849304], [119103.3292878379, 387417.8225849304], [119045.29957560348, 387405.41743267374], [119043.89531287836, 387405.1193473976], [119012.18637233622, 387398.43599224545], [119000.37139926392, 387395.94557296316], [118969.45679028984, 387388.21324565914], [118948.88854981873, 387382.49788552825], [118926.36510061027, 387376.2392205429], [118920.91404399254, 387373.9847512649], [118883.66269350833, 387359.0941966899], [118882.04633817844, 387358.44765455794], [118859.56392976709, 387349.46029143024], [118788.09289818784, 387319.7213545759], [118785.03583549126, 387318.4611600804], [118773.77297319447, 387313.86184975575], [118711.04410894623, 387288.24453872046], [118705.43561148639, 387285.99358197715], [118701.64961148638, 387284.5005819772], [118661.91549190409, 387270.73242251726], [118621.16497067992, 387260.3517918113], [118618.04697067992, 387259.6957918113], [118568.57635142132, 387251.8514074483], [118518.56912008702, 387248.996000272], [118517.70312008703, 387248.990000272], [118515.82970991696, 387248.97736181447], [118497.71936832998, 387249.1833039628], [118495.88836832998, 387249.2373039628], [118425.31389765184, 387256.35225806787], [118335.83989765184, 387271.8462580679], [118335.88393176527, 387272.10054413124], [118316.48226753362, 387275.2008915387], [118314.0087081105, 387275.70860232663], [118309.30411014447, 387276.4497436109], [118241.25165637354, 387288.29282418796], [118216.57863258508, 387292.5493331868], [118209.47781027675, 387293.77157356194], [118146.98964160508, 387304.5248817328], [118142.35805964205, 387305.34435813536], [118109.47198930981, 387311.3226230332], [118103.81290185626, 387312.2981216989], [118014.92977144275, 387327.6247991979], [118014.41341686777, 387327.7141161232], [117915.49441686778, 387344.8781161232], [117868.6307809642, 387353.01044113335], [117816.27944345628, 387365.0231393739], [117765.51875648853, 387382.5821859439], [117716.93449178108, 387405.4849517316], [117671.08730542455, 387433.4671418009], [117628.50626798162, 387466.2058453209], [117552.65226798161, 387531.2988453209], [117552.76985326881, 387531.43586949207], [117551.60017595218, 387532.44255175965], [117549.18846958886, 387533.19866734446], [117537.89948913909, 387536.5671970809], [117532.37997828293, 387538.248912968], [117514.9646959816, 387543.6651103248], [117514.11950003581, 387543.91220966517], [117486.45318104773, 387552.92209140945], [117485.06603270852, 387534.7913512578], [117477.96196116292, 387441.2272843015], [117475.58551522464, 387409.93075035914], [117475.36128728531, 387406.9741164689], [117475.31076681867, 387406.31376183266], [117474.71276681867, 387398.5647618327], [117458.85863786214, 387193.22368464933], [117458.83980120343, 387191.9848145572], [117458.6348702874, 387190.32546961895], [117458.51633200383, 387188.79017374094], [117458.44593086668, 387188.7956093252], [117452.24411162721, 387138.57889453095], [117439.94722504914, 387086.1910906514], [117422.09157362155, 387035.42819941253], [117398.88397545632, 386986.8781962999], [117374.64000653497, 386942.47274298273], [117364.49315905673, 386907.4911152739], [117346.03927475154, 386861.4875643307], [117330.81090627231, 386832.2839214928], [117300.71979791204, 386734.7605546524], [117283.1784337703, 386686.76634200197], [117278.2964337703, 386675.26834200195], [117274.20958420522, 386665.9098936151], [117264.53858420522, 386644.3668936151], [117264.2947504533, 386643.8601995001], [117264.13769037247, 386638.7629941296], [117237.54869037247, 386324.0779941296], [117236.79556888559, 386315.18961669144], [117249.82558053335, 386307.7890846531], [117254.85989715839, 386304.9400551887], [117289.57502393336, 386285.29262619937], [117346.17989639929, 386247.97455192707], [117349.70789639928, 386245.288551927], [117369.27238937088, 386228.9120462105], [117375.62090541664, 386225.9122736411], [117417.58973330744, 386200.7960443065], [117456.90382584083, 386171.6994874862], [117545.22645241275, 386099.3856119762], [117566.09507887882, 386082.2997365365], [117566.09482885721, 386082.299431161], [117567.2429365152, 386081.3584574983], [117567.41793651521, 386081.2144574983], [117603.40179066328, 386048.54594314564], [117636.04395135492, 386012.538181], [117665.03600636974, 385973.53138242103], [117690.1040307018, 385931.8940944997], [117711.01117467934, 385888.0197179222], [117727.5599017864, 385842.3227900113], [117739.59385504281, 385795.2350680619], [117746.99933430848, 385747.2014499783], [117749.70637055392, 385698.6757707546], [117747.68938694717, 385650.11651451554], [117740.96744051077, 385601.98248263093], [117729.60404206577, 385554.72845883254], [117713.70655616377, 385508.8009122907], [117693.42518667674, 385464.6337792494], [117684.89487618089, 385449.9983217615], [117679.90201681337, 385439.9869279237], [117667.26103840864, 385417.0270066221], [117643.77922045413, 385374.31305243005], [117625.99375358099, 385341.5326386692], [117604.16269565996, 385305.0813250096], [117579.31571685369, 385270.6150951365], [117551.43771685367, 385235.2180951365], [117551.2118253776, 385234.93828329095], [117542.21073295629, 385220.34198546543], [117514.02088010202, 385182.9695703852], [117482.45945514042, 385148.39730307064], [117447.8031085064, 385116.9282253775], [117445.2511085064, 385114.8202253775], [117441.03800188962, 385111.6882983674], [117425.72204765581, 385096.45378210384], [117409.0827998513, 385080.646024603], [117398.1677998513, 385070.74302460294], [117354.74868129316, 385035.56591556314], [117337.32368129316, 385022.99391556316], [117280.71751054865, 384987.6450218895], [117245.24110290289, 384968.6570150804], [117237.50300877626, 384964.515109092], [117235.25911042166, 384963.2503488781], [117217.09652632072, 384953.5008967113], [117203.89201596536, 384946.7597400147], [117194.26241427565, 384941.83276200085], [117139.82459340569, 384917.9492920531], [117082.93696816005, 384900.69546431175], [117063.9941097261, 384896.16015778406], [117073.99403508856, 384885.84498360567], [117104.79887136331, 384847.01976858993], [117120.2039181847, 384825.49308743374], [117136.09696506683, 384803.2864054734], [117162.22516642678, 384762.78736593603], [117184.33273633094, 384719.96085005294], [117202.21426405241, 384675.204776989], [117215.70360479906, 384628.9349942364], [117224.67542343453, 384581.5814138002], [117229.04635901982, 384533.5840177055], [117228.77579935465, 384485.38876993954], [117223.86625832267, 384437.4434728124], [117214.36335253375, 384390.19360623776], [117200.35537748096, 384344.07818859164], [117181.97248715001, 384299.52569760813], [117159.38548470386, 384256.95008921257], [117132.80423547869, 384216.74695128296], [117113.69660660464, 384193.1481457467], [117096.96826413974, 384171.10432547383], [117065.31806439304, 384133.4053017285], [117030.11438268411, 384099.00105301576], [116991.69840627155, 384068.2250186444], [116950.44245535147, 384041.3754739735], [116906.74637460237, 384018.71263958496], [116861.03365796803, 384000.45615927625], [116813.74734423624, 383986.7829713154], [116765.34572319285, 383977.8255935894], [116716.29789396592, 383973.67083926674], [116667.079218608, 383974.3589754208], [116618.1667149792, 383979.88333276956], [116570.03443358256, 383990.19037031237], [116523.14886315852, 384005.18019423954], [116477.96440956648, 384024.7075260835], [116434.91899177125, 384048.58311072947], [116394.42979761737, 384076.57555063965], [116360.9262144802, 384104.9898068814], [116364.99361515466, 384070.24576422165], [116370.75612863425, 384020.74862141814], [116376.54995390288, 383971.8300997732], [116382.45209316234, 383922.4230651799], [116382.67415234346, 383920.533688599], [116387.5935390999, 383877.9792371498], [116389.11355377838, 383867.6304589181], [116394.41155377838, 383823.7404589181], [116394.48741476217, 383823.10862774774], [116398.30741476218, 383791.12062774773], [116399.05870300347, 383784.8292140167], [116399.11061806166, 383784.39286991255], [116399.3570541864, 383782.2772607646], [116405.08887149974, 383732.14172059495], [116410.7486523765, 383686.6861906624], [116411.11140166968, 383683.6995773881], [116418.95922448928, 383617.4209647165], [116419.60004599277, 383612.01235149824], [116423.08523635568, 383582.5789735271], [116436.00994343917, 383472.6514795423], [116447.71029943785, 383374.8583501596], [116448.60604064756, 383367.3676626538], [116460.89460163364, 383265.85054969933], [116460.95042453485, 383265.40649114345], [116462.12883758587, 383256.0234936522], [116462.6750641967, 383251.5081984124], [116468.5100641967, 383201.3621984124], [116471.80166280334, 383151.2748355669], [116470.05470235246, 383101.1098411246], [116463.28678926031, 383051.3727936591], [116451.56613268118, 383002.5649587597], [116435.01085707417, 382955.17823711975], [116429.45216078065, 382943.2641060408], [116432.57038674182, 382927.28053925035], [116450.31963758393, 382837.1910769767], [116451.40997883338, 382831.48209813697], [116457.00424454609, 382801.2378370276], [116458.39615758418, 382794.0734270385], [116458.50314451978, 382793.52694263443], [116458.63593517464, 382792.8461498547], [116470.36393517464, 382732.49614985473], [116482.85177490824, 382668.06492443016], [116491.14851719994, 382626.49697717064], [116491.51347273505, 382624.650392705], [116501.8353256877, 382571.90257812396], [116507.5615217271, 382542.68242977606], [116508.26488094799, 382539.09509906045], [116508.59513837103, 382537.3951056852], [116525.75406510079, 382448.2454573214], [116556.26661013474, 382293.7731561188], [116594.18664073652, 382102.019796332], [116595.76724592337, 382094.0299568552], [116600.57361029652, 382069.7257798873], [116601.04701269424, 382067.3316309723], [116601.58146768935, 382064.588452544], [116612.33419846333, 382008.5645962467], [116613.83612294056, 382001.0067057346], [116619.0439947154, 382003.57480062154], [116664.66092546823, 382020.7755580603], [116669.93961604682, 382022.4770227908], [116706.57381842962, 382048.9757122402], [116749.3021634286, 382073.8554248003], [116794.27888849663, 382094.3933352485], [116812.35088849663, 382101.58833524847], [116854.90441403577, 382116.34668270784], [116898.61337644224, 382127.2158115088], [116904.48937644223, 382128.39881150884], [116956.4344755874, 382136.04471737734], [117008.89496103986, 382138.2012580898], [117061.29235035465, 382134.84465344425], [117113.04885684873, 382126.0119167631], [117119.92985684874, 382124.4619167631], [117185.35996598237, 382104.944417173], [117190.17596598236, 382103.14141717297], [117214.1229913473, 382093.46386649105], [117221.74099134731, 382090.15386649105], [117240.89395359007, 382081.34743272676], [117260.32195359007, 382071.91343272675], [117302.61373372213, 382048.794581243], [117342.48303130137, 382021.7110978776], [117379.55936870065, 381990.914650587], [117413.4982213275, 381956.6914093168], [117443.98421905126, 381919.3593868233], [117470.7340767181, 381879.2654836026], [117493.49922652285, 381836.78226438566], [117512.06812777651, 381792.30449615367], [117526.26823260658, 381746.2454798433], [117535.9675893244, 381699.0332098287], [117541.07606856027, 381651.1063968681], [117541.54620077295, 381602.91039146966], [117537.37361735107, 381554.8930455595], [117528.5970912076, 381507.5005509056], [117515.29817649016, 381461.17329296813], [117497.60045075507, 381416.34175870405], [117469.80403309154, 381354.79322514124], [117484.8700266642, 381325.87831467035]]]}, "_shape": null}], "bbox": [68500.0, 354500.0, 129352.37894392274, 394500.0]}
);


Kaartgegevens.Instantie.VoegDataToe ("data13_2",
{"type": "FeatureCollection", "crs": {"type": "name", "properties": {"name": "urn:ogc:def:crs:EPSG::28992"}}, "features": [{"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[79000.0, 394000.0], [69000.0, 384000.0], [79000.0, 374000.0], [89000.0, 384000.0], [79000.0, 394000.0]]]}, "properties": {"id": "37b0a09f-36a0-4e69-80c2-000000000001", "naam": "Speciaal getekend"}, "_shape": null}, {"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[79000.0, 375000.0], [69000.0, 365000.0], [79000.0, 355000.0], [89000.0, 365000.0], [79000.0, 375000.0]]]}, "properties": {"id": "37b0a09f-36a0-4e69-80c2-000000000002", "naam": "Speciaal getekend"}, "_shape": null}, {"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[101000.0, 392000.0], [91000.0, 382000.0], [101000.0, 372000.0], [111000.0, 382000.0], [101000.0, 392000.0]]]}, "properties": {"id": "37b0a09f-36a0-4e69-80c2-000000000003", "naam": "Speciaal getekend"}, "_shape": null}, {"type": "Feature", "geometry": {"type": "MultiPolygon", "coordinates": [[[[123361.236, 383402.986], [123365.57, 383403.3], [123368.18, 383413.23], [123369.95, 383420.38], [123371.21, 383425.96], [123372.71, 383433.78], [123373.74, 383440.07], [123374.73, 383447.31], [123375.82, 383459.21], [123376.39, 383470.19], [123377.9, 383530.02], [123377.76, 383535.45], [123373.354, 383534.897], [123352.959, 383532.337], [123325.483, 383528.889], [123261.141, 383520.813], [123259.669, 383520.628], [123255.86, 383520.15], [123269.36, 383461.75], [123269.363, 383461.714], [123274.91, 383396.69], [123290.37, 383397.86], [123290.398, 383397.862], [123361.236, 383402.986]]], [[[122843.87, 383420.72], [122846.04, 383440.2], [122744.3, 383517.62], [122855.09, 383616.01], [122820.116, 383655.024], [122816.66, 383658.88], [122836.86, 383680.09], [122866.31, 383714.43], [122870.858, 383723.564], [122873.58, 383729.03], [122865.02, 383730.02], [122854.56, 383731.57], [122837.33, 383734.68], [122814.07, 383739.77], [122807.64, 383741.34], [122804.31, 383742.16], [122802.846, 383738.555], [122794.74, 383718.6], [122795.54, 383718.31], [122791.56, 383709.53], [122792.81, 383709.0], [122780.36, 383691.56], [122761.669, 383667.753], [122754.888, 383659.116], [122739.306, 383639.269], [122731.452, 383629.266], [122723.609, 383619.276], [122715.04, 383608.362], [122706.338, 383597.278], [122697.655, 383586.219], [122689.733, 383576.129], [122681.035, 383565.051], [122678.2, 383561.44], [122687.69, 383556.96], [122687.707, 383556.946], [122702.01, 383544.841], [122705.25, 383542.1], [122620.54, 383453.37], [122624.039, 383450.16], [122677.39, 383401.22], [122674.23, 383398.37], [122676.24, 383278.61], [122772.04, 383274.29], [122774.77, 383292.76], [122780.64, 383310.94], [122788.96, 383324.76], [122806.51, 383351.98], [122843.87, 383420.72]]], [[[124028.27, 384582.22], [124021.73, 384411.59], [124053.19, 384418.65], [124066.64, 384583.45], [124028.27, 384582.22]]], [[[119104.35, 380372.91], [119146.12, 380382.97], [119166.54, 380386.6], [119183.33, 380389.3], [119181.49, 380401.18], [119176.48, 380419.44], [119171.58, 380431.85], [119163.73, 380447.1], [119152.93, 380463.19], [119234.6, 380491.06], [119233.73, 380504.38], [119172.01, 380547.79], [119144.5, 380520.25], [119139.65, 380514.56], [119121.9, 380491.28], [119112.23, 380495.59], [119098.49, 380503.72], [119079.62, 380516.6], [119071.89, 380521.44], [119066.03, 380525.13], [119058.88, 380528.13], [119037.63, 380508.02], [119025.06, 380494.67], [119015.705, 380483.399], [119010.98, 380475.9], [119007.1, 380466.65], [119004.37, 380461.03], [118999.94, 380453.99], [118994.53, 380446.83], [118984.87, 380437.41], [118977.99, 380431.03], [118964.59, 380422.53], [118999.85, 380352.57], [119045.3, 380358.31], [119104.35, 380372.91]]], [[[123581.216, 382681.144], [123581.06, 382690.13], [123580.854, 382701.123], [123580.82, 382702.92], [123580.74, 382713.87], [123581.022, 382721.16], [123581.17, 382724.98], [123582.12, 382737.04], [123582.78, 382742.85], [123583.78, 382750.02], [123584.411, 382754.015], [123587.39, 382772.87], [123589.24, 382785.72], [123589.89, 382791.66], [123590.25, 382797.48], [123590.18, 382802.69], [123589.87, 382806.57], [123493.32, 382800.32], [123494.005, 382746.544], [123494.9, 382676.22], [123496.9, 382635.94], [123582.83, 382646.6], [123582.493, 382652.735], [123581.96, 382662.44], [123581.29, 382676.87], [123581.216, 382681.144]]], [[[123347.637, 382963.928], [123348.326, 382980.628], [123348.611, 382987.553], [123348.847, 382993.269], [123349.45, 383007.9], [123376.8, 383008.24], [123373.2, 382919.1], [123386.76, 382915.39], [123397.97, 382912.42], [123402.339, 383008.246], [123402.67, 383015.51], [123402.232, 383023.662], [123401.587, 383035.662], [123400.93, 383048.044], [123400.266, 383060.4], [123399.458, 383075.422], [123396.836, 383124.172], [123396.03, 383139.17], [123375.109, 383138.617], [123355.83, 383138.108], [123303.35, 383136.722], [123301.75, 383136.68], [123300.07, 383127.14], [123298.88, 383118.31], [123297.86, 383106.77], [123297.4, 383094.42], [123298.14, 383063.02], [123299.06, 383036.61], [123299.45, 383025.67], [123299.56, 383014.15], [123299.4, 383004.55], [123298.69, 382990.45], [123297.65, 382976.53], [123295.24, 382945.76], [123295.08, 382939.11], [123300.501, 382937.956], [123304.43, 382937.12], [123315.12, 382934.85], [123321.81, 382933.16], [123327.63, 382931.67], [123346.09, 382926.39], [123347.637, 382963.928]]], [[[123642.983, 383111.289], [123682.23, 383115.23], [123674.57, 383157.75], [123670.42, 383180.07], [123669.516, 383186.369], [123666.42, 383207.94], [123660.54, 383257.34], [123583.74, 383255.06], [123586.301, 383178.182], [123588.327, 383117.338], [123588.71, 383105.84], [123642.983, 383111.289]]], [[[123300.0, 383156.501], [123306.22, 383154.87], [123315.79, 383189.09], [123323.34, 383217.47], [123317.379, 383217.369], [123257.77, 383216.36], [123259.7, 383205.11], [123261.75, 383197.59], [123264.8, 383189.71], [123268.463, 383179.692], [123272.6, 383168.38], [123278.7, 383162.2], [123293.9, 383158.1], [123300.0, 383156.501]]], [[[123648.011, 379296.066], [123649.865, 379298.327], [123671.288, 379324.35], [123673.425, 379326.946], [123752.257, 379422.683], [123890.772, 379586.927], [123958.669, 379667.51], [123984.194, 379697.805], [124058.041, 379787.36], [124073.972, 379806.592], [124085.271, 379820.233], [124180.724, 379935.842], [124184.59, 379940.524], [124279.411, 380055.369], [124322.834, 380108.134], [124323.974, 380109.52], [124324.723, 380110.43], [124351.151, 380142.545], [124368.421, 380163.531], [124369.899, 380165.327], [124371.184, 380166.889], [124374.388, 380170.782], [124407.516, 380211.037], [124408.332, 380212.029], [124442.432, 380253.465], [124495.19, 380317.573], [124659.166, 380516.997], [124702.33, 380569.435], [124744.679, 380620.956], [124745.94, 380622.49], [124888.072, 380795.363], [124973.726, 380899.26], [125098.6, 381050.917], [125099.637, 381052.175], [125186.998, 381158.164], [125273.068, 381262.393], [125274.028, 381263.556], [125274.53, 381264.164], [125276.603, 381266.674], [125282.975, 381274.39], [125329.038, 381330.161], [125350.677, 381356.381], [125491.685, 381527.065], [125493.596, 381529.378], [125494.342, 381530.284], [125495.08, 381531.18], [125509.959, 381549.25], [125595.774, 381621.691], [125595.994, 381621.877], [125696.216, 381706.548], [125698.107, 381708.146], [125705.129, 381714.08], [125706.607, 381715.329], [125828.304, 381818.163], [125828.78, 381818.565], [125833.603, 381822.586], [125905.637, 381882.641], [125935.876, 381907.919], [126073.262, 382022.557], [126073.399, 382022.671], [126184.829, 382115.587], [126249.364, 382169.426], [126254.561, 382173.762], [126259.083, 382177.534], [126292.675, 382205.559], [126332.367, 382238.644], [126405.102, 382299.19], [126472.382, 382354.262], [126544.872, 382416.097], [126594.462, 382453.987], [126664.55, 382511.175], [126666.995, 382513.17], [126668.005, 382513.994], [126668.441, 382514.349], [126674.152, 382519.009], [126674.338, 382519.161], [126866.434, 382677.034], [126951.639, 382747.059], [127030.829, 382810.601], [127069.219, 382841.392], [127186.128, 382935.215], [127261.412, 382996.424], [127261.659, 382996.625], [127266.826, 383000.826], [127317.608, 383042.114], [127378.723, 383091.803], [127380.106, 383092.928], [127383.013, 383095.292], [127426.947, 383131.011], [127428.618, 383132.354], [127430.108, 383133.551], [127433.035, 383135.903], [127653.805, 383313.317], [127684.458, 383337.721], [127747.963, 383396.697], [127819.773, 383445.259], [127820.057, 383445.485], [127825.548, 383449.89], [127830.331, 383453.728], [127896.957, 383507.182], [127910.197, 383517.774], [127942.681, 383543.76], [127944.154, 383544.939], [127965.346, 383570.14], [128006.172, 383623.921], [128025.61, 383647.843], [128051.819, 383683.028], [128092.256, 383734.802], [128138.634, 383806.723], [128143.133, 383810.813], [128148.3, 383812.386], [128158.114, 383811.878], [128175.58, 383815.002], [128194.614, 383820.133], [128200.325, 383822.527], [128212.333, 383828.816], [128221.71, 383832.717], [128234.075, 383838.818], [128242.496, 383844.778], [128256.023, 383852.035], [128260.942, 383856.416], [128264.192, 383861.928], [128281.403, 383872.897], [128294.347, 383874.74], [128305.586, 383877.395], [128329.564, 383884.076], [128334.335, 383886.642], [128353.471, 383898.127], [128359.871, 383902.977], [128371.098, 383918.496], [128377.365, 383926.346], [128385.652, 383932.518], [128391.892, 383935.012], [128399.57, 383939.905], [128404.473, 383946.174], [128415.998, 383968.112], [128423.927, 383979.869], [128430.696, 383989.166], [128434.269, 383994.171], [128436.756, 383999.027], [128434.01, 384003.519], [128389.127, 384012.982], [128385.103, 384016.751], [128388.404, 384026.638], [128403.496, 384056.762], [128405.777, 384067.526], [128408.041, 384121.538], [128411.375, 384169.304], [128410.615, 384181.888], [128414.014, 384244.23], [128421.258, 384288.251], [128426.362, 384319.376], [128434.093, 384364.391], [128439.575, 384398.23], [128442.735, 384418.485], [128456.435, 384508.084], [128456.402, 384513.688], [128455.507, 384520.738], [128451.128, 384525.359], [128446.261, 384527.448], [128434.212, 384540.974], [128432.004, 384546.499], [128431.873, 384548.009], [128433.2, 384566.295], [128435.436, 384590.875], [128435.963, 384607.115], [128436.704, 384616.628], [128439.0, 384626.178], [128442.192, 384634.261], [128447.577, 384643.587], [128449.96, 384648.823], [128453.331, 384657.995], [128455.22, 384666.773], [128456.54, 384671.683], [128457.573, 384675.528], [128457.58, 384675.647], [128458.082, 384683.87], [128458.12, 384687.573], [128458.145, 384690.017], [128461.089, 384705.488], [128467.029, 384726.272], [128477.39, 384738.146], [128516.243, 384780.124], [128521.652, 384785.729], [128523.78, 384787.4], [128530.64, 384790.32], [128537.85, 384790.27], [128557.46, 384785.9], [128577.96, 384780.34], [128593.12, 384777.16], [128602.65, 384776.98], [128604.456, 384777.723], [128605.104, 384778.478], [128606.11, 384779.49], [128611.72, 384786.45], [128628.02, 384805.6], [128630.6, 384810.26], [128631.49, 384816.77], [128631.81, 384829.5], [128633.82, 384842.25], [128639.65, 384861.06], [128647.27, 384879.24], [128649.26, 384883.19], [128650.92, 384885.0], [128655.02, 384887.44], [128661.98, 384888.2], [128682.95, 384890.39], [128713.323, 384893.55], [128722.09, 384895.55], [128729.66, 384898.49], [128734.64, 384902.54], [128741.29, 384910.4], [128747.83, 384920.16], [128773.73, 384959.97], [128791.05, 384984.36], [128795.471, 384991.835], [128805.85, 385015.34], [128817.98, 385050.68], [128828.31, 385101.03], [128837.55, 385136.2], [128844.64, 385179.01], [128852.12, 385228.36], [128852.39, 385268.96], [128852.14, 385274.29], [128851.11, 385282.21], [128849.27, 385286.07], [128844.79, 385293.5], [128837.65, 385300.91], [128828.61, 385307.69], [128820.02, 385315.7], [128810.76, 385327.15], [128794.49, 385349.89], [128783.25, 385370.81], [128774.29, 385387.62], [128770.11, 385400.5], [128769.1, 385406.32], [128770.14, 385411.71], [128778.73, 385430.74], [128784.5, 385441.84], [128791.43, 385453.06], [128796.27, 385459.63], [128802.68, 385467.35], [128817.23, 385481.99], [128820.75, 385486.31], [128823.26, 385491.76], [128822.8, 385503.3], [128816.646, 385530.808], [128814.699, 385531.058], [128814.517, 385531.081], [128814.344, 385531.103], [128805.66, 385532.215], [128786.798, 385534.631], [128718.237, 385543.412], [128658.557, 385551.055], [128644.802, 385552.817], [128610.268, 385557.24], [128594.778, 385559.224], [128575.497, 385561.693], [128505.381, 385570.673], [128491.58, 385572.44], [128468.416, 385575.407], [128454.616, 385577.174], [128436.567, 385579.486], [128367.846, 385588.287], [128318.938, 385594.551], [128318.488, 385594.609], [128311.183, 385595.544], [128310.59, 385595.62], [128310.559, 385595.624], [128304.085, 385596.453], [128279.007, 385599.664], [128275.855, 385600.068], [128271.709, 385600.599], [128270.333, 385600.775], [128035.625, 385630.83], [128034.006, 385631.037], [128032.068, 385631.285], [127929.686, 385644.396], [127841.439, 385655.697], [127836.208, 385656.367], [127821.275, 385658.279], [127801.749, 385660.779], [127731.379, 385669.79], [127692.061, 385674.825], [127653.57, 385679.754], [127639.464, 385681.561], [127565.382, 385691.047], [127562.802, 385691.377], [127464.738, 385703.935], [127423.502, 385709.216], [127389.88, 385713.521], [127388.086, 385713.751], [127385.182, 385714.123], [127383.8, 385714.3], [127377.979, 385715.045], [127377.397, 385715.12], [127313.152, 385723.349], [127300.899, 385724.919], [127216.435, 385735.738], [127105.607, 385749.934], [127092.035, 385751.672], [126877.135, 385779.198], [126744.568, 385794.964], [126700.841, 385804.681], [126683.667, 385808.497], [126510.628, 385813.984], [126509.867, 385814.022], [126501.909, 385814.445], [126481.554, 385862.48], [126478.06, 385862.35], [126478.36, 385861.78], [126479.555, 385859.51], [126475.247, 385860.945], [126466.354, 385860.945], [126462.311, 385862.562], [126459.886, 385864.179], [126455.035, 385865.796], [126447.759, 385864.179], [126441.291, 385863.371], [126434.823, 385860.945], [126428.355, 385856.903], [126411.378, 385848.01], [126376.613, 385830.223], [126363.678, 385822.947], [126344.274, 385811.628], [126337.806, 385808.394], [126336.189, 385806.778], [126330.53, 385799.501], [126310.318, 385771.205], [126290.915, 385743.716], [126272.32, 385719.462], [126263.427, 385712.994], [126259.384, 385711.377], [126248.066, 385706.527], [126245.64, 385704.909], [126241.597, 385703.293], [126233.513, 385701.676], [126230.279, 385700.867], [126224.62, 385699.25], [126217.381, 385697.802], [126216.535, 385697.633], [126214.547, 385697.349], [126210.876, 385696.825], [126204.408, 385695.208], [126201.221, 385694.242], [126195.514, 385692.782], [126189.855, 385691.974], [126178.537, 385687.932], [126166.409, 385682.272], [126155.091, 385676.613], [126136.496, 385664.486], [126133.261, 385662.869], [126125.177, 385657.21], [126114.667, 385651.55], [126110.09, 385649.47], [126107.629, 385648.351], [126105.774, 385647.508], [126102.54, 385645.082], [126081.519, 385634.572], [126057.265, 385624.062], [126015.224, 385604.658], [126013.615, 385603.586], [126012.799, 385603.042], [126010.183, 385601.319], [126007.92, 385606.231], [125968.777, 385690.96], [125937.848, 385662.879], [125894.244, 385623.291], [125814.764, 385630.267], [125743.822, 385636.494], [125736.741, 385694.06], [125642.219, 385677.986], [125562.119, 385664.365], [125550.757, 385662.437], [125497.231, 385653.358], [125378.531, 385660.696], [125345.792, 385662.301], [125283.753, 385665.344], [125265.774, 385666.226], [125287.197, 385612.415], [125295.014, 385592.781], [125234.502, 385571.537], [125230.419, 385570.103], [125227.891, 385574.369], [125212.568, 385599.836], [125194.439, 385627.46], [125161.851, 385675.372], [125146.312, 385697.385], [125126.241, 385726.304], [125122.356, 385731.7], [125119.982, 385734.29], [125119.208, 385734.452], [125115.843, 385735.159], [125115.295, 385735.075], [125112.498, 385734.376], [125108.128, 385731.404], [125100.612, 385726.51], [125090.649, 385720.742], [125082.433, 385717.421], [125069.149, 385713.225], [125053.417, 385710.429], [125025.275, 385704.835], [124940.674, 385688.82], [124925.991, 385686.023], [124909.211, 385683.052], [124884.914, 385678.507], [124870.056, 385675.011], [124862.19, 385673.089], [124848.731, 385670.641], [124834.398, 385668.194], [124821.638, 385666.796], [124802.41, 385665.223], [124766.053, 385662.426], [124748.399, 385661.552], [124739.484, 385660.154], [124725.151, 385657.357], [124705.574, 385653.511], [124672.537, 385646.869], [124655.582, 385643.548], [124642.822, 385641.101], [124594.229, 385630.679], [124480.087, 385605.159], [124417.51, 385591.525], [124411.742, 385585.407], [124411.714, 385585.373], [124301.208, 385447.687], [124279.685, 385428.496], [124271.21, 385420.94], [124242.589, 385394.732], [124146.193, 385412.017], [124104.161, 385418.992], [124074.112, 385424.537], [124051.397, 385429.545], [124032.259, 385434.553], [124020.454, 385437.772], [123962.503, 385456.195], [123950.699, 385459.236], [123942.292, 385460.488], [123936.211, 385460.667], [123938.501, 385468.091], [123942.494, 385482.036], [123859.304, 385515.584], [123852.75, 385518.227], [123791.789, 385542.809], [123788.138, 385544.281], [123731.611, 385567.076], [123713.877, 385574.227], [123563.0, 385614.814], [123547.694, 385618.932], [123545.017, 385619.652], [123518.543, 385626.774], [123509.946, 385629.086], [123455.66, 385643.69], [123391.906, 385660.841], [123385.807, 385662.185], [123372.668, 385669.612], [123228.119, 385790.523], [123227.482, 385791.077], [123227.13, 385791.383], [123220.226, 385797.392], [123165.114, 385845.352], [123154.106, 385854.931], [123110.875, 385892.553], [123109.261, 385893.672], [123105.479, 385897.272], [123016.176, 385973.476], [123002.856, 385985.117], [122992.041, 385994.569], [122981.88, 386003.448], [122975.331, 386009.172], [122952.76, 386028.898], [122909.639, 386066.584], [122909.006, 386067.137], [122908.396, 386067.67], [122906.113, 386069.665], [122901.345, 386073.832], [122899.14, 386075.76], [122864.201, 386105.718], [122863.779, 386106.079], [122782.0, 386176.2], [122754.149, 386200.582], [122688.349, 386258.189], [122638.931, 386301.453], [122631.571, 386307.897], [122404.887, 386504.829], [122394.733, 386513.33], [122393.81, 386515.005], [122393.054, 386527.855], [122402.549, 386578.493], [122402.607, 386578.804], [122403.125, 386581.563], [122403.207, 386582.002], [122331.42, 386658.37], [122253.49, 386663.71], [122249.21, 386664.41], [122244.348, 386665.649], [122240.89, 386666.53], [122151.38, 386740.8], [122142.2, 386749.95], [122142.003, 386750.156], [122123.462, 386769.501], [122055.631, 386817.226], [121958.702, 386885.426], [121951.187, 386890.714], [121944.178, 386895.646], [121835.642, 386972.012], [121827.456, 386977.772], [121812.022, 386988.632], [121625.46, 387119.9], [121567.043, 387160.819], [121482.199, 387220.25], [121481.3, 387220.88], [121462.17, 387234.58], [121414.87, 387267.524], [121357.587, 387307.422], [121350.243, 387312.101], [121227.79, 387398.18], [121064.68, 387511.21], [121030.78, 387534.824], [120982.05, 387568.77], [120976.916, 387571.74], [120971.16, 387575.07], [120915.709, 387604.434], [120835.208, 387647.433], [120753.056, 387690.465], [120639.609, 387752.078], [120636.99, 387753.5], [120612.155, 387767.361], [120589.307, 387780.112], [120549.64, 387802.251], [120457.617, 387786.614], [120455.629, 387786.276], [120435.932, 387782.929], [120116.947, 387728.724], [120115.074, 387728.406], [120084.616, 387723.23], [120082.24, 387722.826], [120079.477, 387722.356], [119978.099, 387705.129], [119970.784, 387709.239], [119905.221, 387746.076], [119907.353, 387763.997], [119912.564, 387807.792], [119913.648, 387816.901], [119713.559, 387850.497], [119682.647, 387855.687], [119608.959, 387868.059], [119525.097, 387882.14], [119492.485, 387887.616], [119447.129, 387895.232], [119422.917, 387899.297], [119404.062, 387902.463], [119301.909, 387919.616], [119232.5, 387931.27], [119228.401, 387937.535], [119199.583, 387981.581], [119197.211, 387986.851], [119195.424, 387990.822], [119191.342, 387989.527], [119182.823, 387985.493], [119181.915, 387985.063], [119183.521, 387982.161], [119200.765, 387951.02], [119196.766, 387950.118], [119131.795, 387935.471], [119118.334, 387932.646], [119105.43, 387929.715], [119093.475, 387927.077], [119082.824, 387925.019], [119073.441, 387922.827], [119053.425, 387918.726], [119047.046, 387917.419], [119042.315, 387916.207], [119037.326, 387915.01], [118998.804, 387906.775], [118940.775, 387894.37], [118909.063, 387887.686], [118888.108, 387883.269], [118841.842, 387871.697], [118815.024, 387864.245], [118811.089, 387863.152], [118760.931, 387849.214], [118735.326, 387838.266], [118698.021, 387823.354], [118696.351, 387822.686], [118670.715, 387812.438], [118670.304, 387812.274], [118596.009, 387781.353], [118584.742, 387776.752], [118522.009, 387751.133], [118518.223, 387749.64], [118515.105, 387748.984], [118514.239, 387748.978], [118512.459, 387748.966], [118510.628, 387749.02], [118421.154, 387764.514], [118420.836, 387764.569], [118418.665, 387764.808], [118417.014, 387764.99], [118416.163, 387765.165], [118415.616, 387765.277], [118414.388, 387765.529], [118413.015, 387765.811], [118411.063, 387766.212], [118402.436, 387767.983], [118402.162, 387768.039], [118397.34, 387768.72], [118395.03, 387769.046], [118326.616, 387780.952], [118301.488, 387785.287], [118294.284, 387786.527], [118231.786, 387797.282], [118196.635, 387803.672], [118195.81, 387803.814], [118188.75, 387805.031], [118099.894, 387820.353], [118000.975, 387837.517], [117954.119, 387845.648], [117878.265, 387910.741], [117871.456, 387916.041], [117873.473, 387923.272], [117881.916, 387952.619], [117847.021, 387963.353], [117819.983, 387971.67], [117808.365, 387975.407], [117791.994, 387980.717], [117777.055, 387985.238], [117769.533, 387987.531], [117766.933, 387988.912], [117744.822, 387995.972], [117727.246, 388001.384], [117710.114, 388006.743], [117695.471, 388011.334], [117680.866, 388015.692], [117659.371, 388022.377], [117654.425, 388023.823], [117631.054, 388032.228], [117610.923, 388039.781], [117591.174, 388047.017], [117571.23, 388053.749], [117569.652, 388054.05], [117566.478, 388054.654], [117561.766, 388054.694], [117545.054, 388054.846], [117522.165, 388055.227], [117509.549, 388055.593], [117486.397, 388056.524], [117469.3, 388057.271], [117459.098, 388057.719], [117454.305, 388057.678], [117432.294, 388058.592], [117427.961, 388058.872], [117409.762, 388060.294], [117392.625, 388061.769], [117394.45, 388096.235], [117393.855, 388108.711], [117392.523, 388120.87], [117391.889, 388121.58], [117390.417, 388122.926], [117390.065, 388123.247], [117389.579, 388123.598], [117389.133, 388123.999], [117388.734, 388124.447], [117388.385, 388124.935], [117388.092, 388125.458], [117387.857, 388126.01], [117387.683, 388126.584], [117383.878, 388123.465], [117382.577, 388122.419], [117381.469, 388121.528], [117378.78, 388119.364], [117364.136, 388107.579], [117360.22, 388104.738], [117355.921, 388102.813], [117351.961, 388101.651], [117347.184, 388101.091], [117341.245, 388101.134], [117317.307, 388104.28], [117265.963, 388111.154], [117227.962, 388115.517], [117215.05, 388116.507], [117205.858, 388116.832], [117201.56, 388116.069], [117198.925, 388114.89], [117196.463, 388111.874], [117193.089, 388104.645], [117190.974, 388102.669], [117175.266, 388096.259], [117171.106, 388095.774], [117161.537, 388101.633], [117158.764, 388102.396], [117152.42, 388101.212], [117148.156, 388100.519], [117143.684, 388101.073], [117139.962, 388102.169], [117136.979, 388103.258], [117135.617, 388103.592], [117130.001, 388104.771], [117123.677, 388105.11], [117118.852, 388107.026], [117118.48, 388106.196], [117117.825, 388104.743], [117117.377, 388103.75], [117085.434, 388032.853], [117085.376, 388032.723], [117009.27, 387862.96], [117003.682, 387795.298], [117003.271, 387790.324], [117002.874, 387785.515], [116999.2, 387741.023], [116999.044, 387739.128], [116999.036, 387739.022], [116994.286, 387675.661], [116993.797, 387669.127], [116990.144, 387620.393], [116989.632, 387613.57], [116986.512, 387572.79], [116986.449, 387571.963], [116979.397, 387479.082], [116977.019, 387447.765], [116976.793, 387444.785], [116976.195, 387437.036], [116960.0, 387227.28], [116960.031, 387226.478], [116928.052, 387167.905], [116885.622, 387088.006], [116878.529, 387073.33], [116891.781, 387070.412], [116869.766, 387032.86], [116859.3, 387000.0], [116822.946, 386882.179], [116818.064, 386870.681], [116808.393, 386849.138], [116796.921, 386826.835], [116795.317, 386822.701], [116795.276, 386822.594], [116794.773, 386821.299], [116789.161, 386813.44], [116786.407, 386807.86], [116784.574, 386802.888], [116782.6, 386797.081], [116769.345, 386736.407], [116759.235, 386694.574], [116762.345, 386691.135], [116763.288, 386690.687], [116765.716, 386689.534], [116765.727, 386689.057], [116765.913, 386680.86], [116739.324, 386366.175], [116737.683, 386346.808], [116730.945, 386267.269], [116721.326, 386153.514], [116721.277, 386153.068], [116721.2, 386152.375], [116720.134, 386142.74], [116719.829, 386139.98], [116719.629, 386137.795], [116701.701, 385941.763], [116707.052, 385942.383], [116707.592, 385942.441], [116711.696, 385942.879], [116712.267, 385942.94], [116713.899, 385943.114], [116846.508, 385957.278], [116847.569, 385957.273], [116852.894, 385957.219], [116856.118, 385956.759], [116861.239, 385954.7], [116898.886, 385933.057], [116900.527, 385932.099], [116902.679, 385930.832], [116906.988, 385928.295], [116945.698, 385905.504], [116949.72, 385903.22], [117003.229, 385872.829], [117008.599, 385869.79], [117043.301, 385850.15], [117046.829, 385847.464], [117047.095, 385846.008], [117044.889, 385841.513], [117044.003, 385840.296], [117044.556, 385839.938], [117106.113, 385800.052], [117126.644, 385786.748], [117130.863, 385784.014], [117136.597, 385780.528], [117140.154, 385784.828], [117228.478, 385712.513], [117249.348, 385695.426], [117249.544, 385695.266], [117249.719, 385695.122], [117247.307, 385693.964], [117245.628, 385691.657], [117241.899, 385681.137], [117229.182, 385658.039], [117204.958, 385613.975], [117186.513, 385579.979], [117158.635, 385544.582], [117158.17, 385544.02], [117140.17, 385522.278], [117135.155, 385512.881], [117134.746, 385512.115], [117129.378, 385502.422], [117126.826, 385500.314], [117122.049, 385499.969], [117120.396, 385499.821], [117118.398, 385498.473], [117109.307, 385487.489], [117107.845, 385485.722], [117104.034, 385481.706], [117103.56, 385481.234], [117073.113, 385450.949], [117062.198, 385441.046], [117044.773, 385428.474], [117009.291, 385409.483], [116996.742, 385402.766], [116989.75, 385398.825], [116976.346, 385391.982], [116966.517, 385386.953], [116866.726, 385363.061], [116861.529, 385362.51], [116857.438, 385362.899], [116846.734, 385364.386], [116817.521, 385369.231], [116757.869, 385445.201], [116753.665, 385452.914], [116741.629, 385474.998], [116712.887, 385527.732], [116708.856, 385534.51], [116697.342, 385553.869], [116662.752, 385619.029], [116650.853, 385641.563], [116641.172, 385661.259], [116640.182, 385663.635], [116637.125, 385663.037], [116636.756, 385662.692], [116632.881, 385659.074], [116602.556, 385620.207], [116580.359, 385592.394], [116528.293, 385527.151], [116522.976, 385520.489], [116520.98, 385517.988], [116510.302, 385515.643], [116504.084, 385467.11], [116486.621, 385430.601], [116484.76, 385426.71], [116467.072, 385389.419], [116453.327, 385357.74], [116432.404, 385318.013], [116417.494, 385300.363], [116406.579, 385291.692], [116378.112, 385205.407], [116377.867, 385204.663], [116377.584, 385204.074], [116375.966, 385200.707], [116375.118, 385198.943], [116372.61, 385190.787], [116372.103, 385186.183], [116354.837, 385152.218], [116348.033, 385141.086], [116343.642, 385130.155], [116336.55, 385117.225], [116334.889, 385114.197], [116333.051, 385111.626], [116321.007, 385091.175], [116320.956, 385091.11], [116316.088, 385084.841], [116314.285, 385082.52], [116312.601, 385080.051], [116310.39, 385076.81], [116301.363, 385067.629], [116253.9, 385019.361], [116251.971, 385017.4], [116251.972, 385016.114], [116252.049, 385014.158], [116252.89, 384986.704], [116254.17, 384944.92], [116230.906, 384915.867], [116219.289, 384898.354], [116209.879, 384882.62], [116205.282, 384873.427], [116162.839, 384853.846], [116143.281, 384843.935], [116146.142, 384838.202], [116150.223, 384832.095], [116153.625, 384824.88], [116161.497, 384807.022], [116169.915, 384792.277], [116168.51, 384790.697], [116165.266, 384787.05], [116163.216, 384785.894], [116139.213, 384772.358], [116131.773, 384767.81], [116130.307, 384766.913], [116118.728, 384760.555], [116118.338, 384761.241], [116085.218, 384741.959], [116041.786, 384717.391], [116007.061, 384697.943], [115988.192, 384686.046], [115951.134, 384658.224], [115920.214, 384635.73], [115884.911, 384609.914], [115865.36, 384595.378], [115836.314, 384573.479], [115818.045, 384556.467], [115809.182, 384547.842], [115805.067, 384543.838], [115805.888, 384536.967], [115806.206, 384534.308], [115806.801, 384529.329], [115830.574, 384330.256], [115850.545, 384163.03], [115850.617, 384162.431], [115850.652, 384162.14], [115856.789, 384111.442], [115862.572, 384061.768], [115864.0, 384049.566], [115868.385, 384012.109], [115874.168, 383962.435], [115880.05, 383912.772], [115885.982, 383863.115], [115891.725, 383813.436], [115892.717, 383807.71], [115898.015, 383763.82], [115901.835, 383731.832], [115902.144, 383729.243], [115902.586, 383725.543], [115902.593, 383725.484], [115902.919, 383722.632], [115903.119, 383720.88], [115908.61, 383672.854], [115914.58, 383624.907], [115922.43, 383558.61], [115923.073, 383553.183], [115926.554, 383523.785], [115939.49, 383413.76], [115951.251, 383315.46], [115952.186, 383307.641], [115952.457, 383305.264], [115952.696, 383303.163], [115964.656, 383204.625], [115964.855, 383203.042], [115966.026, 383193.718], [115971.861, 383143.572], [115906.847, 383131.732], [115904.77, 383121.158], [115901.535, 383071.062], [115900.291, 383067.945], [115899.996, 383067.206], [115898.46, 383063.357], [115901.801, 383043.022], [115902.211, 383034.57], [115903.38, 383026.28], [115909.877, 382994.568], [115916.962, 382958.067], [115919.774, 382944.556], [115941.911, 382831.085], [115942.383, 382828.666], [115959.75, 382740.54], [115965.753, 382708.086], [115966.03, 382706.59], [115967.642, 382698.363], [115967.818, 382697.464], [115979.546, 382637.114], [115992.251, 382571.562], [116000.82, 382528.63], [116011.155, 382475.815], [116016.899, 382446.504], [116017.607, 382442.893], [116034.996, 382352.548], [116035.214, 382351.417], [116035.768, 382348.612], [116065.755, 382196.828], [116103.689, 382005.004], [116105.273, 381996.997], [116110.073, 381972.725], [116110.544, 381970.343], [116121.605, 381912.713], [116138.999, 381825.184], [116148.513, 381774.175], [116144.417, 381740.506], [116140.617, 381723.599], [116139.44, 381718.128], [116136.324, 381703.65], [116124.82, 381639.525], [116119.675, 381613.744], [116116.765, 381606.487], [116116.569, 381605.998], [116115.536, 381603.423], [116137.622, 381600.884], [116144.898, 381601.064], [116150.16, 381601.4], [116158.399, 381602.621], [116165.145, 381604.578], [116186.517, 381614.865], [116191.036, 381616.017], [116194.549, 381615.751], [116198.553, 381613.729], [116201.083, 381611.004], [116207.65, 381599.489], [116210.32, 381591.119], [116214.266, 381571.991], [116216.736, 381565.056], [116219.735, 381561.212], [116223.118, 381558.945], [116235.676, 381554.767], [116244.35, 381548.18], [116248.523, 381542.336], [116254.37, 381526.725], [116253.976, 381495.653], [116258.233, 381491.087], [116262.098, 381488.123], [116279.82, 381483.518], [116290.084, 381480.055], [116329.285, 381461.655], [116382.536, 381454.995], [116387.009, 381451.935], [116389.942, 381449.794], [116392.572, 381442.262], [116394.209, 381438.016], [116401.134, 381432.53], [116412.684, 381432.667], [116433.833, 381437.008], [116449.682, 381439.023], [116460.357, 381439.248], [116469.673, 381436.539], [116472.201, 381434.005], [116472.714, 381430.113], [116471.406, 381424.399], [116467.005, 381420.609], [116461.711, 381414.471], [116459.048, 381410.584], [116457.851, 381408.409], [116458.658, 381400.612], [116462.456, 381396.318], [116464.0, 381395.386], [116468.916, 381393.021], [116472.949, 381393.558], [116478.341, 381398.728], [116483.963, 381411.744], [116486.535, 381416.697], [116488.56, 381417.371], [116490.521, 381417.744], [116519.181, 381410.486], [116521.557, 381409.527], [116528.188, 381422.524], [116531.829, 381454.675], [116533.921, 381461.957], [116544.136, 381479.259], [116549.794, 381486.476], [116555.022, 381487.018], [116559.18, 381484.899], [116562.798, 381482.012], [116567.711, 381476.248], [116579.796, 381458.021], [116586.934, 381455.559], [116590.494, 381455.715], [116597.225, 381460.553], [116604.253, 381481.427], [116613.144, 381484.122], [116621.243, 381481.267], [116635.032, 381469.145], [116652.981, 381451.65], [116656.538, 381450.682], [116661.173, 381451.808], [116666.539, 381456.331], [116668.609, 381478.743], [116671.078, 381483.076], [116677.903, 381486.565], [116700.577, 381484.798], [116712.439, 381478.745], [116723.891, 381467.346], [116730.563, 381462.263], [116765.845, 381446.771], [116774.681, 381446.52], [116786.706, 381463.623], [116791.879, 381468.402], [116794.537, 381468.658], [116795.826, 381472.708], [116796.213, 381473.926], [116805.457, 381502.977], [116810.016, 381517.306], [116818.053, 381544.886], [116821.054, 381545.81], [116844.765, 381553.496], [116850.695, 381555.167], [116859.056, 381555.252], [116868.033, 381554.332], [116891.639, 381549.537], [116894.934, 381549.829], [116903.615, 381553.75], [116914.251, 381558.829], [116925.965, 381564.838], [116931.725, 381569.334], [116944.786, 381579.703], [116951.394, 381586.545], [116955.199, 381592.361], [116965.972, 381608.317], [116975.924, 381623.805], [116979.225, 381629.856], [116997.297, 381637.051], [117003.173, 381638.234], [117010.054, 381636.684], [117014.87, 381634.881], [117022.488, 381631.571], [117041.916, 381622.137], [116974.461, 381472.774], [116967.188, 381456.67], [116966.94, 381456.12], [116895.757, 381370.505], [116893.481, 381367.768], [116896.197, 381367.18], [116905.271, 381361.343], [116912.706, 381345.781], [116917.64, 381329.018], [116915.523, 381329.016], [116914.62, 381329.015], [116893.159, 381328.905], [116836.732, 381261.744], [116800.537, 381218.663], [116777.71, 381191.494], [116775.17, 381188.47], [116733.522, 381118.491], [116732.523, 381116.813], [116691.324, 381047.587], [116686.432, 381049.941], [116649.838, 381067.547], [116639.561, 381072.714], [116634.708, 381075.047], [116628.123, 381078.458], [116625.065, 381080.173], [116711.242, 381224.848], [116691.659, 381233.6], [116663.907, 381245.579], [116661.728, 381246.519], [116617.855, 381265.864], [116570.298, 381175.927], [116564.777, 381179.687], [116454.573, 381254.744], [116452.489, 381256.163], [116452.358, 381256.252], [116478.4, 381310.606], [116485.608, 381329.613], [116429.55, 381354.722], [116357.141, 381388.459], [116334.553, 381399.076], [116306.733, 381412.152], [116268.313, 381429.856], [116243.189, 381441.348], [116232.587, 381437.921], [116206.861, 381442.186], [116205.37, 381442.518], [116174.245, 381449.454], [116159.12, 381452.454], [116114.517, 381461.301], [116071.35, 381469.495], [116070.58, 381469.635], [116029.81, 381477.067], [116000.82, 381480.947], [116000.0, 381481.057], [115999.96, 381481.111], [115996.441, 381485.949], [116000.0, 381496.345], [116001.153, 381499.714], [116036.051, 381601.641], [116033.419, 381603.82], [116030.728, 381606.048], [116026.187, 381603.607], [116024.08, 381604.449], [116018.543, 381606.298], [116009.876, 381613.002], [115997.198, 381623.077], [115972.645, 381633.051], [115964.565, 381636.89], [115961.211, 381639.001], [115958.588, 381641.575], [115956.941, 381643.559], [115955.559, 381646.179], [115954.972, 381647.963], [115955.08, 381649.89], [115956.222, 381652.465], [115959.852, 381656.937], [115976.621, 381672.531], [115980.252, 381676.911], [115983.168, 381688.54], [115982.758, 381695.482], [115981.964, 381700.724], [115979.64, 381701.708], [115956.017, 381708.565], [115945.1, 381705.211], [115943.097, 381701.778], [115921.741, 381669.016], [115919.034, 381666.482], [115913.85, 381665.124], [115907.598, 381665.314], [115899.265, 381670.724], [115895.342, 381678.962], [115891.476, 381689.914], [115889.106, 381692.569], [115877.951, 381702.041], [115856.254, 381705.742], [115852.397, 381704.295], [115833.688, 381688.405], [115829.972, 381686.719], [115825.191, 381685.489], [115819.044, 381684.938], [115787.936, 381686.234], [115777.076, 381683.158], [115762.097, 381674.262], [115757.599, 381673.28], [115755.216, 381673.683], [115750.52, 381676.255], [115746.148, 381683.992], [115737.982, 381694.78], [115728.198, 381703.616], [115725.34, 381704.962], [115715.637, 381705.724], [115682.365, 381692.429], [115679.483, 381690.234], [115679.159, 381686.474], [115689.08, 381668.201], [115691.221, 381661.257], [115684.673, 381651.805], [115660.032, 381645.304], [115648.889, 381647.461], [115642.169, 381652.748], [115637.241, 381663.706], [115628.1, 381670.96], [115622.695, 381671.763], [115615.031, 381674.476], [115605.172, 381681.076], [115597.707, 381687.885], [115594.708, 381696.029], [115593.96, 381714.246], [115587.814, 381724.719], [115584.191, 381727.011], [115578.495, 381732.737], [115577.805, 381735.024], [115577.882, 381738.837], [115582.754, 381748.667], [115585.92, 381758.312], [115588.538, 381763.924], [115587.396, 381776.748], [115583.594, 381780.942], [115568.74, 381784.347], [115566.962, 381784.493], [115559.105, 381785.139], [115544.328, 381785.916], [115539.67, 381786.312], [115535.864, 381787.944], [115533.801, 381790.769], [115531.252, 381793.706], [115529.651, 381799.534], [115530.25, 381813.897], [115528.941, 381821.891], [115525.554, 381828.554], [115519.612, 381832.514], [115513.343, 381834.653], [115496.034, 381835.502], [115488.543, 381838.066], [115482.956, 381842.165], [115476.531, 381847.319], [115467.922, 381855.718], [115464.051, 381858.697], [115457.5, 381861.439], [115414.012, 381872.339], [115407.904, 381873.971], [115394.964, 381879.176], [115390.028, 381881.518], [115386.669, 381883.597], [115371.275, 381896.925], [115343.71, 381914.118], [115336.438, 381918.859], [115333.517, 381920.81], [115329.516, 381926.524], [115324.672, 381941.291], [115320.354, 381945.502], [115312.635, 381947.449], [115303.11, 381950.824], [115302.141, 381953.166], [115303.041, 381956.099], [115303.187, 381976.31], [115301.64, 381985.209], [115297.406, 381990.472], [115289.385, 381995.151], [115281.313, 381994.476], [115264.846, 381982.916], [115262.641, 381980.809], [115261.932, 381979.392], [115262.023, 381977.139], [115259.837, 381968.957], [115256.71, 381959.966], [115253.933, 381953.296], [115251.476, 381950.035], [115247.422, 381946.116], [115242.477, 381943.573], [115234.78, 381941.463], [115227.714, 381941.412], [115216.708, 381949.547], [115201.722, 381952.753], [115191.075, 381960.368], [115171.364, 381977.604], [115170.505, 381981.961], [115172.246, 381984.089], [115173.675, 381984.879], [115186.057, 381990.958], [115187.826, 381997.457], [115186.85, 381999.422], [115172.738, 382005.756], [115154.091, 382009.428], [115149.363, 382010.72], [115143.456, 382009.066], [115127.912, 381996.759], [115121.281, 381995.48], [115116.518, 381997.575], [115113.718, 381999.174], [115107.227, 382011.183], [115101.69, 382016.586], [115095.235, 382019.797], [115090.195, 382023.522], [115085.859, 382029.665], [115076.875, 382049.322], [115069.183, 382060.567], [115064.107, 382064.247], [115058.234, 382066.239], [115029.76, 382071.15], [115012.905, 382074.741], [115009.782, 382073.388], [115006.914, 382071.051], [115006.818, 382064.078], [115007.164, 382047.562], [115004.469, 382039.549], [115001.985, 382037.466], [114999.436, 382035.023], [114996.82, 382033.412], [114979.439, 382028.927], [114970.441, 382030.066], [114957.142, 382037.865], [114947.622, 382043.475], [114906.088, 382064.397], [114894.532, 382072.99], [114890.855, 382073.948], [114886.774, 382072.78], [114873.932, 382060.789], [114859.526, 382051.245], [114838.849, 382040.606], [114834.477, 382039.343], [114830.456, 382039.434], [114826.665, 382040.183], [114824.466, 382044.451], [114823.934, 382048.119], [114826.747, 382059.791], [114826.544, 382063.962], [114826.119, 382068.089], [114820.076, 382071.619], [114802.723, 382071.684], [114792.836, 382074.103], [114773.803, 382081.518], [114765.334, 382082.065], [114751.939, 382080.976], [114742.519, 382084.453], [114717.066, 382105.475], [114714.646, 382109.793], [114713.855, 382112.921], [114715.182, 382117.979], [114723.12, 382124.841], [114728.624, 382131.566], [114730.373, 382137.65], [114731.346, 382140.121], [114730.942, 382142.071], [114729.693, 382146.359], [114725.882, 382149.304], [114704.828, 382158.874], [114699.704, 382164.702], [114697.85, 382169.426], [114696.111, 382173.858], [114694.868, 382176.957], [114692.519, 382181.843], [114687.247, 382192.807], [114682.73, 382199.039], [114678.142, 382201.853], [114672.567, 382202.811], [114649.902, 382195.876], [114627.964, 382186.727], [114622.987, 382188.055], [114618.324, 382190.216], [114608.968, 382205.17], [114596.81, 382218.013], [114586.36, 382235.306], [114588.885, 382237.186], [114592.908, 382240.15], [114599.957, 382246.676], [114602.951, 382251.105], [114608.651, 382262.335], [114609.851, 382264.61], [114612.016, 382267.474], [114618.762, 382267.823], [114623.485, 382268.93], [114628.291, 382270.882], [114630.035, 382273.512], [114630.963, 382277.276], [114630.924, 382282.388], [114627.302, 382288.674], [114622.57, 382291.985], [114622.524, 382292.489], [114609.147, 382289.973], [114601.805, 382291.071], [114594.717, 382292.157], [114581.708, 382292.439], [114578.359, 382293.564], [114574.695, 382299.063], [114573.085, 382300.673], [114565.421, 382307.785], [114563.732, 382310.122], [114564.266, 382318.654], [114560.968, 382326.082], [114557.565, 382328.909], [114545.166, 382328.838], [114536.502, 382324.543], [114525.471, 382314.871], [114522.877, 382315.896], [114512.311, 382314.878], [114504.672, 382312.378], [114502.019, 382309.639], [114493.383, 382288.596], [114481.732, 382261.811], [114479.235, 382257.661], [114473.126, 382253.994], [114466.735, 382251.717], [114458.365, 382245.928], [114455.933, 382244.12], [114448.798, 382250.801], [114443.04, 382254.147], [114439.923, 382255.257], [114431.815, 382256.812], [114427.76, 382258.421], [114424.326, 382261.469], [114418.566, 382270.148], [114415.883, 382273.282], [114413.409, 382274.653], [114386.817, 382279.364], [114376.534, 382280.978], [114370.226, 382282.717], [114356.695, 382287.55], [114344.821, 382291.012], [114335.259, 382292.952], [114322.674, 382292.368], [114317.981, 382293.563], [114314.125, 382296.918], [114309.768, 382307.292], [114302.844, 382314.01], [114298.817, 382314.911], [114294.596, 382315.1], [114290.863, 382314.051], [114283.366, 382305.412], [114279.568, 382301.704], [114275.227, 382298.51], [114271.0, 382298.998], [114267.239, 382303.465], [114264.121, 382310.513], [114262.596, 382318.363], [114260.984, 382321.278], [114257.771, 382326.498], [114251.228, 382330.439], [114247.543, 382338.309], [114249.554, 382345.545], [114255.061, 382357.472], [114255.262, 382367.277], [114250.824, 382368.619], [114237.337, 382368.383], [114219.156, 382364.93], [114212.561, 382366.132], [114207.262, 382368.464], [114196.812, 382376.86], [114185.603, 382386.348], [114181.694, 382386.836], [114177.286, 382385.804], [114154.993, 382365.72], [114150.611, 382362.549], [114145.334, 382360.558], [114126.806, 382357.34], [114117.035, 382354.665], [114112.321, 382352.487], [114093.695, 382340.759], [114081.728, 382330.275], [114072.466, 382326.751], [114065.748, 382332.895], [114065.836, 382341.522], [114073.16, 382353.806], [114073.353, 382358.717], [114071.762, 382363.778], [114067.751, 382368.329], [114049.195, 382369.207], [114042.596, 382368.278], [114036.0, 382359.582], [114027.304, 382341.383], [114024.76, 382336.85], [114018.279, 382332.215], [114009.549, 382337.071], [113999.892, 382348.465], [113992.649, 382355.342], [113989.827, 382360.231], [113987.136, 382374.121], [113983.79, 382379.68], [113976.824, 382385.303], [113967.32, 382383.234], [113962.695, 382373.843], [113961.566, 382369.509], [113961.512, 382364.496], [113960.794, 382361.033], [113958.834, 382356.652], [113955.86, 382352.837], [113947.091, 382345.77], [113938.771, 382341.064], [113933.511, 382334.528], [113919.689, 382307.262], [113917.344, 382304.056], [113911.687, 382299.296], [113864.263, 382305.045], [113858.67, 382305.892], [113855.319, 382307.206], [113852.67, 382308.637], [113851.76, 382311.961], [113853.225, 382317.068], [113860.839, 382332.243], [113863.611, 382341.373], [113863.24, 382345.543], [113856.592, 382350.619], [113848.797, 382353.962], [113838.576, 382355.237], [113829.568, 382353.768], [113820.888, 382351.646], [113813.174, 382348.446], [113785.298, 382331.752], [113773.402, 382325.704], [113764.1, 382321.393], [113761.148, 382320.906], [113756.38, 382321.495], [113754.238, 382323.876], [113750.815, 382327.681], [113748.525, 382334.694], [113740.34, 382348.621], [113718.58, 382374.628], [113713.017, 382373.993], [113709.006, 382370.475], [113701.118, 382354.686], [113694.338, 382344.072], [113689.402, 382338.272], [113682.925, 382332.299], [113678.018, 382329.401], [113666.024, 382330.637], [113661.788, 382338.934], [113661.337, 382341.172], [113662.671, 382343.826], [113668.368, 382356.892], [113662.878, 382367.311], [113658.801, 382371.239], [113652.378, 382378.083], [113645.541, 382386.49], [113637.144, 382394.47], [113620.73, 382405.269], [113614.058, 382408.154], [113604.816, 382413.257], [113601.931, 382413.275], [113594.606, 382407.019], [113589.973, 382402.828], [113586.453, 382400.664], [113576.821, 382399.841], [113570.276, 382410.134], [113567.323, 382415.899], [113564.686, 382424.694], [113562.695, 382434.819], [113563.511, 382439.772], [113565.279, 382444.15], [113573.707, 382459.215], [113574.801, 382461.878], [113572.71, 382468.704], [113567.773, 382472.524], [113564.278, 382472.923], [113555.767, 382472.506], [113534.232, 382468.405], [113531.339, 382466.912], [113529.198, 382464.11], [113528.764, 382460.396], [113529.261, 382453.294], [113528.879, 382451.58], [113522.338, 382446.658], [113520.257, 382446.948], [113506.313, 382451.551], [113495.746, 382458.196], [113485.18, 382463.42], [113477.066, 382464.061], [113471.434, 382462.157], [113466.409, 382457.789], [113462.754, 382455.006], [113456.247, 382451.882], [113440.621, 382446.298], [113432.57, 382445.215], [113419.218, 382459.314], [113415.945, 382460.747], [113412.084, 382461.786], [113407.6, 382462.865], [113407.361, 382465.276], [113407.333, 382465.555], [113407.236, 382467.835], [113406.762, 382478.974], [113405.082, 382487.402], [113404.125, 382492.2], [113399.083, 382505.841], [113397.814, 382509.016], [113393.43, 382519.986], [113389.294, 382530.855], [113374.535, 382569.638], [113356.593, 382616.785], [113351.395, 382630.308], [113325.651, 382697.288], [113322.052, 382706.651], [113314.07, 382726.08], [113271.033, 382726.221], [113250.072, 382726.289], [113249.619, 382729.047], [113242.136, 382774.609], [113238.704, 382795.388], [113237.146, 382781.749], [113236.721, 382779.094], [113232.865, 382773.137], [113208.26, 382771.306], [113079.058, 382761.692], [113076.093, 382761.471], [113072.332, 382761.191], [113069.874, 382761.008], [113069.685, 382760.995], [113068.059, 382760.881], [112985.858, 382755.125], [112928.572, 382750.091], [112912.91, 382748.715], [112891.191, 382748.795], [112874.636, 382750.029], [112858.339, 382751.884], [112852.525, 382753.162], [112845.538, 382754.697], [112838.984, 382758.147], [112800.55, 382747.281], [112799.234, 382746.909], [112752.708, 382733.755], [112720.6, 382725.084], [112718.618, 382724.549], [112707.217, 382721.47], [112624.718, 382699.499], [112618.067, 382698.742], [112577.303, 382693.241], [112540.22, 382688.236], [112508.812, 382683.92], [112477.926, 382680.441], [112422.742, 382681.853], [112366.231, 382680.737], [112365.099, 382677.35], [112364.121, 382674.423], [112363.511, 382672.6], [112362.537, 382669.685], [112349.622, 382656.75], [112315.369, 382652.255], [112268.0, 382622.659], [112261.951, 382617.37], [112254.55, 382606.957], [112243.316, 382589.976], [112242.32, 382588.47], [112240.464, 382586.696], [112231.627, 382595.015], [112224.207, 382594.944], [112220.185, 382592.825], [112218.035, 382590.024], [112210.671, 382583.321], [112199.938, 382580.203], [112180.624, 382577.456], [112162.376, 382577.412], [112137.957, 382574.974], [112130.384, 382573.256], [112115.258, 382565.126], [112108.333, 382563.816], [112093.056, 382564.793], [112088.996, 382562.49], [112086.947, 382560.901], [112086.513, 382556.114], [112094.132, 382550.249], [112096.24, 382546.217], [112095.4, 382541.147], [112087.63, 382532.417], [112086.711, 382530.686], [112087.001, 382528.457], [112092.794, 382521.212], [112090.52, 382517.928], [112067.613, 382517.459], [112060.881, 382515.112], [112046.488, 382507.086], [112040.586, 382505.608], [112010.456, 382500.89], [112006.76, 382501.743], [112004.843, 382505.495], [112005.648, 382510.718], [111993.761, 382536.118], [111988.458, 382543.209], [111978.569, 382550.539], [111956.31, 382558.54], [111941.626, 382565.216], [111936.274, 382571.621], [111930.247, 382581.564], [111915.824, 382597.49], [111914.846, 382597.573], [111897.076, 382593.206], [111895.099, 382591.578], [111892.85, 382588.034], [111884.278, 382571.525], [111880.834, 382567.6], [111873.877, 382565.449], [111871.456, 382565.681], [111857.409, 382565.228], [111853.744, 382564.554], [111842.902, 382560.472], [111840.009, 382558.96], [111840.929, 382555.715], [111859.968, 382521.223], [111863.057, 382517.606], [111864.618, 382515.892], [111870.261, 382513.812], [111883.451, 382515.978], [111888.882, 382513.867], [111899.968, 382508.326], [111903.804, 382506.115], [111919.222, 382489.069], [111925.874, 382476.118], [111926.554, 382472.57], [111927.905, 382458.807], [111930.111, 382453.282], [111936.444, 382447.823], [111959.176, 382433.244], [111960.057, 382432.497], [111968.508, 382424.338], [111979.366, 382412.318], [111984.57, 382405.909], [111987.22, 382397.088], [111983.367, 382390.193], [111980.488, 382385.907], [111959.636, 382349.726], [111955.508, 382340.89], [111954.445, 382338.01], [111955.952, 382325.71], [111958.54, 382319.403], [111962.411, 382316.274], [111965.017, 382314.632], [111973.465, 382312.659], [111976.802, 382312.573], [111981.784, 382313.51], [111993.804, 382315.335], [111997.883, 382315.946], [111999.818, 382315.704], [112001.82, 382314.065], [112002.108, 382310.589], [112002.773, 382306.659], [112000.937, 382302.816], [112000.989, 382300.315], [111998.035, 382290.714], [111994.348, 382283.628], [111982.218, 382265.783], [111974.422, 382256.53], [111973.105, 382240.203], [111979.265, 382228.559], [111989.575, 382219.877], [112002.321, 382216.532], [112009.924, 382216.617], [112014.135, 382217.574], [112030.826, 382225.753], [112033.974, 382227.101], [112040.089, 382224.026], [112041.901, 382213.2], [112035.548, 382181.863], [112033.761, 382175.737], [112033.594, 382170.795], [112034.58, 382154.558], [112035.116, 382151.331], [112035.139, 382149.348], [112037.377, 382143.614], [112039.225, 382139.279], [112041.841, 382135.931], [112046.774, 382133.55], [112068.288, 382133.305], [112078.427, 382135.11], [112080.382, 382134.639], [112084.251, 382131.026], [112085.203, 382128.443], [112085.438, 382122.275], [112084.729, 382118.871], [112073.301, 382091.954], [112070.863, 382080.529], [112069.198, 382078.507], [112060.651, 382074.718], [112042.505, 382073.369], [112037.964, 382071.132], [112037.405, 382069.253], [112038.928, 382065.132], [112053.175, 382028.099], [112058.12, 382017.583], [112056.792, 382012.965], [112046.938, 381993.425], [112042.685, 381987.302], [112040.342, 381981.42], [112044.576, 381970.099], [112048.55, 381962.499], [112061.83, 381951.046], [112073.885, 381944.236], [112084.576, 381939.704], [112085.277, 381931.579], [112079.366, 381925.39], [112053.442, 381914.058], [112053.667, 381907.812], [112070.524, 381891.07], [112071.302, 381888.494], [112071.237, 381883.953], [112070.743, 381881.026], [112053.428, 381846.526], [112042.321, 381820.465], [112041.24, 381813.544], [112041.066, 381795.161], [112043.728, 381790.319], [112046.146, 381788.375], [112049.621, 381789.089], [112051.915, 381792.281], [112053.722, 381798.738], [112054.425, 381801.408], [112060.792, 381806.982], [112067.019, 381806.867], [112084.135, 381806.627], [112088.258, 381806.501], [112091.673, 381803.338], [112092.609, 381801.266], [112082.015, 381762.18], [112079.999, 381751.203], [112083.113, 381744.904], [112088.99, 381742.89], [112127.314, 381755.966], [112137.152, 381753.174], [112139.475, 381747.229], [112136.944, 381737.962], [112126.271, 381732.232], [112122.871, 381727.752], [112115.184, 381717.626], [112112.707, 381712.169], [112108.396, 381699.358], [112110.371, 381685.763], [112108.481, 381682.65], [112104.647, 381675.613], [112096.24, 381671.483], [112083.483, 381667.324], [112080.586, 381666.927], [112078.222, 381665.838], [112073.35, 381660.457], [112074.268, 381652.847], [112081.759, 381644.463], [112081.109, 381640.207], [112078.167, 381634.517], [112072.826, 381627.362], [112071.365, 381626.136], [112068.303, 381626.813], [112057.703, 381629.723], [112046.77, 381635.257], [112041.907, 381637.926], [112039.461, 381638.517], [112036.328, 381633.534], [112022.336, 381611.743], [112015.942, 381600.486], [112013.193, 381595.311], [112011.232, 381585.923], [112007.707, 381573.146], [112002.994, 381566.047], [111997.958, 381559.08], [111994.738, 381551.957], [111991.755, 381544.044], [111991.476, 381534.059], [111992.56, 381528.37], [111994.269, 381523.243], [111996.87, 381520.776], [112018.159, 381504.814], [112016.307, 381477.96], [111997.647, 381469.063], [111995.699, 381466.076], [111992.174, 381456.728], [111991.361, 381453.489], [111993.214, 381449.897], [111998.477, 381445.087], [112003.415, 381439.57], [112004.55, 381435.477], [112005.945, 381427.908], [112005.01, 381424.34], [112003.584, 381419.487], [112001.058, 381417.713], [111995.046, 381415.738], [111992.613, 381417.048], [111988.655, 381419.69], [111983.942, 381416.903], [111982.575, 381414.071], [111981.368, 381412.031], [111981.066, 381399.401], [111979.694, 381384.455], [111978.754, 381380.123], [111971.121, 381371.24], [111969.432, 381368.082], [111969.381, 381351.564], [111974.28, 381338.747], [111993.22, 381315.692], [112010.59, 381300.884], [112012.61, 381296.888], [112011.116, 381291.937], [112009.28, 381289.131], [112005.94, 381284.112], [112003.525, 381279.196], [111997.111, 381255.85], [111989.872, 381246.524], [111990.469, 381240.114], [111993.061, 381238.431], [111994.768, 381237.43], [112016.529, 381234.599], [112019.629, 381234.74], [112027.882, 381237.899], [112044.819, 381244.285], [112048.029, 381245.845], [112048.432, 381249.013], [112036.862, 381266.552], [112037.487, 381268.651], [112043.119, 381277.609], [112045.107, 381279.793], [112047.614, 381279.774], [112053.541, 381279.996], [112057.715, 381275.644], [112058.515, 381273.339], [112061.139, 381243.118], [112064.32, 381237.604], [112074.117, 381225.192], [112085.581, 381209.229], [112086.634, 381206.101], [112087.359, 381194.462], [112085.845, 381192.37], [112080.345, 381187.174], [112075.285, 381183.59], [112048.117, 381168.173], [112046.783, 381161.271], [112055.372, 381143.542], [112057.176, 381130.529], [112057.179, 381130.504], [112057.271, 381129.843], [112058.405, 381118.85], [112058.48, 381118.31], [112059.225, 381112.945], [112073.255, 381098.228], [112075.856, 381097.017], [112087.406, 381093.214], [112097.754, 381091.573], [112101.752, 381081.265], [112106.704, 381040.319], [112111.628, 381024.328], [112116.876, 381014.003], [112123.218, 381009.948], [112125.624, 381009.72], [112132.412, 381011.818], [112135.674, 381014.175], [112139.112, 381017.134], [112152.397, 381030.229], [112162.834, 381042.388], [112168.667, 381043.061], [112176.932, 381037.838], [112187.186, 381021.473], [112191.03, 381018.275], [112195.931, 381011.446], [112197.668, 381005.816], [112190.127, 380979.883], [112188.758, 380906.748], [112193.555, 380897.766], [112213.257, 380869.091], [112209.286, 380856.16], [112202.008, 380845.173], [112159.703, 380840.457], [112148.417, 380835.538], [112144.927, 380831.233], [112146.925, 380823.015], [112172.903, 380805.888], [112177.806, 380802.281], [112227.274, 380786.851], [112231.369, 380779.658], [112230.88, 380759.672], [112231.971, 380754.842], [112233.08, 380749.933], [112235.514, 380739.157], [112248.788, 380729.327], [112275.243, 380738.345], [112282.151, 380730.689], [112283.755, 380716.394], [112273.916, 380686.243], [112275.621, 380683.105], [112281.855, 380671.632], [112289.119, 380672.382], [112290.453, 380669.589], [112290.007, 380660.58], [112296.708, 380658.383], [112304.387, 380661.241], [112305.559, 380665.821], [112312.535, 380667.835], [112320.275, 380677.701], [112326.275, 380677.933], [112344.587, 380689.245], [112349.401, 380689.536], [112351.589, 380694.104], [112354.787, 380695.739], [112360.161, 380693.711], [112367.735, 380685.613], [112377.825, 380678.055], [112384.629, 380667.979], [112389.253, 380672.75], [112392.305, 380681.499], [112396.592, 380686.212], [112400.182, 380691.308], [112404.165, 380693.895], [112408.166, 380703.096], [112418.9, 380718.344], [112428.425, 380730.189], [112432.293, 380732.025], [112446.777, 380730.69], [112466.638, 380723.365], [112471.13, 380719.298], [112476.58, 380718.078], [112480.36, 380718.141], [112483.548, 380715.059], [112491.759, 380714.104], [112496.528, 380711.907], [112498.58, 380710.026], [112505.278, 380707.851], [112511.044, 380708.658], [112521.292, 380707.927], [112529.141, 380710.231], [112539.491, 380711.22], [112560.15, 380706.885], [112572.706, 380701.352], [112585.181, 380698.341], [112591.36, 380697.543], [112596.234, 380699.847], [112598.883, 380699.903], [112602.208, 380698.523], [112604.245, 380697.319], [112607.01, 380693.404], [112613.91, 380688.712], [112615.746, 380686.567], [112622.686, 380680.928], [112625.018, 380676.662], [112627.944, 380673.391], [112646.012, 380655.422], [112658.132, 380643.153], [112660.497, 380642.404], [112665.987, 380638.522], [112670.741, 380629.889], [112686.873, 380610.079], [112687.406, 380608.894], [112690.046, 380604.644], [112695.493, 380599.716], [112698.218, 380593.954], [112706.835, 380586.017], [112709.91, 380577.897], [112714.517, 380575.855], [112721.936, 380566.028], [112730.125, 380557.33], [112732.971, 380553.009], [112738.115, 380549.43], [112741.859, 380542.81], [112745.916, 380538.286], [112747.347, 380534.085], [112749.314, 380531.037], [112753.236, 380526.517], [112757.307, 380520.448], [112762.481, 380516.053], [112768.174, 380507.623], [112773.862, 380500.958], [112776.362, 380498.915], [112778.536, 380497.519], [112824.769, 380475.957], [112838.866, 380466.673], [112847.782, 380459.942], [112854.112, 380455.883], [112873.088, 380446.414], [112894.459, 380432.126], [112904.131, 380420.772], [112910.28, 380415.406], [112913.952, 380409.303], [112920.633, 380401.359], [112929.359, 380394.821], [112935.761, 380388.966], [112941.929, 380384.16], [112951.66, 380381.552], [112956.899, 380380.592], [112973.341, 380375.905], [112984.806, 380371.501], [112997.837, 380367.904], [113012.85, 380365.07], [113022.361, 380361.208], [113034.484, 380357.767], [113044.439, 380354.175], [113051.159, 380352.763], [113055.186, 380351.042], [113066.28, 380348.962], [113078.59, 380345.044], [113084.688, 380343.936], [113086.283, 380341.49], [113086.908, 380337.69], [113085.765, 380333.401], [113086.154, 380328.01], [113087.442, 380324.104], [113090.554, 380318.978], [113090.673, 380311.475], [113091.928, 380310.989], [113136.528, 380323.579], [113181.752, 380334.921], [113225.317, 380258.641], [113237.629, 380237.364], [113258.959, 380199.851], [113270.398, 380193.629], [113403.475, 380153.697], [113512.778, 380251.048], [113514.166, 380249.473], [113515.912, 380247.493], [113517.234, 380245.993], [113605.211, 380325.083], [113641.985, 380237.116], [113642.906, 380237.487], [113643.886, 380237.881], [113644.08, 380237.399], [113650.249, 380239.883], [113650.548, 380239.353], [113663.663, 380207.44], [113675.987, 380209.773], [113704.897, 380219.456], [113705.927, 380219.965], [113739.046, 380236.346], [113779.066, 380257.369], [113782.727, 380259.292], [113826.483, 380284.6], [113860.108, 380291.265], [113868.231, 380292.875], [113892.496, 380297.685], [113942.183, 380307.939], [113942.587, 380308.024], [114017.63, 380323.749], [114069.763, 380334.673], [114243.101, 380370.996], [114392.41, 380402.283], [114491.925, 380419.016], [114540.547, 380426.846], [114586.127, 380434.186], [114587.012, 380434.329], [114589.86, 380434.773], [114723.116, 380455.538], [114797.486, 380467.334], [114797.993, 380467.414], [114800.616, 380467.816], [114801.503, 380467.952], [114852.836, 380475.816], [114879.236, 380480.107], [114951.432, 380491.108], [114984.871, 380496.203], [115031.621, 380504.096], [115117.4, 380517.834], [115119.004, 380518.148], [115120.483, 380518.38], [115273.505, 380542.423], [115392.425, 380560.861], [115464.645, 380572.317], [115471.787, 380573.45], [115504.182, 380578.589], [115546.75, 380585.341], [115575.083, 380589.364], [115582.792, 380590.458], [115586.046, 380591.231], [115588.336, 380591.775], [115592.435, 380592.748], [115593.424, 380592.983], [115668.944, 380603.971], [115836.403, 380628.921], [115879.628, 380635.361], [115908.096, 380639.602], [115987.533, 380651.137], [115988.65, 380651.299], [115989.315, 380651.375], [116094.222, 380663.339], [116193.813, 380674.451], [116230.16, 380678.528], [116320.697, 380688.685], [116321.702, 380688.8], [116402.367, 380698.029], [116508.375, 380709.884], [116590.346, 380718.954], [116637.116, 380724.008], [116690.001, 380730.047], [116733.364, 380734.809], [116886.624, 380752.771], [116888.958, 380751.622], [116891.188, 380750.524], [116901.527, 380745.432], [116906.594, 380742.937], [116957.346, 380721.166], [116976.388, 380712.797], [117022.613, 380693.785], [117068.804, 380674.69], [117114.908, 380655.382], [117186.096, 380626.349], [117232.457, 380607.674], [117278.786, 380588.924], [117325.215, 380570.415], [117348.35, 380560.836], [117367.113, 380553.697], [117368.34, 380553.23], [117398.771, 380591.307], [117407.788, 380601.755], [117412.174, 380607.312], [117416.673, 380612.391], [117419.518, 380617.467], [117420.867, 380616.433], [117424.557, 380613.604], [117425.804, 380612.788], [117465.811, 380586.607], [117510.674, 380553.899], [117513.36, 380551.941], [117532.132, 380540.029], [117609.238, 380698.001], [117614.139, 380708.541], [117614.203, 380708.68], [117615.948, 380712.44], [117616.665, 380711.223], [117639.817, 380707.437], [117645.603, 380702.882], [117649.932, 380699.475], [117645.296, 380693.468], [117636.049, 380692.189], [117635.769, 380691.992], [117631.666, 380689.102], [117632.592, 380683.758], [117644.04, 380659.829], [117647.83, 380657.985], [117654.436, 380661.438], [117673.767, 380688.434], [117676.495, 380695.984], [117677.158, 380703.606], [117679.648, 380707.309], [117686.229, 380707.172], [117691.258, 380704.322], [117702.993, 380695.362], [117716.092, 380687.757], [117722.023, 380685.198], [117728.804, 380684.143], [117736.26, 380685.471], [117748.634, 380689.648], [117751.149, 380691.129], [117756.917, 380692.529], [117762.422, 380689.696], [117768.866, 380685.842], [117776.135, 380680.392], [117786.019, 380671.313], [117790.549, 380666.91], [117795.641, 380660.47], [117800.933, 380652.799], [117803.974, 380647.511], [117806.563, 380641.66], [117807.376, 380636.371], [117804.261, 380625.265], [117804.774, 380621.208], [117806.525, 380618.069], [117810.654, 380619.357], [117813.106, 380628.902], [117814.558, 380631.614], [117816.522, 380632.411], [117822.928, 380628.652], [117827.269, 380623.317], [117831.323, 380619.55], [117835.277, 380614.737], [117837.629, 380612.298], [117847.901, 380611.887], [117861.314, 380610.905], [117868.921, 380608.859], [117874.614, 380611.909], [117878.68, 380621.101], [117885.762, 380625.327], [117902.914, 380630.413], [117918.817, 380639.516], [117919.944, 380639.503], [117928.338, 380639.403], [117934.681, 380640.16], [117938.56, 380639.419], [117942.964, 380636.111], [117944.641, 380632.224], [117945.679, 380625.117], [117946.08, 380617.326], [117948.607, 380604.488], [117955.263, 380589.67], [117957.015, 380588.752], [117961.731, 380590.152], [117964.258, 380594.418], [117965.785, 380608.037], [117968.475, 380610.322], [117983.023, 380612.837], [117988.206, 380613.816], [117990.07, 380612.745], [117990.508, 380609.526], [117988.706, 380606.7], [117985.055, 380602.688], [117981.712, 380599.014], [117982.763, 380594.82], [117986.441, 380590.466], [118001.168, 380579.037], [118008.586, 380577.637], [118012.097, 380577.775], [118016.781, 380577.959], [118019.622, 380577.194], [118021.161, 380575.27], [118020.998, 380572.276], [118017.97, 380567.479], [118010.153, 380564.525], [118008.661, 380563.961], [118006.171, 380561.635], [118005.696, 380558.198], [118008.524, 380547.654], [118011.339, 380543.048], [118015.005, 380542.726], [118026.941, 380550.702], [118033.997, 380553.954], [118041.555, 380553.769], [118056.431, 380541.632], [118063.488, 380539.941], [118073.771, 380545.23], [118081.654, 380552.762], [118086.095, 380553.68], [118089.986, 380551.056], [118090.8, 380542.493], [118090.074, 380532.23], [118093.89, 380529.156], [118098.094, 380530.967], [118107.415, 380541.785], [118113.296, 380544.634], [118116.436, 380546.364], [118120.065, 380546.107], [118123.631, 380545.101], [118138.317, 380535.996], [118146.775, 380531.086], [118156.872, 380533.477], [118156.596, 380539.103], [118147.988, 380557.745], [118146.775, 380559.161], [118148.088, 380566.436], [118152.543, 380569.978], [118163.178, 380580.554], [118167.857, 380582.542], [118170.884, 380582.993], [118174.262, 380582.406], [118175.175, 380578.623], [118174.7, 380576.369], [118173.912, 380571.531], [118168.619, 380562.742], [118168.882, 380558.928], [118173.211, 380556.175], [118205.266, 380541.317], [118210.133, 380541.156], [118219.755, 380560.327], [118224.309, 380561.679], [118238.82, 380553.294], [118246.002, 380549.962], [118252.408, 380548.618], [118254.272, 380549.624], [118255.123, 380552.288], [118251.057, 380566.873], [118250.206, 380572.467], [118252.746, 380576.088], [118257.075, 380577.754], [118276.592, 380579.484], [118282.347, 380582.64], [118285.888, 380587.485], [118286.289, 380590.697], [118287.99, 380593.441], [118297.987, 380597.917], [118304.706, 380599.003], [118316.955, 380597.273], [118319.044, 380595.043], [118318.481, 380590.672], [118315.003, 380587.083], [118301.178, 380574.832], [118299.814, 380570.189], [118301.59, 380557.101], [118302.316, 380555.612], [118308.735, 380555.99], [118310.336, 380563.508], [118312.914, 380564.925], [118322.473, 380562.359], [118322.1, 380558.385], [118322.057, 380557.923], [118305.619, 380382.607], [118300.987, 380361.141], [118305.277, 380349.968], [118318.94, 380328.865], [118327.138, 380317.454], [118335.272, 380301.636], [118338.979, 380292.368], [118346.02, 380284.004], [118356.886, 380278.095], [118359.305, 380278.06], [118368.15, 380277.932], [118383.277, 380276.39], [118403.5, 380272.844], [118425.545, 380271.038], [118428.052, 380270.501], [118434.284, 380269.167], [118442.0, 380268.733], [118448.093, 380268.39], [118458.31, 380266.742], [118464.327, 380266.085], [118513.514, 380260.718], [118513.709, 380260.697], [118565.05, 380255.102], [118565.741, 380255.027], [118571.342, 380253.315], [118573.234, 380252.736], [118599.169, 380249.777], [118607.746, 380248.228], [118643.958, 380239.482], [118652.109, 380239.396], [118679.011, 380234.108], [118703.372, 380229.32], [118717.128, 380227.842], [118717.295, 380227.824], [118739.564, 380223.979], [118745.771, 380222.906], [118749.766, 380222.215], [118753.253, 380214.489], [118770.202, 380193.485], [118784.401, 380178.167], [118832.586, 380126.184], [118888.232, 380185.778], [118888.467, 380186.029], [118891.06, 380188.806], [118890.893, 380191.919], [118897.026, 380205.974], [118901.597, 380214.169], [118903.895, 380219.417], [118903.936, 380231.537], [118901.256, 380234.73], [118882.457, 380243.589], [118880.294, 380244.622], [118880.93, 380249.776], [118883.314, 380252.507], [118885.901, 380257.141], [118892.199, 380275.62], [118891.225, 380277.966], [118885.133, 380278.565], [118878.56, 380278.618], [118873.385, 380282.78], [118871.226, 380293.162], [118869.948, 380295.428], [118865.502, 380297.707], [118860.174, 380294.612], [118851.727, 380291.963], [118841.838, 380293.458], [118832.702, 380297.81], [118817.752, 380307.911], [118815.05, 380309.168], [118813.017, 380309.846], [118808.884, 380298.571], [118806.706, 380295.242], [118801.199, 380297.51], [118796.381, 380301.031], [118790.499, 380302.723], [118779.866, 380302.229], [118773.367, 380303.985], [118773.037, 380309.287], [118769.743, 380320.969], [118766.775, 380324.916], [118762.616, 380327.331], [118755.373, 380332.344], [118754.658, 380336.094], [118755.982, 380339.616], [118757.968, 380345.698], [118757.514, 380356.741], [118759.613, 380363.017], [118765.827, 380371.837], [118766.117, 380375.624], [118757.116, 380386.038], [118758.997, 380387.571], [118760.306, 380388.638], [118768.984, 380395.708], [118782.776, 380409.78], [118792.967, 380416.164], [118806.716, 380424.962], [118848.344, 380456.011], [118859.9, 380471.402], [118875.553, 380488.988], [118879.944, 380507.115], [118938.462, 380520.145], [118929.842, 380545.389], [119013.466, 380562.071], [119045.899, 380555.416], [119064.207, 380598.696], [119086.885, 380608.317], [119095.359, 380615.661], [119100.098, 380623.327], [119106.739, 380636.485], [119166.38, 380641.74], [119169.653, 380620.116], [119220.059, 380624.544], [119217.629, 380644.787], [119239.907, 380649.602], [119249.57, 380653.17], [119253.853, 380672.367], [119264.779, 380685.484], [119265.047, 380685.806], [119272.34, 380691.438], [119272.895, 380691.682], [119286.688, 380697.744], [119272.655, 380736.035], [119268.416, 380747.937], [119268.175, 380748.615], [119267.454, 380750.641], [119296.069, 380760.863], [119338.368, 380775.482], [119361.839, 380782.0], [119410.326, 380792.097], [119438.864, 380798.594], [119466.343, 380802.051], [119504.581, 380805.586], [119550.018, 380810.227], [119562.956, 380813.251], [119563.54, 380811.331], [119563.682, 380810.864], [119568.981, 380793.446], [119587.502, 380732.556], [119604.379, 380680.523], [119607.093, 380675.737], [119670.556, 380694.816], [119671.148, 380694.994], [119696.596, 380702.644], [119701.431, 380704.551], [119732.824, 380748.261], [119751.205, 380772.373], [119758.963, 380771.269], [119764.92, 380772.594], [119773.346, 380778.406], [119782.089, 380786.476], [119790.765, 380804.37], [119797.826, 380815.822], [119809.066, 380826.08], [119817.603, 380824.261], [119854.459, 380810.355], [119864.614, 380806.523], [119891.625, 380802.254], [119891.862, 380802.217], [119930.039, 380805.175], [119927.824, 380925.921], [119922.473, 380935.897], [119922.237, 380936.337], [119921.369, 380937.956], [119944.953, 380939.266], [119966.19, 380942.163], [120016.096, 380949.115], [120058.193, 380954.579], [120104.294, 380954.78], [120123.397, 380954.058], [120139.878, 380952.315], [120139.623, 380949.78], [120125.498, 380809.256], [120145.791, 380804.413], [120189.792, 380784.56], [120200.339, 380777.646], [120260.723, 380782.733], [120261.479, 380782.797], [120302.608, 380788.832], [120316.686, 380805.335], [120323.859, 380813.798], [120331.444, 380820.788], [120338.107, 380824.101], [120347.636, 380826.63], [120378.08, 380825.588], [120400.414, 380801.74], [120407.16, 380792.613], [120417.453, 380766.209], [120432.526, 380741.392], [120442.546, 380753.695], [120451.498, 380764.209], [120461.524, 380774.26], [120470.051, 380781.929], [120470.176, 380782.042], [120471.901, 380783.594], [120474.982, 380780.085], [120479.642, 380774.778], [120525.289, 380722.794], [120534.065, 380714.039], [120599.831, 380658.212], [120688.059, 380571.478], [120706.618, 380554.917], [120717.69, 380545.027], [120724.959, 380539.478], [120730.684, 380535.935], [120736.991, 380533.01], [120741.725, 380532.337], [120775.94, 380531.947], [120802.367, 380532.588], [120817.663, 380532.986], [120860.584, 380530.492], [120861.425, 380528.001], [120871.674, 380497.63], [120873.698, 380492.808], [120872.642, 380489.276], [120873.039, 380483.253], [120871.652, 380476.92], [120874.978, 380474.323], [120875.149, 380474.19], [120875.644, 380472.485], [120881.52, 380452.245], [120895.283, 380409.495], [120899.469, 380401.831], [120905.483, 380398.828], [120922.249, 380396.126], [120935.554, 380397.905], [120949.645, 380400.959], [120965.131, 380404.89], [120982.012, 380410.602], [121008.039, 380424.471], [121003.381, 380479.272], [121003.3, 380480.226], [121003.289, 380480.358], [121003.148, 380480.654], [121000.261, 380486.723], [121000.672, 380498.409], [121001.9, 380517.071], [121002.069, 380519.637], [121000.629, 380519.847], [120986.219, 380521.946], [120982.194, 380525.284], [120972.426, 380533.386], [120928.115, 380583.155], [120936.647, 380597.96], [120940.999, 380602.947], [120949.047, 380608.874], [120958.509, 380613.356], [120970.234, 380616.389], [120992.074, 380621.475], [121046.077, 380634.051], [121024.161, 380667.85], [121034.898, 380676.946], [121062.142, 380696.593], [121106.728, 380728.745], [121151.223, 380688.181], [121159.35, 380677.913], [121164.526, 380688.606], [121182.755, 380671.796], [121184.061, 380670.591], [121185.281, 380669.465], [121184.735, 380666.477], [121187.756, 380662.997], [121169.324, 380614.466], [121152.186, 380574.397], [121158.842, 380573.192], [121168.107, 380582.014], [121169.526, 380583.366], [121235.066, 380646.137], [121237.585, 380644.612], [121305.966, 380603.216], [121328.063, 380602.848], [121297.682, 380541.03], [121286.289, 380518.032], [121283.737, 380486.781], [121283.685, 380486.138], [121283.547, 380484.444], [121270.938, 380486.395], [121230.512, 380492.914], [121215.337, 380494.91], [121200.315, 380495.482], [121174.557, 380494.266], [121131.914, 380490.738], [121129.178, 380490.512], [121123.113, 380490.01], [121122.11, 380486.905], [121128.602, 380474.158], [121134.246, 380457.784], [121136.742, 380450.313], [121138.76, 380439.117], [121138.93, 380422.271], [121137.129, 380410.208], [121117.881, 380314.754], [121113.113, 380300.299], [121108.888, 380292.898], [121096.741, 380278.935], [121106.655, 380277.461], [121117.397, 380275.863], [121207.183, 380262.509], [121239.314, 380257.47], [121245.477, 380255.82], [121292.474, 380235.135], [121293.273, 380237.314], [121293.615, 380238.566], [121312.31, 380307.019], [121312.535, 380307.843], [121327.992, 380364.44], [121328.031, 380364.583], [121330.559, 380373.838], [121342.241, 380410.859], [121345.636, 380419.569], [121345.724, 380419.795], [121347.333, 380423.925], [121355.417, 380440.185], [121364.352, 380455.532], [121367.749, 380463.204], [121372.534, 380474.404], [121372.593, 380474.543], [121373.183, 380475.923], [121407.836, 380449.764], [121444.471, 380418.274], [121443.823, 380416.61], [121443.687, 380416.261], [121433.52, 380390.148], [121364.441, 380210.606], [121362.219, 380204.985], [121362.084, 380204.645], [121361.206, 380202.424], [121376.971, 380195.652], [121388.038, 380192.229], [121396.861, 380189.779], [121443.905, 380176.712], [121449.44, 380177.279], [121453.603, 380181.679], [121470.471, 380204.906], [121475.696, 380203.628], [121487.082, 380200.843], [121500.404, 380197.585], [121499.929, 380195.643], [121500.691, 380186.485], [121505.04, 380172.599], [121512.141, 380153.833], [121517.325, 380141.619], [121524.734, 380110.511], [121524.519, 380094.453], [121517.139, 380062.699], [121515.313, 380050.565], [121556.8, 380093.855], [121579.295, 380071.622], [121631.576, 380023.239], [121651.658, 380005.279], [121669.794, 379991.619], [121704.832, 379971.001], [121712.499, 379965.392], [121713.153, 379964.918], [121759.253, 379931.536], [121767.535, 379926.535], [121772.884, 379924.191], [121774.444, 379923.508], [121775.115, 379923.065], [121783.954, 379919.312], [121784.23, 379916.605], [121779.134, 379900.831], [121769.707, 379870.632], [121753.243, 379812.268], [121733.128, 379743.271], [121696.48, 379605.51], [121696.025, 379603.8], [121696.651, 379603.941], [121702.469, 379595.46], [121702.337, 379594.75], [121701.756, 379591.633], [121701.648, 379591.054], [121700.746, 379586.207], [121706.95, 379581.367], [121713.409, 379574.226], [121776.315, 379492.43], [121825.583, 379428.162], [121831.214, 379418.904], [121832.392, 379411.649], [121831.488, 379403.271], [121829.182, 379393.333], [121823.601, 379378.226], [121811.928, 379355.342], [121805.04, 379343.411], [121808.989, 379341.47], [121811.167, 379340.4], [121825.453, 379333.38], [121889.043, 379309.965], [121900.379, 379306.889], [121947.23, 379289.152], [121948.175, 379288.794], [122003.144, 379267.983], [122075.549, 379240.571], [122183.962, 379200.996], [122336.412, 379145.378], [122337.608, 379140.459], [122334.617, 379133.485], [122281.756, 379051.621], [122250.033, 379002.369], [122218.778, 378949.915], [122217.18, 378947.232], [122257.143, 378928.524], [122309.54, 378908.32], [122356.352, 378891.357], [122356.4, 378890.352], [122357.954, 378857.772], [122368.997, 378870.934], [122370.68, 378872.94], [122376.481, 378879.886], [122378.902, 378882.785], [122380.78, 378885.033], [122391.1, 378897.39], [122411.69, 378898.76], [122422.28, 378900.53], [122544.406, 378910.151], [122572.19, 378912.34], [122694.002, 378919.86], [122695.78, 378919.97], [122714.45, 378924.78], [122717.931, 378920.684], [122721.18, 378916.86], [122784.02, 378843.15], [122786.17, 378834.44], [122808.47, 378743.81], [122806.564, 378741.057], [122805.02, 378738.826], [122769.416, 378730.535], [122765.218, 378729.558], [122736.55, 378722.882], [122729.653, 378722.93], [122729.554, 378722.931], [122673.974, 378723.324], [122654.69, 378723.803], [122653.761, 378723.826], [122593.469, 378725.323], [122576.059, 378725.756], [122498.246, 378727.693], [122497.525, 378727.734], [122494.278, 378727.916], [122459.346, 378729.875], [122429.791, 378731.533], [122429.774, 378731.534], [122381.017, 378734.449], [122364.23, 378735.452], [122345.022, 378736.547], [122333.066, 378737.228], [122323.216, 378727.528], [122318.034, 378722.425], [122275.494, 378680.533], [122271.795, 378676.89], [122268.7, 378673.799], [122163.654, 378570.352], [122056.435, 378542.587], [122116.325, 378523.944], [122237.534, 378484.876], [122278.176, 378471.797], [122283.283, 378470.153], [122294.155, 378466.654], [122296.015, 378466.056], [122338.955, 378452.266], [122396.042, 378433.933], [122397.391, 378433.5], [122439.66, 378419.924], [122477.208, 378407.865], [122478.678, 378407.393], [122549.05, 378385.181], [122550.306, 378384.784], [122627.448, 378415.364], [122629.161, 378416.043], [122629.522, 378416.186], [122706.311, 378446.585], [122707.506, 378447.058], [122717.921, 378451.181], [122789.498, 378479.876], [122799.667, 378483.953], [122806.433, 378486.665], [122808.588, 378487.529], [122842.666, 378501.19], [123031.366, 378576.623], [122968.434, 378623.862], [122851.876, 378711.271], [122850.578, 378712.223], [122850.016, 378712.627], [122838.178, 378742.827], [122835.333, 378750.084], [122828.563, 378769.08], [122822.848, 378788.414], [122805.61, 378838.135], [122802.431, 378881.903], [122799.147, 378927.109], [122796.192, 378944.932], [122795.312, 378950.236], [122805.833, 378953.864], [122865.75, 378974.263], [122885.574, 378982.574], [122919.341, 378998.62], [122954.222, 379018.022], [122970.946, 379027.124], [122989.515, 379036.513], [123013.521, 379047.704], [123037.424, 379054.523], [123037.8, 379051.436], [123046.554, 378979.551], [123047.958, 378977.886], [123058.752, 378886.738], [123089.449, 378627.518], [123093.423, 378630.91], [123106.492, 378641.359], [123110.081, 378644.229], [123188.769, 378738.262], [123259.662, 378822.946], [123261.416, 378825.082], [123367.261, 378954.0], [123445.954, 379049.532], [123461.536, 379068.449], [123507.151, 379124.219], [123550.472, 379177.095], [123648.011, 379296.066]], [[122625.19, 383780.81], [122641.702, 383771.379], [122648.124, 383767.711], [122650.14, 383766.56], [122658.96, 383785.51], [122659.398, 383786.585], [122660.578, 383789.476], [122660.91, 383790.29], [122665.02, 383800.04], [122670.64, 383812.3], [122680.088, 383827.721], [122683.16, 383832.71], [122681.91, 383834.18], [122675.57, 383841.91], [122671.14, 383847.5], [122642.26, 383883.88], [122635.62, 383892.22], [122634.391, 383893.761], [122627.27, 383902.69], [122619.12, 383911.68], [122613.54, 383916.6], [122606.94, 383921.18], [122609.374, 383927.289], [122621.08, 383956.95], [122579.97, 384070.2], [122598.18, 384074.06], [122626.87, 384077.75], [122606.64, 384127.54], [122593.41, 384119.66], [122567.803, 384147.961], [122567.65, 384148.13], [122552.92, 384164.41], [122545.26, 384172.878], [122540.61, 384178.02], [122520.36, 384123.79], [122518.1, 384118.36], [122513.24, 384110.56], [122510.875, 384112.37], [122471.83, 384142.25], [122460.4, 384151.598], [122455.64, 384155.49], [122442.97, 384168.16], [122437.11, 384173.34], [122428.91, 384175.25], [122424.629, 384176.322], [122402.67, 384181.82], [122422.86, 384236.61], [122433.77, 384245.61], [122469.79, 384301.09], [122481.83, 384308.99], [122490.795, 384296.307], [122500.031, 384283.241], [122507.449, 384272.744], [122512.168, 384266.067], [122519.117, 384256.237], [122530.482, 384240.158], [122541.818, 384224.121], [122542.004, 384223.858], [122558.707, 384200.227], [122559.01, 384199.8], [122580.695, 384221.1], [122581.57, 384221.96], [122585.44, 384225.73], [122590.89, 384229.195], [122591.37, 384229.5], [122615.37, 384247.263], [122624.89, 384254.31], [122643.16, 384267.43], [122659.05, 384282.84], [122695.64, 384323.78], [122714.47, 384343.48], [122732.76, 384356.95], [122800.62, 384238.08], [122798.278, 384237.114], [122797.536, 384236.808], [122793.77, 384235.255], [122780.268, 384229.686], [122768.86, 384224.98], [122772.63, 384219.29], [122686.157, 384179.839], [122674.19, 384174.38], [122673.926, 384174.264], [122666.24, 384170.89], [122730.86, 384132.78], [122761.6, 384115.39], [122783.73, 384103.26], [122819.8, 384084.06], [122805.334, 384083.561], [122804.14, 384083.52], [122787.85, 384082.96], [122786.293, 384082.916], [122735.86, 384081.51], [122778.82, 383969.06], [122806.62, 383987.52], [122817.91, 383972.43], [122843.503, 383994.177], [122870.971, 384017.518], [122894.485, 384037.48], [122898.9, 384041.25], [122925.03, 384025.85], [122976.09, 383995.63], [123002.823, 383979.96], [123017.748, 383971.211], [123063.83, 383944.2], [123071.31, 383940.41], [123079.11, 383936.54], [123073.045, 383932.996], [123063.005, 383927.127], [123061.467, 383926.228], [123050.758, 383919.97], [123032.689, 383909.41], [122987.278, 383882.872], [122934.148, 383851.823], [122921.07, 383844.18], [122936.837, 383820.771], [122941.075, 383814.478], [122954.64, 383794.338], [122966.79, 383776.3], [122971.47, 383778.68], [122972.926, 383774.946], [122992.225, 383725.443], [122994.18, 383720.43], [122953.53, 383723.15], [122952.5, 383717.66], [122943.54, 383669.87], [122965.49, 383680.59], [122971.23, 383680.12], [122974.08, 383665.94], [123018.26, 383570.19], [123029.35, 383537.78], [122995.59, 383515.97], [123001.28, 383511.46], [123024.62, 383476.05], [123035.44, 383458.08], [123038.489, 383453.78], [123044.32, 383445.557], [123054.94, 383430.58], [123068.364, 383410.028], [123070.405, 383406.904], [123070.415, 383406.888], [123082.12, 383388.969], [123092.61, 383372.91], [123098.979, 383389.93], [123108.717, 383415.951], [123108.738, 383416.007], [123115.774, 383434.812], [123119.902, 383445.843], [123119.908, 383445.858], [123119.95, 383445.97], [123124.88, 383459.32], [123128.668, 383466.001], [123128.688, 383466.036], [123132.373, 383472.536], [123132.396, 383472.576], [123135.381, 383477.842], [123135.469, 383477.997], [123138.389, 383483.148], [123138.464, 383483.28], [123142.779, 383490.892], [123143.98, 383493.01], [123147.651, 383497.177], [123147.685, 383497.216], [123153.919, 383504.291], [123153.979, 383504.359], [123157.6, 383508.47], [123157.881, 383508.766], [123157.975, 383508.865], [123164.461, 383515.694], [123164.523, 383515.759], [123172.132, 383523.772], [123172.149, 383523.789], [123177.712, 383529.647], [123177.798, 383529.738], [123181.851, 383534.006], [123181.896, 383534.053], [123186.08, 383538.459], [123186.104, 383538.484], [123191.01, 383543.65], [123179.911, 383563.513], [123179.894, 383563.543], [123173.948, 383574.183], [123167.148, 383586.352], [123167.117, 383586.407], [123160.962, 383597.421], [123151.24, 383614.82], [123147.308, 383622.08], [123135.508, 383643.869], [123133.19, 383648.15], [123131.371, 383659.085], [123128.872, 383674.103], [123126.371, 383689.132], [123122.979, 383709.521], [123122.67, 383711.38], [123126.44, 383711.66], [123131.34, 383712.42], [123139.52, 383714.03], [123142.38, 383714.84], [123146.24, 383716.14], [123150.93, 383717.96], [123163.04, 383723.02], [123167.57, 383725.14], [123172.38, 383727.54], [123178.17, 383731.04], [123206.94, 383750.85], [123206.844, 383754.478], [123205.51, 383804.66], [123205.7, 383808.71], [123210.109, 383808.426], [123245.3, 383806.16], [123245.268, 383813.727], [123245.262, 383815.281], [123245.21, 383822.533], [123246.85, 383822.8], [123248.71, 383819.33], [123256.64, 383825.2], [123273.06, 383837.26], [123274.061, 383837.995], [123278.834, 383841.502], [123283.16, 383844.68], [123280.28, 383847.37], [123277.68, 383850.33], [123276.73, 383851.58], [123282.042, 383854.13], [123284.012, 383855.076], [123285.295, 383855.697], [123297.99, 383861.8], [123316.92, 383869.3], [123327.12, 383872.79], [123351.682, 383882.6], [123354.41, 383883.69], [123362.621, 383887.442], [123369.9, 383890.78], [123371.693, 383891.537], [123373.572, 383892.339], [123373.88, 383892.47], [123375.03, 383893.12], [123379.476, 383886.155], [123380.66, 383884.3], [123389.624, 383886.309], [123411.929, 383891.308], [123431.17, 383895.62], [123431.623, 383893.082], [123434.8, 383875.29], [123470.11, 383882.361], [123473.35, 383883.01], [123471.1, 383897.04], [123456.12, 383978.05], [123455.24, 383980.21], [123451.29, 383987.11], [123450.737, 383987.857], [123441.71, 384000.06], [123443.9, 384003.91], [123452.05, 384019.11], [123455.74, 384026.02], [123476.64, 384065.25], [123484.55, 384079.57], [123497.29, 384101.75], [123510.8, 384124.68], [123526.41, 384150.15], [123536.58, 384164.95], [123543.75, 384174.49], [123549.01, 384180.59], [123553.49, 384185.8], [123571.16, 384204.59], [123601.76, 384236.75], [123606.76, 384232.533], [123607.12, 384232.23], [123607.116, 384231.966], [123607.01, 384225.82], [123608.561, 384223.256], [123614.64, 384213.21], [123618.56, 384205.8], [123622.04, 384198.14], [123625.07, 384190.15], [123626.623, 384185.074], [123626.64, 384185.02], [123627.405, 384182.03], [123642.116, 384124.522], [123642.193, 384124.221], [123644.35, 384115.79], [123598.03, 384087.11], [123577.56, 384074.34], [123575.32, 384072.93], [123576.57, 384068.863], [123576.618, 384068.708], [123576.896, 384067.805], [123576.921, 384067.725], [123581.963, 384051.325], [123595.56, 384007.1], [123601.427, 384008.422], [123608.841, 384010.093], [123617.146, 384011.965], [123630.458, 384014.965], [123645.169, 384018.281], [123667.153, 384023.214], [123682.7, 384026.74], [123684.362, 384020.234], [123686.45, 384012.06], [123693.37, 384018.33], [123713.18, 384030.63], [123725.66, 384037.36], [123736.89, 384041.23], [123736.959, 384041.251], [123754.38, 384046.64], [123779.43, 384054.39], [123779.613, 384053.532], [123790.066, 384004.637], [123791.165, 383999.497], [123798.338, 383965.945], [123809.4, 383914.2], [123841.96, 383926.76], [123845.279, 383907.42], [123850.662, 383876.05], [123850.665, 383876.033], [123853.356, 383860.354], [123853.362, 383860.317], [123855.221, 383849.485], [123855.227, 383849.451], [123858.98, 383827.584], [123862.832, 383805.14], [123866.391, 383784.4], [123874.443, 383737.476], [123875.33, 383732.31], [123830.83, 383735.04], [123830.019, 383740.182], [123824.138, 383777.351], [123824.129, 383777.411], [123821.789, 383792.2], [123821.784, 383792.232], [123819.445, 383807.016], [123819.443, 383807.029], [123817.101, 383821.833], [123814.757, 383836.65], [123812.413, 383851.463], [123810.078, 383866.222], [123810.068, 383866.283], [123807.724, 383881.099], [123807.721, 383881.116], [123804.638, 383900.605], [123804.63, 383900.655], [123802.9, 383911.59], [123798.77, 383909.94], [123782.4, 383903.85], [123757.95, 383896.48], [123760.489, 383885.939], [123760.497, 383885.904], [123762.792, 383876.374], [123764.965, 383867.354], [123767.138, 383858.332], [123769.309, 383849.318], [123771.484, 383840.285], [123773.66, 383831.254], [123775.833, 383822.231], [123778.047, 383813.038], [123779.94, 383805.178], [123780.167, 383804.237], [123781.04, 383800.61], [123780.768, 383796.703], [123780.466, 383792.363], [123779.421, 383777.338], [123777.056, 383743.329], [123776.71, 383738.36], [123756.13, 383739.53], [123747.85, 383740.14], [123737.69, 383741.23], [123729.53, 383742.45], [123709.045, 383746.28], [123662.24, 383755.03], [123655.39, 383756.305], [123651.23, 383757.08], [123642.24, 383758.41], [123630.98, 383759.76], [123616.11, 383760.98], [123534.29, 383765.3], [123510.12, 383766.29], [123510.051, 383762.033], [123509.91, 383753.29], [123510.64, 383734.07], [123504.35, 383733.78], [123493.678, 383698.897], [123480.277, 383655.091], [123472.49, 383629.64], [123481.098, 383629.442], [123496.788, 383629.082], [123508.676, 383628.809], [123508.992, 383628.802], [123509.037, 383628.801], [123533.684, 383628.235], [123553.08, 383627.79], [123553.061, 383626.118], [123552.489, 383576.542], [123552.16, 383548.073], [123551.4, 383482.08], [123658.34, 383493.15], [123657.9, 383487.21], [123654.46, 383440.8], [123529.79, 383437.39], [123532.75, 383397.43], [123534.82, 383369.63], [123651.83, 383374.15], [123652.673, 383360.623], [123657.4, 383284.72], [123838.87, 383305.51], [123826.68, 383381.74], [123822.19, 383453.31], [123898.44, 383467.23], [123904.88, 383439.52], [123930.899, 383308.379], [123931.03, 383307.72], [123921.67, 383293.7], [123866.87, 383211.61], [123868.161, 383207.449], [123869.31, 383203.747], [123902.44, 383096.99], [123855.52, 383087.36], [123854.23, 383090.56], [123824.55, 383082.24], [123824.21, 383085.24], [123787.94, 383071.98], [123782.106, 383076.771], [123782.09, 383076.784], [123777.15, 383080.84], [123753.403, 383047.602], [123739.67, 383028.38], [123701.58, 382978.57], [123693.78, 382966.9], [123683.01, 382950.78], [123662.24, 382917.43], [123642.29, 382888.06], [123648.31, 382882.07], [123653.31, 382875.29], [123656.0, 382871.62], [123659.94, 382866.58], [123664.65, 382862.275], [123664.7, 382862.23], [123670.64, 382858.5], [123676.88, 382856.12], [123684.53, 382854.51], [123689.04, 382854.03], [123693.76, 382853.88], [123703.17, 382854.32], [123709.86, 382855.03], [123718.07, 382856.25], [123729.78, 382858.82], [123809.64, 382878.2], [123817.7, 382879.2], [123824.19, 382879.56], [123836.52, 382878.93], [123858.791, 382877.278], [123898.67, 382874.32], [123897.769, 382869.4], [123897.608, 382868.52], [123896.331, 382861.548], [123880.52, 382775.2], [123865.54, 382773.89], [123861.328, 382671.381], [123861.07, 382665.09], [123888.35, 382671.66], [123891.44, 382658.913], [123891.813, 382657.376], [123907.23, 382593.78], [123857.192, 382579.249], [123857.156, 382579.239], [123853.409, 382578.151], [123848.38, 382576.69], [123850.246, 382572.066], [123879.72, 382499.03], [123778.78, 382457.78], [123763.075, 382447.071], [123734.14, 382427.34], [123737.09, 382423.31], [123632.34, 382358.43], [123620.32, 382359.14], [123619.03, 382360.66], [123604.251, 382378.126], [123593.342, 382391.018], [123544.333, 382448.939], [123544.106, 382449.207], [123544.098, 382449.217], [123544.075, 382449.244], [123544.067, 382449.253], [123544.059, 382449.262], [123543.889, 382449.463], [123530.818, 382464.911], [123517.806, 382480.29], [123513.33, 382485.58], [123510.18, 382485.15], [123504.56, 382485.24], [123493.23, 382484.47], [123489.02, 382484.33], [123480.89, 382483.73], [123475.15, 382482.84], [123469.32, 382481.65], [123465.36, 382480.72], [123465.049, 382482.418], [123455.79, 382532.65], [123420.79, 382521.353], [123380.744, 382508.427], [123368.106, 382504.348], [123324.852, 382490.387], [123279.89, 382475.874], [123278.547, 382475.44], [123278.041, 382475.277], [123270.74, 382472.92], [123263.45, 382457.37], [123255.2, 382429.55], [123246.15, 382417.45], [123237.652, 382428.47], [123162.89, 382525.42], [123150.701, 382511.1], [123146.189, 382505.8], [123135.353, 382493.069], [123128.05, 382484.49], [123124.56, 382480.39], [123122.64, 382478.13], [123101.85, 382496.88], [123084.94, 382512.27], [123072.47, 382528.67], [123063.92, 382541.88], [123055.65, 382557.68], [123047.46, 382574.25], [123044.38, 382579.87], [123034.15, 382610.23], [123025.33, 382635.49], [123022.15, 382643.75], [123018.34, 382652.75], [123012.31, 382665.18], [122987.45, 382715.76], [122975.92, 382739.31], [122971.8, 382748.17], [122970.6, 382752.01], [122969.72, 382757.18], [122969.446, 382759.232], [122969.28, 382760.48], [122969.26, 382765.69], [122969.85, 382769.11], [122970.83, 382772.35], [122972.46, 382776.73], [122974.6, 382781.95], [122990.39, 382821.66], [122981.371, 382813.296], [122981.17, 382813.11], [122975.22, 382809.28], [122969.27, 382806.14], [122964.5, 382804.14], [122958.2, 382802.08], [122952.34, 382800.78], [122945.74, 382800.34], [122934.93, 382800.17], [122934.274, 382804.764], [122930.297, 382832.638], [122929.91, 382835.35], [122928.5, 382852.12], [122901.392, 382849.632], [122888.18, 382848.42], [122876.96, 382864.91], [122857.151, 382854.207], [122855.99, 382853.58], [122862.62, 382837.0], [122874.898, 382806.244], [122876.6, 382801.98], [122832.39, 382803.85], [122803.91, 382807.42], [122753.54, 382816.17], [122702.8, 382828.09], [122689.54, 382829.13], [122690.706, 382834.065], [122692.49, 382841.61], [122691.18, 382858.32], [122680.29, 382876.87], [122668.044, 382880.368], [122646.713, 382886.46], [122624.473, 382892.812], [122603.092, 382898.92], [122581.968, 382904.955], [122560.216, 382911.168], [122559.972, 382911.238], [122544.21, 382915.74], [122538.739, 382917.439], [122511.17, 382926.0], [122511.64, 382927.11], [122449.54, 382958.81], [122432.19, 382969.8], [122410.8, 382981.55], [122394.83, 382995.0], [122393.449, 382996.3], [122382.43, 383006.67], [122372.31, 383006.08], [122321.998, 382940.233], [122319.07, 382936.4], [122231.4, 382974.69], [122222.193, 382983.794], [122221.949, 382984.035], [122221.501, 382984.477], [122213.62, 382992.27], [122208.697, 382994.636], [122206.4, 382995.74], [122172.42, 383018.909], [122170.336, 383020.33], [122166.39, 383023.02], [122172.67, 383026.83], [122186.04, 383033.12], [122310.35, 383081.1], [122312.995, 383077.965], [122363.86, 383017.69], [122370.62, 383010.61], [122378.0, 383013.39], [122401.73, 383039.79], [122401.945, 383040.051], [122414.238, 383054.952], [122456.18, 383105.79], [122477.789, 383136.158], [122483.22, 383143.79], [122521.31, 383125.19], [122528.12, 383135.8], [122555.99, 383123.27], [122598.16, 383191.69], [122504.263, 383320.267], [122501.07, 383324.64], [122510.799, 383337.815], [122511.91, 383339.32], [122587.085, 383418.087], [122606.52, 383438.45], [122603.003, 383441.41], [122560.56, 383477.14], [122554.69, 383469.04], [122531.09, 383486.46], [122600.3, 383581.91], [122583.3, 383585.916], [122581.402, 383586.363], [122572.894, 383588.368], [122562.515, 383590.814], [122562.49, 383590.82], [122479.91, 383608.61], [122479.607, 383608.67], [122460.67, 383612.43], [122550.843, 383700.084], [122550.89, 383700.13], [122562.253, 383712.469], [122625.19, 383780.81]], [[123902.44, 383096.99], [123961.979, 383110.439], [123964.86, 383111.09], [123964.82, 383112.35], [123967.619, 383112.991], [124056.91, 383133.44], [124061.749, 383115.141], [124062.418, 383112.611], [124072.948, 383072.796], [124073.458, 383070.869], [124081.62, 383040.01], [124083.34, 383026.39], [124095.314, 382984.121], [124095.36, 382983.96], [124077.31, 382978.33], [124031.38, 382958.82], [124018.542, 382953.001], [124012.369, 382950.203], [124009.9, 382949.084], [124009.201, 382948.767], [123972.87, 382932.3], [123972.016, 382943.402], [123971.75, 382946.86], [123970.18, 382967.64], [123968.95, 382999.98], [123954.23, 382998.52], [123932.04, 382999.77], [123926.15, 383010.4], [123917.26, 383026.41], [123902.44, 383096.99]], [[122395.38, 383920.22], [122390.545, 383978.75], [122398.812, 383987.224], [122406.32, 383994.92], [122434.49, 383985.98], [122441.41, 383983.65], [122438.913, 383975.006], [122435.99, 383964.88], [122432.743, 383958.512], [122423.6, 383940.58], [122418.05, 383939.62], [122417.63, 383936.42], [122413.7, 383935.71], [122416.41, 383920.76], [122395.38, 383920.22]], [[123977.34, 383361.24], [123976.393, 383366.049], [123959.43, 383452.23], [124064.24, 383476.0], [124056.285, 383507.559], [124049.94, 383532.73], [124119.464, 383544.966], [124120.509, 383545.15], [124123.92, 383545.75], [124098.52, 383500.29], [124083.25, 383477.31], [124076.008, 383467.893], [124069.4, 383459.3], [124057.79, 383446.66], [124039.41, 383427.69], [124034.65, 383422.32], [124035.403, 383419.279], [124035.779, 383417.76], [124038.443, 383406.996], [124060.599, 383317.485], [124060.62, 383317.4], [124001.2, 383300.34], [123997.895, 383309.825], [123981.464, 383356.987], [123980.151, 383360.755], [123979.25, 383363.34], [123977.34, 383361.24]], [[124154.68, 384359.31], [124145.5, 384356.79], [124130.72, 384352.79], [124026.38, 384324.93], [124015.14, 384321.63], [124008.65, 384319.44], [124009.235, 384313.08], [124009.24, 384313.03], [124010.232, 384302.319], [124014.919, 384251.739], [124015.8, 384242.23], [124013.562, 384242.479], [124007.71, 384243.13], [123990.193, 384240.771], [123960.04, 384236.71], [123949.057, 384269.06], [123945.04, 384280.8], [123944.775, 384281.581], [123943.11, 384286.49], [123925.88, 384277.28], [123892.26, 384259.34], [123894.03, 384253.16], [123897.373, 384241.522], [123908.825, 384201.654], [123921.161, 384158.708], [123924.404, 384147.479], [123936.35, 384105.83], [123919.81, 384103.11], [123909.068, 384140.499], [123905.538, 384152.783], [123893.756, 384193.791], [123893.715, 384193.935], [123893.708, 384193.958], [123882.352, 384233.482], [123878.98, 384245.22], [123877.23, 384251.32], [123847.56, 384235.49], [123846.753, 384241.634], [123846.664, 384242.306], [123841.721, 384279.973], [123836.09, 384322.88], [123750.573, 384305.146], [123749.056, 384304.831], [123692.408, 384293.083], [123684.29, 384291.4], [123663.571, 384295.906], [123663.185, 384295.99], [123650.31, 384298.79], [123659.93, 384314.53], [123665.58, 384324.39], [123674.33, 384340.23], [123680.098, 384350.828], [123688.96, 384367.11], [123678.531, 384366.907], [123631.65, 384365.96], [123610.61, 384365.145], [123610.539, 384365.142], [123582.934, 384364.074], [123582.801, 384364.069], [123582.417, 384364.054], [123553.759, 384362.944], [123551.368, 384362.851], [123546.346, 384362.657], [123543.608, 384362.552], [123543.592, 384364.77], [123543.57, 384367.82], [123541.54, 384374.41], [123537.43, 384384.1], [123535.346, 384388.444], [123524.568, 384410.915], [123516.19, 384428.38], [123513.441, 384433.765], [123502.109, 384455.961], [123490.714, 384478.281], [123479.421, 384500.402], [123468.056, 384522.663], [123456.719, 384544.87], [123445.387, 384567.068], [123432.7, 384591.92], [123433.236, 384592.099], [123434.606, 384592.555], [123451.901, 384598.322], [123467.43, 384603.5], [123468.171, 384603.678], [123487.671, 384608.352], [123490.71, 384609.08], [123504.469, 384611.096], [123508.861, 384611.74], [123527.281, 384614.439], [123539.119, 384616.174], [123589.04, 384623.49], [123630.807, 384631.631], [123632.46, 384631.95], [123639.829, 384632.071], [123721.32, 384633.41], [123724.52, 384654.82], [123766.92, 384652.08], [123771.06, 384686.93], [123857.379, 384684.032], [123872.32, 384683.53], [123875.14, 384687.14], [123878.01, 384690.58], [123895.775, 384690.815], [123989.36, 384692.05], [123988.682, 384704.751], [123987.41, 384728.55], [124018.883, 384729.159], [124018.96, 384729.16], [124019.897, 384729.184], [124122.981, 384731.858], [124123.033, 384731.859], [124125.78, 384731.93], [124125.95, 384730.05], [124130.47, 384680.2], [124133.278, 384680.72], [124158.811, 384685.448], [124159.317, 384685.542], [124187.748, 384690.806], [124187.787, 384690.813], [124246.613, 384701.705], [124261.76, 384704.51], [124266.901, 384705.537], [124296.24, 384711.398], [124297.4, 384711.63], [124359.94, 384724.36], [124371.34, 384724.29], [124377.13, 384721.79], [124372.0, 384741.77], [124426.2, 384761.45], [124444.24, 384701.78], [124494.56, 384745.61], [124519.14, 384767.02], [124518.36, 384769.67], [124533.38, 384782.01], [124551.12, 384791.13], [124579.292, 384797.57], [124589.13, 384799.82], [124653.38, 384820.27], [124636.9, 384882.02], [124607.74, 384874.82], [124582.15, 384963.16], [124578.999, 384983.573], [124571.91, 385029.49], [124712.157, 385049.284], [124713.62, 385049.49], [124716.31, 384985.53], [124719.28, 384932.99], [124722.1, 384919.33], [124726.78, 384908.39], [124730.25, 384902.89], [124731.48, 384901.25], [124743.04, 384891.21], [124762.1, 384873.39], [124773.068, 384860.878], [124775.39, 384858.23], [124786.88, 384843.62], [124794.57, 384831.82], [124801.81, 384817.72], [124697.5, 384752.54], [124733.56, 384693.01], [124742.35, 384697.12], [124770.939, 384659.485], [124772.66, 384657.22], [124775.99, 384652.84], [124755.39, 384638.43], [124697.9, 384599.22], [124685.7, 384591.45], [124679.55, 384587.84], [124669.14, 384581.91], [124658.34, 384576.53], [124652.914, 384574.22], [124646.57, 384571.52], [124635.2, 384567.53], [124625.95, 384564.9], [124571.28, 384550.98], [124503.21, 384533.6], [124493.66, 384531.1], [124488.1, 384529.42], [124489.076, 384522.822], [124492.54, 384499.39], [124482.25, 384439.32], [124477.9, 384436.18], [124474.069, 384352.848], [124473.95, 384350.25], [124471.998, 384348.307], [124464.93, 384341.27], [124430.577, 384343.067], [124388.328, 384345.276], [124355.73, 384346.981], [124355.36, 384347.0], [124351.88, 384349.37], [124342.25, 384356.36], [124333.73, 384361.33], [124327.54, 384363.23], [124314.96, 384365.26], [124303.43, 384366.47], [124290.99, 384366.95], [124275.7, 384369.93], [124267.08, 384374.11], [124260.493, 384378.764], [124260.453, 384378.792], [124258.97, 384379.84], [124253.325, 384384.514], [124252.894, 384384.871], [124250.729, 384386.664], [124243.38, 384392.75], [124338.071, 384438.901], [124346.05, 384442.79], [124355.6, 384447.42], [124353.956, 384453.22], [124329.97, 384537.85], [124322.142, 384535.731], [124318.432, 384534.727], [124297.061, 384528.943], [124274.81, 384522.92], [124227.628, 384508.85], [124227.609, 384508.844], [124192.409, 384498.348], [124191.98, 384498.22], [124178.102, 384495.27], [124158.58, 384491.12], [124155.126, 384374.4], [124154.919, 384367.39], [124154.846, 384364.932], [124154.68, 384359.31]], [[124525.81, 385192.81], [124545.83, 385197.32], [124583.98, 385205.91], [124597.38, 385116.03], [124558.76, 385110.35], [124566.43, 385058.94], [124543.6, 385056.38], [124525.81, 385192.81]], [[123588.101, 380114.301], [123593.58, 380115.25], [123625.71, 379758.02], [123632.397, 379677.015], [123632.59, 379674.68], [123629.78, 379674.57], [123627.211, 379674.465], [123457.08, 379667.53], [123396.725, 379665.149], [123347.85, 379663.22], [123343.484, 379663.049], [123337.896, 379662.83], [123086.303, 379652.899], [123082.77, 379652.76], [123089.523, 379657.849], [123089.79, 379658.05], [123090.646, 379658.663], [123098.27, 379664.13], [123107.9, 379673.25], [123115.79, 379682.89], [123118.06, 379684.11], [123168.8, 379681.4], [123172.81, 379682.34], [123186.1, 379691.66], [123206.74, 379715.582], [123206.85, 379715.71], [123237.83, 379751.74], [123243.05, 379756.12], [123249.65, 379755.77], [123257.1, 379750.92], [123274.71, 379729.17], [123278.18, 379726.38], [123283.02, 379725.31], [123304.39, 379725.26], [123327.19, 379734.95], [123327.673, 379735.268], [123330.357, 379737.039], [123330.92, 379737.41], [123341.42, 379744.18], [123341.82, 379744.461], [123352.68, 379752.09], [123356.24, 379756.4], [123360.63, 379776.23], [123354.2, 379806.07], [123352.51, 379810.6], [123349.64, 379812.79], [123336.586, 379812.322], [123335.98, 379812.3], [123325.16, 379809.56], [123324.772, 379809.458], [123321.24, 379808.53], [123319.606, 379807.446], [123310.9, 379801.67], [123303.41, 379802.62], [123299.78, 379811.07], [123296.94, 379823.36], [123294.74, 379827.39], [123293.648, 379828.605], [123293.14, 379829.17], [123283.25, 379836.56], [123279.15, 379840.87], [123276.23, 379847.41], [123274.9, 379860.03], [123273.76, 379867.95], [123264.34, 379881.83], [123216.88, 379916.35], [123179.89, 379937.27], [123174.65, 379938.09], [123149.66, 379939.94], [123135.12, 379944.65], [123128.74, 379946.24], [123111.72, 379945.72], [123091.73, 379947.0], [123073.01, 379949.51], [123060.31, 379953.24], [123035.81, 379960.78], [123002.483, 379997.848], [123002.14, 379998.23], [122999.44, 380001.35], [123001.67, 379999.72], [123003.97, 379999.16], [123149.83, 379982.73], [123242.23, 379972.79], [123248.43, 379971.87], [123252.48, 379971.88], [123260.34, 379973.05], [123281.23, 379973.9], [123305.986, 379974.484], [123311.34, 379974.61], [123315.33, 379974.95], [123318.119, 379974.998], [123319.056, 379975.014], [123322.35, 379975.07], [123324.89, 379977.9], [123337.74, 379990.75], [123340.78, 379992.24], [123347.23, 379993.47], [123349.898, 379993.859], [123351.83, 379994.14], [123355.17, 380003.59], [123359.7, 380005.78], [123361.23, 380008.26], [123361.78, 380012.25], [123364.511, 380014.216], [123368.6, 380017.16], [123369.64, 380019.89], [123370.2, 380024.64], [123373.01, 380029.1], [123373.4, 380039.34], [123375.19, 380042.57], [123389.82, 380051.62], [123393.12, 380055.32], [123395.44, 380060.79], [123395.7, 380079.79], [123396.44, 380081.55], [123421.44, 380085.68], [123450.83, 380090.54], [123453.845, 380091.062], [123547.652, 380107.299], [123588.101, 380114.301]], [[118726.15, 380701.63], [118731.483, 380702.34], [118731.847, 380702.388], [118784.114, 380709.341], [118811.09, 380712.93], [118824.96, 380681.67], [118846.186, 380636.867], [118846.36, 380636.5], [118847.74, 380633.279], [118847.776, 380633.195], [118867.34, 380587.53], [118840.64, 380591.35], [118814.19, 380594.93], [118811.85, 380594.67], [118806.4, 380593.25], [118762.75, 380579.41], [118756.812, 380594.965], [118745.705, 380624.044], [118745.5, 380624.58], [118744.67, 380626.75], [118746.84, 380626.41], [118746.452, 380628.823], [118744.13, 380643.27], [118738.73, 380662.03], [118731.651, 380684.314], [118726.15, 380701.63]], [[119274.13, 380828.9], [119257.19, 380880.04], [119270.74, 380887.73], [119290.63, 380901.3], [119297.879, 380906.109], [119324.03, 380923.46], [119339.526, 380933.493], [119357.53, 380945.15], [119390.7, 380895.59], [119369.8, 380885.48], [119348.192, 380874.656], [119347.5, 380874.31], [119347.293, 380874.215], [119343.68, 380872.55], [119324.73, 380861.39], [119310.72, 380852.93], [119304.59, 380848.82], [119300.6, 380845.51], [119295.72, 380841.61], [119290.28, 380837.65], [119284.37, 380834.31], [119280.17, 380832.08], [119274.13, 380828.9]], [[120320.82, 381849.18], [120372.931, 381880.425], [120374.59, 381881.42], [120428.16, 381913.94], [120429.843, 381912.116], [120434.143, 381907.453], [120459.13, 381880.36], [120464.14, 381859.29], [120502.48, 381829.46], [120519.772, 381851.494], [120525.23, 381858.45], [120527.29, 381859.95], [120530.34, 381857.83], [120564.75, 381804.1], [120579.1, 381781.59], [120573.74, 381776.43], [120542.1, 381741.5], [120536.77, 381732.24], [120522.64, 381694.51], [120517.86, 381684.33], [120374.17, 381710.84], [120443.76, 381759.53], [120322.99, 381847.597], [120320.82, 381849.18]], [[116935.593, 381216.209], [116935.936, 381216.468], [116937.685, 381217.786], [116942.45, 381216.78], [116946.67, 381217.4], [116959.07, 381223.03], [116963.79, 381224.39], [116969.3, 381221.74], [116974.03, 381217.38], [116975.61, 381212.26], [116972.18, 381200.27], [116963.61, 381186.67], [116962.36, 381182.09], [116963.6, 381179.88], [116965.44, 381178.21], [116971.36, 381173.03], [116975.1, 381167.25], [116975.14, 381161.06], [116972.16, 381155.86], [116969.95, 381143.37], [116970.47, 381137.55], [116973.26, 381133.63], [116977.33, 381130.24], [116984.7, 381126.12], [116996.72, 381121.6], [117009.18, 381117.68], [117020.69, 381115.12], [117027.85, 381115.84], [117030.83, 381116.48], [117028.878, 381113.796], [117026.972, 381111.175], [117014.859, 381094.517], [116995.2, 381067.48], [116905.65, 381117.42], [116849.23, 381149.21], [116853.32, 381154.21], [116935.593, 381216.209]], [[124475.83, 383936.69], [124473.966, 383940.457], [124469.17, 383950.15], [124471.08, 383974.68], [124466.805, 383974.526], [124384.38, 383971.55], [124361.636, 383969.654], [124361.13, 383969.612], [124329.079, 383966.94], [124328.719, 383966.91], [124325.36, 383966.63], [124313.36, 383965.62], [124314.57, 383952.87], [124189.806, 383934.139], [124189.309, 383934.064], [124184.62, 383933.36], [124181.08, 383948.65], [124185.639, 383949.336], [124187.548, 383949.623], [124313.09, 383968.52], [124311.5, 383989.773], [124307.037, 384049.407], [124307.0, 384049.9], [124323.09, 384050.43], [124321.67, 384104.11], [124357.219, 384104.008], [124387.99, 384103.92], [124446.5, 384104.25], [124447.59, 384163.68], [124459.49, 384155.23], [124475.82, 384146.85], [124485.07, 384143.52], [124492.76, 384142.51], [124502.81, 384142.42], [124516.8, 384145.23], [124525.78, 384144.51], [124536.71, 384142.7], [124540.58, 384141.729], [124545.335, 384140.536], [124551.06, 384139.1], [124557.89, 384130.81], [124564.5, 384118.01], [124571.424, 384117.271], [124579.58, 384116.4], [124583.19, 384102.84], [124584.2, 384079.47], [124589.87, 384080.69], [124590.9, 384075.98], [124577.86, 384073.16], [124581.05, 384056.19], [124531.88, 384051.42], [124534.401, 384046.705], [124592.801, 383937.532], [124596.21, 383931.16], [124554.24, 383936.37], [124541.13, 383936.56], [124539.309, 383936.409], [124517.8, 383934.63], [124494.92, 383935.32], [124475.83, 383936.69]], [[124210.06, 384963.85], [124158.89, 384950.43], [124126.94, 384942.414], [124126.922, 384942.409], [124114.967, 384939.41], [124111.62, 384938.57], [124111.31, 384944.84], [124111.043, 384946.087], [124107.53, 384962.47], [124107.022, 384973.2], [124107.02, 384973.24], [124104.322, 384982.224], [124101.21, 384992.59], [124108.65, 385010.22], [124123.747, 385011.675], [124133.408, 385012.606], [124150.37, 385014.24], [124171.11, 385017.31], [124227.18, 385026.89], [124227.21, 385026.38], [124249.16, 385030.06], [124252.642, 385010.333], [124258.56, 384976.8], [124210.06, 384963.85]], [[116696.268, 384553.916], [116698.19, 384556.04], [116713.601, 384534.505], [116729.5, 384512.29], [116727.591, 384510.152], [116720.92, 384502.68], [116698.67, 384473.36], [116665.64, 384519.51], [116672.49, 384527.64], [116686.684, 384543.324], [116696.268, 384553.916]], [[123890.29, 383502.21], [124006.84, 383526.68], [124013.15, 383498.53], [123896.83, 383474.16], [123890.29, 383502.21]], [[123905.97, 383946.76], [123925.69, 383865.58], [123925.401, 383865.496], [123902.85, 383858.93], [123926.833, 383734.669], [123927.91, 383729.09], [123889.29, 383731.46], [123888.374, 383736.8], [123879.801, 383786.803], [123876.271, 383807.392], [123872.42, 383829.856], [123868.665, 383851.758], [123868.659, 383851.794], [123866.802, 383862.627], [123866.788, 383862.706], [123864.114, 383878.306], [123864.107, 383878.349], [123858.731, 383909.701], [123854.94, 383931.81], [123905.97, 383946.76]], [[123979.94, 384114.12], [123978.93, 384117.38], [124057.94, 384145.23], [124071.55, 384099.24], [123992.82, 384071.49], [123979.94, 384114.12]], [[122811.08, 384242.23], [122903.93, 384275.03], [122982.702, 384159.064], [123001.136, 384131.925], [123001.88, 384130.83], [123001.261, 384130.586], [122991.08, 384126.57], [122985.567, 384124.398], [122976.33, 384120.76], [122966.51, 384115.96], [122955.68, 384109.59], [122944.22, 384100.9], [122932.58, 384092.1], [122917.63, 384080.85], [122915.629, 384083.881], [122909.255, 384093.534], [122903.729, 384101.904], [122901.062, 384105.943], [122897.481, 384111.367], [122892.363, 384119.118], [122891.474, 384120.465], [122890.605, 384121.781], [122883.846, 384132.018], [122874.838, 384145.661], [122869.109, 384154.339], [122811.08, 384242.23]], [[123334.161, 384320.455], [123335.466, 384321.343], [123352.778, 384333.119], [123353.05, 384333.31], [123352.188, 384334.656], [123348.699, 384340.105], [123345.174, 384345.612], [123341.558, 384351.259], [123338.052, 384356.736], [123334.548, 384362.209], [123330.959, 384367.815], [123327.437, 384373.317], [123323.935, 384378.788], [123322.25, 384381.42], [123327.584, 384384.873], [123337.354, 384391.198], [123346.614, 384397.193], [123365.867, 384409.657], [123370.017, 384412.343], [123378.43, 384417.79], [123381.777, 384419.586], [123387.827, 384422.833], [123393.206, 384425.72], [123401.924, 384430.399], [123425.171, 384442.875], [123431.041, 384446.026], [123439.431, 384450.529], [123440.47, 384451.087], [123444.09, 384453.03], [123444.506, 384452.3], [123444.595, 384452.144], [123445.617, 384450.351], [123451.391, 384440.218], [123456.44, 384431.357], [123461.6, 384422.303], [123466.735, 384413.292], [123471.841, 384404.333], [123477.654, 384394.133], [123478.716, 384392.269], [123490.286, 384371.966], [123492.812, 384367.533], [123500.16, 384354.64], [123497.547, 384354.027], [123491.12, 384352.52], [123481.23, 384349.83], [123476.55, 384347.39], [123472.05, 384344.4], [123466.352, 384338.999], [123463.99, 384336.76], [123461.4, 384333.12], [123457.525, 384330.654], [123455.9, 384329.62], [123447.213, 384325.172], [123436.871, 384319.876], [123426.493, 384314.562], [123422.775, 384312.658], [123409.164, 384305.688], [123405.239, 384303.678], [123403.554, 384302.815], [123402.06, 384302.05], [123391.841, 384296.916], [123383.35, 384292.65], [123382.922, 384292.408], [123374.172, 384287.457], [123365.42, 384282.505], [123356.691, 384277.566], [123349.01, 384273.22], [123345.098, 384278.863], [123340.92, 384284.889], [123332.512, 384297.017], [123332.142, 384297.55], [123326.647, 384305.477], [123322.957, 384310.799], [123322.0, 384312.18], [123328.762, 384316.781], [123333.767, 384320.187], [123334.161, 384320.455]], [[123062.228, 384454.682], [123052.208, 384466.158], [123050.048, 384468.632], [123040.238, 384479.867], [123033.6, 384487.47], [123037.453, 384490.268], [123050.93, 384500.056], [123057.332, 384504.715], [123072.393, 384515.644], [123073.052, 384516.122], [123089.64, 384528.17], [123096.228, 384519.243], [123104.404, 384508.162], [123107.364, 384504.151], [123121.73, 384484.682], [123123.633, 384482.104], [123129.899, 384473.613], [123130.403, 384472.93], [123136.36, 384464.857], [123141.906, 384457.342], [123150.907, 384445.143], [123156.68, 384437.32], [123146.048, 384430.475], [123144.873, 384429.719], [123131.565, 384421.151], [123117.797, 384412.287], [123113.214, 384409.336], [123105.92, 384404.64], [123090.39, 384422.428], [123078.437, 384436.118], [123069.618, 384446.218], [123062.228, 384454.682]], [[123191.467, 384585.404], [123184.158, 384596.412], [123183.09, 384598.02], [123183.84, 384598.631], [123189.341, 384603.112], [123195.887, 384608.444], [123197.936, 384610.114], [123202.84, 384614.11], [123208.258, 384620.419], [123217.471, 384631.145], [123218.707, 384632.584], [123222.719, 384637.256], [123225.242, 384640.194], [123228.481, 384643.966], [123233.889, 384650.263], [123238.362, 384655.471], [123244.204, 384662.273], [123245.846, 384664.185], [123248.293, 384667.035], [123252.07, 384671.433], [123253.748, 384673.387], [123258.217, 384678.59], [123259.963, 384680.623], [123267.971, 384689.948], [123270.3, 384692.66], [123279.745, 384675.737], [123284.767, 384666.738], [123289.745, 384657.818], [123294.728, 384648.889], [123299.739, 384639.912], [123304.748, 384630.937], [123309.636, 384622.179], [123319.808, 384603.952], [123322.89, 384598.43], [123323.567, 384597.329], [123326.443, 384592.651], [123328.324, 384589.591], [123341.368, 384568.375], [123342.719, 384566.177], [123344.31, 384563.59], [123343.302, 384562.974], [123333.076, 384556.723], [123322.803, 384550.443], [123321.482, 384549.636], [123319.77, 384548.589], [123300.443, 384536.774], [123290.015, 384530.399], [123273.338, 384520.204], [123267.173, 384516.435], [123251.519, 384506.865], [123249.007, 384505.329], [123245.9, 384503.43], [123244.425, 384505.652], [123243.942, 384506.379], [123226.35, 384532.833], [123224.157, 384536.174], [123210.399, 384556.894], [123210.096, 384557.351], [123201.086, 384570.919], [123200.328, 384572.061], [123194.48, 384580.867], [123191.467, 384585.404]], [[123960.79, 385233.44], [123967.495, 385267.311], [124031.07, 385260.08], [124063.08, 385223.26], [123960.79, 385233.44]]]]}, "properties": {"id": "37b0a09f-36a0-4e69-80c2-000000000744", "naam": "Bestaande geometrie ambtsgebied"}, "_shape": null}], "properties": {"id": ["ID", ""], "naam": ["Naam", ""]}, "bbox": [69000.0, 355000.0, 128852.39, 394000.0]}
);


window.addEventListener("load", function () {
var kaart = new Kaart ();
kaart.VoegLaagToe ("Juridische nauwkeurigheid", "data12_2", "sym2").AlsAanUitLaag (false);
kaart.VoegLaagToe ("GIO-versie", "data13_2", "sym11");
kaart.Toon ({"kaartelementId": "kaart_14", "kaartelementWidth": 900, "kaartelementHeight": 600, "juridische-nauwkeurigheid": 10000, "maxZoom": 13, "bbox": [68500.0, 354500.0, 129352.37894392274, 394500.0]});
});

Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym15",`<FeatureTypeStyle version="1.1.0" xmlns="http://www.opengis.net/se" xmlns:ogc="http://www.opengis.net/ogc">
	<FeatureTypeName>geo:Locatie</FeatureTypeName>
	<SemanticTypeIdentifier>geo:groepID</SemanticTypeIdentifier>
	<Rule>
		<Name>Vlak</Name>
		<PolygonSymbolizer>
			<Name>10</Name>
			<Fill>
				<SvgParameter name="fill">#DAE8FC</SvgParameter>
				<SvgParameter name="fill-opacity">0.7</SvgParameter>
			</Fill>
			<Stroke>
				<SvgParameter name="stroke">#6C8EBF</SvgParameter>
				<SvgParameter name="stroke-opacity">1</SvgParameter>
				<SvgParameter name="stroke-width">1</SvgParameter>
				<SvgParameter name="stroke-linejoin">round</SvgParameter>
			</Stroke>
		</PolygonSymbolizer>
	</Rule>
</FeatureTypeStyle>
`);


Kaartgegevens.Instantie.VoegDataToe ("data16_2",
{"type": "FeatureCollection", "crs": {"type": "name", "properties": {"name": "urn:ogc:def:crs:EPSG::28992"}}, "features": [{"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[85852.48022837921, 447599.4453706186], [85852.73868270862, 447599.48630514485], [85853.0, 447599.5], [85853.26131729138, 447599.48630514485], [85853.51977162079, 447599.4453706186], [85853.77253139255, 447599.37764489517], [85862.58931139254, 447596.5129448952], [85862.83361269326, 447596.4191676131], [85863.06677320012, 447596.3003674354], [85863.28623832065, 447596.15784598066], [85863.48960351407, 447595.9931647666], [85863.67464063635, 447595.8081281011], [85863.83932235256, 447595.6047633143], [85869.28839235257, 447588.1047633143], [85869.43091341492, 447587.88530016376], [85869.54971358259, 447587.6521417459], [85869.64349125567, 447587.40784259385], [85869.7112189861, 447587.15507930104], [85869.75215473447, 447586.8966211958], [85869.76585, 447586.6353], [85869.76585, 447577.3647], [85869.75215473447, 447577.1033788042], [85869.7112189861, 447576.84492069896], [85869.64349125567, 447576.59215740615], [85869.54971358259, 447576.3478582541], [85869.43091341492, 447576.11469983624], [85869.28839235257, 447575.8952366857], [85863.83932235256, 447568.3952366857], [85863.67464063635, 447568.1918718989], [85863.48960351407, 447568.0068352334], [85863.28623832065, 447567.84215401934], [85863.06677320012, 447567.6996325646], [85862.83361269326, 447567.5808323869], [85862.58931139254, 447567.4870551048], [85853.77253139255, 447564.62235510483], [85853.51977162079, 447564.5546293814], [85853.26131729138, 447564.51369485515], [85853.0, 447564.5], [85852.73868270862, 447564.51369485515], [85852.48022837921, 447564.5546293814], [85852.22746860745, 447564.62235510483], [85843.41068860746, 447567.4870551048], [85843.16638730674, 447567.5808323869], [85842.93322679988, 447567.6996325646], [85842.71376167935, 447567.84215401934], [85842.51039648593, 447568.0068352334], [85842.32535936365, 447568.1918718989], [85842.16067764744, 447568.3952366857], [85836.71160764743, 447575.8952366857], [85836.56908658508, 447576.11469983624], [85836.45028641741, 447576.3478582541], [85836.35650874433, 447576.59215740615], [85836.2887810139, 447576.84492069896], [85836.24784526553, 447577.1033788042], [85836.23415, 447577.3647], [85836.23415, 447586.6353], [85836.24784526553, 447586.8966211958], [85836.2887810139, 447587.15507930104], [85836.35650874433, 447587.40784259385], [85836.45028641741, 447587.6521417459], [85836.56908658508, 447587.88530016376], [85836.71160764743, 447588.1047633143], [85842.16067764744, 447595.6047633143], [85842.32535936365, 447595.8081281011], [85842.51039648593, 447595.9931647666], [85842.71376167935, 447596.15784598066], [85842.93322679988, 447596.3003674354], [85843.16638730674, 447596.4191676131], [85843.41068860746, 447596.5129448952], [85852.22746860745, 447599.37764489517], [85852.48022837921, 447599.4453706186]], [[85845.72830106263, 447592.008667724], [85841.23415, 447585.82300063403], [85841.23415, 447578.17699936597], [85845.72830106263, 447571.991332276], [85853.0, 447569.62865157565], [85860.27169893737, 447571.991332276], [85864.76585, 447578.17699936597], [85864.76585, 447585.82300063403], [85860.27169893737, 447592.008667724], [85853.0, 447594.37134842435], [85845.72830106263, 447592.008667724]]]}, "_shape": null}, {"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[85850.5, 447627.0], [85850.51150954516, 447627.2396148079], [85850.54593220493, 447627.4770233298], [85850.60295102799, 447627.7100395945], [85850.68204100576, 447627.93651807297], [85850.78247390651, 447628.1543734338], [85850.90332498062, 447628.3615997441], [85851.0434814754, 447628.5562889394], [85851.20165288082, 447628.7366483924], [85851.37638281214, 447628.901017419], [85851.56606241973, 447629.0478825689], [85851.7689452028, 447629.17589156126], [85851.9831630905, 447629.28386573587], [85852.20674364245, 447629.3708109058], [85852.4376282103, 447629.43592651165], [85852.67369089296, 447629.4786129925], [85852.91275811114, 447629.49847730686], [85853.15262862088, 447629.4953365513], [85853.39109378183, 447629.4692196447], [85867.29685378182, 447627.2667196447], [85867.55280836426, 447627.2123143643], [85867.80167412471, 447627.1314532731], [85868.04072458217, 447627.02502225514], [85880.58530458217, 447620.63332225516], [85880.81193307436, 447620.5024793507], [85881.02364278969, 447620.34866343625], [85881.21811405565, 447620.17355985026], [85891.17353405565, 447610.2180598503], [85891.34862785673, 447610.0235973309], [85891.50243606055, 447609.8118981409], [85891.63327358107, 447609.58528160607], [85897.32953783553, 447598.4058], [85945.79754, 447598.4058], [85946.04258285083, 447598.39376181667], [85946.28526580504, 447598.357763201], [85946.52325169314, 447598.29815083934], [85946.75424858091, 447598.2154988313], [85946.97603184206, 447598.11060316087], [85947.18646558255, 447597.9844740308], [85947.3835232104, 447597.83832613344], [85947.56530695297, 447597.673566953], [85947.7300661334, 447597.4917832104], [85947.87621403075, 447597.2947255826], [85948.00234316087, 447597.08429184207], [85948.10723883128, 447596.8625085809], [85948.18989083933, 447596.6315116931], [85948.249503201, 447596.39352580503], [85948.28550181667, 447596.15084285085], [85948.29754, 447595.9058], [85948.29754, 447568.0942], [85948.28550181667, 447567.84915714915], [85948.249503201, 447567.60647419497], [85948.18989083933, 447567.3684883069], [85948.10723883128, 447567.1374914191], [85948.00234316087, 447566.91570815793], [85947.87621403075, 447566.7052744174], [85947.7300661334, 447566.5082167896], [85947.56530695297, 447566.326433047], [85947.3835232104, 447566.16167386656], [85947.18646558255, 447566.0155259692], [85946.97603184206, 447565.88939683913], [85946.75424858091, 447565.7845011687], [85946.52325169314, 447565.70184916066], [85946.28526580504, 447565.642236799], [85946.04258285083, 447565.60623818333], [85945.79754, 447565.5942], [85897.32953783553, 447565.5942], [85891.63327358107, 447554.41471839393], [85891.50243606055, 447554.1881018591], [85891.34862785673, 447553.9764026691], [85891.17353405565, 447553.7819401497], [85881.21811405565, 447543.82644014974], [85881.02364278969, 447543.65133656375], [85880.81193307436, 447543.4975206493], [85880.58530458217, 447543.36667774484], [85868.04072458217, 447536.97497774486], [85867.80167412471, 447536.8685467269], [85867.55280836426, 447536.7876856357], [85867.29685378182, 447536.7332803553], [85853.39109378183, 447534.5307803553], [85853.15262862088, 447534.5046634487], [85852.91275811114, 447534.50152269314], [85852.67369089296, 447534.5213870075], [85852.4376282103, 447534.56407348835], [85852.20674364245, 447534.6291890942], [85851.9831630905, 447534.71613426413], [85851.7689452028, 447534.82410843874], [85851.56606241973, 447534.9521174311], [85851.37638281214, 447535.098982581], [85851.20165288082, 447535.2633516076], [85851.0434814754, 447535.4437110606], [85850.90332498062, 447535.6384002559], [85850.78247390651, 447535.8456265662], [85850.68204100576, 447536.06348192703], [85850.60295102799, 447536.2899604055], [85850.54593220493, 447536.5229766702], [85850.51150954516, 447536.7603851921], [85850.5, 447537.0], [85850.5, 447567.0], [85850.5116709998, 447567.24128569535], [85850.54657502942, 447567.48031855444], [85850.60438619692, 447567.7148667754], [85850.684564731, 447567.94274042826], [85850.78636202074, 447568.1618119025], [85850.9088276052, 447568.3700357715], [85851.05081804776, 447568.5654678908], [85851.21100761207, 447568.7462835497], [85851.38790064021, 447568.91079450864], [85851.57984551742, 447569.0574647617], [85851.78505009276, 447569.18492487806], [85852.00159841221, 447569.29198478826], [85852.22746860745, 447569.37764489517], [85860.27169893737, 447571.991332276], [85864.76585, 447578.17699936597], [85864.76585, 447585.82300063403], [85860.27169893737, 447592.008667724], [85852.22746860745, 447594.62235510483], [85852.00159841221, 447594.70801521174], [85851.78505009276, 447594.81507512194], [85851.57984551742, 447594.9425352383], [85851.38790064021, 447595.08920549136], [85851.21100761207, 447595.2537164503], [85851.05081804776, 447595.4345321092], [85850.9088276052, 447595.6299642285], [85850.78636202074, 447595.8381880975], [85850.684564731, 447596.05725957174], [85850.60438619692, 447596.2851332246], [85850.54657502942, 447596.51968144556], [85850.5116709998, 447596.75871430465], [85850.5, 447597.0], [85850.5, 447627.0]], [[85862.58931139254, 447596.5129448952], [85862.83361269326, 447596.4191676131], [85863.06677320012, 447596.3003674354], [85863.28623832065, 447596.15784598066], [85863.48960351407, 447595.9931647666], [85863.67464063635, 447595.8081281011], [85863.83932235256, 447595.6047633143], [85869.28839235257, 447588.1047633143], [85869.43091341492, 447587.88530016376], [85869.54971358259, 447587.6521417459], [85869.64349125567, 447587.40784259385], [85869.7112189861, 447587.15507930104], [85869.75215473447, 447586.8966211958], [85869.76585, 447586.6353], [85869.76585, 447577.3647], [85869.75215473447, 447577.1033788042], [85869.7112189861, 447576.84492069896], [85869.64349125567, 447576.59215740615], [85869.54971358259, 447576.3478582541], [85869.43091341492, 447576.11469983624], [85869.28839235257, 447575.8952366857], [85863.83932235256, 447568.3952366857], [85863.67464063635, 447568.1918718989], [85863.48960351407, 447568.0068352334], [85863.28623832065, 447567.84215401934], [85863.06677320012, 447567.6996325646], [85862.83361269326, 447567.5808323869], [85862.58931139254, 447567.4870551048], [85855.5, 447565.1836347693], [85855.5, 447539.92713306006], [85866.12359078073, 447541.60977814347], [85877.96255998495, 447547.6419561408], [85887.35800610915, 447557.0374777652], [85893.57002641892, 447569.22918160603], [85893.69440912276, 447569.4458066414], [85893.83978863157, 447569.6489377848], [85894.00471353535, 447569.83654705714], [85894.1875372908, 447570.0067614438], [85894.38643465977, 447570.15788159333], [85894.59941993165, 447570.28839878354], [85894.82436674794, 447570.3970099838], [85895.05902933095, 447570.4826308639], [85895.30106490469, 447570.5444066198], [85895.54805708426, 447570.5817205074], [85895.79754, 447570.5942], [85943.29754, 447570.5942], [85943.29754, 447593.4058], [85895.79754, 447593.4058], [85895.54805708426, 447593.4182794926], [85895.30106490469, 447593.4555933802], [85895.05902933095, 447593.5173691361], [85894.82436674794, 447593.6029900162], [85894.59941993165, 447593.71160121646], [85894.38643465977, 447593.84211840667], [85894.1875372908, 447593.9932385562], [85894.00471353535, 447594.16345294286], [85893.83978863157, 447594.3510622152], [85893.69440912276, 447594.5541933586], [85893.57002641892, 447594.77081839397], [85887.35800610915, 447606.9625222348], [85877.96255998495, 447616.3580438592], [85866.12359078073, 447622.39022185653], [85855.5, 447624.07286693994], [85855.5, 447598.8163652307], [85862.58931139254, 447596.5129448952]]]}, "_shape": null}], "bbox": [85836.23415, 447534.50152269314, 85948.29754, 447629.49847730686]}
);


Kaartgegevens.Instantie.VoegDataToe ("data17_2",
{"type": "FeatureCollection", "crs": {"type": "name", "properties": {"name": "urn:ogc:def:crs:EPSG::28992"}}, "features": [{"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[85853.0, 447597.0], [85861.81678, 447594.1353], [85867.26585, 447586.6353], [85867.26585, 447577.3647], [85861.81678, 447569.8647], [85853.0, 447567.0], [85844.18322, 447569.8647], [85838.73415, 447577.3647], [85838.73415, 447586.6353], [85844.18322, 447594.1353], [85853.0, 447597.0]]]}, "properties": {"id": "37b0a09f-36a0-4e69-80c2-000000000002", "naam": "Binnengebied"}, "_shape": null}, {"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[85853.0, 447597.0], [85861.81678, 447594.1353], [85867.26585, 447586.6353], [85867.26585, 447577.3647], [85861.81678, 447569.8647], [85853.0, 447567.0], [85853.0, 447537.0], [85866.90576, 447539.2025], [85879.45034, 447545.5942], [85889.40576, 447555.5497], [85895.79754, 447568.0942], [85945.79754, 447568.0942], [85945.79754, 447595.9058], [85895.79754, 447595.9058], [85889.40576, 447608.4503], [85879.45034, 447618.4058], [85866.90576, 447624.7975], [85853.0, 447627.0], [85853.0, 447597.0]]]}, "properties": {"id": "37b0a09f-36a0-4e69-80c2-000000000003", "naam": "Buitengebied"}, "_shape": null}], "properties": {"id": ["ID", ""], "naam": ["Naam", ""]}, "bbox": [85838.73415, 447537.0, 85945.79754, 447627.0]}
);


window.addEventListener("load", function () {
var kaart = new Kaart ();
kaart.VoegLaagToe ("Juridische nauwkeurigheid", "data16_2", "sym2").AlsAanUitLaag (false);
kaart.VoegLaagToe ("GIO-versie", "data17_2", "sym15");
kaart.Toon ({"kaartelementId": "kaart_18", "kaartelementWidth": 900, "kaartelementHeight": 600, "juridische-nauwkeurigheid": 50, "maxZoom": 21, "bbox": [85836.23415, 447534.50152269314, 85948.29754, 447629.49847730686]});
});

Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym19",`<FeatureTypeStyle version="1.1.0" xmlns="http://www.opengis.net/se" xmlns:ogc="http://www.opengis.net/ogc">
	<FeatureTypeName>geo:Locatie</FeatureTypeName>
	<SemanticTypeIdentifier>geo:groepID</SemanticTypeIdentifier>
	<Rule>
		<Name>Vlak</Name>
		<PolygonSymbolizer>
			<Name>10</Name>
			<Fill>
				<SvgParameter name="fill">#DAE8FC</SvgParameter>
				<SvgParameter name="fill-opacity">0.7</SvgParameter>
			</Fill>
			<Stroke>
				<SvgParameter name="stroke">#6C8EBF</SvgParameter>
				<SvgParameter name="stroke-opacity">1</SvgParameter>
				<SvgParameter name="stroke-width">1</SvgParameter>
				<SvgParameter name="stroke-linejoin">round</SvgParameter>
			</Stroke>
		</PolygonSymbolizer>
	</Rule>
</FeatureTypeStyle>
`);


Kaartgegevens.Instantie.VoegDataToe ("data20_2",
{"type": "FeatureCollection", "crs": {"type": "name", "properties": {"name": "urn:ogc:def:crs:EPSG::28992"}}, "features": [{"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[85857.69135225614, 447598.7651704281], [85857.94301993013, 447598.74678320636], [85858.19155205844, 447598.70311984356], [85858.43441660739, 447598.63462518004], [85858.66913928425, 447598.54199703626], [85858.89332874538, 447598.4261791034], [85859.10470095903, 447598.28835132916], [85866.60470095903, 447592.83935132914], [85866.8080672615, 447592.6746703963], [85866.99310546542, 447592.48963384394], [85867.15778821337, 447592.2862690114], [85867.30031117103, 447592.06680405024], [85867.41911279614, 447591.8336435122], [85867.51289144749, 447591.5893420035], [85870.37764144749, 447582.77254200354], [85870.44536907214, 447582.5197788963], [85870.4863047561, 447582.26132099004], [85870.5, 447582.0], [85870.4863047561, 447581.73867900996], [85870.44536907214, 447581.4802211037], [85870.37764144749, 447581.22745799646], [85867.51289144749, 447572.4106579965], [85867.41911279614, 447572.1663564878], [85867.30031117103, 447571.93319594976], [85867.15778821337, 447571.7137309886], [85866.99310546542, 447571.51036615606], [85866.8080672615, 447571.3253296037], [85866.60470095903, 447571.16064867086], [85859.10470095903, 447565.71164867084], [85858.88523914217, 447565.5691302218], [85858.65208244481, 447565.45033227635], [85858.4077853316, 447565.3565563847], [85858.15502432163, 447565.2888299555], [85857.89656866441, 447565.24789499945], [85857.63525, 447565.2342], [85848.76764133963, 447565.2342], [85782.50486510566, 447543.3073699429], [85782.26762248673, 447543.24163214717], [85782.02506459433, 447543.1995466764], [85781.77954348389, 447543.1815216285], [85781.53343994488, 447543.18773179036], [85781.2891404145, 447543.21811694256], [85781.04901383669, 447543.272382444], [85780.81538869074, 447543.3500020884], [85780.59053041232, 447543.4502232072], [85780.37661942584, 447543.5720739679], [85780.17573000108, 447543.714372798], [85779.98981013925, 447543.8757398423], [85779.82066268349, 447544.0546103436], [85779.66992783686, 447544.24924981553], [85779.53906725753, 447544.4577708619], [85779.4293498852, 447544.67815147864], [85779.34183963637, 447544.90825466067], [85771.60728963638, 447568.7126546607], [85771.54283503846, 447568.9502493492], [85771.50206119359, 447569.1930314012], [85771.48536348171, 447569.4386465832], [85771.49290381889, 447569.684713189], [85771.5246090872, 447569.9288451352], [85771.58017184382, 447570.1686750985], [85771.65905330218, 447570.40187747136], [85771.76048855661, 447570.6261909136], [85771.88349399948, 447570.8394402799], [85772.02687685918, 447571.03955771227], [85772.18924676633, 447571.22460269183], [85772.369029236, 447571.39278085565], [85772.5644809354, 447571.54246139684], [85772.77370658873, 447571.6721928779], [85772.99467735557, 447571.78071730555], [85773.22525050426, 447571.86698232923], [85839.62461087605, 447593.04533770913], [85844.56652250914, 447597.2661171602], [85844.7741282647, 447597.4254181224], [85844.9972482858, 447597.56214559765], [85845.23343799998, 447597.67480155715], [85845.4801096392, 447597.76215170714], [85845.73456059216, 447597.82323901216], [85845.99400301499, 447597.85739418067], [85857.43911301499, 447598.75809418067], [85857.69135225614, 447598.7651704281]], [[85847.19607649204, 447592.93653490674], [85842.48836749086, 447588.91578283976], [85842.29144491469, 447588.76386512024], [85842.08040205487, 447588.632265706], [85841.8573276446, 447588.52228706266], [85841.62442949574, 447588.43501767074], [85777.13930376926, 447567.8672154855], [85783.3203881021, 447548.84387167194], [85847.57936489434, 447570.1076300571], [85847.8361607543, 447570.1776797747], [85848.09894879302, 447570.22002978466], [85848.36475, 447570.2342], [85856.82295907609, 447570.2342], [85863.00862532228, 447574.7282927168], [85865.3713446127, 447582.0], [85863.00862532228, 447589.2717072832], [85856.911945748, 447593.7011482166], [85847.19607649204, 447592.93653490674]]]}, "_shape": null}, {"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[85850.5, 447627.0], [85850.51150954516, 447627.2396148079], [85850.54593220493, 447627.4770233298], [85850.60295102799, 447627.7100395945], [85850.68204100576, 447627.93651807297], [85850.78247390651, 447628.1543734338], [85850.90332498062, 447628.3615997441], [85851.0434814754, 447628.5562889394], [85851.20165288082, 447628.7366483924], [85851.37638281214, 447628.901017419], [85851.56606241973, 447629.0478825689], [85851.7689452028, 447629.17589156126], [85851.9831630905, 447629.28386573587], [85852.20674364245, 447629.3708109058], [85852.4376282103, 447629.43592651165], [85852.67369089296, 447629.4786129925], [85852.91275811114, 447629.49847730686], [85853.15262862088, 447629.4953365513], [85853.39109378183, 447629.4692196447], [85867.29685378182, 447627.2667196447], [85867.55280836426, 447627.2123143643], [85867.80167412471, 447627.1314532731], [85868.04072458217, 447627.02502225514], [85880.58530458217, 447620.63332225516], [85880.81193307436, 447620.5024793507], [85881.02364278969, 447620.34866343625], [85881.21811405565, 447620.17355985026], [85891.17353405565, 447610.2180598503], [85891.34862785673, 447610.0235973309], [85891.50243606055, 447609.8118981409], [85891.63327358107, 447609.58528160607], [85898.02505358108, 447597.04078160605], [85898.1219794442, 447596.82611585356], [85898.19827320782, 447596.60328122904], [85898.2532576762, 447596.37425564864], [85898.28644479834, 447596.14107198035], [85898.29754, 447595.9058], [85898.29754, 447568.0942], [85898.28644479834, 447567.85892801965], [85898.2532576762, 447567.62574435136], [85898.19827320782, 447567.39671877096], [85898.1219794442, 447567.17388414644], [85898.02505358108, 447566.95921839395], [85891.63327358107, 447554.41471839393], [85891.50243606055, 447554.1881018591], [85891.34862785673, 447553.9764026691], [85891.17353405565, 447553.7819401497], [85881.21811405565, 447543.82644014974], [85881.02364278969, 447543.65133656375], [85880.81193307436, 447543.4975206493], [85880.58530458217, 447543.36667774484], [85868.04072458217, 447536.97497774486], [85867.80167412471, 447536.8685467269], [85867.55280836426, 447536.7876856357], [85867.29685378182, 447536.7332803553], [85853.39109378183, 447534.5307803553], [85853.15262862088, 447534.5046634487], [85852.91275811114, 447534.50152269314], [85852.67369089296, 447534.5213870075], [85852.4376282103, 447534.56407348835], [85852.20674364245, 447534.6291890942], [85851.9831630905, 447534.71613426413], [85851.7689452028, 447534.82410843874], [85851.56606241973, 447534.9521174311], [85851.37638281214, 447535.098982581], [85851.20165288082, 447535.2633516076], [85851.0434814754, 447535.4437110606], [85850.90332498062, 447535.6384002559], [85850.78247390651, 447535.8456265662], [85850.68204100576, 447536.06348192703], [85850.60295102799, 447536.2899604055], [85850.54593220493, 447536.5229766702], [85850.51150954516, 447536.7603851921], [85850.5, 447537.0], [85850.5, 447567.0], [85850.5116709998, 447567.24128569535], [85850.54657502942, 447567.48031855444], [85850.60438619692, 447567.7148667754], [85850.684564731, 447567.94274042826], [85850.78636202074, 447568.1618119025], [85850.9088276052, 447568.3700357715], [85851.05081804776, 447568.5654678908], [85851.21100761207, 447568.7462835497], [85851.38790064021, 447568.91079450864], [85851.57984551742, 447569.0574647617], [85851.78505009276, 447569.18492487806], [85852.00159841221, 447569.29198478826], [85852.22746860745, 447569.37764489517], [85860.27169893737, 447571.991332276], [85864.76585, 447578.17699936597], [85864.76585, 447585.82300063403], [85860.27169893737, 447592.008667724], [85852.22746860745, 447594.62235510483], [85852.00159841221, 447594.70801521174], [85851.78505009276, 447594.81507512194], [85851.57984551742, 447594.9425352383], [85851.38790064021, 447595.08920549136], [85851.21100761207, 447595.2537164503], [85851.05081804776, 447595.4345321092], [85850.9088276052, 447595.6299642285], [85850.78636202074, 447595.8381880975], [85850.684564731, 447596.05725957174], [85850.60438619692, 447596.2851332246], [85850.54657502942, 447596.51968144556], [85850.5116709998, 447596.75871430465], [85850.5, 447597.0], [85850.5, 447627.0]], [[85862.58931139254, 447596.5129448952], [85862.83361269326, 447596.4191676131], [85863.06677320012, 447596.3003674354], [85863.28623832065, 447596.15784598066], [85863.48960351407, 447595.9931647666], [85863.67464063635, 447595.8081281011], [85863.83932235256, 447595.6047633143], [85869.28839235257, 447588.1047633143], [85869.43091341492, 447587.88530016376], [85869.54971358259, 447587.6521417459], [85869.64349125567, 447587.40784259385], [85869.7112189861, 447587.15507930104], [85869.75215473447, 447586.8966211958], [85869.76585, 447586.6353], [85869.76585, 447577.3647], [85869.75215473447, 447577.1033788042], [85869.7112189861, 447576.84492069896], [85869.64349125567, 447576.59215740615], [85869.54971358259, 447576.3478582541], [85869.43091341492, 447576.11469983624], [85869.28839235257, 447575.8952366857], [85863.83932235256, 447568.3952366857], [85863.67464063635, 447568.1918718989], [85863.48960351407, 447568.0068352334], [85863.28623832065, 447567.84215401934], [85863.06677320012, 447567.6996325646], [85862.83361269326, 447567.5808323869], [85862.58931139254, 447567.4870551048], [85855.5, 447565.1836347693], [85855.5, 447539.92713306006], [85866.12359078073, 447541.60977814347], [85877.96255998495, 447547.6419561408], [85887.35800610915, 447557.0374777652], [85893.29754, 447568.6944000769], [85893.29754, 447595.3055999231], [85887.35800610915, 447606.9625222348], [85877.96255998495, 447616.3580438592], [85866.12359078073, 447622.39022185653], [85855.5, 447624.07286693994], [85855.5, 447598.8163652307], [85862.58931139254, 447596.5129448952]]]}, "_shape": null}], "bbox": [85771.48536348171, 447534.50152269314, 85898.29754, 447629.49847730686]}
);


Kaartgegevens.Instantie.VoegDataToe ("data21_2",
{"type": "FeatureCollection", "crs": {"type": "name", "properties": {"name": "urn:ogc:def:crs:EPSG::28992"}}, "features": [{"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[85857.63525, 447596.2658], [85865.13525, 447590.8168], [85868.0, 447582.0], [85865.13525, 447573.1832], [85857.63525, 447567.7342], [85848.36475, 447567.7342], [85781.71948, 447545.6808], [85773.98493, 447569.4852], [85840.86475, 447590.8168], [85846.19014, 447595.3651], [85857.63525, 447596.2658]]]}, "properties": {"id": "37b0a09f-36a0-4e69-80c2-100000000001", "naam": "Binnengebied"}, "_shape": null}, {"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[85853.0, 447597.0], [85861.81678, 447594.1353], [85867.26585, 447586.6353], [85867.26585, 447577.3647], [85861.81678, 447569.8647], [85853.0, 447567.0], [85853.0, 447537.0], [85866.90576, 447539.2025], [85879.45034, 447545.5942], [85889.40576, 447555.5497], [85895.79754, 447568.0942], [85895.79754, 447595.9058], [85889.40576, 447608.4503], [85879.45034, 447618.4058], [85866.90576, 447624.7975], [85853.0, 447627.0], [85853.0, 447597.0]]]}, "properties": {"id": "37b0a09f-36a0-4e69-80c2-100000000002", "naam": "Buitengebied"}, "_shape": null}], "properties": {"id": ["ID", ""], "naam": ["Naam", ""]}, "bbox": [85773.98493, 447537.0, 85895.79754, 447627.0]}
);


window.addEventListener("load", function () {
var kaart = new Kaart ();
kaart.VoegLaagToe ("Juridische nauwkeurigheid", "data20_2", "sym2").AlsAanUitLaag (false);
kaart.VoegLaagToe ("GIO-versie", "data21_2", "sym19");
kaart.Toon ({"kaartelementId": "kaart_22", "kaartelementWidth": 900, "kaartelementHeight": 600, "juridische-nauwkeurigheid": 50, "maxZoom": 21, "bbox": [85771.48536348171, 447534.50152269314, 85898.29754, 447629.49847730686]});
});

Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym23",`<FeatureTypeStyle version="1.1.0" xmlns="http://www.opengis.net/se" xmlns:ogc="http://www.opengis.net/ogc">
	<FeatureTypeName>geo:Locatie</FeatureTypeName>
	<SemanticTypeIdentifier>geo:groepID</SemanticTypeIdentifier>
	<Rule>
		<Name>Vlak</Name>
		<PolygonSymbolizer>
			<Name>10</Name>
			<Fill>
				<SvgParameter name="fill">#DAE8FC</SvgParameter>
				<SvgParameter name="fill-opacity">0.7</SvgParameter>
			</Fill>
			<Stroke>
				<SvgParameter name="stroke">#6C8EBF</SvgParameter>
				<SvgParameter name="stroke-opacity">1</SvgParameter>
				<SvgParameter name="stroke-width">1</SvgParameter>
				<SvgParameter name="stroke-linejoin">round</SvgParameter>
			</Stroke>
		</PolygonSymbolizer>
	</Rule>
</FeatureTypeStyle>
`);


Kaartgegevens.Instantie.VoegDataToe ("data25_2",
{"type": "FeatureCollection", "crs": {"type": "name", "properties": {"name": "urn:ogc:def:crs:EPSG::28992"}}, "features": [{"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[85852.48022837921, 447599.4453706186], [85852.73868270862, 447599.48630514485], [85853.0, 447599.5], [85853.26131729138, 447599.48630514485], [85853.51977162079, 447599.4453706186], [85853.77253139255, 447599.37764489517], [85862.58931139254, 447596.5129448952], [85862.83361269326, 447596.4191676131], [85863.06677320012, 447596.3003674354], [85863.28623832065, 447596.15784598066], [85863.48960351407, 447595.9931647666], [85863.67464063635, 447595.8081281011], [85863.83932235256, 447595.6047633143], [85869.28839235257, 447588.1047633143], [85869.43091341492, 447587.88530016376], [85869.54971358259, 447587.6521417459], [85869.64349125567, 447587.40784259385], [85869.7112189861, 447587.15507930104], [85869.75215473447, 447586.8966211958], [85869.76585, 447586.6353], [85869.76585, 447577.3647], [85869.75215473447, 447577.1033788042], [85869.7112189861, 447576.84492069896], [85869.64349125567, 447576.59215740615], [85869.54971358259, 447576.3478582541], [85869.43091341492, 447576.11469983624], [85869.28839235257, 447575.8952366857], [85863.83932235256, 447568.3952366857], [85863.67464063635, 447568.1918718989], [85863.48960351407, 447568.0068352334], [85863.28623832065, 447567.84215401934], [85863.06677320012, 447567.6996325646], [85862.83361269326, 447567.5808323869], [85862.58931139254, 447567.4870551048], [85853.77253139255, 447564.62235510483], [85853.51977162079, 447564.5546293814], [85853.26131729138, 447564.51369485515], [85853.0, 447564.5], [85852.73868270862, 447564.51369485515], [85852.48022837921, 447564.5546293814], [85852.22746860745, 447564.62235510483], [85843.41068860746, 447567.4870551048], [85843.16638730674, 447567.5808323869], [85842.93322679988, 447567.6996325646], [85842.71376167935, 447567.84215401934], [85842.51039648593, 447568.0068352334], [85842.32535936365, 447568.1918718989], [85842.16067764744, 447568.3952366857], [85836.71160764743, 447575.8952366857], [85836.56908658508, 447576.11469983624], [85836.45028641741, 447576.3478582541], [85836.35650874433, 447576.59215740615], [85836.2887810139, 447576.84492069896], [85836.24784526553, 447577.1033788042], [85836.23415, 447577.3647], [85836.23415, 447586.6353], [85836.24784526553, 447586.8966211958], [85836.2887810139, 447587.15507930104], [85836.35650874433, 447587.40784259385], [85836.45028641741, 447587.6521417459], [85836.56908658508, 447587.88530016376], [85836.71160764743, 447588.1047633143], [85842.16067764744, 447595.6047633143], [85842.32535936365, 447595.8081281011], [85842.51039648593, 447595.9931647666], [85842.71376167935, 447596.15784598066], [85842.93322679988, 447596.3003674354], [85843.16638730674, 447596.4191676131], [85843.41068860746, 447596.5129448952], [85852.22746860745, 447599.37764489517], [85852.48022837921, 447599.4453706186]], [[85845.72830106263, 447592.008667724], [85841.23415, 447585.82300063403], [85841.23415, 447578.17699936597], [85845.72830106263, 447571.991332276], [85853.0, 447569.62865157565], [85860.27169893737, 447571.991332276], [85864.76585, 447578.17699936597], [85864.76585, 447585.82300063403], [85860.27169893737, 447592.008667724], [85853.0, 447594.37134842435], [85845.72830106263, 447592.008667724]]]}, "_shape": null}, {"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[85850.5, 447627.0], [85850.51150954516, 447627.2396148079], [85850.54593220493, 447627.4770233298], [85850.60295102799, 447627.7100395945], [85850.68204100576, 447627.93651807297], [85850.78247390651, 447628.1543734338], [85850.90332498062, 447628.3615997441], [85851.0434814754, 447628.5562889394], [85851.20165288082, 447628.7366483924], [85851.37638281214, 447628.901017419], [85851.56606241973, 447629.0478825689], [85851.7689452028, 447629.17589156126], [85851.9831630905, 447629.28386573587], [85852.20674364245, 447629.3708109058], [85852.4376282103, 447629.43592651165], [85852.67369089296, 447629.4786129925], [85852.91275811114, 447629.49847730686], [85853.15262862088, 447629.4953365513], [85853.39109378183, 447629.4692196447], [85867.29685378182, 447627.2667196447], [85867.55280836426, 447627.2123143643], [85867.80167412471, 447627.1314532731], [85868.04072458217, 447627.02502225514], [85880.58530458217, 447620.63332225516], [85880.81193307436, 447620.5024793507], [85881.02364278969, 447620.34866343625], [85881.21811405565, 447620.17355985026], [85891.17353405565, 447610.2180598503], [85891.34862785673, 447610.0235973309], [85891.50243606055, 447609.8118981409], [85891.63327358107, 447609.58528160607], [85897.32953783553, 447598.4058], [85945.79754, 447598.4058], [85946.04258285083, 447598.39376181667], [85946.28526580504, 447598.357763201], [85946.52325169314, 447598.29815083934], [85946.75424858091, 447598.2154988313], [85946.97603184206, 447598.11060316087], [85947.18646558255, 447597.9844740308], [85947.3835232104, 447597.83832613344], [85947.56530695297, 447597.673566953], [85947.7300661334, 447597.4917832104], [85947.87621403075, 447597.2947255826], [85948.00234316087, 447597.08429184207], [85948.10723883128, 447596.8625085809], [85948.18989083933, 447596.6315116931], [85948.249503201, 447596.39352580503], [85948.28550181667, 447596.15084285085], [85948.29754, 447595.9058], [85948.29754, 447568.0942], [85948.28550181667, 447567.84915714915], [85948.249503201, 447567.60647419497], [85948.18989083933, 447567.3684883069], [85948.10723883128, 447567.1374914191], [85948.00234316087, 447566.91570815793], [85947.87621403075, 447566.7052744174], [85947.7300661334, 447566.5082167896], [85947.56530695297, 447566.326433047], [85947.3835232104, 447566.16167386656], [85947.18646558255, 447566.0155259692], [85946.97603184206, 447565.88939683913], [85946.75424858091, 447565.7845011687], [85946.52325169314, 447565.70184916066], [85946.28526580504, 447565.642236799], [85946.04258285083, 447565.60623818333], [85945.79754, 447565.5942], [85897.32953783553, 447565.5942], [85891.63327358107, 447554.41471839393], [85891.50243606055, 447554.1881018591], [85891.34862785673, 447553.9764026691], [85891.17353405565, 447553.7819401497], [85881.21811405565, 447543.82644014974], [85881.02364278969, 447543.65133656375], [85880.81193307436, 447543.4975206493], [85880.58530458217, 447543.36667774484], [85868.04072458217, 447536.97497774486], [85867.80167412471, 447536.8685467269], [85867.55280836426, 447536.7876856357], [85867.29685378182, 447536.7332803553], [85853.39109378183, 447534.5307803553], [85853.15262862088, 447534.5046634487], [85852.91275811114, 447534.50152269314], [85852.67369089296, 447534.5213870075], [85852.4376282103, 447534.56407348835], [85852.20674364245, 447534.6291890942], [85851.9831630905, 447534.71613426413], [85851.7689452028, 447534.82410843874], [85851.56606241973, 447534.9521174311], [85851.37638281214, 447535.098982581], [85851.20165288082, 447535.2633516076], [85851.0434814754, 447535.4437110606], [85850.90332498062, 447535.6384002559], [85850.78247390651, 447535.8456265662], [85850.68204100576, 447536.06348192703], [85850.60295102799, 447536.2899604055], [85850.54593220493, 447536.5229766702], [85850.51150954516, 447536.7603851921], [85850.5, 447537.0], [85850.5, 447567.0], [85850.5116709998, 447567.24128569535], [85850.54657502942, 447567.48031855444], [85850.60438619692, 447567.7148667754], [85850.684564731, 447567.94274042826], [85850.78636202074, 447568.1618119025], [85850.9088276052, 447568.3700357715], [85851.05081804776, 447568.5654678908], [85851.21100761207, 447568.7462835497], [85851.38790064021, 447568.91079450864], [85851.57984551742, 447569.0574647617], [85851.78505009276, 447569.18492487806], [85852.00159841221, 447569.29198478826], [85852.22746860745, 447569.37764489517], [85860.27169893737, 447571.991332276], [85864.76585, 447578.17699936597], [85864.76585, 447585.82300063403], [85860.27169893737, 447592.008667724], [85852.22746860745, 447594.62235510483], [85852.00159841221, 447594.70801521174], [85851.78505009276, 447594.81507512194], [85851.57984551742, 447594.9425352383], [85851.38790064021, 447595.08920549136], [85851.21100761207, 447595.2537164503], [85851.05081804776, 447595.4345321092], [85850.9088276052, 447595.6299642285], [85850.78636202074, 447595.8381880975], [85850.684564731, 447596.05725957174], [85850.60438619692, 447596.2851332246], [85850.54657502942, 447596.51968144556], [85850.5116709998, 447596.75871430465], [85850.5, 447597.0], [85850.5, 447627.0]], [[85862.58931139254, 447596.5129448952], [85862.83361269326, 447596.4191676131], [85863.06677320012, 447596.3003674354], [85863.28623832065, 447596.15784598066], [85863.48960351407, 447595.9931647666], [85863.67464063635, 447595.8081281011], [85863.83932235256, 447595.6047633143], [85869.28839235257, 447588.1047633143], [85869.43091341492, 447587.88530016376], [85869.54971358259, 447587.6521417459], [85869.64349125567, 447587.40784259385], [85869.7112189861, 447587.15507930104], [85869.75215473447, 447586.8966211958], [85869.76585, 447586.6353], [85869.76585, 447577.3647], [85869.75215473447, 447577.1033788042], [85869.7112189861, 447576.84492069896], [85869.64349125567, 447576.59215740615], [85869.54971358259, 447576.3478582541], [85869.43091341492, 447576.11469983624], [85869.28839235257, 447575.8952366857], [85863.83932235256, 447568.3952366857], [85863.67464063635, 447568.1918718989], [85863.48960351407, 447568.0068352334], [85863.28623832065, 447567.84215401934], [85863.06677320012, 447567.6996325646], [85862.83361269326, 447567.5808323869], [85862.58931139254, 447567.4870551048], [85855.5, 447565.1836347693], [85855.5, 447539.92713306006], [85866.12359078073, 447541.60977814347], [85877.96255998495, 447547.6419561408], [85887.35800610915, 447557.0374777652], [85893.57002641892, 447569.22918160603], [85893.69440912276, 447569.4458066414], [85893.83978863157, 447569.6489377848], [85894.00471353535, 447569.83654705714], [85894.1875372908, 447570.0067614438], [85894.38643465977, 447570.15788159333], [85894.59941993165, 447570.28839878354], [85894.82436674794, 447570.3970099838], [85895.05902933095, 447570.4826308639], [85895.30106490469, 447570.5444066198], [85895.54805708426, 447570.5817205074], [85895.79754, 447570.5942], [85943.29754, 447570.5942], [85943.29754, 447593.4058], [85895.79754, 447593.4058], [85895.54805708426, 447593.4182794926], [85895.30106490469, 447593.4555933802], [85895.05902933095, 447593.5173691361], [85894.82436674794, 447593.6029900162], [85894.59941993165, 447593.71160121646], [85894.38643465977, 447593.84211840667], [85894.1875372908, 447593.9932385562], [85894.00471353535, 447594.16345294286], [85893.83978863157, 447594.3510622152], [85893.69440912276, 447594.5541933586], [85893.57002641892, 447594.77081839397], [85887.35800610915, 447606.9625222348], [85877.96255998495, 447616.3580438592], [85866.12359078073, 447622.39022185653], [85855.5, 447624.07286693994], [85855.5, 447598.8163652307], [85862.58931139254, 447596.5129448952]]]}, "_shape": null}], "bbox": [85836.23415, 447534.50152269314, 85948.29754, 447629.49847730686]}
);


Kaartgegevens.Instantie.VoegDataToe ("data26_2",
{"type": "FeatureCollection", "crs": {"type": "name", "properties": {"name": "urn:ogc:def:crs:EPSG::28992"}}, "features": [{"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[85857.69135225614, 447598.7651704281], [85857.94301993013, 447598.74678320636], [85858.19155205844, 447598.70311984356], [85858.43441660739, 447598.63462518004], [85858.66913928425, 447598.54199703626], [85858.89332874538, 447598.4261791034], [85859.10470095903, 447598.28835132916], [85866.60470095903, 447592.83935132914], [85866.8080672615, 447592.6746703963], [85866.99310546542, 447592.48963384394], [85867.15778821337, 447592.2862690114], [85867.30031117103, 447592.06680405024], [85867.41911279614, 447591.8336435122], [85867.51289144749, 447591.5893420035], [85870.37764144749, 447582.77254200354], [85870.44536907214, 447582.5197788963], [85870.4863047561, 447582.26132099004], [85870.5, 447582.0], [85870.4863047561, 447581.73867900996], [85870.44536907214, 447581.4802211037], [85870.37764144749, 447581.22745799646], [85867.51289144749, 447572.4106579965], [85867.41911279614, 447572.1663564878], [85867.30031117103, 447571.93319594976], [85867.15778821337, 447571.7137309886], [85866.99310546542, 447571.51036615606], [85866.8080672615, 447571.3253296037], [85866.60470095903, 447571.16064867086], [85859.10470095903, 447565.71164867084], [85858.88523914217, 447565.5691302218], [85858.65208244481, 447565.45033227635], [85858.4077853316, 447565.3565563847], [85858.15502432163, 447565.2888299555], [85857.89656866441, 447565.24789499945], [85857.63525, 447565.2342], [85848.76764133963, 447565.2342], [85782.50486510566, 447543.3073699429], [85782.26762248673, 447543.24163214717], [85782.02506459433, 447543.1995466764], [85781.77954348389, 447543.1815216285], [85781.53343994488, 447543.18773179036], [85781.2891404145, 447543.21811694256], [85781.04901383669, 447543.272382444], [85780.81538869074, 447543.3500020884], [85780.59053041232, 447543.4502232072], [85780.37661942584, 447543.5720739679], [85780.17573000108, 447543.714372798], [85779.98981013925, 447543.8757398423], [85779.82066268349, 447544.0546103436], [85779.66992783686, 447544.24924981553], [85779.53906725753, 447544.4577708619], [85779.4293498852, 447544.67815147864], [85779.34183963637, 447544.90825466067], [85771.60728963638, 447568.7126546607], [85771.54283503846, 447568.9502493492], [85771.50206119359, 447569.1930314012], [85771.48536348171, 447569.4386465832], [85771.49290381889, 447569.684713189], [85771.5246090872, 447569.9288451352], [85771.58017184382, 447570.1686750985], [85771.65905330218, 447570.40187747136], [85771.76048855661, 447570.6261909136], [85771.88349399948, 447570.8394402799], [85772.02687685918, 447571.03955771227], [85772.18924676633, 447571.22460269183], [85772.369029236, 447571.39278085565], [85772.5644809354, 447571.54246139684], [85772.77370658873, 447571.6721928779], [85772.99467735557, 447571.78071730555], [85773.22525050426, 447571.86698232923], [85839.62461087605, 447593.04533770913], [85844.56652250914, 447597.2661171602], [85844.7741282647, 447597.4254181224], [85844.9972482858, 447597.56214559765], [85845.23343799998, 447597.67480155715], [85845.4801096392, 447597.76215170714], [85845.73456059216, 447597.82323901216], [85845.99400301499, 447597.85739418067], [85857.43911301499, 447598.75809418067], [85857.69135225614, 447598.7651704281]], [[85847.19607649204, 447592.93653490674], [85842.48836749086, 447588.91578283976], [85842.29144491469, 447588.76386512024], [85842.08040205487, 447588.632265706], [85841.8573276446, 447588.52228706266], [85841.62442949574, 447588.43501767074], [85777.13930376926, 447567.8672154855], [85783.3203881021, 447548.84387167194], [85847.57936489434, 447570.1076300571], [85847.8361607543, 447570.1776797747], [85848.09894879302, 447570.22002978466], [85848.36475, 447570.2342], [85856.82295907609, 447570.2342], [85863.00862532228, 447574.7282927168], [85865.3713446127, 447582.0], [85863.00862532228, 447589.2717072832], [85856.911945748, 447593.7011482166], [85847.19607649204, 447592.93653490674]]]}, "_shape": null}, {"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[85850.5, 447627.0], [85850.51150954516, 447627.2396148079], [85850.54593220493, 447627.4770233298], [85850.60295102799, 447627.7100395945], [85850.68204100576, 447627.93651807297], [85850.78247390651, 447628.1543734338], [85850.90332498062, 447628.3615997441], [85851.0434814754, 447628.5562889394], [85851.20165288082, 447628.7366483924], [85851.37638281214, 447628.901017419], [85851.56606241973, 447629.0478825689], [85851.7689452028, 447629.17589156126], [85851.9831630905, 447629.28386573587], [85852.20674364245, 447629.3708109058], [85852.4376282103, 447629.43592651165], [85852.67369089296, 447629.4786129925], [85852.91275811114, 447629.49847730686], [85853.15262862088, 447629.4953365513], [85853.39109378183, 447629.4692196447], [85867.29685378182, 447627.2667196447], [85867.55280836426, 447627.2123143643], [85867.80167412471, 447627.1314532731], [85868.04072458217, 447627.02502225514], [85880.58530458217, 447620.63332225516], [85880.81193307436, 447620.5024793507], [85881.02364278969, 447620.34866343625], [85881.21811405565, 447620.17355985026], [85891.17353405565, 447610.2180598503], [85891.34862785673, 447610.0235973309], [85891.50243606055, 447609.8118981409], [85891.63327358107, 447609.58528160607], [85898.02505358108, 447597.04078160605], [85898.1219794442, 447596.82611585356], [85898.19827320782, 447596.60328122904], [85898.2532576762, 447596.37425564864], [85898.28644479834, 447596.14107198035], [85898.29754, 447595.9058], [85898.29754, 447568.0942], [85898.28644479834, 447567.85892801965], [85898.2532576762, 447567.62574435136], [85898.19827320782, 447567.39671877096], [85898.1219794442, 447567.17388414644], [85898.02505358108, 447566.95921839395], [85891.63327358107, 447554.41471839393], [85891.50243606055, 447554.1881018591], [85891.34862785673, 447553.9764026691], [85891.17353405565, 447553.7819401497], [85881.21811405565, 447543.82644014974], [85881.02364278969, 447543.65133656375], [85880.81193307436, 447543.4975206493], [85880.58530458217, 447543.36667774484], [85868.04072458217, 447536.97497774486], [85867.80167412471, 447536.8685467269], [85867.55280836426, 447536.7876856357], [85867.29685378182, 447536.7332803553], [85853.39109378183, 447534.5307803553], [85853.15262862088, 447534.5046634487], [85852.91275811114, 447534.50152269314], [85852.67369089296, 447534.5213870075], [85852.4376282103, 447534.56407348835], [85852.20674364245, 447534.6291890942], [85851.9831630905, 447534.71613426413], [85851.7689452028, 447534.82410843874], [85851.56606241973, 447534.9521174311], [85851.37638281214, 447535.098982581], [85851.20165288082, 447535.2633516076], [85851.0434814754, 447535.4437110606], [85850.90332498062, 447535.6384002559], [85850.78247390651, 447535.8456265662], [85850.68204100576, 447536.06348192703], [85850.60295102799, 447536.2899604055], [85850.54593220493, 447536.5229766702], [85850.51150954516, 447536.7603851921], [85850.5, 447537.0], [85850.5, 447567.0], [85850.5116709998, 447567.24128569535], [85850.54657502942, 447567.48031855444], [85850.60438619692, 447567.7148667754], [85850.684564731, 447567.94274042826], [85850.78636202074, 447568.1618119025], [85850.9088276052, 447568.3700357715], [85851.05081804776, 447568.5654678908], [85851.21100761207, 447568.7462835497], [85851.38790064021, 447568.91079450864], [85851.57984551742, 447569.0574647617], [85851.78505009276, 447569.18492487806], [85852.00159841221, 447569.29198478826], [85852.22746860745, 447569.37764489517], [85860.27169893737, 447571.991332276], [85864.76585, 447578.17699936597], [85864.76585, 447585.82300063403], [85860.27169893737, 447592.008667724], [85852.22746860745, 447594.62235510483], [85852.00159841221, 447594.70801521174], [85851.78505009276, 447594.81507512194], [85851.57984551742, 447594.9425352383], [85851.38790064021, 447595.08920549136], [85851.21100761207, 447595.2537164503], [85851.05081804776, 447595.4345321092], [85850.9088276052, 447595.6299642285], [85850.78636202074, 447595.8381880975], [85850.684564731, 447596.05725957174], [85850.60438619692, 447596.2851332246], [85850.54657502942, 447596.51968144556], [85850.5116709998, 447596.75871430465], [85850.5, 447597.0], [85850.5, 447627.0]], [[85862.58931139254, 447596.5129448952], [85862.83361269326, 447596.4191676131], [85863.06677320012, 447596.3003674354], [85863.28623832065, 447596.15784598066], [85863.48960351407, 447595.9931647666], [85863.67464063635, 447595.8081281011], [85863.83932235256, 447595.6047633143], [85869.28839235257, 447588.1047633143], [85869.43091341492, 447587.88530016376], [85869.54971358259, 447587.6521417459], [85869.64349125567, 447587.40784259385], [85869.7112189861, 447587.15507930104], [85869.75215473447, 447586.8966211958], [85869.76585, 447586.6353], [85869.76585, 447577.3647], [85869.75215473447, 447577.1033788042], [85869.7112189861, 447576.84492069896], [85869.64349125567, 447576.59215740615], [85869.54971358259, 447576.3478582541], [85869.43091341492, 447576.11469983624], [85869.28839235257, 447575.8952366857], [85863.83932235256, 447568.3952366857], [85863.67464063635, 447568.1918718989], [85863.48960351407, 447568.0068352334], [85863.28623832065, 447567.84215401934], [85863.06677320012, 447567.6996325646], [85862.83361269326, 447567.5808323869], [85862.58931139254, 447567.4870551048], [85855.5, 447565.1836347693], [85855.5, 447539.92713306006], [85866.12359078073, 447541.60977814347], [85877.96255998495, 447547.6419561408], [85887.35800610915, 447557.0374777652], [85893.29754, 447568.6944000769], [85893.29754, 447595.3055999231], [85887.35800610915, 447606.9625222348], [85877.96255998495, 447616.3580438592], [85866.12359078073, 447622.39022185653], [85855.5, 447624.07286693994], [85855.5, 447598.8163652307], [85862.58931139254, 447596.5129448952]]]}, "_shape": null}], "bbox": [85771.48536348171, 447534.50152269314, 85898.29754, 447629.49847730686]}
);


Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym27",`<FeatureTypeStyle version="1.1.0"
    xmlns="http://www.opengis.net/se"
    xmlns:ogc="http://www.opengis.net/ogc">
    <FeatureTypeName>geo:Locatie</FeatureTypeName>
    <SemanticTypeIdentifier>geo:geometrie</SemanticTypeIdentifier>
    <Rule>
        <Name>Vlak</Name>
        <PolygonSymbolizer>
            <Fill>
                <SvgParameter name="fill">#CCCCCC</SvgParameter>
                <SvgParameter name="fill-opacity">0.5</SvgParameter>
            </Fill>
            <Stroke>
                <SvgParameter name="stroke">#000000</SvgParameter>
                <SvgParameter name="stroke-opacity">1</SvgParameter>
                <SvgParameter name="stroke-width">3</SvgParameter>
                <SvgParameter name="stroke-linejoin">round</SvgParameter>
            </Stroke>
        </PolygonSymbolizer>
    </Rule>
</FeatureTypeStyle>`);


Kaartgegevens.Instantie.VoegDataToe ("data28_2",
{"type": "FeatureCollection", "crs": {"type": "name", "properties": {"name": "urn:ogc:def:crs:EPSG::28992"}}, "features": [{"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[85853.0, 447597.0], [85861.81678, 447594.1353], [85867.26585, 447586.6353], [85867.26585, 447577.3647], [85861.81678, 447569.8647], [85853.0, 447567.0], [85844.18322, 447569.8647], [85838.73415, 447577.3647], [85838.73415, 447586.6353], [85844.18322, 447594.1353], [85853.0, 447597.0]]]}, "properties": {"w": "verwijder"}, "_shape": null}, {"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[85853.0, 447597.0], [85861.81678, 447594.1353], [85867.26585, 447586.6353], [85867.26585, 447577.3647], [85861.81678, 447569.8647], [85853.0, 447567.0], [85853.0, 447537.0], [85866.90576, 447539.2025], [85879.45034, 447545.5942], [85889.40576, 447555.5497], [85895.79754, 447568.0942], [85945.79754, 447568.0942], [85945.79754, 447595.9058], [85895.79754, 447595.9058], [85889.40576, 447608.4503], [85879.45034, 447618.4058], [85866.90576, 447624.7975], [85853.0, 447627.0], [85853.0, 447597.0]]]}, "properties": {"w": "verwijder"}, "_shape": null}], "properties": {"w": ["wijzigactie", ""]}, "bbox": [85838.73415, 447537.0, 85945.79754, 447627.0]}
);


Kaartgegevens.Instantie.VoegDataToe ("data29_2",
{"type": "FeatureCollection", "crs": {"type": "name", "properties": {"name": "urn:ogc:def:crs:EPSG::28992"}}, "features": [{"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[85857.63525, 447596.2658], [85865.13525, 447590.8168], [85868.0, 447582.0], [85865.13525, 447573.1832], [85857.63525, 447567.7342], [85848.36475, 447567.7342], [85781.71948, 447545.6808], [85773.98493, 447569.4852], [85840.86475, 447590.8168], [85846.19014, 447595.3651], [85857.63525, 447596.2658]]]}, "properties": {"w": "voegtoe"}, "_shape": null}, {"type": "Feature", "geometry": {"type": "Polygon", "coordinates": [[[85853.0, 447597.0], [85861.81678, 447594.1353], [85867.26585, 447586.6353], [85867.26585, 447577.3647], [85861.81678, 447569.8647], [85853.0, 447567.0], [85853.0, 447537.0], [85866.90576, 447539.2025], [85879.45034, 447545.5942], [85889.40576, 447555.5497], [85895.79754, 447568.0942], [85895.79754, 447595.9058], [85889.40576, 447608.4503], [85879.45034, 447618.4058], [85866.90576, 447624.7975], [85853.0, 447627.0], [85853.0, 447597.0]]]}, "properties": {"w": "voegtoe"}, "_shape": null}], "properties": {"w": ["wijzigactie", ""]}, "bbox": [85773.98493, 447537.0, 85895.79754, 447627.0]}
);


Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym30",`<FeatureTypeStyle version="1.1.0"
    xmlns="http://www.opengis.net/se"
    xmlns:ogc="http://www.opengis.net/ogc">
    <FeatureTypeName>geo:Locatie</FeatureTypeName>
    <SemanticTypeIdentifier>geo:geometrie</SemanticTypeIdentifier>
    <Rule>
        <Name>Punt</Name>
        <PointSymbolizer>
            <Graphic>
                <Mark>
                    <WellKnownName>square</WellKnownName>
                    <Fill>
                        <SvgParameter name="fill">#F8CECC</SvgParameter>
                        <SvgParameter name="fill-opacity">1</SvgParameter>
                    </Fill>
                    <Stroke>
                        <SvgParameter name="stroke">#B85450</SvgParameter>
                        <SvgParameter name="stroke-opacity">1</SvgParameter>
                        <SvgParameter name="stroke-width">1</SvgParameter>
                    </Stroke>
                </Mark>
                <Size>12</Size>
                <Rotation>0</Rotation>
            </Graphic>
        </PointSymbolizer>
    </Rule>
</FeatureTypeStyle>`);


Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym31",`<FeatureTypeStyle version="1.1.0"
    xmlns="http://www.opengis.net/se"
    xmlns:ogc="http://www.opengis.net/ogc">
    <FeatureTypeName>geo:Locatie</FeatureTypeName>
    <SemanticTypeIdentifier>geo:geometrie</SemanticTypeIdentifier>
    <Rule>
        <Name>Lijn</Name>
        <LineSymbolizer>
            <Stroke>
                <SvgParameter name="stroke">#B85450</SvgParameter>
                <SvgParameter name="stroke-opacity">1</SvgParameter>
                <SvgParameter name="stroke-width">3</SvgParameter>
                <SvgParameter name="stroke-linecap">butt</SvgParameter>
            </Stroke>
        </LineSymbolizer>
    </Rule>
</FeatureTypeStyle>`);


Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym32",`<FeatureTypeStyle version="1.1.0"
    xmlns="http://www.opengis.net/se"
    xmlns:ogc="http://www.opengis.net/ogc">
    <FeatureTypeName>geo:Locatie</FeatureTypeName>
    <SemanticTypeIdentifier>geo:geometrie</SemanticTypeIdentifier>
    <Rule>
        <Name>Vlak</Name>
        <PolygonSymbolizer>
            <Fill>
                <SvgParameter name="fill">#F8CECC</SvgParameter>
                <SvgParameter name="fill-opacity">1</SvgParameter>
            </Fill>
            <Stroke>
                <SvgParameter name="stroke">#B85450</SvgParameter>
                <SvgParameter name="stroke-opacity">1</SvgParameter>
                <SvgParameter name="stroke-width">3</SvgParameter>
                <SvgParameter name="stroke-linejoin">round</SvgParameter>
            </Stroke>
        </PolygonSymbolizer>
    </Rule>
</FeatureTypeStyle>`);


Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym33",`<FeatureTypeStyle version="1.1.0"
    xmlns="http://www.opengis.net/se"
    xmlns:ogc="http://www.opengis.net/ogc">
    <FeatureTypeName>geo:Locatie</FeatureTypeName>
    <SemanticTypeIdentifier>geo:geometrie</SemanticTypeIdentifier>
    <Rule>
        <Name>Punt</Name>
        <PointSymbolizer>
            <Graphic>
                <Mark>
                    <WellKnownName>square</WellKnownName>
                    <Fill>
                        <SvgParameter name="fill">#D5E8D4</SvgParameter>
                        <SvgParameter name="fill-opacity">1</SvgParameter>
                    </Fill>
                    <Stroke>
                        <SvgParameter name="stroke">#82B366</SvgParameter>
                        <SvgParameter name="stroke-opacity">1</SvgParameter>
                        <SvgParameter name="stroke-width">1</SvgParameter>
                    </Stroke>
                </Mark>
                <Size>12</Size>
                <Rotation>0</Rotation>
            </Graphic>
        </PointSymbolizer>
    </Rule>
</FeatureTypeStyle>`);


Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym34",`<FeatureTypeStyle version="1.1.0"
    xmlns="http://www.opengis.net/se"
    xmlns:ogc="http://www.opengis.net/ogc">
    <FeatureTypeName>geo:Locatie</FeatureTypeName>
    <SemanticTypeIdentifier>geo:geometrie</SemanticTypeIdentifier>
    <Rule>
        <Name>Lijn</Name>
        <LineSymbolizer>
            <Stroke>
                <SvgParameter name="stroke">#82B366</SvgParameter>
                <SvgParameter name="stroke-opacity">1</SvgParameter>
                <SvgParameter name="stroke-width">3</SvgParameter>
                <SvgParameter name="stroke-linecap">butt</SvgParameter>
            </Stroke>
        </LineSymbolizer>
    </Rule>
</FeatureTypeStyle>`);


Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym35",`<FeatureTypeStyle version="1.1.0"
    xmlns="http://www.opengis.net/se"
    xmlns:ogc="http://www.opengis.net/ogc">
    <FeatureTypeName>geo:Locatie</FeatureTypeName>
    <SemanticTypeIdentifier>geo:geometrie</SemanticTypeIdentifier>
    <Rule>
        <Name>Vlak</Name>
        <PolygonSymbolizer>
            <Fill>
                <SvgParameter name="fill">#D5E8D4</SvgParameter>
                <SvgParameter name="fill-opacity">1</SvgParameter>
            </Fill>
            <Stroke>
                <SvgParameter name="stroke">#82B366</SvgParameter>
                <SvgParameter name="stroke-opacity">1</SvgParameter>
                <SvgParameter name="stroke-width">3</SvgParameter>
                <SvgParameter name="stroke-linejoin">round</SvgParameter>
            </Stroke>
        </PolygonSymbolizer>
    </Rule>
</FeatureTypeStyle>`);


Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym37",`<FeatureTypeStyle version="1.1.0"
    xmlns="http://www.opengis.net/se"
    xmlns:ogc="http://www.opengis.net/ogc">
    <FeatureTypeName>geo:Locatie</FeatureTypeName>
    <SemanticTypeIdentifier>geo:geometrie</SemanticTypeIdentifier>
    <Rule>
        <Name>Punt</Name>
        <PointSymbolizer>
            <Graphic>
                <Mark>
                    <WellKnownName>square</WellKnownName>
                    <Fill>
                        <SvgParameter name="fill">#FFF2CC</SvgParameter>
                        <SvgParameter name="fill-opacity">1</SvgParameter>
                    </Fill>
                    <Stroke>
                        <SvgParameter name="stroke">#D6B656</SvgParameter>
                        <SvgParameter name="stroke-opacity">1</SvgParameter>
                        <SvgParameter name="stroke-width">1</SvgParameter>
                    </Stroke>
                </Mark>
                <Size>12</Size>
                <Rotation>0</Rotation>
            </Graphic>
        </PointSymbolizer>
    </Rule>
</FeatureTypeStyle>`);


Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym38",`<FeatureTypeStyle version="1.1.0"
    xmlns="http://www.opengis.net/se"
    xmlns:ogc="http://www.opengis.net/ogc">
    <FeatureTypeName>geo:Locatie</FeatureTypeName>
    <SemanticTypeIdentifier>geo:geometrie</SemanticTypeIdentifier>
    <Rule>
        <Name>Lijn</Name>
        <LineSymbolizer>
            <Stroke>
                <SvgParameter name="stroke">#D6B656</SvgParameter>
                <SvgParameter name="stroke-opacity">1</SvgParameter>
                <SvgParameter name="stroke-width">3</SvgParameter>
                <SvgParameter name="stroke-linecap">butt</SvgParameter>
            </Stroke>
        </LineSymbolizer>
    </Rule>
</FeatureTypeStyle>`);


Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym39",`<FeatureTypeStyle version="1.1.0"
    xmlns="http://www.opengis.net/se"
    xmlns:ogc="http://www.opengis.net/ogc">
    <FeatureTypeName>geo:Locatie</FeatureTypeName>
    <SemanticTypeIdentifier>geo:geometrie</SemanticTypeIdentifier>
    <Rule>
        <Name>Vlak</Name>
        <PolygonSymbolizer>
            <Fill>
                <SvgParameter name="fill">#FFF2CC</SvgParameter>
                <SvgParameter name="fill-opacity">1</SvgParameter>
            </Fill>
            <Stroke>
                <SvgParameter name="stroke">#D6B656</SvgParameter>
                <SvgParameter name="stroke-opacity">1</SvgParameter>
                <SvgParameter name="stroke-width">3</SvgParameter>
                <SvgParameter name="stroke-linejoin">round</SvgParameter>
            </Stroke>
        </PolygonSymbolizer>
    </Rule>
</FeatureTypeStyle>`);


Kaartgegevens.Instantie.VoegDataToe ("data40_2",
{"type": "FeatureCollection", "crs": {"type": "name", "properties": {"name": "urn:ogc:def:crs:EPSG::28992"}}, "features": [{"type": "Feature", "properties": {"id": "4e4783ef-62f9-4628-bfb7-d9ae197bfeb5"}, "geometry": {"type": "Polygon", "coordinates": [[[85943.29754, 447593.4058], [85943.29754, 447570.5942], [85898.29754, 447570.5942], [85898.29754, 447593.4058], [85943.29754, 447593.4058]]]}, "_shape": null}, {"type": "Feature", "properties": {"id": "f753988f-bee7-4612-924b-a83d0c7dfd3f"}, "geometry": {"type": "Polygon", "coordinates": [[[85836.23843869919, 447586.7171332435], [85836.23415, 447586.6353], [85836.23415, 447577.3647], [85836.24784526553, 447577.1033788042], [85836.2887810139, 447576.84492069896], [85836.35650874433, 447576.59215740615], [85836.45028641741, 447576.3478582541], [85836.56908658508, 447576.11469983624], [85836.71160764743, 447575.8952366857], [85842.16067764744, 447568.3952366857], [85842.21220984512, 447568.33159978274], [85783.32038810207, 447548.84387167194], [85777.13930376922, 447567.86721548554], [85836.23843869919, 447586.7171332435]]]}, "_shape": null}], "bbox": [85777.13930376922, 447548.84387167194, 85943.29754, 447593.4058]}
);


Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym41",`<FeatureTypeStyle version="1.1.0"
    xmlns="http://www.opengis.net/se"
    xmlns:ogc="http://www.opengis.net/ogc">
    <FeatureTypeName>geo:Locatie</FeatureTypeName>
    <SemanticTypeIdentifier>geo:geometrie</SemanticTypeIdentifier>
    <Rule>
        <Name>Punt</Name>
        <PointSymbolizer>
            <Graphic>
                <Mark>
                    <WellKnownName>square</WellKnownName>
                    <Fill>
                        <SvgParameter name="fill">#E1D5E7</SvgParameter>
                        <SvgParameter name="fill-opacity">1</SvgParameter>
                    </Fill>
                    <Stroke>
                        <SvgParameter name="stroke">#9673A6</SvgParameter>
                        <SvgParameter name="stroke-opacity">1</SvgParameter>
                        <SvgParameter name="stroke-width">1</SvgParameter>
                    </Stroke>
                </Mark>
                <Size>12</Size>
                <Rotation>0</Rotation>
            </Graphic>
        </PointSymbolizer>
    </Rule>
</FeatureTypeStyle>`);


Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym42",`<FeatureTypeStyle version="1.1.0"
    xmlns="http://www.opengis.net/se"
    xmlns:ogc="http://www.opengis.net/ogc">
    <FeatureTypeName>geo:Locatie</FeatureTypeName>
    <SemanticTypeIdentifier>geo:geometrie</SemanticTypeIdentifier>
    <Rule>
        <Name>Lijn</Name>
        <LineSymbolizer>
            <Stroke>
                <SvgParameter name="stroke">#9673A6</SvgParameter>
                <SvgParameter name="stroke-opacity">1</SvgParameter>
                <SvgParameter name="stroke-width">3</SvgParameter>
                <SvgParameter name="stroke-linecap">butt</SvgParameter>
            </Stroke>
        </LineSymbolizer>
    </Rule>
</FeatureTypeStyle>`);


Kaartgegevens.Instantie.VoegSymbolisatieToe ("sym43",`<FeatureTypeStyle version="1.1.0"
    xmlns="http://www.opengis.net/se"
    xmlns:ogc="http://www.opengis.net/ogc">
    <FeatureTypeName>geo:Locatie</FeatureTypeName>
    <SemanticTypeIdentifier>geo:geometrie</SemanticTypeIdentifier>
    <Rule>
        <Name>Vlak</Name>
        <PolygonSymbolizer>
            <Fill>
                <SvgParameter name="fill">#E1D5E7</SvgParameter>
                <SvgParameter name="fill-opacity">1</SvgParameter>
            </Fill>
            <Stroke>
                <SvgParameter name="stroke">#9673A6</SvgParameter>
                <SvgParameter name="stroke-opacity">1</SvgParameter>
                <SvgParameter name="stroke-width">3</SvgParameter>
                <SvgParameter name="stroke-linejoin">round</SvgParameter>
            </Stroke>
        </PolygonSymbolizer>
    </Rule>
</FeatureTypeStyle>`);


window.addEventListener("load", function () {
var kaart = new Kaart ();
kaart.VoegLaagToe ("Juridische nauwkeurigheid", "data25_2", "sym27").AlsAanUitLaag (false).AlsOudLaag ();
kaart.VoegLaagToe ("Juridische nauwkeurigheid", "data26_2", "sym27").AlsAanUitLaag (false).AlsNieuwLaag ();
kaart.VoegLaagToe ("GIO-versies", "data17_2", "sym23").AlsAanUitLaag (false).AlsOudLaag ();
kaart.VoegLaagToe ("GIO-versies", "data21_2", "sym23").AlsAanUitLaag (false).AlsNieuwLaag ();
kaart.VoegLaagToe ("LocatieMutaties (geen revisie)", "data28_2", "sym32").AlsAanUitLaag (true).AlsOudLaag ();
kaart.VoegLaagToe ("LocatieMutaties (geen revisie)", "data29_2", "sym35").AlsAanUitLaag (true).AlsNieuwLaag ();
kaart.VoegLaagToe ("Wijzigmarkeringen", "data40_2", "sym43").AlsAanUitLaag (true);
kaart.Toon ({"kaartelementId": "kaart_24", "kaartelementWidth": 900, "kaartelementHeight": 600, "juridische-nauwkeurigheid": 50, "bbox": [85771.48536348171, 447534.50152269314, 85948.29754, 447629.49847730686]});
});
</script>
</body>
</html>
